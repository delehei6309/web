webpackJsonp([11],{

/***/ 389:
/***/ (function(module, exports, __webpack_require__) {

eval("/* WEBPACK VAR INJECTION */(function(global, process) {(function (global, undefined) {\n    \"use strict\";\n\n    if (global.setImmediate) {\n        return;\n    }\n\n    var nextHandle = 1; // Spec says greater than zero\n    var tasksByHandle = {};\n    var currentlyRunningATask = false;\n    var doc = global.document;\n    var registerImmediate;\n\n    function setImmediate(callback) {\n        // Callback can either be a function or a string\n        if (typeof callback !== \"function\") {\n            callback = new Function(\"\" + callback);\n        }\n        // Copy function arguments\n        var args = new Array(arguments.length - 1);\n        for (var i = 0; i < args.length; i++) {\n            args[i] = arguments[i + 1];\n        }\n        // Store and register the task\n        var task = { callback: callback, args: args };\n        tasksByHandle[nextHandle] = task;\n        registerImmediate(nextHandle);\n        return nextHandle++;\n    }\n\n    function clearImmediate(handle) {\n        delete tasksByHandle[handle];\n    }\n\n    function run(task) {\n        var callback = task.callback;\n        var args = task.args;\n        switch (args.length) {\n            case 0:\n                callback();\n                break;\n            case 1:\n                callback(args[0]);\n                break;\n            case 2:\n                callback(args[0], args[1]);\n                break;\n            case 3:\n                callback(args[0], args[1], args[2]);\n                break;\n            default:\n                callback.apply(undefined, args);\n                break;\n        }\n    }\n\n    function runIfPresent(handle) {\n        // From the spec: \"Wait until any invocations of this algorithm started before this one have completed.\"\n        // So if we're currently running a task, we'll need to delay this invocation.\n        if (currentlyRunningATask) {\n            // Delay by doing a setTimeout. setImmediate was tried instead, but in Firefox 7 it generated a\n            // \"too much recursion\" error.\n            setTimeout(runIfPresent, 0, handle);\n        } else {\n            var task = tasksByHandle[handle];\n            if (task) {\n                currentlyRunningATask = true;\n                try {\n                    run(task);\n                } finally {\n                    clearImmediate(handle);\n                    currentlyRunningATask = false;\n                }\n            }\n        }\n    }\n\n    function installNextTickImplementation() {\n        registerImmediate = function registerImmediate(handle) {\n            process.nextTick(function () {\n                runIfPresent(handle);\n            });\n        };\n    }\n\n    function canUsePostMessage() {\n        // The test against `importScripts` prevents this implementation from being installed inside a web worker,\n        // where `global.postMessage` means something completely different and can't be used for this purpose.\n        if (global.postMessage && !global.importScripts) {\n            var postMessageIsAsynchronous = true;\n            var oldOnMessage = global.onmessage;\n            global.onmessage = function () {\n                postMessageIsAsynchronous = false;\n            };\n            global.postMessage(\"\", \"*\");\n            global.onmessage = oldOnMessage;\n            return postMessageIsAsynchronous;\n        }\n    }\n\n    function installPostMessageImplementation() {\n        // Installs an event handler on `global` for the `message` event: see\n        // * https://developer.mozilla.org/en/DOM/window.postMessage\n        // * http://www.whatwg.org/specs/web-apps/current-work/multipage/comms.html#crossDocumentMessages\n\n        var messagePrefix = \"setImmediate$\" + Math.random() + \"$\";\n        var onGlobalMessage = function onGlobalMessage(event) {\n            if (event.source === global && typeof event.data === \"string\" && event.data.indexOf(messagePrefix) === 0) {\n                runIfPresent(+event.data.slice(messagePrefix.length));\n            }\n        };\n\n        if (global.addEventListener) {\n            global.addEventListener(\"message\", onGlobalMessage, false);\n        } else {\n            global.attachEvent(\"onmessage\", onGlobalMessage);\n        }\n\n        registerImmediate = function registerImmediate(handle) {\n            global.postMessage(messagePrefix + handle, \"*\");\n        };\n    }\n\n    function installMessageChannelImplementation() {\n        var channel = new MessageChannel();\n        channel.port1.onmessage = function (event) {\n            var handle = event.data;\n            runIfPresent(handle);\n        };\n\n        registerImmediate = function registerImmediate(handle) {\n            channel.port2.postMessage(handle);\n        };\n    }\n\n    function installReadyStateChangeImplementation() {\n        var html = doc.documentElement;\n        registerImmediate = function registerImmediate(handle) {\n            // Create a <script> element; its readystatechange event will be fired asynchronously once it is inserted\n            // into the document. Do so, thus queuing up the task. Remember to clean up once it's been called.\n            var script = doc.createElement(\"script\");\n            script.onreadystatechange = function () {\n                runIfPresent(handle);\n                script.onreadystatechange = null;\n                html.removeChild(script);\n                script = null;\n            };\n            html.appendChild(script);\n        };\n    }\n\n    function installSetTimeoutImplementation() {\n        registerImmediate = function registerImmediate(handle) {\n            setTimeout(runIfPresent, 0, handle);\n        };\n    }\n\n    // If supported, we should attach to the prototype of global, since that is where setTimeout et al. live.\n    var attachTo = Object.getPrototypeOf && Object.getPrototypeOf(global);\n    attachTo = attachTo && attachTo.setTimeout ? attachTo : global;\n\n    // Don't get fooled by e.g. browserify environments.\n    if ({}.toString.call(global.process) === \"[object process]\") {\n        // For Node.js before 0.9\n        installNextTickImplementation();\n    } else if (canUsePostMessage()) {\n        // For non-IE10 modern browsers\n        installPostMessageImplementation();\n    } else if (global.MessageChannel) {\n        // For web workers, where supported\n        installMessageChannelImplementation();\n    } else if (doc && \"onreadystatechange\" in doc.createElement(\"script\")) {\n        // For IE 6â€“8\n        installReadyStateChangeImplementation();\n    } else {\n        // For older browsers\n        installSetTimeoutImplementation();\n    }\n\n    attachTo.setImmediate = setImmediate;\n    attachTo.clearImmediate = clearImmediate;\n})(typeof self === \"undefined\" ? typeof global === \"undefined\" ? this : global : self);\n/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(66), __webpack_require__(43)))\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L19zZXRpbW1lZGlhdGVAMS4wLjVAc2V0aW1tZWRpYXRlL3NldEltbWVkaWF0ZS5qcz85YTQ1Il0sIm5hbWVzIjpbImdsb2JhbCIsInVuZGVmaW5lZCIsInNldEltbWVkaWF0ZSIsIm5leHRIYW5kbGUiLCJ0YXNrc0J5SGFuZGxlIiwiY3VycmVudGx5UnVubmluZ0FUYXNrIiwiZG9jIiwiZG9jdW1lbnQiLCJyZWdpc3RlckltbWVkaWF0ZSIsImNhbGxiYWNrIiwiRnVuY3Rpb24iLCJhcmdzIiwiQXJyYXkiLCJhcmd1bWVudHMiLCJsZW5ndGgiLCJpIiwidGFzayIsImNsZWFySW1tZWRpYXRlIiwiaGFuZGxlIiwicnVuIiwiYXBwbHkiLCJydW5JZlByZXNlbnQiLCJzZXRUaW1lb3V0IiwiaW5zdGFsbE5leHRUaWNrSW1wbGVtZW50YXRpb24iLCJwcm9jZXNzIiwibmV4dFRpY2siLCJjYW5Vc2VQb3N0TWVzc2FnZSIsInBvc3RNZXNzYWdlIiwiaW1wb3J0U2NyaXB0cyIsInBvc3RNZXNzYWdlSXNBc3luY2hyb25vdXMiLCJvbGRPbk1lc3NhZ2UiLCJvbm1lc3NhZ2UiLCJpbnN0YWxsUG9zdE1lc3NhZ2VJbXBsZW1lbnRhdGlvbiIsIm1lc3NhZ2VQcmVmaXgiLCJNYXRoIiwicmFuZG9tIiwib25HbG9iYWxNZXNzYWdlIiwiZXZlbnQiLCJzb3VyY2UiLCJkYXRhIiwiaW5kZXhPZiIsInNsaWNlIiwiYWRkRXZlbnRMaXN0ZW5lciIsImF0dGFjaEV2ZW50IiwiaW5zdGFsbE1lc3NhZ2VDaGFubmVsSW1wbGVtZW50YXRpb24iLCJjaGFubmVsIiwiTWVzc2FnZUNoYW5uZWwiLCJwb3J0MSIsInBvcnQyIiwiaW5zdGFsbFJlYWR5U3RhdGVDaGFuZ2VJbXBsZW1lbnRhdGlvbiIsImh0bWwiLCJkb2N1bWVudEVsZW1lbnQiLCJzY3JpcHQiLCJjcmVhdGVFbGVtZW50Iiwib25yZWFkeXN0YXRlY2hhbmdlIiwicmVtb3ZlQ2hpbGQiLCJhcHBlbmRDaGlsZCIsImluc3RhbGxTZXRUaW1lb3V0SW1wbGVtZW50YXRpb24iLCJhdHRhY2hUbyIsIk9iamVjdCIsImdldFByb3RvdHlwZU9mIiwidG9TdHJpbmciLCJjYWxsIiwic2VsZiJdLCJtYXBwaW5ncyI6IkFBQUMsa0VBQVVBLE1BQVYsRUFBa0JDLFNBQWxCLEVBQTZCO0FBQzFCOztBQUVBLFFBQUlELE9BQU9FLFlBQVgsRUFBeUI7QUFDckI7QUFDSDs7QUFFRCxRQUFJQyxhQUFhLENBQWpCLENBUDBCLENBT047QUFDcEIsUUFBSUMsZ0JBQWdCLEVBQXBCO0FBQ0EsUUFBSUMsd0JBQXdCLEtBQTVCO0FBQ0EsUUFBSUMsTUFBTU4sT0FBT08sUUFBakI7QUFDQSxRQUFJQyxpQkFBSjs7QUFFQSxhQUFTTixZQUFULENBQXNCTyxRQUF0QixFQUFnQztBQUM5QjtBQUNBLFlBQUksT0FBT0EsUUFBUCxLQUFvQixVQUF4QixFQUFvQztBQUNsQ0EsdUJBQVcsSUFBSUMsUUFBSixDQUFhLEtBQUtELFFBQWxCLENBQVg7QUFDRDtBQUNEO0FBQ0EsWUFBSUUsT0FBTyxJQUFJQyxLQUFKLENBQVVDLFVBQVVDLE1BQVYsR0FBbUIsQ0FBN0IsQ0FBWDtBQUNBLGFBQUssSUFBSUMsSUFBSSxDQUFiLEVBQWdCQSxJQUFJSixLQUFLRyxNQUF6QixFQUFpQ0MsR0FBakMsRUFBc0M7QUFDbENKLGlCQUFLSSxDQUFMLElBQVVGLFVBQVVFLElBQUksQ0FBZCxDQUFWO0FBQ0g7QUFDRDtBQUNBLFlBQUlDLE9BQU8sRUFBRVAsVUFBVUEsUUFBWixFQUFzQkUsTUFBTUEsSUFBNUIsRUFBWDtBQUNBUCxzQkFBY0QsVUFBZCxJQUE0QmEsSUFBNUI7QUFDQVIsMEJBQWtCTCxVQUFsQjtBQUNBLGVBQU9BLFlBQVA7QUFDRDs7QUFFRCxhQUFTYyxjQUFULENBQXdCQyxNQUF4QixFQUFnQztBQUM1QixlQUFPZCxjQUFjYyxNQUFkLENBQVA7QUFDSDs7QUFFRCxhQUFTQyxHQUFULENBQWFILElBQWIsRUFBbUI7QUFDZixZQUFJUCxXQUFXTyxL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SU8sSUFBSUcsbUJBQUosRUFBeUI7QUFDNUI7QUFDQU07QUFFSCxLQUpNLE1BSUEsSUFBSWhDLE9BQU84QyxjQUFYLEVBQTJCO0FBQzlCO0FBQ0FGO0FBRUgsS0FKTSxNQUlBLElBQUl0QyxPQUFPLHdCQUF3QkEsSUFBSStDLGFBQUosQ0FBa0IsUUFBbEIsQ0FBbkMsRUFBZ0U7QUFDbkU7QUFDQUo7QUFFSCxLQUpNLE1BSUE7QUFDSDtBQUNBUTtBQUNIOztBQUVEQyxhQUFTeEQsWUFBVCxHQUF3QkEsWUFBeEI7QUFDQXdELGFBQVN6QyxjQUFULEdBQTBCQSxjQUExQjtBQUNILENBekxBLEVBeUxDLE9BQU84QyxJQUFQLEtBQWdCLFdBQWhCLEdBQThCLE9BQU8vRCxNQUFQLEtBQWtCLFdBQWxCLEdBQWdDLElBQWhDLEdBQXVDQSxNQUFyRSxHQUE4RStELElBekwvRSxDQUFELEMiLCJmaWxlIjoiMzg5LmpzIiwic291cmNlc0NvbnRlbnQiOlsiKGZ1bmN0aW9uIChnbG9iYWwsIHVuZGVmaW5lZCkge1xuICAgIFwidXNlIHN0cmljdFwiO1xuXG4gICAgaWYgKGdsb2JhbC5zZXRJbW1lZGlhdGUpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBuZXh0SGFuZGxlID0gMTsgLy8gU3BlYyBzYXlzIGdyZWF0ZXIgdGhhbiB6ZXJvXG4gICAgdmFyIHRhc2tzQnlIYW5kbGUgPSB7fTtcbiAgICB2YXIgY3VycmVudGx5UnVubmluZ0FUYXNrID0gZmFsc2U7XG4gICAgdmFyIGRvYyA9IGdsb2JhbC5kb2N1bWVudDtcbiAgICB2YXIgcmVnaXN0ZXJJbW1lZGlhdGU7XG5cbiAgICBmdW5jdGlvbiBzZXRJbW1lZGlhdGUoY2FsbGJhY2spIHtcbiAgICAgIC8vIENhbGxiYWNrIGNhbiBlaXRoZXIgYmUgYSBmdW5jdGlvbiBvciBhIHN0cmluZ1xuICAgICAgaWYgKHR5cGVvZiBjYWxsYmFjayAhPT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgIGNhbGxiYWNrID0gbmV3IEZ1bmN0aW9uKFwiXCIgKyBjYWxsYmFjayk7XG4gICAgICB9XG4gICAgICAvLyBDb3B5IGZ1bmN0aW9uIGFyZ3VtZW50c1xuICAgICAgdmFyIGFyZ3MgPSBuZXcgQXJyYXkoYXJndW1lbnRzLmxlbmd0aCAtIDEpO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcmdzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgYXJnc1tpXSA9IGFyZ3VtZW50c1tpICsgMV07XG4gICAgICB9XG4gICAgICAvLyBTdG9yZSBhbmQgcmVnaXN0ZXIgdGhlIHRhc2tcbiAgICAgIHZhciB0YXNrID0geyBjYWxsYmFjazogY2FsbGJhY2ssIGFyZ3M6IGFyZ3MgfTtcbiAgICAgIHRhc2tzQnlIYW5kbGVbbmV4dEhhbmRsZV0gPSB0YXNrO1xuICAgICAgcmVnaXN0ZXJJbW1lZGlhdGUobmV4dEhhbmRsZSk7XG4gICAgICByZXR1cm4gbmV4dEhhbmRsZSsrO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNsZWFySW1tZWRpYXRlKGhhbmRsZSkge1xuICAgICAgICBkZWxldGUgdGFza3NCeUhhbmRsZVtoYW5kbGVdO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHJ1bih0YXNrKSB7XG4gICAgICAgIHZhciBjYWxsYmFjayA9IHRhc2suY2FsbGJhY2s7XG4gICAgICAgIHZhciBhcmdzID0gdGFzay5hcmdzO1xuICAgICAgICBzd2l0Y2ggKGFyZ3MubGVuZ3RoKSB7XG4gICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgIGNhbGxiYWNrKCk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgY2FsbGJhY2soYXJnc1swXSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgY2FsbGJhY2soYXJnc1swXSwgYXJnc1sxXSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgY2FsbGJhY2soYXJnc1swXSwgYXJnc1sxXSwgYXJnc1syXSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIGNhbGxiYWNrLmFwcGx5KHVuZGVmaW5lZCwgYXJncyk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIHJ1bklmUHJlc2VudChoYW5kbGUpIHtcbiAgICAgICAgLy8gRnJvbSB0aGUgc3BlYzogXCJXYWl0IHVudGlsIGFueSBpbnZvY2F0aW9ucyBvZiB0aGlzIGFsZ29yaXRobSBzdGFydGVkIGJlZm9yZSB0aGlzIG9uZSBoYXZlIGNvbXBsZXRlZC5cIlxuICAgICAgICAvLyBTbyBpZiB3ZSdyZSBjdXJyZW50bHkgcnVubmluZyBhIHRhc2ssIHdlJ2xsIG5lZWQgdG8gZGVsYXkgdGhpcyBpbnZvY2F0aW9uLlxuICAgICAgICBpZiAoY3VycmVudGx5UnVubmluZ0FUYXNrKSB7XG4gICAgICAgICAgICAvLyBEZWxheSBieSBkb2luZyBhIHNldFRpbWVvdXQuIHNldEltbWVkaWF0ZSB3YXMgdHJpZWQgaW5zdGVhZCwgYnV0IGluIEZpcmVmb3ggNyBpdCBnZW5lcmF0ZWQgYVxuICAgICAgICAgICAgLy8gXCJ0b28gbXVjaCByZWN1cnNpb25cIiBlcnJvci5cbiAgICAgICAgICAgIHNldFRpbWVvdXQocnVuSWZQcmVzZW50LCAwLCBoYW5kbGUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdmFyIHRhc2sgPSB0YXNrc0J5SGFuZGxlW2hhbmRsZV07XG4gICAgICAgICAgICBpZiAodGFzaykge1xuICAgICAgICAgICAgICAgIGN1cnJlbnRseVJ1bm5pbmdBVGFzayA9IHRydWU7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgcnVuKHRhc2spO1xuICAgICAgICAgICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICAgICAgICAgIGNsZWFySW1tZWRpYXRlKGhhbmRsZSk7XG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnRseVJ1bm5pbmdBVGFzayA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGluc3RhbGxOZXh0VGlja0ltcGxlbWVudGF0aW9uKCkge1xuICAgICAgICByZWdpc3RlckltbWVkaWF0ZSA9IGZ1bmN0aW9uKGhhbmRsZSkge1xuICAgICAgICAgICAgcHJvY2Vzcy5uZXh0VGljayhmdW5jdGlvbiAoKSB7IHJ1bklmUHJlc2VudChoYW5kbGUpOyB9KTtcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjYW5Vc2VQb3N0TWVzc2FnZSgpIHtcbiAgICAgICAgLy8gVGhlIHRlc3QgYWdhaW5zdCBgaW1wb3J0U2NyaXB0c2AgcHJldmVudHMgdGhpcyBpbXBsZW1lbnRhdGlvbiBmcm9tIGJlaW5nIGluc3RhbGxlZCBpbnNpZGUgYSB3ZWIgd29ya2VyLFxuICAgICAgICAvLyB3aGVyZSBgZ2xvYmFsLnBvc3RNZXNzYWdlYCBtZWFucyBzb21ldGhpbmcgY29tcGxldGVseSBkaWZmZXJlbnQgYW5kIGNhbid0IGJlIHVzZWQgZm9yIHRoaXMgcHVycG9zZS5cbiAgICAgICAgaWYgKGdsb2JhbC5wb3N0TWVzc2FnZSAmJiAhZ2xvYmFsLmltcG9ydFNjcmlwdHMpIHtcbiAgICAgICAgICAgIHZhciBwb3N0TWVzc2FnZUlzQXN5bmNocm9ub3VzID0gdHJ1ZTtcbiAgICAgICAgICAgIHZhciBvbGRPbk1lc3NhZ2UgPSBnbG9iYWwub25tZXNzYWdlO1xuICAgICAgICAgICAgZ2xvYmFsLm9ubWVzc2FnZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHBvc3RNZXNzYWdlSXNBc3luY2hyb25vdXMgPSBmYWxzZTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBnbG9iYWwucG9zdE1lc3NhZ2UoXCJcIiwgXCIqXCIpO1xuICAgICAgICAgICAgZ2xvYmFsLm9ubWVzc2FnZSA9IG9sZE9uTWVzc2FnZTtcbiAgICAgICAgICAgIHJldHVybiBwb3N0TWVzc2FnZUlzQXN5bmNocm9ub3VzO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaW5zdGFsbFBvc3RNZXNzYWdlSW1wbGVtZW50YXRpb24oKSB7XG4gICAgICAgIC8vIEluc3RhbGxzIGFuIGV2ZW50IGhhbmRsZXIgb24gYGdsb2JhbGAgZm9yIHRoZSBgbWVzc2FnZWAgZXZlbnQ6IHNlZVxuICAgICAgICAvLyAqIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuL0RPTS93aW5kb3cucG9zdE1lc3NhZ2VcbiAgICAgICAgLy8gKiBodHRwOi8vd3d3LndoYXR3Zy5vcmcvc3BlY3Mvd2ViLWFwcHMvY3VycmVudC13b3JrL211bHRpcGFnZS9jb21tcy5odG1sI2Nyb3NzRG9jdW1lbnRNZXNzYWdlc1xuXG4gICAgICAgIHZhciBtZXNzYWdlUHJlZml4ID0gXCJzZXRJbW1lZGlhdGUkXCIgKyBNYXRoLnJhbmRvbSgpICsgXCIkXCI7XG4gICAgICAgIHZhciBvbkdsb2JhbE1lc3NhZ2UgPSBmdW5jdGlvbihldmVudCkge1xuICAgICAgICAgICAgaWYgKGV2ZW50LnNvdXJjZSA9PT0gZ2xvYmFsICYmXG4gICAgICAgICAgICAgICAgdHlwZW9mIGV2ZW50LmRhdGEgPT09IFwic3RyaW5nXCIgJiZcbiAgICAgICAgICAgICAgICBldmVudC5kYXRhLmluZGV4T2YobWVzc2FnZVByZWZpeCkgPT09IDApIHtcbiAgICAgICAgICAgICAgICBydW5JZlByZXNlbnQoK2V2ZW50LmRhdGEuc2xpY2UobWVzc2FnZVByZWZpeC5sZW5ndGgpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcblxuICAgICAgICBpZiAoZ2xvYmFsLmFkZEV2ZW50TGlzdGVuZXIpIHtcbiAgICAgICAgICAgIGdsb2JhbC5hZGRFdmVudExpc3RlbmVyKFwibWVzc2FnZVwiLCBvbkdsb2JhbE1lc3NhZ2UsIGZhbHNlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGdsb2JhbC5hdHRhY2hFdmVudChcIm9ubWVzc2FnZVwiLCBvbkdsb2JhbE1lc3NhZ2UpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmVnaXN0ZXJJbW1lZGlhdGUgPSBmdW5jdGlvbihoYW5kbGUpIHtcbiAgICAgICAgICAgIGdsb2JhbC5wb3N0TWVzc2FnZShtZXNzYWdlUHJlZml4ICsgaGFuZGxlLCBcIipcIik7XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaW5zdGFsbE1lc3NhZ2VDaGFubmVsSW1wbGVtZW50YXRpb24oKSB7XG4gICAgICAgIHZhciBjaGFubmVsID0gbmV3IE1lc3NhZ2VDaGFubmVsKCk7XG4gICAgICAgIGNoYW5uZWwucG9ydDEub25tZXNzYWdlID0gZnVuY3Rpb24oZXZlbnQpIHtcbiAgICAgICAgICAgIHZhciBoYW5kbGUgPSBldmVudC5kYXRhO1xuICAgICAgICAgICAgcnVuSWZQcmVzZW50KGhhbmRsZSk7XG4gICAgICAgIH07XG5cbiAgICAgICAgcmVnaXN0ZXJJbW1lZGlhdGUgPSBmdW5jdGlvbihoYW5kbGUpIHtcbiAgICAgICAgICAgIGNoYW5uZWwucG9ydDIucG9zdE1lc3NhZ2UoaGFuZGxlKTtcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpbnN0YWxsUmVhZHlTdGF0ZUNoYW5nZUltcGxlbWVudGF0aW9uKCkge1xuICAgICAgICB2YXIgaHRtbCA9IGRvYy5kb2N1bWVudEVsZW1lbnQ7XG4gICAgICAgIHJlZ2lzdGVySW1tZWRpYXRlID0gZnVuY3Rpb24oaGFuZGxlKSB7XG4gICAgICAgICAgICAvLyBDcmVhdGUgYSA8c2NyaXB0PiBlbGVtZW50OyBpdHMgcmVhZHlzdGF0ZWNoYW5nZSBldmVudCB3aWxsIGJlIGZpcmVkIGFzeW5jaHJvbm91c2x5IG9uY2UgaXQgaXMgaW5zZXJ0ZWRcbiAgICAgICAgICAgIC8vIGludG8gdGhlIGRvY3VtZW50LiBEbyBzbywgdGh1cyBxdWV1aW5nIHVwIHRoZSB0YXNrLiBSZW1lbWJlciB0byBjbGVhbiB1cCBvbmNlIGl0J3MgYmVlbiBjYWxsZWQuXG4gICAgICAgICAgICB2YXIgc2NyaXB0ID0gZG9jLmNyZWF0ZUVsZW1lbnQoXCJzY3JpcHRcIik7XG4gICAgICAgICAgICBzY3JpcHQub25yZWFkeXN0YXRlY2hhbmdlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHJ1bklmUHJlc2VudChoYW5kbGUpO1xuICAgICAgICAgICAgICAgIHNjcmlwdC5vbnJlYWR5c3RhdGVjaGFuZ2UgPSBudWxsO1xuICAgICAgICAgICAgICAgIGh0bWwucmVtb3ZlQ2hpbGQoc2NyaXB0KTtcbiAgICAgICAgICAgICAgICBzY3JpcHQgPSBudWxsO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGh0bWwuYXBwZW5kQ2hpbGQoc2NyaXB0KTtcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpbnN0YWxsU2V0VGltZW91dEltcGxlbWVudGF0aW9uKCkge1xuICAgICAgICByZWdpc3RlckltbWVkaWF0ZSA9IGZ1bmN0aW9uKGhhbmRsZSkge1xuICAgICAgICAgICAgc2V0VGltZW91dChydW5JZlByZXNlbnQsIDAsIGhhbmRsZSk7XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgLy8gSWYgc3VwcG9ydGVkLCB3ZSBzaG91bGQgYXR0YWNoIHRvIHRoZSBwcm90b3R5cGUgb2YgZ2xvYmFsLCBzaW5jZSB0aGF0IGlzIHdoZXJlIHNldFRpbWVvdXQgZXQgYWwuIGxpdmUuXG4gICAgdmFyIGF0dGFjaFRvID0gT2JqZWN0LmdldFByb3RvdHlwZU9mICYmIE9iamVjdC5nZXRQcm90b3R5cGVPZihnbG9iYWwpO1xuICAgIGF0dGFjaFRvID0gYXR0YWNoVG8gJiYgYXR0YWNoVG8uc2V0VGltZW91dCA/IGF0dGFjaFRvIDogZ2xvYmFsO1xuXG4gICAgLy8gRG9uJ3QgZ2V0IGZvb2xlZCBieSBlLmcuIGJyb3dzZXJpZnkgZW52aXJvbm1lbnRzLlxuICAgIGlmICh7fS50b1N0cmluZy5jYWxsKGdsb2JhbC5wcm9jZXNzKSA9PT0gXCJbb2JqZWN0IHByb2Nlc3NdXCIpIHtcbiAgICAgICAgLy8gRm9yIE5vZGUuanMgYmVmb3JlIDAuOVxuICAgICAgICBpbnN0YWxsTmV4dFRpY2tJbXBsZW1lbnRhdGlvbigpO1xuXG4gICAgfSBlbHNlIGlmIChjYW5Vc2VQb3N0TWVzc2FnZSgpKSB7XG4gICAgICAgIC8vIEZvciBub24tSUUxMCBtb2Rlcm4gYnJvd3NlcnNcbiAgICAgICAgaW5zdGFsbFBvc3RNZXNzYWdlSW1wbGVtZW50YXRpb24oKTtcblxuICAgIH0gZWxzZSBpZiAoZ2xvYmFsLk1lc3NhZ2VDaGFubmVsKSB7XG4gICAgICAgIC8vIEZvciB3ZWIgd29ya2Vycywgd2hlcmUgc3VwcG9ydGVkXG4gICAgICAgIGluc3RhbGxNZXNzYWdlQ2hhbm5lbEltcGxlbWVudGF0aW9uKCk7XG5cbiAgICB9IGVsc2UgaWYgKGRvYyAmJiBcIm9ucmVhZHlzdGF0ZWNoYW5nZVwiIGluIGRvYy5jcmVhdGVFbGVtZW50KFwic2NyaXB0XCIpKSB7XG4gICAgICAgIC8vIEZvciBJRSA24oCTOFxuICAgICAgICBpbnN0YWxsUmVhZHlTdGF0ZUNoYW5nZUltcGxlbWVudGF0aW9uKCk7XG5cbiAgICB9IGVsc2Uge1xuICAgICAgICAvLyBGb3Igb2xkZXIgYnJvd3NlcnNcbiAgICAgICAgaW5zdGFsbFNldFRpbWVvdXRJbXBsZW1lbnRhdGlvbigpO1xuICAgIH1cblxuICAgIGF0dGFjaFRvLnNldEltbWVkaWF0ZSA9IHNldEltbWVkaWF0ZTtcbiAgICBhdHRhY2hUby5jbGVhckltbWVkaWF0ZSA9IGNsZWFySW1tZWRpYXRlO1xufSh0eXBlb2Ygc2VsZiA9PT0gXCJ1bmRlZmluZWRcIiA/IHR5cGVvZiBnbG9iYWwgPT09IFwidW5kZWZpbmVkXCIgPyB0aGlzIDogZ2xvYmFsIDogc2VsZikpO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9fc2V0aW1tZWRpYXRlQDEuMC41QHNldGltbWVkaWF0ZS9zZXRJbW1lZGlhdGUuanMiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///389\n");

/***/ }),

/***/ 391:
/***/ (function(module, exports, __webpack_require__) {

eval("var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_RESULT__;var _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\n/*! tether 1.4.3 */\n\n(function (root, factory) {\n  if (true) {\n    !(__WEBPACK_AMD_DEFINE_FACTORY__ = (factory),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?\n\t\t\t\t(__WEBPACK_AMD_DEFINE_FACTORY__.call(exports, __webpack_require__, exports, module)) :\n\t\t\t\t__WEBPACK_AMD_DEFINE_FACTORY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n  } else if ((typeof exports === 'undefined' ? 'undefined' : _typeof(exports)) === 'object') {\n    module.exports = factory(require, exports, module);\n  } else {\n    root.Tether = factory();\n  }\n})(this, function (require, exports, module) {\n\n  'use strict';\n\n  var _createClass = function () {\n    function defineProperties(target, props) {\n      for (var i = 0; i < props.length; i++) {\n        var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ('value' in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);\n      }\n    }return function (Constructor, protoProps, staticProps) {\n      if (protoProps) defineProperties(Constructor.prototype, protoProps);if (staticProps) defineProperties(Constructor, staticProps);return Constructor;\n    };\n  }();\n\n  function _classCallCheck(instance, Constructor) {\n    if (!(instance instanceof Constructor)) {\n      throw new TypeError('Cannot call a class as a function');\n    }\n  }\n\n  var TetherBase = undefined;\n  if (typeof TetherBase === 'undefined') {\n    TetherBase = { modules: [] };\n  }\n\n  var zeroElement = null;\n\n  // Same as native getBoundingClientRect, except it takes into account parent <frame> offsets\n  // if the element lies within a nested document (<frame> or <iframe>-like).\n  function getActualBoundingClientRect(node) {\n    var boundingRect = node.getBoundingClientRect();\n\n    // The original object returned by getBoundingClientRect is immutable, so we clone it\n    // We can't use extend because the properties are not considered part of the object by hasOwnProperty in IE9\n    var rect = {};\n    for (var k in boundingRect) {\n      rect[k] = boundingRect[k];\n    }\n\n    if (node.ownerDocument !== document) {\n      var _frameElement = node.ownerDocument.defaultView.frameElement;\n      if (_frameElement) {\n        var frameRect = getActualBoundingClientRect(_frameElement);\n        rect.top += frameRect.top;\n        rect.bottom += frameRect.top;\n        rect.left += frameRect.left;\n        rect.right += frameRect.left;\n      }\n    }\n\n    return rect;\n  }\n\n  function getScrollParents(el) {\n    // In firefox if the el is inside an iframe with display: none; window.getComputedStyle() will return null;\n    // https://bugzilla.mozilla.org/show_bug.cgi?id=548397\n    var computedStyle = getComputedStyle(el) || {};\n    var position = computedStyle.position;\n    var parents = [];\n\n    if (position === 'fixed') {\n      return [el];\n    }\n\n    var parent = el;\n    while ((parent = parent.parentNode) && parent && parent.nodeType === 1) {\n      var style = undefined;\n      try {\n        style = getComputedStyle(parent);\n      } catch (err) {}\n\n      if (typeof style === 'undefined' || style === null) {\n        parents.push(parent);\n        return parents;\n      }\n\n      var _style = style;\n      var overflow = _style.overflow;\n      var overflowX = _style.overflowX;\n      var overflowY = _style.overflowY;\n\n      if (/(auto|scroll|overlay)/.test(overflow + overflowY + overflowX)) {\n        if (position !== 'absolute' || ['relative', 'absolute', 'fixed'].indexOf(style.position) >= 0) {\n          parents.push(parent);\n        }\n      }\n    }\n\n    parents.push(el.ownerDocument.body);\n\n    // If the node is within a frame, account for the parent window scroll\n    if (el.ownerDocument !== document) {\n      parents.push(el.ownerDocument.defaultView);\n    }\n\n    return parents;\n  }\n\n  var uniqueId = function () {\n    var id = 0;\n    return function () {\n      return ++id;\n    };\n  }();\n\n  var zeroPosCache = {};\n  var getOrigin = function getOrigin() {\n    // getBoundingClientRect is unfortunately too accurate.  It introduces a pixel or two of\n    // jitter as the user scrolls that messes with our ability to detect if two positions\n    // are equivilant or not.  We place an element at the top left of the page that will\n    // get the same jitter, so we can cancel the two out.\n    var node = zeroElement;\n    if (!node || !document.body.contains(node)) {\n      node = document.createElement('div');\n      node.setAttribute('data-tether-id', uniqueId());\n      extend(node.style, {\n        top: 0,\n        left: 0,\n        position: 'absolute'\n      });\n\n      document.body.appendChild(node);\n\n      zeroElement = node;\n    }\n\n    var id = node.getAttribute('data-tether-id');\n    if (typeof zeroPosCache[id] === 'undefined') {\n      zeroPosCache[id] = getActualBoundingClientRect(node);\n\n      // Clear the cache when this position call is done\n      defer(function () {\n        delete zeroPosCache[id];\n      });\n    }\n\n    return zeroPosCache[id];\n  };\n\n  function removeUtilElements() {\n    if (zeroElement) {\n      document.body.removeChild(zeroElement);\n    }\n    zeroElement = null;\n  };\n\n  function getBounds(el) {\n    var doc = undefined;\n    if (el === document) {\n      doc = document;\n      el = document.documentElement;\n    } else {\n      doc = el.ownerDocument;\n    }\n\n    var docEl = doc.documentElement;\n\n    var box = getActualBoundingClientRect(el);\n\n    var origin = getOrigin();\n\n    box.top -= origin.top;\n    box.left -= origin.left;\n\n    if (typeof box.width === 'undefined') {\n      box.width = document.body.scrollWidth - box.left - box.right;\n    }\n    if (typeof box.height === 'undefined') {\n      box.height = document.body.scrollHeight - box.top - box.bottom;\n    }\n\n    box.top = box.top - docEl.clientTop;\n    box.left = box.left - docEl.clientLeft;\n    box.right = doc.body.clientWidth - box.width - box.left;\n    box.bottom = doc.body.clientHeight - box.height - box.top;\n\n    return box;\n  }\n\n  function getOffsetParent(el) {\n    return el.offsetParent || document.documentElement;\n  }\n\n  var _scrollBarSize = null;\n  function getScrollBarSize() {\n    if (_scrollBarSize) {\n      return _scrollBarSize;\n    }\n    var inner = document.createElement('div');\n    inner.style.width = '100%';\n    inner.style.height = '200px';\n\n    var outer = document.createElement('div');\n    extend(outer.style, {\n      position: 'absolute',\n      top: 0,\n      left: 0,\n      pointerEvents: 'none',\n      visibility: 'hidden',\n      width: '200px',\n      height: '150px',\n      overflow: 'hidden'\n    });\n\n    outer.appendChild(inner);\n\n    document.body.appendChild(outer);\n\n    var widthContained = inner.offsetWidth;\n    outer.style.overflow = 'scroll';\n    var widthScroll = inner.offsetWidth;\n\n    if (widthContained === widthScroll) {\n      widthScroll = outer.clientWidth;\n    }\n\n    document.body.removeChild(outer);\n\n    var width = widthContained - widthScroll;\n\n    _scrollBarSize = { width: width, height: width };\n    return _scrollBarSize;\n  }\n\n  function extend() {\n    var out = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];\n\n    var args = [];\n\n    Array.prototype.push.apply(args, arguments);\n\n    args.slice(1).forEach(function (obj) {\n      if (obj) {\n        for (var key in obj) {\n          if ({}.hasOwnProperty.call(obj, key)) {\n            out[key] = obj[key];\n          }\n        }\n      }\n    });\n\n    return out;\n  }\n\n  function removeClass(el, name) {\n    if (typeof el.classList !== 'undefined') {\n      name.split(' ').forEach(function (cls) {\n        if (cls.trim()) {\n          el.classList.remove(cls);\n        }\n      });\n    } else {\n      var regex = new RegExp('(^| )' + name.split(' ').join('|') + '( |$)', 'gi');\n      var className = getClassName(el).replace(regex, ' ');\n      setClassName(el, className);\n    }\n  }\n\n  function addClass(el, name) {\n    if (typeof el.classList !== 'undefined') {\n      name.split(' ').forEach(function (cls) {\n        if (cls.trim()) {\n          el.classList.add(cls);\n        }\n      });\n    } else {\n      removeClass(el, name);\n      var cls = getClassName(el) + (' ' + name);\n      setClassName(el, cls);\n    }\n  }\n\n  function hasClass(el, name) {\n    if (typeof el.classList !== 'undefined') {\n      return el.classList.contains(name);\n    }\n    var className = getClassName(el);\n    return new RegExp('(^| )' + name + '( |$)', 'gi').test(className);\n  }\n\n  function getClassName(el) {\n    // Can't use just SVGAnimatedString here since nodes within a Frame in IE have\n    // completely separately SVGAnimatedString base classes\n    if (el.className instanceof el.ownerDocument.defaultView.SVGAnimatedString) {\n      return el.className.baseVal;\n    }\n    return el.className;\n  }\n\n  function setClassName(el, className) {\n    el.setAttribute('class', className);\n  }\n\n  function updateClasses(el, add, all) {\n    // Of the set of 'all' classes, we need the 'add' classes, and only the\n    // 'add' classes to be set.\n    all.forEach(function (cls) {\n      if (add.indexOf(cls) === -1 && hasClass(el, cls)) {\n        removeClass(el, cls);\n      }\n    });\n\n    add.forEach(function (cls) {\n      if (!hasClass(el, cls)) {\n        addClass(el, cls);\n      }\n    });\n  }\n\n  var deferred = [];\n\n  var defer = function defer(fn) {\n    deferred.push(fn);\n  };\n\n  var flush = function flush() {\n    var fn = undefined;\n    while (fn = deferred.pop()) {\n      fn();\n    }\n  };\n\n  var Evented = function () {\n    function Evented() {\n      _classCallCheck(this, Evented);\n    }\n\n    _createClass(Evented, [{\n      key: 'on',\n      value: function on(event, handler, ctx) {\n        var once = arguments.length <= 3 || arguments[3] === undefined ? false : arguments[3];\n\n        if (typeof this.bindings === 'undefined') {\n          this.bindings = {};\n        }\n        if (typeof this.bindings[event] === 'undefined') {\n          this.bindings[event] = [];\n        }\n        this.bindings[event].push({ handler: handler, ctx: ctx, once: once });\n      }\n    }, {\n      key: 'once',\n      value: function once(event, handler, ctx) {\n        this.on(event, handler, ctx, true);\n      }\n    }, {\n      key: 'off',\n      value: function off(event, handler) {\n        if (typeof this.bindings === 'undefined' || typeof this.bindings[event] === 'undefined') {\n          return;\n        }\n\n        if (typeof handler === 'undefined') {\n          delete this.bindings[event];\n        } else {\n          var i = 0;\n          while (i < this.bindings[event].length) {\n            if (this.bindings[event][i].handler === handler) {\n              this.bindings[event].splice(i, 1);\n            } else {\n              ++i;\n            }\n          }\n        }\n      }\n    }, {\n      key: 'trigger',\n      value: function trigger(event) {\n        if (typeof this.bindings !== 'undefined' && this.bindings[event]) {\n          var i = 0;\n\n          for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n            args[_key - 1] = arguments[_key];\n          }\n\n          while (i < this.bindings[event].length) {\n            var _bindings$event$i = this.bindings[event][i];\n            var handler = _bindings$event$i.handler;\n            var ctx = _bindings$event$i.ctx;\n            var once = _bindings$event$i.once;\n\n            var context = ctx;\n            if (typeof context === 'undefined') {\n              context = this;\n            }\n\n            handler.apply(context, args);\n\n            if (once) {\n              this.bindings[event].splice(i, 1);\n            } else {\n              ++i;\n            }\n          }\n        }\n      }\n    }]);\n\n    return Evented;\n  }();\n\n  TetherBase.Utils = {\n    getActualBoundingClientRect: getActualBoundingClientRect,\n    getScrollParents: getScrollParents,\n    getBounds: getBounds,\n    getOffsetParent: getOffsetParent,\n    extend: extend,\n    addClass: addClass,\n    removeClass: removeClass,\n    hasClass: hasClass,\n    updateClasses: updateClasses,\n    defer: defer,\n    flush: flush,\n    uniqueId: uniqueId,\n    Evented: Evented,\n    getScrollBarSize: getScrollBarSize,\n    removeUtilElements: removeUtilElements\n  };\n  /* globals TetherBase, performance */\n\n  'use strict';\n\n  var _slicedToArray = function () {\n    function sliceIterator(arr, i) {\n      var _arr = [];var _n = true;var _d = false;var _e = undefined;try {\n        for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {\n          _arr.push(_s.value);if (i && _arr.length === i) break;\n        }\n      } catch (err) {\n        _d = true;_e = err;\n      } finally {\n        try {\n          if (!_n && _i['return']) _i['return']();\n        } finally {\n          if (_d) throw _e;\n        }\n      }return _arr;\n    }return function (arr, i) {\n      if (Array.isArray(arr)) {\n        return arr;\n      } else if (Symbol.iterator in Object(arr)) {\n        return sliceIterator(arr, i);\n      } else {\n        throw new TypeError('Invalid attempt to destructure non-iterable instance');\n      }\n    };\n  }();\n\n  var _createClass = function () {\n    function defineProperties(target, props) {\n      for (var i = 0; i < props.length; i++) {\n        var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ('value' in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);\n      }\n    }return function (Constructor, protoProps, staticProps) {\n      if (protoProps) defineProperties(Constructor.prototype, protoProps);if (staticProps) defineProperties(Constructor, staticProps);return Constructor;\n    };\n  }();\n\n  var _get = function get(_x6, _x7, _x8) {\n    var _again = true;_function: while (_again) {\n      var object = _x6,\n          property = _x7,\n          receiver = _x8;_again = false;if (object === null) object = Function.prototype;var desc = Object.getOwnPropertyDescriptor(object, property);if (desc === undefined) {\n        var parent = Object.getPrototypeOf(object);if (parent === null) {\n          return undefined;\n        } else {\n          _x6 = parent;_x7 = property;_x8 = receiver;_again = true;desc = parent = undefined;continue _function;\n        }\n      } else if ('value' in desc) {\n        return desc.value;\n      } else {\n        var getter = desc.get;if (getter === undefined) {\n          return undefined;\n        }return getter.call(receiver);\n      }\n    }\n  };\n\n  function _classCallCheck(instance, Constructor) {\n    if (!(instance instanceof Constructor)) {\n      throw new TypeError('Cannot call a class as a function');\n    }\n  }\n\n  function _inherits(subClass, superClass) {\n    if (typeof superClass !== 'function' && superClass !== null) {\n      throw new TypeError('Super expression must either be null or a function, not ' + (typeof superClass === 'undefined' ? 'undefined' : _typeof(superClass)));\n    }subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;\n  }\n\n  if (typeof TetherBase === 'undefined') {\n    throw new Error('You must include the utils.js file before tether.js');\n  }\n\n  var _TetherBase$Utils = TetherBase.Utils;\n  var getScrollParents = _TetherBase$Utils.getScrollParents;\n  var getBounds = _TetherBase$Utils.getBounds;\n  var getOffsetParent = _TetherBase$Utils.getOffsetParent;\n  var extend = _TetherBase$Utils.extend;\n  var addClass = _TetherBase$Utils.addClass;\n  var removeClass = _TetherBase$Utils.removeClass;\n  var updateClasses = _TetherBase$Utils.updateClasses;\n  var defer = _TetherBase$Utils.defer;\n  var flush = _TetherBase$Utils.flush;\n  var getScrollBarSize = _TetherBase$Utils.getScrollBarSize;\n  var removeUtilElements = _TetherBase$Utils.removeUtilElements;\n\n  function within(a, b) {\n    var diff = arguments.length <= 2 || arguments[2] === undefined ? 1 : arguments[2];\n\n    return a + diff >= b && b >= a - diff;\n  }\n\n  var transformKey = function () {\n    if (typeof document === 'undefined') {\n      return '';\n    }\n    var el = document.createElement('div');\n\n    var transforms = ['transform', 'WebkitTransform', 'OTransform', 'MozTransform', 'msTransform'];\n    for (var i = 0; i < transforms.length; ++i) {\n      var key = transforms[i];\n      if (el.style[key] !== undefined) {\n        return key;\n      }\n    }\n  }();\n\n  var tethers = [];\n\n  var position = function position() {\n    tethers.forEach(function (tether) {\n      tether.position(false);\n    });\n    flush();\n  };\n\n  function now() {\n    if ((typeof performance === 'undefined' ? 'undefined' : _typeof(performance)) === 'object' && typeof performance.now === 'function') {\n      return performance.now();\n    }\n    return +new Date();\n  }\n\n  (function () {\n    var lastCall = null;\n    var lastDuration = null;\n    var pendingTimeout = null;\n\n    var tick = function tick() {\n      if (typeof lastDuration !== 'undefined' && lastDuration > 16) {\n        // We voluntarily throttle ourselves if we can't manage 60fps\n        lastDuration = Math.min(lastDuration - 16, 250);\n\n        // Just in case this is the last event, remember to position just once more\n        pendingTimeout = setTimeout(tick, 250);\n        return;\n      }\n\n      if (typeof lastCall !== 'undefined' && now() - lastCall < 10) {\n        // Some browsers call events a little too frequently, refuse to run more than is reasonable\n        return;\n      }\n\n      if (pendingTimeout != null) {\n        clearTimeout(pendingTimeout);\n        pendingTimeout = null;\n      }\n\n      lastCall = now();\n      position();\n      lastDuration = now() - lastCall;\n    };\n\n    if (typeof window !== 'undefined' && typeof window.addEventListener !== 'undefined') {\n      ['resize', 'scroll', 'touchmove'].forEach(function (event) {\n        window.addEventListener(event, tick);\n      });\n    }\n  })();\n\n  var MIRROR_LR = {\n    center: 'center',\n    left: 'right',\n    right: 'left'\n  };\n\n  var MIRROR_TB = {\n    middle: 'middle',\n    top: 'bottom',\n    bottom: 'top'\n  };\n\n  var OFFSET_MAP = {\n    top: 0,\n    left: 0,\n    middle: '50%',\n    center: '50%',\n    bottom: '100%',\n    right: '100%'\n  };\n\n  var autoToFixedAttachment = function autoToFixedAttachment(attachment, relativeToAttachment) {\n    var left = attachment.left;\n    var top = attachment.top;\n\n    if (left === 'auto') {\n      left = MIRROR_LR[relativeToAttachment.left];\n    }\n\n    if (top === 'auto') {\n      top = MIRROR_TB[relativeToAttachment.top];\n    }\n\n    return { left: left, top: top };\n  };\n\n  var attachmentToOffset = function attachmentToOffset(attachment) {\n    var left = attachment.left;\n    var top = attachment.top;\n\n    if (typeof OFFSET_MAP[attachment.left] !== 'undefined') {\n      left = OFFSET_MAP[attachment.left];\n    }\n\n    if (typeof OFFSET_MAP[attachment.top] !== 'undefined') {\n      top = OFFSET_MAP[attachment.top];\n    }\n\n    return { left: left, top: top };\n  };\n\n  function addOffset() {\n    var out = { top: 0, left: 0 };\n\n    for (var _len = arguments.length, offsets = Array(_len), _key = 0; _key < _len; _key++) {\n      offsets[_key] = arguments[_key];\n    }\n\n    offsets.forEach(function (_ref) {\n      var top = _ref.top;\n      var left = _ref.left;\n\n      if (typeof top === 'string') {\n        top = parseFloat(top, 10);\n      }\n      if (typeof left === 'string') {\n        left = parseFloat(left, 10);\n      }\n\n      out.top += top;\n      out.left += left;\n    });\n\n    return out;\n  }\n\n  function offsetToPx(offset, size) {\n    if (typeof offset.left === 'string' && offset.left.indexOf('%') !== -1) {\n      offset.left = parseFloat(offset.left, 10) / 100 * size.width;\n    }\n    if (typeof offset.top === 'string' && offset.top.indexOf('%') !== -1) {\n      offset.top = parseFloat(offset.top, 10) / 100 * size.height;\n    }\n\n    return offset;\n  }\n\n  var parseOffset = function parseOffset(value) {\n    var _value$split = value.split(' ');\n\n    var _value$split2 = _slicedToArray(_value$split, 2);\n\n    var top = _value$split2[0];\n    var left = _value$split2[1];\n\n    return { top: top, left: left };\n  };\n  var parseAttachment = parseOffset;\n\n  var TetherClass = function (_Evented) {\n    _inherits(TetherClass, _Evented);\n\n    function TetherClass(options) {\n      var _this = this;\n\n      _classCallCheck(this, TetherClass);\n\n      _get(Object.getPrototypeOf(TetherClass.prototype), 'constructor', this).call(this);\n      this.position = this.position.bind(this);\n\n      tethers.push(this);\n\n      this.history = [];\n\n      this.setOptions(options, false);\n\n      TetherBase.modules.forEach(function (module) {\n        if (typeof module.initialize !== 'undefined') {\n          module.initialize.call(_this);\n        }\n      });\n\n      this.position();\n    }\n\n    _createClass(TetherClass, [{\n      key: 'getClass',\n      value: function getClass() {\n        var key = arguments.length <= 0 || arguments[0] === undefined ? '' : arguments[0];\n        var classes = this.options.classes;\n\n        if (typeof classes !== 'undefined' && classes[key]) {\n          return this.options.classes[key];\n        } else if (this.options.classPrefix) {\n          return this.options.classPrefix + '-' + key;\n        } else {\n          return key;\n        }\n      }\n    }, {\n      key: 'setOptions',\n      value: function setOptions(options) {\n        var _this2 = this;\n\n        var pos = arguments.length <= 1 || arguments[1] === undefined ? true : arguments[1];\n\n        var defaults = {\n          offset: '0 0',\n          targetOffset: '0 0',\n          targetAttachment: 'auto auto',\n          classPrefix: 'tether'\n        };\n\n        this.options = extend(defaults, options);\n\n        var _options = this.options;\n        var element = _options.element;\n        var target = _options.target;\n        var targetModifier = _options.targetModifier;\n\n        this.element = element;\n        this.target = target;\n        this.targetModifier = targetModifier;\n\n        if (this.target === 'viewport') {\n          this.target = document.body;\n          this.targetModifier = 'visible';\n        } else if (this.target === 'scroll-handle') {\n          this.target = document.body;\n          this.targetModifier = 'scroll-handle';\n        }\n\n        ['element', 'target'].forEach(function (key) {\n          if (typeof _this2[key] === 'undefined') {\n            throw new Error('Tether Error: Both element and target must be defined');\n          }\n\n          if (typeof _this2[key].jquery !== 'undefined') {\n            _this2[key] = _this2[key][0];\n          } else if (typeof _this2[key] === 'string') {\n            _this2[key] = document.querySelector(_this2[key]);\n          }\n        });\n\n        addClass(this.element, this.getClass('element'));\n        if (!(this.options.addTargetClasses === false)) {\n          addClass(this.target, this.getClass('target'));\n        }\n\n        if (!this.options.attachment) {\n          throw new Error('Tether Error: You must provide an attachment');\n        }\n\n        this.targetAttachment = parseAttachment(this.options.targetAttachment);\n        this.attachment = parseAttachment(this.options.attachment);\n        this.offset = parseOffset(this.options.offset);\n        this.targetOffset = parseOffset(this.options.targetOffset);\n\n        if (typeof this.scrollParents !== 'undefined') {\n          this.disable();\n        }\n\n        if (this.targetModifier === 'scroll-handle') {\n          this.scrollParents = [this.target];\n        } else {\n          this.scrollParents = getScrollParents(this.target);\n        }\n\n        if (!(this.options.enabled === false)) {\n          this.enable(pos);\n        }\n      }\n    }, {\n      key: 'getTargetBounds',\n      value: function getTargetBounds() {\n        if (typeof this.targetModifier !== 'undefined') {\n          if (this.targetModifier === 'visible') {\n            if (this.target === document.body) {\n              return { top: pageYOffset, left: pageXOffset, height: innerHeight, width: innerWidth };\n            } else {\n              var bounds = getBounds(this.target);\n\n              var out = {\n                height: bounds.height,\n                width: bounds.width,\n                top: bounds.top,\n                left: bounds.left\n              };\n\n              out.height = Math.min(out.height, bounds.height - (pageYOffset - bounds.top));\n              out.height = Math.min(out.height, bounds.height - (bounds.top + bounds.height - (pageYOffset + innerHeight)));\n              out.height = Math.min(innerHeight, out.height);\n              out.height -= 2;\n\n              out.width = Math.min(out.width, bounds.width - (pageXOffset - bounds.left));\n              out.width = Math.min(out.width, bounds.width - (bounds.left + bounds.width - (pageXOffset + innerWidth)));\n              out.width = Math.min(innerWidth, out.width);\n              out.width -= 2;\n\n              if (out.top < pageYOffset) {\n                out.top = pageYOffset;\n              }\n              if (out.left < pageXOffset) {\n                out.left = pageXOffset;\n              }\n\n              return out;\n            }\n          } else if (this.targetModifier === 'scroll-handle') {\n            var bounds = undefined;\n            var target = this.target;\n            if (target === document.body) {\n              target = document.documentElement;\n\n              bounds = {\n                left: pageXOffset,\n                top: pageYOffset,\n                height: innerHeight,\n                width: innerWidth\n              };\n            } else {\n              bounds = getBounds(target);\n            }\n\n            var style = getComputedStyle(target);\n\n            var hasBottomScroll = target.scrollWidth > target.clientWidth || [style.overflow, style.overflowX].indexOf('scroll') >= 0 || this.target !== document.body;\n\n            var scrollBottom = 0;\n            if (hasBottomScroll) {\n              scrollBottom = 15;\n            }\n\n            var height = bounds.height - parseFloat(style.borderTopWidth) - parseFloat(style.borderBottomWidth) - scrollBottom;\n\n            var out = {\n              width: 15,\n              height: height * 0.975 * (height / target.scrollHeight),\n              left: bounds.left + bounds.width - parseFloat(style.borderLeftWidth) - 15\n            };\n\n            var fitAdj = 0;\n            if (height < 408 && this.target === document.body) {\n              fitAdj = -0.00011 * Math.pow(height, 2) - 0.00727 * height + 22.58;\n            }\n\n            if (this.target !== document.body) {\n              out.height = Math.max(out.height, 24);\n            }\n\n            var scrollPercentage = this.target.scrollTop / (target.scrollHeight - height);\n            out.top = scrollPercentage * (height - out.height - fitAdj) + bounds.top + parseFloat(style.borderTopWidth);\n\n            if (this.target === document.body) {\n              out.height = Math.max(out.height, 24);\n            }\n\n            return out;\n          }\n        } else {\n          return getBounds(this.target);\n        }\n      }\n    }, {\n      key: 'clearCache',\n      value: function clearCache() {\n        this._cache = {};\n      }\n    }, {\n      key: 'cache',\n      value: function cache(k, getter) {\n        // More than one module will often need the same DOM info, so\n        // we keep a cache which is cleared on each position call\n        if (typeof this._cache === 'undefined') {\n          this._cache = {};\n        }\n\n        if (typeof this._cache[k] === 'undefined') {\n          this._cache[k] = getter.call(this);\n        }\n\n        return this._cache[k];\n      }\n    }, {\n      key: 'enable',\n      value: function enable() {\n        var _this3 = this;\n\n        var pos = arguments.length <= 0 || arguments[0] === undefined ? true : arguments[0];\n\n        if (!(this.options.addTargetClasses === false)) {\n          addClass(this.target, this.getClass('enabled'));\n        }\n        addClass(this.element, this.getClass('enabled'));\n        this.enabled = true;\n\n        this.scrollParents.forEach(function (parent) {\n          if (parent !== _this3.target.ownerDocument) {\n            parent.addEventListener('scroll', _this3.position);\n          }\n        });\n\n        if (pos) {\n          this.position();\n        }\n      }\n    }, {\n      key: 'disable',\n      value: function disable() {\n        var _this4 = this;\n\n        removeClass(this.target, this.getClass('enabled'));\n        removeClass(this.element, this.getClass('enabled'));\n        this.enabled = false;\n\n        if (typeof this.scrollParents !== 'undefined') {\n          this.scrollParents.forEach(function (parent) {\n            parent.removeEventListener('scroll', _this4.position);\n          });\n        }\n      }\n    }, {\n      key: 'destroy',\n      value: function destroy() {\n        var _this5 = this;\n\n        this.disable();\n\n        tethers.forEach(function (tether, i) {\n          if (tether === _this5) {\n            tethers.splice(i, 1);\n          }\n        });\n\n        // Remove any elements we were using for convenience from the DOM\n        if (tethers.length === 0) {\n          removeUtilElements();\n        }\n      }\n    }, {\n      key: 'updateAttachClasses',\n      value: function updateAttachClasses(elementAttach, targetAttach) {\n        var _this6 = this;\n\n        elementAttach = elementAttach || this.attachment;\n        targetAttach = targetAttach || this.targetAttachment;\n        var sides = ['left', 'top', 'bottom', 'right', 'middle', 'center'];\n\n        if (typeof this._addAttachClasses !== 'undefined' && this._addAttachClasses.length) {\n          // updateAttachClasses can be called more than once in a position call, so\n          // we need to clean up after ourselves such that when the last defer gets\n          // ran it doesn't add any extra classes from previous calls.\n          this._addAttachClasses.splice(0, this._addAttachClasses.length);\n        }\n\n        if (typeof this._addAttachClasses === 'undefined') {\n          this._addAttachClasses = [];\n        }\n        var add = this._addAttachClasses;\n\n        if (elementAttach.top) {\n          add.push(this.getClass('element-attached') + '-' + elementAttach.top);\n        }\n        if (elementAttach.left) {\n          add.push(this.getClass('element-attached') + '-' + elementAttach.left);\n        }\n        if (targetAttach.top) {\n          add.push(this.getClass('target-attached') + '-' + targetAttach.top);\n        }\n        if (targetAttach.left) {\n          add.push(this.getClass('target-attached') + '-' + targetAttach.left);\n        }\n\n        var all = [];\n        sides.forEach(function (side) {\n          all.push(_this6.getClass('element-attached') + '-' + side);\n          all.push(_this6.getClass('target-attached') + '-' + side);\n        });\n\n        defer(function () {\n          if (!(typeof _this6._addAttachClasses !== 'undefined')) {\n            return;\n          }\n\n          updateClasses(_this6.element, _this6._addAttachClasses, all);\n          if (!(_this6.options.addTargetClasses === false)) {\n            updateClasses(_this6.target, _this6._addAttachClasses, all);\n          }\n\n          delete _this6._addAttachClasses;\n        });\n      }\n    }, {\n      key: 'position',\n      value: function position() {\n        var _this7 = this;\n\n        var flushChanges = arguments.length <= 0 || arguments[0] === undefined ? true : arguments[0];\n\n        // flushChanges commits the changes immediately, leave true unless you are positioning multiple\n        // tethers (in which case call Tether.Utils.flush yourself when you're done)\n\n        if (!this.enabled) {\n          return;\n        }\n\n        this.clearCache();\n\n        // Turn 'auto' attachments into the appropriate corner or edge\n        var targetAttachment = autoToFixedAttachment(this.targetAttachment, this.attachment);\n\n        this.updateAttachClasses(this.attachment, targetAttachment);\n\n        var elementPos = this.cache('element-bounds', function () {\n          return getBounds(_this7.element);\n        });\n\n        var width = elementPos.width;\n        var height = elementPos.height;\n\n        if (width === 0 && height === 0 && typeof this.lastSize !== 'undefined') {\n          var _lastSize = this.lastSize;\n\n          // We cache the height and width to make it possible to position elements that are\n          // getting hidden.\n          width = _lastSize.width;\n          height = _lastSize.height;\n        } else {\n          this.lastSize = { width: width, height: height };\n        }\n\n        var targetPos = this.cache('target-bounds', function () {\n          return _this7.getTargetBounds();\n        });\n        var targetSize = targetPos;\n\n        // Get an actual px offset from the attachment\n        var offset = offsetToPx(attachmentToOffset(this.attachment), { width: width, height: height });\n        var targetOffset = offsetToPx(attachmentToOffset(targetAttachment), targetSize);\n\n        var manualOffset = offsetToPx(this.offset, { width: width, height: height });\n        var manualTargetOffset = offsetToPx(this.targetOffset, targetSize);\n\n        // Add the manually provided offset\n        offset = addOffset(offset, manualOffset);\n        targetOffset = addOffset(targetOffset, manualTargetOffset);\n\n        // It's now our goal to make (element position + offset) == (target position + target offset)\n        var left = targetPos.left + targetOffset.left - offset.left;\n        var top = targetPos.top + targetOffset.top - offset.top;\n\n        for (var i = 0; i < TetherBase.modules.length; ++i) {\n          var _module2 = TetherBase.modules[i];\n          var ret = _module2.position.call(this, {\n            left: left,\n            top: top,\n            targetAttachment: targetAttachment,\n            targetPos: targetPos,\n            elementPos: elementPos,\n            offset: offset,\n            targetOffset: targetOffset,\n            manualOffset: manualOffset,\n            manualTargetOffset: manualTargetOffset,\n            scrollbarSize: scrollbarSize,\n            attachment: this.attachment\n          });\n\n          if (ret === false) {\n            return false;\n          } else if (typeof ret === 'undefined' || (typeof ret === 'undefined' ? 'undefined' : _typeof(ret)) !== 'object') {\n            continue;\n          } else {\n            top = ret.top;\n            left = ret.left;\n          }\n        }\n\n        // We describe the position three different ways to give the optimizer\n        // a chance to decide the best possible way to position the element\n        // with the fewest repaints.\n        var next = {\n          // It's position relative to the page (absolute positioning when\n          // the element is a child of the body)\n          page: {\n            top: top,\n            left: left\n          },\n\n          // It's position relative to the viewport (fixed positioning)\n          viewport: {\n            top: top - pageYOffset,\n            bottom: pageYOffset - top - height + innerHeight,\n            left: left - pageXOffset,\n            right: pageXOffset - left - width + innerWidth\n          }\n        };\n\n        var doc = this.target.ownerDocument;\n        var win = doc.defaultView;\n\n        var scrollbarSize = undefined;\n        if (win.innerHeight > doc.documentElement.clientHeight) {\n          scrollbarSize = this.cache('scrollbar-size', getScrollBarSize);\n          next.viewport.bottom -= scrollbarSize.height;\n        }\n\n        if (win.innerWidth > doc.documentElement.clientWidth) {\n          scrollbarSize = this.cache('scrollbar-size', getScrollBarSize);\n          next.viewport.right -= scrollbarSize.width;\n        }\n\n        if (['', 'static'].indexOf(doc.body.style.position) === -1 || ['', 'static'].indexOf(doc.body.parentElement.style.position) === -1) {\n          // Absolute positioning in the body will be relative to the page, not the 'initial containing block'\n          next.page.bottom = doc.body.scrollHeight - top - height;\n          next.page.right = doc.body.scrollWidth - left - width;\n        }\n\n        if (typeof this.options.optimizations !== 'undefined' && this.options.optimizations.moveElement !== false && !(typeof this.targetModifier !== 'undefined')) {\n          (function () {\n            var offsetParent = _this7.cache('target-offsetparent', function () {\n              return getOffsetParent(_this7.target);\n            });\n            var offsetPosition = _this7.cache('target-offsetparent-bounds', function () {\n              return getBounds(offsetParent);\n            });\n            var offsetParentStyle = getComputedStyle(offsetParent);\n            var offsetParentSize = offsetPosition;\n\n            var offsetBorder = {};\n            ['Top', 'Left', 'Bottom', 'Right'].forEach(function (side) {\n              offsetBorder[side.toLowerCase()] = parseFloat(offsetParentStyle['border' + side + 'Width']);\n            });\n\n            offsetPosition.right = doc.body.scrollWidth - offsetPosition.left - offsetParentSize.width + offsetBorder.right;\n            offsetPosition.bottom = doc.body.scrollHeight - offsetPosition.top - offsetParentSize.height + offsetBorder.bottom;\n\n            if (next.page.top >= offsetPosition.top + offsetBorder.top && next.page.bottom >= offsetPosition.bottom) {\n              if (next.page.left >= offsetPosition.left + offsetBorder.left && next.page.right >= offsetPosition.right) {\n                // We're within the visible part of the target's scroll parent\n                var scrollTop = offsetParent.scrollTop;\n                var scrollLeft = offsetParent.scrollLeft;\n\n                // It's position relative to the target's offset parent (absolute positioning when\n                // the element is moved to be a child of the target's offset parent).\n                next.offset = {\n                  top: next.page.top - offsetPosition.top + scrollTop - offsetBorder.top,\n                  left: next.page.left - offsetPosition.left + scrollLeft - offsetBorder.left\n                };\n              }\n            }\n          })();\n        }\n\n        // We could also travel up the DOM and try each containing context, rather than only\n        // looking at the body, but we're gonna get diminishing returns.\n\n        this.move(next);\n\n        this.history.unshift(next);\n\n        if (this.history.length > 3) {\n          this.history.pop();\n        }\n\n        if (flushChanges) {\n          flush();\n        }\n\n        return true;\n      }\n\n      // THE ISSUE\n    }, {\n      key: 'move',\n      value: function move(pos) {\n        var _this8 = this;\n\n        if (!(typeof this.element.parentNode !== 'undefined')) {\n          return;\n        }\n\n        var same = {};\n\n        for (var type in pos) {\n          same[type] = {};\n\n          for (var key in pos[type]) {\n            var found = false;\n\n            for (var i = 0; i < this.history.length; ++i) {\n              var point = this.history[i];\n              if (typeof point[type] !== 'undefined' && !within(point[type][key], pos[type][key])) {\n                found = true;\n                break;\n              }\n            }\n\n            if (!found) {\n              same[type][key] = true;\n            }\n          }\n        }\n\n        var css = { top: '', left: '', right: '', bottom: '' };\n\n        var transcribe = function transcribe(_same, _pos) {\n          var hasOptimizations = typeof _this8.options.optimizations !== 'undefined';\n          var gpu = hasOptimizations ? _this8.options.optimizations.gpu : null;\n          if (gpu !== false) {\n            var yPos = undefined,\n                xPos = undefined;\n            if (_same.top) {\n              css.top = 0;\n              yPos = _pos.top;\n            } else {\n              css.bottom = 0;\n              yPos = -_pos.bottom;\n            }\n\n            if (_same.left) {\n              css.left = 0;\n              xPos = _pos.left;\n            } else {\n              css.right = 0;\n              xPos = -_pos.right;\n            }\n\n            if (window.matchMedia) {\n              // HubSpot/tether#207\n              var retina = window.matchMedia('only screen and (min-resolution: 1.3dppx)').matches || window.matchMedia('only screen and (-webkit-min-device-pixel-ratio: 1.3)').matches;\n              if (!retina) {\n                xPos = Math.round(xPos);\n                yPos = Math.round(yPos);\n              }\n            }\n\n            css[transformKey] = 'translateX(' + xPos + 'px) translateY(' + yPos + 'px)';\n\n            if (transformKey !== 'msTransform') {\n              // The Z transform will keep this in the GPU (faster, and prevents artifacts),\n              // but IE9 doesn't support 3d transforms and will choke.\n              css[transformKey] += \" translateZ(0)\";\n            }\n          } else {\n            if (_same.top) {\n              css.top = _pos.top + 'px';\n            } else {\n              css.bottom = _pos.bottom + 'px';\n            }\n\n            if (_same.left) {\n              css.left = _pos.left + 'px';\n            } else {\n              css.right = _pos.right + 'px';\n            }\n          }\n        };\n\n        var moved = false;\n        if ((same.page.top || same.page.bottom) && (same.page.left || same.page.right)) {\n          css.position = 'absolute';\n          transcribe(same.page, pos.page);\n        } else if ((same.viewport.top || same.viewport.bottom) && (same.viewport.left || same.viewport.right)) {\n          css.position = 'fixed';\n          transcribe(same.viewport, pos.viewport);\n        } else if (typeof same.offset !== 'undefined' && same.offset.top && same.offset.left) {\n          (function () {\n            css.position = 'absolute';\n            var offsetParent = _this8.cache('target-offsetparent', function () {\n              return getOffsetParent(_this8.target);\n            });\n\n            if (getOffsetParent(_this8.element) !== offsetParent) {\n              defer(function () {\n                _this8.element.parentNode.removeChild(_this8.element);\n                offsetParent.appendChild(_this8.element);\n              });\n            }\n\n            transcribe(same.offset, pos.offset);\n            moved = true;\n          })();\n        } else {\n          css.position = 'absolute';\n          transcribe({ top: true, left: true }, pos.page);\n        }\n\n        if (!moved) {\n          if (this.options.bodyElement) {\n            if (this.element.parentNode !== this.options.bodyElement) {\n              this.options.bodyElement.appendChild(this.element);\n            }\n          } else {\n            var offsetParentIsBody = true;\n            var currentNode = this.element.parentNode;\n            while (currentNode && currentNode.nodeType === 1 && currentNode.tagName !== 'BODY') {\n              if (getComputedStyle(currentNode).position !== 'static') {\n                offsetParentIsBody = false;\n                break;\n              }\n\n              currentNode = currentNode.parentNode;\n            }\n\n            if (!offsetParentIsBody) {\n              this.element.parentNode.removeChild(this.element);\n              this.element.ownerDocument.body.appendChild(this.element);\n            }\n          }\n        }\n\n        // Any css change will trigger a repaint, so let's avoid one if nothing changed\n        var writeCSS = {};\n        var write = false;\n        for (var key in css) {\n          var val = css[key];\n          var elVal = this.element.style[key];\n\n          if (elVal !== val) {\n            write = true;\n            writeCSS[key] = val;\n          }\n        }\n\n        if (write) {\n          defer(function () {\n            extend(_this8.element.style, writeCSS);\n            _this8.trigger('repositioned');\n          });\n        }\n      }\n    }]);\n\n    return TetherClass;\n  }(Evented);\n\n  TetherClass.modules = [];\n\n  TetherBase.position = position;\n\n  var Tether = extend(TetherClass, TetherBase);\n  /* globals TetherBase */\n\n  'use strict';\n\n  var _slicedToArray = function () {\n    function sliceIterator(arr, i) {\n      var _arr = [];var _n = true;var _d = false;var _e = undefined;try {\n        for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {\n          _arr.push(_s.value);if (i && _arr.length === i) break;\n        }\n      } catch (err) {\n        _d = true;_e = err;\n      } finally {\n        try {\n          if (!_n && _i['return']) _i['return']();\n        } finally {\n          if (_d) throw _e;\n        }\n      }return _arr;\n    }return function (arr, i) {\n      if (Array.isArray(arr)) {\n        return arr;\n      } else if (Symbol.iterator in Object(arr)) {\n        return sliceIterator(arr, i);\n      } else {\n        throw new TypeError('Invalid attempt to destructure non-iterable instance');\n      }\n    };\n  }();\n\n  var _TetherBase$Utils = TetherBase.Utils;\n  var getBounds = _TetherBase$Utils.getBounds;\n  var extend = _TetherBase$Utils.extend;\n  var updateClasses = _TetherBase$Utils.updateClasses;\n  var defer = _TetherBase$Utils.defer;\n\n  var BOUNDS_FORMAT = ['left', 'top', 'right', 'bottom'];\n\n  function getBoundingRect(tether, to) {\n    if (to === 'scrollParent') {\n      to = tether.scrollParents[0];\n    } else if (to === 'window') {\n      to = [pageXOffset, pageYOffset, innerWidth + pageXOffset, innerHeight + pageYOffset];\n    }\n\n    if (to === document) {\n      to = to.documentElement;\n    }\n\n    if (typeof to.nodeType !== 'undefined') {\n      (function () {\n        var node = to;\n        var size = getBounds(to);\n        var pos = size;\n        var style = getComputedStyle(to);\n\n        to = [pos.left, pos.top, size.width + pos.left, size.height + pos.top];\n\n        // Account any parent Frames scroll offset\n        if (node.ownerDocument !== document) {\n          var win = node.ownerDocument.defaultView;\n          to[0] += win.pageXOffset;\n          to[1] += win.pageYOffset;\n          to[2] += win.pageXOffset;\n          to[3] += win.pageYOffset;\n        }\n\n        BOUNDS_FORMAT.forEach(function (side, i) {\n          side = side[0].toUpperCase() + side.substr(1);\n          if (side === 'Top' || side === 'Left') {\n            to[i] += parseFloat(style['border' + side + 'Width']);\n          } else {\n            to[i] -= parseFloat(style['border' + side + 'Width']);\n          }\n        });\n      })();\n    }\n\n    return to;\n  }\n\n  TetherBase.modules.push({\n    position: function position(_ref) {\n      var _this = this;\n\n      var top = _ref.top;\n      var left = _ref.left;\n      var targetAttachment = _ref.targetAttachment;\n\n      if (!this.options.constraints) {\n        return true;\n      }\n\n      var _cache = this.cache('element-bounds', function () {\n        return getBounds(_this.element);\n      });\n\n      var height = _cache.height;\n      var width = _cache.width;\n\n      if (width === 0 && height === 0 && typeof this.lastSize !== 'undefined') {\n        var _lastSize = this.lastSize;\n\n        // Handle the item getting hidden as a result of our positioning without glitching\n        // the classes in and out\n        width = _lastSize.width;\n        height = _lastSize.height;\n      }\n\n      var targetSize = this.cache('target-bounds', function () {\n        return _this.getTargetBounds();\n      });\n\n      var targetHeight = targetSize.height;\n      var targetWidth = targetSize.width;\n\n      var allClasses = [this.getClass('pinned'), this.getClass('out-of-bounds')];\n\n      this.options.constraints.forEach(function (constraint) {\n        var outOfBoundsClass = constraint.outOfBoundsClass;\n        var pinnedClass = constraint.pinnedClass;\n\n        if (outOfBoundsClass) {\n          allClasses.push(outOfBoundsClass);\n        }\n        if (pinnedClass) {\n          allClasses.push(pinnedClass);\n        }\n      });\n\n      allClasses.forEach(function (cls) {\n        ['left', 'top', 'right', 'bottom'].forEach(function (side) {\n          allClasses.push(cls + '-' + side);\n        });\n      });\n\n      var addClasses = [];\n\n      var tAttachment = extend({}, targetAttachment);\n      var eAttachment = extend({}, this.attachment);\n\n      this.options.constraints.forEach(function (constraint) {\n        var to = constraint.to;\n        var attachment = constraint.attachment;\n        var pin = constraint.pin;\n\n        if (typeof attachment === 'undefined') {\n          attachment = '';\n        }\n\n        var changeAttachX = undefined,\n            changeAttachY = undefined;\n        if (attachment.indexOf(' ') >= 0) {\n          var _attachment$split = attachment.split(' ');\n\n          var _attachment$split2 = _slicedToArray(_attachment$split, 2);\n\n          changeAttachY = _attachment$split2[0];\n          changeAttachX = _attachment$split2[1];\n        } else {\n          changeAttachX = changeAttachY = attachment;\n        }\n\n        var bounds = getBoundingRect(_this, to);\n\n        if (changeAttachY === 'target' || changeAttachY === 'both') {\n          if (top < bounds[1] && tAttachment.top === 'top') {\n            top += targetHeight;\n            tAttachment.top = 'bottom';\n          }\n\n          if (top + height > bounds[3] && tAttachment.top === 'bottom') {\n            top -= targetHeight;\n            tAttachment.top = 'top';\n          }\n        }\n\n        if (changeAttachY === 'together') {\n          if (tAttachment.top === 'top') {\n            if (eAttachment.top === 'bottom' && top < bounds[1]) {\n              top += targetHeight;\n              tAttachment.top = 'bottom';\n\n              top += height;\n              eAttachment.top = 'top';\n            } else if (eAttachment.top === 'top' && top + height > bounds[3] && top - (height - targetHeight) >= bounds[1]) {\n              top -= height - targetHeight;\n              tAttachment.top = 'bottom';\n\n              eAttachment.top = 'bottom';\n            }\n          }\n\n          if (tAttachment.top === 'bottom') {\n            if (eAttachment.top === 'top' && top + height > bounds[3]) {\n              top -= targetHeight;\n              tAttachment.top = 'top';\n\n              top -= height;\n              eAttachment.top = 'bottom';\n            } else if (eAttachment.top === 'bottom' && top < bounds[1] && top + (height * 2 - targetHeight) <= bounds[3]) {\n              top += height - targetHeight;\n              tAttachment.top = 'top';\n\n              eAttachment.top = 'top';\n            }\n          }\n\n          if (tAttachment.top === 'middle') {\n            if (top + height > bounds[3] && eAttachment.top === 'top') {\n              top -= height;\n              eAttachment.top = 'bottom';\n            } else if (top < bounds[1] && eAttachment.top === 'bottom') {\n              top += height;\n              eAttachment.top = 'top';\n            }\n          }\n        }\n\n        if (changeAttachX === 'target' || changeAttachX === 'both') {\n          if (left < bounds[0] && tAttachment.left === 'left') {\n            left += targetWidth;\n            tAttachment.left = 'right';\n          }\n\n          if (left + width > bounds[2] && tAttachment.left === 'right') {\n            left -= targetWidth;\n            tAttachment.left = 'left';\n          }\n        }\n\n        if (changeAttachX === 'together') {\n          if (left < bounds[0] && tAttachment.left === 'left') {\n            if (eAttachment.left === 'right') {\n              left += targetWidth;\n              tAttachment.left = 'right';\n\n              left += width;\n              eAttachment.left = 'left';\n            } else if (eAttachment.left === 'left') {\n              left += targetWidth;\n              tAttachment.left = 'right';\n\n              left -= width;\n              eAttachment.left = 'right';\n            }\n          } else if (left + width > bounds[2] && tAttachment.left === 'right') {\n            if (eAttachment.left === 'left') {\n              left -= targetWidth;\n              tAttachment.left = 'left';\n\n              left -= width;\n              eAttachment.left = 'right';\n            } else if (eAttachment.left === 'right') {\n              left -= targetWidth;\n              tAttachment.left = 'left';\n\n              left += width;\n              eAttachment.left = 'left';\n            }\n          } else if (tAttachment.left === 'center') {\n            if (left + width > bounds[2] && eAttachment.left === 'left') {\n              left -= width;\n              eAttachment.left = 'right';\n            } else if (left < bounds[0] && eAttachment.left === 'right') {\n              left += width;\n              eAttachment.left = 'left';\n            }\n          }\n        }\n\n        if (changeAttachY === 'element' || changeAttachY === 'both') {\n          if (top < bounds[1] && eAttachment.top === 'bottom') {\n            top += height;\n            eAttachment.top = 'top';\n          }\n\n          if (top + height > bounds[3] && eAttachment.top === 'top') {\n            top -= height;\n            eAttachment.top = 'bottom';\n          }\n        }\n\n        if (changeAttachX === 'element' || changeAttachX === 'both') {\n          if (left < bounds[0]) {\n            if (eAttachment.left === 'right') {\n              left += width;\n              eAttachment.left = 'left';\n            } else if (eAttachment.left === 'center') {\n              left += width / 2;\n              eAttachment.left = 'left';\n            }\n          }\n\n          if (left + width > bounds[2]) {\n            if (eAttachment.left === 'left') {\n              left -= width;\n              eAttachment.left = 'right';\n            } else if (eAttachment.left === 'center') {\n              left -= width / 2;\n              eAttachment.left = 'right';\n            }\n          }\n        }\n\n        if (typeof pin === 'string') {\n          pin = pin.split(',').map(function (p) {\n            return p.trim();\n          });\n        } else if (pin === true) {\n          pin = ['top', 'left', 'right', 'bottom'];\n        }\n\n        pin = pin || [];\n\n        var pinned = [];\n        var oob = [];\n\n        if (top < bounds[1]) {\n          if (pin.indexOf('top') >= 0) {\n            top = bounds[1];\n            pinned.push('top');\n          } else {\n            oob.push('top');\n          }\n        }\n\n        if (top + height > bounds[3]) {\n          if (pin.indexOf('bottom') >= 0) {\n            top = bounds[3] - height;\n            pinned.push('bottom');\n          } else {\n            oob.push('bottom');\n          }\n        }\n\n        if (left < bounds[0]) {\n          if (pin.indexOf('left') >= 0) {\n            left = bounds[0];\n            pinned.push('left');\n          } else {\n            oob.push('left');\n          }\n        }\n\n        if (left + width > bounds[2]) {\n          if (pin.indexOf('right') >= 0) {\n            left = bounds[2] - width;\n            pinned.push('right');\n          } else {\n            oob.push('right');\n          }\n        }\n\n        if (pinned.length) {\n          (function () {\n            var pinnedClass = undefined;\n            if (typeof _this.options.pinnedClass !== 'undefined') {\n              pinnedClass = _this.options.pinnedClass;\n            } else {\n              pinnedClass = _this.getClass('pinned');\n            }\n\n            addClasses.push(pinnedClass);\n            pinned.forEach(function (side) {\n              addClasses.push(pinnedClass + '-' + side);\n            });\n          })();\n        }\n\n        if (oob.length) {\n          (function () {\n            var oobClass = undefined;\n            if (typeof _this.options.outOfBoundsClass !== 'undefined') {\n              oobClass = _this.options.outOfBoundsClass;\n            } else {\n              oobClass = _this.getClass('out-of-bounds');\n            }\n\n            addClasses.push(oobClass);\n            oob.forEach(function (side) {\n              addClasses.push(oobClass + '-' + side);\n            });\n          })();\n        }\n\n        if (pinned.indexOf('left') >= 0 || pinned.indexOf('right') >= 0) {\n          eAttachment.left = tAttachment.left = false;\n        }\n        if (pinned.indexOf('top') >= 0 || pinned.indexOf('bottom') >= 0) {\n          eAttachment.top = tAttachment.top = false;\n        }\n\n        if (tAttachment.top !== targetAttachment.top || tAttachment.left !== targetAttachment.left || eAttachment.top !== _this.attachment.top || eAttachment.left !== _this.attachment.left) {\n          _this.updateAttachClasses(eAttachment, tAttachment);\n          _this.trigger('update', {\n            attachment: eAttachment,\n            targetAttachment: tAttachment\n          });\n        }\n      });\n\n      defer(function () {\n        if (!(_this.options.addTargetClasses === false)) {\n          updateClasses(_this.target, addClasses, allClasses);\n        }\n        updateClasses(_this.element, addClasses, allClasses);\n      });\n\n      return { top: top, left: left };\n    }\n  });\n  /* globals TetherBase */\n\n  'use strict';\n\n  var _TetherBase$Utils = TetherBase.Utils;\n  var getBounds = _TetherBase$Utils.getBounds;\n  var updateClasses = _TetherBase$Utils.updateClasses;\n  var defer = _TetherBase$Utils.defer;\n\n  TetherBase.modules.push({\n    position: function position(_ref) {\n      var _this = this;\n\n      var top = _ref.top;\n      var left = _ref.left;\n\n      var _cache = this.cache('element-bounds', function () {\n        return getBounds(_this.element);\n      });\n\n      var height = _cache.height;\n      var width = _cache.width;\n\n      var targetPos = this.getTargetBounds();\n\n      var bottom = top + height;\n      var right = left + width;\n\n      var abutted = [];\n      if (top <= targetPos.bottom && bottom >= targetPos.top) {\n        ['left', 'right'].forEach(function (side) {\n          var targetPosSide = targetPos[side];\n          if (targetPosSide === left || targetPosSide === right) {\n            abutted.push(side);\n          }\n        });\n      }\n\n      if (left <= targetPos.right && right >= targetPos.left) {\n        ['top', 'bottom'].forEach(function (side) {\n          var targetPosSide = targetPos[side];\n          if (targetPosSide === top || targetPosSide === bottom) {\n            abutted.push(side);\n          }\n        });\n      }\n\n      var allClasses = [];\n      var addClasses = [];\n\n      var sides = ['left', 'top', 'right', 'bottom'];\n      allClasses.push(this.getClass('abutted'));\n      sides.forEach(function (side) {\n        allClasses.push(_this.getClass('abutted') + '-' + side);\n      });\n\n      if (abutted.length) {\n        addClasses.push(this.getClass('abutted'));\n      }\n\n      abutted.forEach(function (side) {\n        addClasses.push(_this.getClass('abutted') + '-' + side);\n      });\n\n      defer(function () {\n        if (!(_this.options.addTargetClasses === false)) {\n          updateClasses(_this.target, addClasses, allClasses);\n        }\n        updateClasses(_this.element, addClasses, allClasses);\n      });\n\n      return true;\n    }\n  });\n  /* globals TetherBase */\n\n  'use strict';\n\n  var _slicedToArray = function () {\n    function sliceIterator(arr, i) {\n      var _arr = [];var _n = true;var _d = false;var _e = undefined;try {\n        for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {\n          _arr.push(_s.value);if (i && _arr.length === i) break;\n        }\n      } catch (err) {\n        _d = true;_e = err;\n      } finally {\n        try {\n          if (!_n && _i['return']) _i['return']();\n        } finally {\n          if (_d) throw _e;\n        }\n      }return _arr;\n    }return function (arr, i) {\n      if (Array.isArray(arr)) {\n        return arr;\n      } else if (Symbol.iterator in Object(arr)) {\n        return sliceIterator(arr, i);\n      } else {\n        throw new TypeError('Invalid attempt to destructure non-iterable instance');\n      }\n    };\n  }();\n\n  TetherBase.modules.push({\n    position: function position(_ref) {\n      var top = _ref.top;\n      var left = _ref.left;\n\n      if (!this.options.shift) {\n        return;\n      }\n\n      var shift = this.options.shift;\n      if (typeof this.options.shift === 'function') {\n        shift = this.options.shift.call(this, { top: top, left: left });\n      }\n\n      var shiftTop = undefined,\n          shiftLeft = undefined;\n      if (typeof shift === 'string') {\n        shift = shift.split(' ');\n        shift[1] = shift[1] || shift[0];\n\n        var _shift = shift;\n\n        var _shift2 = _slicedToArray(_shift, 2);\n\n        shiftTop = _shift2[0];\n        shiftLeft = _shift2[1];\n\n        shiftTop = parseFloat(shiftTop, 10);\n        shiftLeft = parseFloat(shiftLeft, 10);\n      } else {\n        shiftTop = shift.top;\n        shiftLeft = shift.left;\n      }\n\n      top += shiftTop;\n      left += shiftLeft;\n\n      return { top: top, left: left };\n    }\n  });\n  return Tether;\n});\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L190ZXRoZXJAMS40LjNAdGV0aGVyL2Rpc3QvanMvdGV0aGVyLmpzPzM1NDAiXSwibmFtZXMiOlsicm9vdCIsImZhY3RvcnkiLCJkZWZpbmUiLCJleHBvcnRzIiwibW9kdWxlIiwicmVxdWlyZSIsIlRldGhlciIsIl9jcmVhdGVDbGFzcyIsImRlZmluZVByb3BlcnRpZXMiLCJ0YXJnZXQiLCJwcm9wcyIsImkiLCJsZW5ndGgiLCJkZXNjcmlwdG9yIiwiZW51bWVyYWJsZSIsImNvbmZpZ3VyYWJsZSIsIndyaXRhYmxlIiwiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJrZXkiLCJDb25zdHJ1Y3RvciIsInByb3RvUHJvcHMiLCJzdGF0aWNQcm9wcyIsInByb3RvdHlwZSIsIl9jbGFzc0NhbGxDaGVjayIsImluc3RhbmNlIiwiVHlwZUVycm9yIiwiVGV0aGVyQmFzZSIsInVuZGVmaW5lZCIsIm1vZHVsZXMiLCJ6ZXJvRWxlbWVudCIsImdldEFjdHVhbEJvdW5kaW5nQ2xpZW50UmVjdCIsIm5vZGUiLCJib3VuZGluZ1JlY3QiLCJnZXRCb3VuZGluZ0NsaWVudFJlY3QiLCJyZWN0IiwiayIsIm93bmVyRG9jdW1lbnQiLCJkb2N1bWVudCIsIl9mcmFtZUVsZW1lbnQiLCJkZWZhdWx0VmlldyIsImZyYW1lRWxlbWVudCIsImZyYW1lUmVjdCIsInRvcCIsImJvdHRvbSIsImxlZnQiLCJyaWdodCIsImdldFNjcm9sbFBhcmVudHMiLCJlbCIsImNvbXB1dGVkU3R5bGUiLCJnZXRDb21wdXRlZFN0eWxlIiwicG9zaXRpb24iLCJwYXJlbnRzIiwicGFyZW50IiwicGFyZW50Tm9kZSIsIm5vZGVUeXBlIiwic3R5bGUiLCJlcnIiLCJwdXNoIiwiX3N0eWxlIiwib3ZlcmZsb3ciLCJvdmVyZmxvd1giLCJvdmVyZmxvd1kiLCJ0ZXN0IiwiaW5kZXhPZiIsImJvZHkiLCJ1bmlxdWVJZCIsImlkIiwiemVyb1Bvc0NhY2hlIiwiZ2V0T3JpZ2luIiwiY29udGFpbnMiLCJjcmVhdGVFbGVtZW50Iiwic2V0QXR0cmlidXRlIiwiZXh0ZW5kIiwiYXBwZW5kQ2hpbGQiLCJnZXRBdHRyaWJ1dGUiLCJkZWZlciIsInJlbW92ZVV0aWxFbGVtZW50cyIsInJlbW92ZUNoaWxkIiwiZ2V0Qm91bmRzIiwiZG9jIiwiZG9jdW1lbnRFbGVtZW50IiwiZG9jRWwiLCJib3giLCJvcmlnaW4iLCJ3aWR0aCIsInNjcm9sbFdpZHRoIiwiaGVpZ2h0Iiwic2Nyb2xsSGVpZ2h0IiwiY2xpZW50VG9wIiwiY2xpZW50TGVmdCIsImNsaWVudFdpZHRoIiwiY2xpZW50SGVpZ2h0IiwiZ2V0T2Zmc2V0UGFyZW50Iiwib2Zmc2V0UGFyZW50IiwiX3Njcm9sbEJhclNpemUiLCJnZXRTY3JvbGxCYXJTaXplIiwiaW5uZXIiLCJvdXRlciIsInBvaW50ZXJFdmVudHMiLCJ2aXNpYmlsaXR5Iiwid2lkdGhDb250YWluZWQiLCJvZmZzZXRXaWR0aCIsIndpZHRoU2Nyb2xsIiwib3V0IiwiYXJndW1lbnRzIiwiYXJncyIsIkFycmF5IiwiYXBwbHkiLCJzbGljZSIsImZvckVhY2giLCJvYmoiLCJoYXNPd25Qcm9wZXJ0eSIsImNhbGwiLCJyZW1vdmVDbGFzcyIsIm5hbWUiLCJjbGFzc0xpc3QiLCJzcGxpdCIsImNscyIsInRyaW0iLCJyZW1vdmUiLCJyZWdleCIsIlJlZ0V4cCIsImpvaW4iLCJjbGFzc05hbWUiLCJnZXRDbGFzc05hbWUiLCJyZXBsYWNlIiwic2V0Q2xhc3NOYW1lIiwiYWRkQ2xhc3MiLCJhZGQiLCJoYXNDbGFzcyIsIlNWR0FuaW1hdGVkU3RyaW5nIiwiYmFzZVZhbCIsInVwZGF0ZUNsYXNzZXMiLCJhbGwiLCJkZWZlcnJlZCIsImZuIiwiZmx1c2giLCJwb3AiLCJFdmVudGVkIiwidmFsdWUiLCJvbiIsImV2ZW50IiwiaGFuZGxlciIsImN0eCIsIm9uY2UiLCJiaW5kaW5ncyIsIm9mZiIsInNwbGljZSIsInRyaWdnZXIiLCJfbGVuIiwiX2tleSIsIl9iaW5kaW5ncyRldmVudCRpIiwiY29udGV4dCIsIlV0aWxzIiwiX3NsaWNlZFRvQXJyYXkiLCJzbGljZUl0ZXJhdG9yIiwiYXJyIiwiX2FyciIsIl9uIiwiX2QiLCJfZSIsIl9pIiwiU3ltYm9sIiwiaXRlcmF0b3IiLCJfcyIsIm5leHQiLCJkb25lIiwiaXNBcnJheSIsIl9nZXQiLCJnZXQiLCJfeDYiLCJfeDciLCJfeDgiLCJfYWdhaW4iLCJfZnVuY3Rpb24iLCJvYmplY3QiLCJwcm9wZXJ0eSIsInJlY2VpdmVyIiwiRnVuY3Rpb24iLCJkZXNjIiwiZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yIiwiZ2V0UHJvdG90eXBlT2YiLCJnZXR0ZXIiLCJfaW5oZXJpdHMiLCJzdWJDbGFzcyIsInN1cGVyQ2xhc3MiLCJjcmVhdGUiLCJjb25zdHJ1Y3RvciIsInNldFByb3RvdHlwZU9mIiwiX19wcm90b19fIiwiRXJyb3IiLCJfVGV0aGVyQmFzZSRVdGlscyIsIndpdGhpbiIsImEiLCJiIiwiZGlmZiIsInRyYW5zZm9ybUtleSIsInRyYW5zZm9ybXMiLCJ0ZXRoZXJzIiwidGV0aGVyIiwibm93IiwicGVyZm9ybWFuY2UiLCJEYXRlIiwibGFzdENhbGwiLCJsYXN0RHVyYXRpb24iLCJwZW5kaW5nVGltZW91dCIsInRpY2siLCJNYXRoIiwibWluIiwic2V0VGltZW91dCIsImNsZWFyVGltZW91dCIsIndpbmRvdyIsImFkZEV2ZW50TGlzdGVuZXIiLCJNSVJST1JfTFIiLCJjZW50ZXIiLCJNSVJST1JfVEIiLCJtaWRkbGUiLCJPRkZTRVRfTUFQIiwiYXV0b1RvRml4ZWRBdHRhY2htZW50IiwiYXR0YWNobWVudCIsInJlbGF0aXZlVG9BdHRhY2htZW50IiwiYXR0YWNobWVudFRvT2Zmc2V0IiwiYWRkT2Zmc2V0Iiwib2Zmc2V0cyIsIl9yZWYiLCJwYXJzZUZsb2F0Iiwib2Zmc2V0VG9QeCIsIm9mZnNldCIsInNpemUiLCJwYXJzZU9mZnNldCIsIl92YWx1ZSRzcGxpdCIsIl92YWx1ZSRzcGxpdDIiLCJwYXJzZUF0dGFjaG1lbnQiLCJUZXRoZXJDbGFzcyIsIl9FdmVudGVkIiwib3B0aW9ucyIsIl90aGlzIiwiYmluZCIsImhpc3RvcnkiLCJzZXRPcHRpb25zIiwiaW5pdGlhbGl6ZSIsImdldENsYXNzIiwiY2xhc3NlcyIsImNsYXNzUHJlZml4IiwiX3RoaXMyIiwicG9zIiwiZGVmYXVsdHMiLCJ0YXJnZXRPZmZzZXQiLCJ0YXJnZXRBdHRhY2htZW50IiwiX29wdGlvbnMiLCJlbGVtZW50IiwidGFyZ2V0TW9kaWZpZXIiLCJqcXVlcnkiLCJxdWVyeVNlbGVjdG9yIiwiYWRkVGFyZ2V0Q2xhc3NlcyIsInNjcm9sbFBhcmVudHMiLCJkaXNhYmxlIiwiZW5hYmxlZCIsImVuYWJsZSIsImdldFRhcmdldEJvdW5kcyIsInBhZ2VZT2Zmc2V0IiwicGFnZVhPZmZzZXQiLCJpbm5lckhlaWdodCIsImlubmVyV2lkdGgiLCJib3VuZHMiLCJoYXNCb3R0b21TY3JvbGwiLCJzY3JvbGxCb3R0b20iLCJib3JkZXJUb3BXaWR0aCIsImJvcmRlckJvdHRvbVdpZHRoIiwiYm9yZGVyTGVmdFdpZHRoIiwiZml0QWRqIiwicG93IiwibWF4Iiwic2Nyb2xsUGVyY2VudGFnZSIsInNjcm9sbFRvcCIsImNsZWFyQ2FjaGUiLCJfY2FjaGUiLCJjYWNoZSIsIl90aGlzMyIsIl90aGlzNCIsInJlbW92ZUV2ZW50TGlzdGVuZXIiLCJkZXN0cm95IiwiX3RoaXM1IiwidXBkYXRlQXR0YWNoQ2xhc3NlcyIsImVsZW1lbnRBdHRhY2giLCJ0YXJnZXRBdHRhY2giLCJfdGhpczYiLCJzaWRlcyIsIl9hZGRBdHRhY2hDbGFzc2VzIiwic2lkZSIsIl90aGlzNyIsImZsdXNoQ2hhbmdlcyIsImVsZW1lbnRQb3MiLCJsYXN0U2l6ZSIsIl9sYXN0U2l6ZSIsInRhcmdldFBvcyIsInRhcmdldFNpemUiLCJtYW51YWxPZmZzZXQiLCJtYW51YWxUYXJnZXRPZmZzZXQiLCJfbW9kdWxlMiIsInJldCIsInNjcm9sbGJhclNpemUiLCJwYWdlIiwidmlld3BvcnQiLCJ3aW4iLCJwYXJlbnRFbGVtZW50Iiwib3B0aW1pemF0aW9ucyIsIm1vdmVFbGVtZW50Iiwib2Zmc2V0UG9zaXRpb24iLCJvZmZzZXRQYXJlbnRTdHlsZSIsIm9mZnNldFBhcmVudFNpemUiLCJvZmZzZXRCb3JkZXIiLCJ0b0xvd2VyQ2FzZSIsInNjcm9sbExlZnQiLCJtb3ZlIiwidW5zaGlmdCIsIl90aGlzOCIsInNhbWUiLCJ0eXBlIiwiZm91bmQiLCJwb2ludCIsImNzcyIsInRyYW5zY3JpYmUiLCJfc2FtZSIsIl9wb3MiLCJoYXNPcHRpbWl6YXRpb25zIiwiZ3B1IiwieVBvcyIsInhQb3MiLCJtYXRjaE1lZGlhIiwicmV0aW5hIiwibWF0Y2hlcyIsInJvdW5kIiwibW92ZWQiLCJib2R5RWxlbWVudCIsIm9mZnNldFBhcmVudElzQm9keSIsImN1cnJlbnROb2RlIiwidGFnTmFtZSIsIndyaXRlQ1NTIiwid3JpdGUiLCJ2YWwiLCJlbFZhbCIsIkJPVU5EU19GT1JNQVQiLCJnZXRCb3VuZGluZ1JlY3QiLCJ0byIsInRvVXBwZXJDYXNlIiwic3Vic3RyIiwiY29uc3RyYWludHMiLCJ0YXJnZXRIZWlnaHQiLCJ0YXJnZXRXaWR0aCIsImFsbENsYXNzZXMiLCJjb25zdHJhaW50Iiwib3V0T2ZCb3VuZHNDbGFzcyIsInBpbm5lZENsYXNzIiwiYWRkQ2xhc3NlcyIsInRBdHRhY2htZW50IiwiZUF0dGFjaG1lbnQiLCJwaW4iLCJjaGFuZ2VBdHRhY2hYIiwiY2hhbmdlQXR0YWNoWSIsIl9hdHRhY2htZW50JHNwbGl0IiwiX2F0dGFjaG1lbnQkc3BsaXQyIiwibWFwIiwicCIsInBpbm5lZCIsIm9vYiIsIm9vYkNsYXNzIiwiYWJ1dHRlZCIsInRhcmdldFBvc1NpZGUiLCJzaGlmdCIsInNoaWZ0VG9wIiwic2hpZnRMZWZ0IiwiX3NoaWZ0IiwiX3NoaWZ0MiJdLCJtYXBwaW5ncyI6Ijs7QUFBQTs7QUFFQyxXQUFTQSxJQUFULEVBQWVDLE9BQWYsRUFBd0I7QUFDdkIsTUFBSSxJQUFKLEVBQWdEO0FBQzlDQyxJQUFBLG9DQUFPRCxPQUFQO0FBQUE7QUFB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O0FBQ0F0VSxjQUFRdVUsU0FBUjs7QUFFQSxhQUFPLEVBQUV6VSxLQUFLQSxHQUFQLEVBQVlFLE1BQU1BLElBQWxCLEVBQVA7QUFDRDtBQXRDcUIsR0FBeEI7QUF3Q0EsU0FBT3ZDLE1BQVA7QUFFQyxDQWx4REEsQ0FBRCIsImZpbGUiOiIzOTEuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvKiEgdGV0aGVyIDEuNC4zICovXG5cbihmdW5jdGlvbihyb290LCBmYWN0b3J5KSB7XG4gIGlmICh0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQpIHtcbiAgICBkZWZpbmUoZmFjdG9yeSk7XG4gIH0gZWxzZSBpZiAodHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnKSB7XG4gICAgbW9kdWxlLmV4cG9ydHMgPSBmYWN0b3J5KHJlcXVpcmUsIGV4cG9ydHMsIG1vZHVsZSk7XG4gIH0gZWxzZSB7XG4gICAgcm9vdC5UZXRoZXIgPSBmYWN0b3J5KCk7XG4gIH1cbn0odGhpcywgZnVuY3Rpb24ocmVxdWlyZSwgZXhwb3J0cywgbW9kdWxlKSB7XG5cbid1c2Ugc3RyaWN0JztcblxudmFyIF9jcmVhdGVDbGFzcyA9IChmdW5jdGlvbiAoKSB7IGZ1bmN0aW9uIGRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoJ3ZhbHVlJyBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpOyB9IH0gcmV0dXJuIGZ1bmN0aW9uIChDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfTsgfSkoKTtcblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKCdDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb24nKTsgfSB9XG5cbnZhciBUZXRoZXJCYXNlID0gdW5kZWZpbmVkO1xuaWYgKHR5cGVvZiBUZXRoZXJCYXNlID09PSAndW5kZWZpbmVkJykge1xuICBUZXRoZXJCYXNlID0geyBtb2R1bGVzOiBbXSB9O1xufVxuXG52YXIgemVyb0VsZW1lbnQgPSBudWxsO1xuXG4vLyBTYW1lIGFzIG5hdGl2ZSBnZXRCb3VuZGluZ0NsaWVudFJlY3QsIGV4Y2VwdCBpdCB0YWtlcyBpbnRvIGFjY291bnQgcGFyZW50IDxmcmFtZT4gb2Zmc2V0c1xuLy8gaWYgdGhlIGVsZW1lbnQgbGllcyB3aXRoaW4gYSBuZXN0ZWQgZG9jdW1lbnQgKDxmcmFtZT4gb3IgPGlmcmFtZT4tbGlrZSkuXG5mdW5jdGlvbiBnZXRBY3R1YWxCb3VuZGluZ0NsaWVudFJlY3Qobm9kZSkge1xuICB2YXIgYm91bmRpbmdSZWN0ID0gbm9kZS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcblxuICAvLyBUaGUgb3JpZ2luYWwgb2JqZWN0IHJldHVybmVkIGJ5IGdldEJvdW5kaW5nQ2xpZW50UmVjdCBpcyBpbW11dGFibGUsIHNvIHdlIGNsb25lIGl0XG4gIC8vIFdlIGNhbid0IHVzZSBleHRlbmQgYmVjYXVzZSB0aGUgcHJvcGVydGllcyBhcmUgbm90IGNvbnNpZGVyZWQgcGFydCBvZiB0aGUgb2JqZWN0IGJ5IGhhc093blByb3BlcnR5IGluIElFOVxuICB2YXIgcmVjdCA9IHt9O1xuICBmb3IgKHZhciBrIGluIGJvdW5kaW5nUmVjdCkge1xuICAgIHJlY3Rba10gPSBib3VuZGluZ1JlY3Rba107XG4gIH1cblxuICBpZiAobm9kZS5vd25lckRvY3VtZW50ICE9PSBkb2N1bWVudCkge1xuICAgIHZhciBfZnJhbWVFbGVtZW50ID0gbm9kZS5vd25lckRvY3VtZW50LmRlZmF1bHRWaWV3LmZyYW1lRWxlbWVudDtcbiAgICBpZiAoX2ZyYW1lRWxlbWVudCkge1xuICAgICAgdmFyIGZyYW1lUmVjdCA9IGdldEFjdHVhbEJvdW5kaW5nQ2xpZW50UmVjdChfZnJhbWVFbGVtZW50KTtcbiAgICAgIHJlY3QudG9wICs9IGZyYW1lUmVjdC50b3A7XG4gICAgICByZWN0LmJvdHRvbSArPSBmcmFtZVJlY3QudG9wO1xuICAgICAgcmVjdC5sZWZ0ICs9IGZyYW1lUmVjdC5sZWZ0O1xuICAgICAgcmVjdC5yaWdodCArPSBmcmFtZVJlY3QubGVmdDtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gcmVjdDtcbn1cblxuZnVuY3Rpb24gZ2V0U2Nyb2xsUGFyZW50cyhlbCkge1xuICAvLyBJbiBmaXJlZm94IGlmIHRoZSBlbCBpcyBpbnNpZGUgYW4gaWZyYW1lIHdpdGggZGlzcGxheTogbm9uZTsgd2luZG93LmdldENvbXB1dGVkU3R5bGUoKSB3aWxsIHJldHVybiBudWxsO1xuICAvLyBodHRwczovL2J1Z3ppbGxhLm1vemlsbGEub3JnL3Nob3dfYnVnLmNnaT9pZD01NDgzOTdcbiAgdmFyIGNvbXB1dGVkU3R5bGUgPSBnZXRDb21wdXRlZFN0eWxlKGVsKSB8fCB7fTtcbiAgdmFyIHBvc2l0aW9uID0gY29tcHV0ZWRTdHlsZS5wb3NpdGlvbjtcbiAgdmFyIHBhcmVudHMgPSBbXTtcblxuICBpZiAocG9zaXRpb24gPT09ICdmaXhlZCcpIHtcbiAgICByZXR1cm4gW2VsXTtcbiAgfVxuXG4gIHZhciBwYXJlbnQgPSBlbDtcbiAgd2hpbGUgKChwYXJlbnQgPSBwYXJlbnQucGFyZW50Tm9kZSkgJiYgcGFyZW50ICYmIHBhcmVudC5ub2RlVHlwZSA9PT0gMSkge1xuICAgIHZhciBzdHlsZSA9IHVuZGVmaW5lZDtcbiAgICB0cnkge1xuICAgICAgc3R5bGUgPSBnZXRDb21wdXRlZFN0eWxlKHBhcmVudCk7XG4gICAgfSBjYXRjaCAoZXJyKSB7fVxuXG4gICAgaWYgKHR5cGVvZiBzdHlsZSA9PT0gJ3VuZGVmaW5lZCcgfHwgc3R5bGUgPT09IG51bGwpIHtcbiAgICAgIHBhcmVudHMucHVzaChwYXJlbnQpO1xuICAgICAgcmV0dXJuIHBhcmVudHM7XG4gICAgfVxuXG4gICAgdmFyIF9zdHlsZSA9IHN0eWxlO1xuICAgIHZhciBvdmVyZmxvdyA9IF9zdHlsZS5vdmVyZmxvdztcbiAgICB2YXIgb3ZlcmZsb3dYID0gX3N0eWxlLm92ZXJmbG93WDtcbiAgICB2YXIgb3ZlcmZsb3dZID0gX3N0eWxlLm92ZXJmbG93WTtcblxuICAgIGlmICgvKGF1dG98c2Nyb2xsfG92ZXJsYXkpLy50ZXN0KG92ZXJmbG93ICsgb3ZlcmZsb3dZICsgb3ZlcmZsb3dYKSkge1xuICAgICAgaWYgKHBvc2l0aW9uICE9PSAnYWJzb2x1dGUnIHx8IFsncmVsYXRpdmUnLCAnYWJzb2x1dGUnLCAnZml4ZWQnXS5pbmRleE9mKHN0eWxlLnBvc2l0aW9uKSA+PSAwKSB7XG4gICAgICAgIHBhcmVudHMucHVzaChwYXJlbnQpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHBhcmVudHMucHVzaChlbC5vd25lckRvY3VtZW50LmJvZHkpO1xuXG4gIC8vIElmIHRoZSBub2RlIGlzIHdpdGhpbiBhIGZyYW1lLCBhY2NvdW50IGZvciB0aGUgcGFyZW50IHdpbmRvdyBzY3JvbGxcbiAgaWYgKGVsLm93bmVyRG9jdW1lbnQgIT09IGRvY3VtZW50KSB7XG4gICAgcGFyZW50cy5wdXNoKGVsLm93bmVyRG9jdW1lbnQuZGVmYXVsdFZpZXcpO1xuICB9XG5cbiAgcmV0dXJuIHBhcmVudHM7XG59XG5cbnZhciB1bmlxdWVJZCA9IChmdW5jdGlvbiAoKSB7XG4gIHZhciBpZCA9IDA7XG4gIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuICsraWQ7XG4gIH07XG59KSgpO1xuXG52YXIgemVyb1Bvc0NhY2hlID0ge307XG52YXIgZ2V0T3JpZ2luID0gZnVuY3Rpb24gZ2V0T3JpZ2luKCkge1xuICAvLyBnZXRCb3VuZGluZ0NsaWVudFJlY3QgaXMgdW5mb3J0dW5hdGVseSB0b28gYWNjdXJhdGUuICBJdCBpbnRyb2R1Y2VzIGEgcGl4ZWwgb3IgdHdvIG9mXG4gIC8vIGppdHRlciBhcyB0aGUgdXNlciBzY3JvbGxzIHRoYXQgbWVzc2VzIHdpdGggb3VyIGFiaWxpdHkgdG8gZGV0ZWN0IGlmIHR3byBwb3NpdGlvbnNcbiAgLy8gYXJlIGVxdWl2aWxhbnQgb3Igbm90LiAgV2UgcGxhY2UgYW4gZWxlbWVudCBhdCB0aGUgdG9wIGxlZnQgb2YgdGhlIHBhZ2UgdGhhdCB3aWxsXG4gIC8vIGdldCB0aGUgc2FtZSBqaXR0ZXIsIHNvIHdlIGNhbiBjYW5jZWwgdGhlIHR3byBvdXQuXG4gIHZhciBub2RlID0gemVyb0VsZW1lbnQ7XG4gIGlmICghbm9kZSB8fCAhZG9jdW1lbnQuYm9keS5jb250YWlucyhub2RlKSkge1xuICAgIG5vZGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICBub2RlLnNldEF0dHJpYnV0ZSgnZGF0YS10ZXRoZXItaWQnLCB1bmlxdWVJZCgpKTtcbiAgICBleHRlbmQobm9kZS5zdHlsZSwge1xuICAgICAgdG9wOiAwLFxuICAgICAgbGVmdDogMCxcbiAgICAgIHBvc2l0aW9uOiAnYWJzb2x1dGUnXG4gICAgfSk7XG5cbiAgICBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKG5vZGUpO1xuXG4gICAgemVyb0VsZW1lbnQgPSBub2RlO1xuICB9XG5cbiAgdmFyIGlkID0gbm9kZS5nZXRBdHRyaWJ1dGUoJ2RhdGEtdGV0aGVyLWlkJyk7XG4gIGlmICh0eXBlb2YgemVyb1Bvc0NhY2hlW2lkXSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICB6ZXJvUG9zQ2FjaGVbaWRdID0gZ2V0QWN0dWFsQm91bmRpbmdDbGllbnRSZWN0KG5vZGUpO1xuXG4gICAgLy8gQ2xlYXIgdGhlIGNhY2hlIHdoZW4gdGhpcyBwb3NpdGlvbiBjYWxsIGlzIGRvbmVcbiAgICBkZWZlcihmdW5jdGlvbiAoKSB7XG4gICAgICBkZWxldGUgemVyb1Bvc0NhY2hlW2lkXTtcbiAgICB9KTtcbiAgfVxuXG4gIHJldHVybiB6ZXJvUG9zQ2FjaGVbaWRdO1xufTtcblxuZnVuY3Rpb24gcmVtb3ZlVXRpbEVsZW1lbnRzKCkge1xuICBpZiAoemVyb0VsZW1lbnQpIHtcbiAgICBkb2N1bWVudC5ib2R5LnJlbW92ZUNoaWxkKHplcm9FbGVtZW50KTtcbiAgfVxuICB6ZXJvRWxlbWVudCA9IG51bGw7XG59O1xuXG5mdW5jdGlvbiBnZXRCb3VuZHMoZWwpIHtcbiAgdmFyIGRvYyA9IHVuZGVmaW5lZDtcbiAgaWYgKGVsID09PSBkb2N1bWVudCkge1xuICAgIGRvYyA9IGRvY3VtZW50O1xuICAgIGVsID0gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50O1xuICB9IGVsc2Uge1xuICAgIGRvYyA9IGVsLm93bmVyRG9jdW1lbnQ7XG4gIH1cblxuICB2YXIgZG9jRWwgPSBkb2MuZG9jdW1lbnRFbGVtZW50O1xuXG4gIHZhciBib3ggPSBnZXRBY3R1YWxCb3VuZGluZ0NsaWVudFJlY3QoZWwpO1xuXG4gIHZhciBvcmlnaW4gPSBnZXRPcmlnaW4oKTtcblxuICBib3gudG9wIC09IG9yaWdpbi50b3A7XG4gIGJveC5sZWZ0IC09IG9yaWdpbi5sZWZ0O1xuXG4gIGlmICh0eXBlb2YgYm94LndpZHRoID09PSAndW5kZWZpbmVkJykge1xuICAgIGJveC53aWR0aCA9IGRvY3VtZW50LmJvZHkuc2Nyb2xsV2lkdGggLSBib3gubGVmdCAtIGJveC5yaWdodDtcbiAgfVxuICBpZiAodHlwZW9mIGJveC5oZWlnaHQgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgYm94LmhlaWdodCA9IGRvY3VtZW50LmJvZHkuc2Nyb2xsSGVpZ2h0IC0gYm94LnRvcCAtIGJveC5ib3R0b207XG4gIH1cblxuICBib3gudG9wID0gYm94LnRvcCAtIGRvY0VsLmNsaWVudFRvcDtcbiAgYm94LmxlZnQgPSBib3gubGVmdCAtIGRvY0VsLmNsaWVudExlZnQ7XG4gIGJveC5yaWdodCA9IGRvYy5ib2R5LmNsaWVudFdpZHRoIC0gYm94LndpZHRoIC0gYm94LmxlZnQ7XG4gIGJveC5ib3R0b20gPSBkb2MuYm9keS5jbGllbnRIZWlnaHQgLSBib3guaGVpZ2h0IC0gYm94LnRvcDtcblxuICByZXR1cm4gYm94O1xufVxuXG5mdW5jdGlvbiBnZXRPZmZzZXRQYXJlbnQoZWwpIHtcbiAgcmV0dXJuIGVsLm9mZnNldFBhcmVudCB8fCBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQ7XG59XG5cbnZhciBfc2Nyb2xsQmFyU2l6ZSA9IG51bGw7XG5mdW5jdGlvbiBnZXRTY3JvbGxCYXJTaXplKCkge1xuICBpZiAoX3Njcm9sbEJhclNpemUpIHtcbiAgICByZXR1cm4gX3Njcm9sbEJhclNpemU7XG4gIH1cbiAgdmFyIGlubmVyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gIGlubmVyLnN0eWxlLndpZHRoID0gJzEwMCUnO1xuICBpbm5lci5zdHlsZS5oZWlnaHQgPSAnMjAwcHgnO1xuXG4gIHZhciBvdXRlciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICBleHRlbmQob3V0ZXIuc3R5bGUsIHtcbiAgICBwb3NpdGlvbjogJ2Fic29sdXRlJyxcbiAgICB0b3A6IDAsXG4gICAgbGVmdDogMCxcbiAgICBwb2ludGVyRXZlbnRzOiAnbm9uZScsXG4gICAgdmlzaWJpbGl0eTogJ2hpZGRlbicsXG4gICAgd2lkdGg6ICcyMDBweCcsXG4gICAgaGVpZ2h0OiAnMTUwcHgnLFxuICAgIG92ZXJmbG93OiAnaGlkZGVuJ1xuICB9KTtcblxuICBvdXRlci5hcHBlbmRDaGlsZChpbm5lcik7XG5cbiAgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChvdXRlcik7XG5cbiAgdmFyIHdpZHRoQ29udGFpbmVkID0gaW5uZXIub2Zmc2V0V2lkdGg7XG4gIG91dGVyLnN0eWxlLm92ZXJmbG93ID0gJ3Njcm9sbCc7XG4gIHZhciB3aWR0aFNjcm9sbCA9IGlubmVyLm9mZnNldFdpZHRoO1xuXG4gIGlmICh3aWR0aENvbnRhaW5lZCA9PT0gd2lkdGhTY3JvbGwpIHtcbiAgICB3aWR0aFNjcm9sbCA9IG91dGVyLmNsaWVudFdpZHRoO1xuICB9XG5cbiAgZG9jdW1lbnQuYm9keS5yZW1vdmVDaGlsZChvdXRlcik7XG5cbiAgdmFyIHdpZHRoID0gd2lkdGhDb250YWluZWQgLSB3aWR0aFNjcm9sbDtcblxuICBfc2Nyb2xsQmFyU2l6ZSA9IHsgd2lkdGg6IHdpZHRoLCBoZWlnaHQ6IHdpZHRoIH07XG4gIHJldHVybiBfc2Nyb2xsQmFyU2l6ZTtcbn1cblxuZnVuY3Rpb24gZXh0ZW5kKCkge1xuICB2YXIgb3V0ID0gYXJndW1lbnRzLmxlbmd0aCA8PSAwIHx8IGFyZ3VtZW50c1swXSA9PT0gdW5kZWZpbmVkID8ge30gOiBhcmd1bWVudHNbMF07XG5cbiAgdmFyIGFyZ3MgPSBbXTtcblxuICBBcnJheS5wcm90b3R5cGUucHVzaC5hcHBseShhcmdzLCBhcmd1bWVudHMpO1xuXG4gIGFyZ3Muc2xpY2UoMSkuZm9yRWFjaChmdW5jdGlvbiAob2JqKSB7XG4gICAgaWYgKG9iaikge1xuICAgICAgZm9yICh2YXIga2V5IGluIG9iaikge1xuICAgICAgICBpZiAoKHt9KS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwga2V5KSkge1xuICAgICAgICAgIG91dFtrZXldID0gb2JqW2tleV07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH0pO1xuXG4gIHJldHVybiBvdXQ7XG59XG5cbmZ1bmN0aW9uIHJlbW92ZUNsYXNzKGVsLCBuYW1lKSB7XG4gIGlmICh0eXBlb2YgZWwuY2xhc3NMaXN0ICE9PSAndW5kZWZpbmVkJykge1xuICAgIG5hbWUuc3BsaXQoJyAnKS5mb3JFYWNoKGZ1bmN0aW9uIChjbHMpIHtcbiAgICAgIGlmIChjbHMudHJpbSgpKSB7XG4gICAgICAgIGVsLmNsYXNzTGlzdC5yZW1vdmUoY2xzKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfSBlbHNlIHtcbiAgICB2YXIgcmVnZXggPSBuZXcgUmVnRXhwKCcoXnwgKScgKyBuYW1lLnNwbGl0KCcgJykuam9pbignfCcpICsgJyggfCQpJywgJ2dpJyk7XG4gICAgdmFyIGNsYXNzTmFtZSA9IGdldENsYXNzTmFtZShlbCkucmVwbGFjZShyZWdleCwgJyAnKTtcbiAgICBzZXRDbGFzc05hbWUoZWwsIGNsYXNzTmFtZSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gYWRkQ2xhc3MoZWwsIG5hbWUpIHtcbiAgaWYgKHR5cGVvZiBlbC5jbGFzc0xpc3QgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgbmFtZS5zcGxpdCgnICcpLmZvckVhY2goZnVuY3Rpb24gKGNscykge1xuICAgICAgaWYgKGNscy50cmltKCkpIHtcbiAgICAgICAgZWwuY2xhc3NMaXN0LmFkZChjbHMpO1xuICAgICAgfVxuICAgIH0pO1xuICB9IGVsc2Uge1xuICAgIHJlbW92ZUNsYXNzKGVsLCBuYW1lKTtcbiAgICB2YXIgY2xzID0gZ2V0Q2xhc3NOYW1lKGVsKSArICgnICcgKyBuYW1lKTtcbiAgICBzZXRDbGFzc05hbWUoZWwsIGNscyk7XG4gIH1cbn1cblxuZnVuY3Rpb24gaGFzQ2xhc3MoZWwsIG5hbWUpIHtcbiAgaWYgKHR5cGVvZiBlbC5jbGFzc0xpc3QgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgcmV0dXJuIGVsLmNsYXNzTGlzdC5jb250YWlucyhuYW1lKTtcbiAgfVxuICB2YXIgY2xhc3NOYW1lID0gZ2V0Q2xhc3NOYW1lKGVsKTtcbiAgcmV0dXJuIG5ldyBSZWdFeHAoJyhefCApJyArIG5hbWUgKyAnKCB8JCknLCAnZ2knKS50ZXN0KGNsYXNzTmFtZSk7XG59XG5cbmZ1bmN0aW9uIGdldENsYXNzTmFtZShlbCkge1xuICAvLyBDYW4ndCB1c2UganVzdCBTVkdBbmltYXRlZFN0cmluZyBoZXJlIHNpbmNlIG5vZGVzIHdpdGhpbiBhIEZyYW1lIGluIElFIGhhdmVcbiAgLy8gY29tcGxldGVseSBzZXBhcmF0ZWx5IFNWR0FuaW1hdGVkU3RyaW5nIGJhc2UgY2xhc3Nlc1xuICBpZiAoZWwuY2xhc3NOYW1lIGluc3RhbmNlb2YgZWwub3duZXJEb2N1bWVudC5kZWZhdWx0Vmlldy5TVkdBbmltYXRlZFN0cmluZykge1xuICAgIHJldHVybiBlbC5jbGFzc05hbWUuYmFzZVZhbDtcbiAgfVxuICByZXR1cm4gZWwuY2xhc3NOYW1lO1xufVxuXG5mdW5jdGlvbiBzZXRDbGFzc05hbWUoZWwsIGNsYXNzTmFtZSkge1xuICBlbC5zZXRBdHRyaWJ1dGUoJ2NsYXNzJywgY2xhc3NOYW1lKTtcbn1cblxuZnVuY3Rpb24gdXBkYXRlQ2xhc3NlcyhlbCwgYWRkLCBhbGwpIHtcbiAgLy8gT2YgdGhlIHNldCBvZiAnYWxsJyBjbGFzc2VzLCB3ZSBuZWVkIHRoZSAnYWRkJyBjbGFzc2VzLCBhbmQgb25seSB0aGVcbiAgLy8gJ2FkZCcgY2xhc3NlcyB0byBiZSBzZXQuXG4gIGFsbC5mb3JFYWNoKGZ1bmN0aW9uIChjbHMpIHtcbiAgICBpZiAoYWRkLmluZGV4T2YoY2xzKSA9PT0gLTEgJiYgaGFzQ2xhc3MoZWwsIGNscykpIHtcbiAgICAgIHJlbW92ZUNsYXNzKGVsLCBjbHMpO1xuICAgIH1cbiAgfSk7XG5cbiAgYWRkLmZvckVhY2goZnVuY3Rpb24gKGNscykge1xuICAgIGlmICghaGFzQ2xhc3MoZWwsIGNscykpIHtcbiAgICAgIGFkZENsYXNzKGVsLCBjbHMpO1xuICAgIH1cbiAgfSk7XG59XG5cbnZhciBkZWZlcnJlZCA9IFtdO1xuXG52YXIgZGVmZXIgPSBmdW5jdGlvbiBkZWZlcihmbikge1xuICBkZWZlcnJlZC5wdXNoKGZuKTtcbn07XG5cbnZhciBmbHVzaCA9IGZ1bmN0aW9uIGZsdXNoKCkge1xuICB2YXIgZm4gPSB1bmRlZmluZWQ7XG4gIHdoaWxlIChmbiA9IGRlZmVycmVkLnBvcCgpKSB7XG4gICAgZm4oKTtcbiAgfVxufTtcblxudmFyIEV2ZW50ZWQgPSAoZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBFdmVudGVkKCkge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBFdmVudGVkKTtcbiAgfVxuXG4gIF9jcmVhdGVDbGFzcyhFdmVudGVkLCBbe1xuICAgIGtleTogJ29uJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gb24oZXZlbnQsIGhhbmRsZXIsIGN0eCkge1xuICAgICAgdmFyIG9uY2UgPSBhcmd1bWVudHMubGVuZ3RoIDw9IDMgfHwgYXJndW1lbnRzWzNdID09PSB1bmRlZmluZWQgPyBmYWxzZSA6IGFyZ3VtZW50c1szXTtcblxuICAgICAgaWYgKHR5cGVvZiB0aGlzLmJpbmRpbmdzID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICB0aGlzLmJpbmRpbmdzID0ge307XG4gICAgICB9XG4gICAgICBpZiAodHlwZW9mIHRoaXMuYmluZGluZ3NbZXZlbnRdID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICB0aGlzLmJpbmRpbmdzW2V2ZW50XSA9IFtdO1xuICAgICAgfVxuICAgICAgdGhpcy5iaW5kaW5nc1tldmVudF0ucHVzaCh7IGhhbmRsZXI6IGhhbmRsZXIsIGN0eDogY3R4LCBvbmNlOiBvbmNlIH0pO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ29uY2UnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBvbmNlKGV2ZW50LCBoYW5kbGVyLCBjdHgpIHtcbiAgICAgIHRoaXMub24oZXZlbnQsIGhhbmRsZXIsIGN0eCwgdHJ1ZSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnb2ZmJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gb2ZmKGV2ZW50LCBoYW5kbGVyKSB7XG4gICAgICBpZiAodHlwZW9mIHRoaXMuYmluZGluZ3MgPT09ICd1bmRlZmluZWQnIHx8IHR5cGVvZiB0aGlzLmJpbmRpbmdzW2V2ZW50XSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBpZiAodHlwZW9mIGhhbmRsZXIgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIGRlbGV0ZSB0aGlzLmJpbmRpbmdzW2V2ZW50XTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciBpID0gMDtcbiAgICAgICAgd2hpbGUgKGkgPCB0aGlzLmJpbmRpbmdzW2V2ZW50XS5sZW5ndGgpIHtcbiAgICAgICAgICBpZiAodGhpcy5iaW5kaW5nc1tldmVudF1baV0uaGFuZGxlciA9PT0gaGFuZGxlcikge1xuICAgICAgICAgICAgdGhpcy5iaW5kaW5nc1tldmVudF0uc3BsaWNlKGksIDEpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICArK2k7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAndHJpZ2dlcicsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHRyaWdnZXIoZXZlbnQpIHtcbiAgICAgIGlmICh0eXBlb2YgdGhpcy5iaW5kaW5ncyAhPT0gJ3VuZGVmaW5lZCcgJiYgdGhpcy5iaW5kaW5nc1tldmVudF0pIHtcbiAgICAgICAgdmFyIGkgPSAwO1xuXG4gICAgICAgIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gQXJyYXkoX2xlbiA+IDEgPyBfbGVuIC0gMSA6IDApLCBfa2V5ID0gMTsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuICAgICAgICAgIGFyZ3NbX2tleSAtIDFdID0gYXJndW1lbnRzW19rZXldO1xuICAgICAgICB9XG5cbiAgICAgICAgd2hpbGUgKGkgPCB0aGlzLmJpbmRpbmdzW2V2ZW50XS5sZW5ndGgpIHtcbiAgICAgICAgICB2YXIgX2JpbmRpbmdzJGV2ZW50JGkgPSB0aGlzLmJpbmRpbmdzW2V2ZW50XVtpXTtcbiAgICAgICAgICB2YXIgaGFuZGxlciA9IF9iaW5kaW5ncyRldmVudCRpLmhhbmRsZXI7XG4gICAgICAgICAgdmFyIGN0eCA9IF9iaW5kaW5ncyRldmVudCRpLmN0eDtcbiAgICAgICAgICB2YXIgb25jZSA9IF9iaW5kaW5ncyRldmVudCRpLm9uY2U7XG5cbiAgICAgICAgICB2YXIgY29udGV4dCA9IGN0eDtcbiAgICAgICAgICBpZiAodHlwZW9mIGNvbnRleHQgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBjb250ZXh0ID0gdGhpcztcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBoYW5kbGVyLmFwcGx5KGNvbnRleHQsIGFyZ3MpO1xuXG4gICAgICAgICAgaWYgKG9uY2UpIHtcbiAgICAgICAgICAgIHRoaXMuYmluZGluZ3NbZXZlbnRdLnNwbGljZShpLCAxKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgKytpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBFdmVudGVkO1xufSkoKTtcblxuVGV0aGVyQmFzZS5VdGlscyA9IHtcbiAgZ2V0QWN0dWFsQm91bmRpbmdDbGllbnRSZWN0OiBnZXRBY3R1YWxCb3VuZGluZ0NsaWVudFJlY3QsXG4gIGdldFNjcm9sbFBhcmVudHM6IGdldFNjcm9sbFBhcmVudHMsXG4gIGdldEJvdW5kczogZ2V0Qm91bmRzLFxuICBnZXRPZmZzZXRQYXJlbnQ6IGdldE9mZnNldFBhcmVudCxcbiAgZXh0ZW5kOiBleHRlbmQsXG4gIGFkZENsYXNzOiBhZGRDbGFzcyxcbiAgcmVtb3ZlQ2xhc3M6IHJlbW92ZUNsYXNzLFxuICBoYXNDbGFzczogaGFzQ2xhc3MsXG4gIHVwZGF0ZUNsYXNzZXM6IHVwZGF0ZUNsYXNzZXMsXG4gIGRlZmVyOiBkZWZlcixcbiAgZmx1c2g6IGZsdXNoLFxuICB1bmlxdWVJZDogdW5pcXVlSWQsXG4gIEV2ZW50ZWQ6IEV2ZW50ZWQsXG4gIGdldFNjcm9sbEJhclNpemU6IGdldFNjcm9sbEJhclNpemUsXG4gIHJlbW92ZVV0aWxFbGVtZW50czogcmVtb3ZlVXRpbEVsZW1lbnRzXG59O1xuLyogZ2xvYmFscyBUZXRoZXJCYXNlLCBwZXJmb3JtYW5jZSAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBfc2xpY2VkVG9BcnJheSA9IChmdW5jdGlvbiAoKSB7IGZ1bmN0aW9uIHNsaWNlSXRlcmF0b3IoYXJyLCBpKSB7IHZhciBfYXJyID0gW107IHZhciBfbiA9IHRydWU7IHZhciBfZCA9IGZhbHNlOyB2YXIgX2UgPSB1bmRlZmluZWQ7IHRyeSB7IGZvciAodmFyIF9pID0gYXJyW1N5bWJvbC5pdGVyYXRvcl0oKSwgX3M7ICEoX24gPSAoX3MgPSBfaS5uZXh0KCkpLmRvbmUpOyBfbiA9IHRydWUpIHsgX2Fyci5wdXNoKF9zLnZhbHVlKTsgaWYgKGkgJiYgX2Fyci5sZW5ndGggPT09IGkpIGJyZWFrOyB9IH0gY2F0Y2ggKGVycikgeyBfZCA9IHRydWU7IF9lID0gZXJyOyB9IGZpbmFsbHkgeyB0cnkgeyBpZiAoIV9uICYmIF9pWydyZXR1cm4nXSkgX2lbJ3JldHVybiddKCk7IH0gZmluYWxseSB7IGlmIChfZCkgdGhyb3cgX2U7IH0gfSByZXR1cm4gX2FycjsgfSByZXR1cm4gZnVuY3Rpb24gKGFyciwgaSkgeyBpZiAoQXJyYXkuaXNBcnJheShhcnIpKSB7IHJldHVybiBhcnI7IH0gZWxzZSBpZiAoU3ltYm9sLml0ZXJhdG9yIGluIE9iamVjdChhcnIpKSB7IHJldHVybiBzbGljZUl0ZXJhdG9yKGFyciwgaSk7IH0gZWxzZSB7IHRocm93IG5ldyBUeXBlRXJyb3IoJ0ludmFsaWQgYXR0ZW1wdCB0byBkZXN0cnVjdHVyZSBub24taXRlcmFibGUgaW5zdGFuY2UnKTsgfSB9OyB9KSgpO1xuXG52YXIgX2NyZWF0ZUNsYXNzID0gKGZ1bmN0aW9uICgpIHsgZnVuY3Rpb24gZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTsgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOyBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7IGlmICgndmFsdWUnIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlOyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7IH0gfSByZXR1cm4gZnVuY3Rpb24gKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgeyBpZiAocHJvdG9Qcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOyBpZiAoc3RhdGljUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsgcmV0dXJuIENvbnN0cnVjdG9yOyB9OyB9KSgpO1xuXG52YXIgX2dldCA9IGZ1bmN0aW9uIGdldChfeDYsIF94NywgX3g4KSB7IHZhciBfYWdhaW4gPSB0cnVlOyBfZnVuY3Rpb246IHdoaWxlIChfYWdhaW4pIHsgdmFyIG9iamVjdCA9IF94NiwgcHJvcGVydHkgPSBfeDcsIHJlY2VpdmVyID0gX3g4OyBfYWdhaW4gPSBmYWxzZTsgaWYgKG9iamVjdCA9PT0gbnVsbCkgb2JqZWN0ID0gRnVuY3Rpb24ucHJvdG90eXBlOyB2YXIgZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iob2JqZWN0LCBwcm9wZXJ0eSk7IGlmIChkZXNjID09PSB1bmRlZmluZWQpIHsgdmFyIHBhcmVudCA9IE9iamVjdC5nZXRQcm90b3R5cGVPZihvYmplY3QpOyBpZiAocGFyZW50ID09PSBudWxsKSB7IHJldHVybiB1bmRlZmluZWQ7IH0gZWxzZSB7IF94NiA9IHBhcmVudDsgX3g3ID0gcHJvcGVydHk7IF94OCA9IHJlY2VpdmVyOyBfYWdhaW4gPSB0cnVlOyBkZXNjID0gcGFyZW50ID0gdW5kZWZpbmVkOyBjb250aW51ZSBfZnVuY3Rpb247IH0gfSBlbHNlIGlmICgndmFsdWUnIGluIGRlc2MpIHsgcmV0dXJuIGRlc2MudmFsdWU7IH0gZWxzZSB7IHZhciBnZXR0ZXIgPSBkZXNjLmdldDsgaWYgKGdldHRlciA9PT0gdW5kZWZpbmVkKSB7IHJldHVybiB1bmRlZmluZWQ7IH0gcmV0dXJuIGdldHRlci5jYWxsKHJlY2VpdmVyKTsgfSB9IH07XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcignQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uJyk7IH0gfVxuXG5mdW5jdGlvbiBfaW5oZXJpdHMoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHsgaWYgKHR5cGVvZiBzdXBlckNsYXNzICE9PSAnZnVuY3Rpb24nICYmIHN1cGVyQ2xhc3MgIT09IG51bGwpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcignU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb24sIG5vdCAnICsgdHlwZW9mIHN1cGVyQ2xhc3MpOyB9IHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcyAmJiBzdXBlckNsYXNzLnByb3RvdHlwZSwgeyBjb25zdHJ1Y3RvcjogeyB2YWx1ZTogc3ViQ2xhc3MsIGVudW1lcmFibGU6IGZhbHNlLCB3cml0YWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlIH0gfSk7IGlmIChzdXBlckNsYXNzKSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3Quc2V0UHJvdG90eXBlT2Yoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIDogc3ViQ2xhc3MuX19wcm90b19fID0gc3VwZXJDbGFzczsgfVxuXG5pZiAodHlwZW9mIFRldGhlckJhc2UgPT09ICd1bmRlZmluZWQnKSB7XG4gIHRocm93IG5ldyBFcnJvcignWW91IG11c3QgaW5jbHVkZSB0aGUgdXRpbHMuanMgZmlsZSBiZWZvcmUgdGV0aGVyLmpzJyk7XG59XG5cbnZhciBfVGV0aGVyQmFzZSRVdGlscyA9IFRldGhlckJhc2UuVXRpbHM7XG52YXIgZ2V0U2Nyb2xsUGFyZW50cyA9IF9UZXRoZXJCYXNlJFV0aWxzLmdldFNjcm9sbFBhcmVudHM7XG52YXIgZ2V0Qm91bmRzID0gX1RldGhlckJhc2UkVXRpbHMuZ2V0Qm91bmRzO1xudmFyIGdldE9mZnNldFBhcmVudCA9IF9UZXRoZXJCYXNlJFV0aWxzLmdldE9mZnNldFBhcmVudDtcbnZhciBleHRlbmQgPSBfVGV0aGVyQmFzZSRVdGlscy5leHRlbmQ7XG52YXIgYWRkQ2xhc3MgPSBfVGV0aGVyQmFzZSRVdGlscy5hZGRDbGFzcztcbnZhciByZW1vdmVDbGFzcyA9IF9UZXRoZXJCYXNlJFV0aWxzLnJlbW92ZUNsYXNzO1xudmFyIHVwZGF0ZUNsYXNzZXMgPSBfVGV0aGVyQmFzZSRVdGlscy51cGRhdGVDbGFzc2VzO1xudmFyIGRlZmVyID0gX1RldGhlckJhc2UkVXRpbHMuZGVmZXI7XG52YXIgZmx1c2ggPSBfVGV0aGVyQmFzZSRVdGlscy5mbHVzaDtcbnZhciBnZXRTY3JvbGxCYXJTaXplID0gX1RldGhlckJhc2UkVXRpbHMuZ2V0U2Nyb2xsQmFyU2l6ZTtcbnZhciByZW1vdmVVdGlsRWxlbWVudHMgPSBfVGV0aGVyQmFzZSRVdGlscy5yZW1vdmVVdGlsRWxlbWVudHM7XG5cbmZ1bmN0aW9uIHdpdGhpbihhLCBiKSB7XG4gIHZhciBkaWZmID0gYXJndW1lbnRzLmxlbmd0aCA8PSAyIHx8IGFyZ3VtZW50c1syXSA9PT0gdW5kZWZpbmVkID8gMSA6IGFyZ3VtZW50c1syXTtcblxuICByZXR1cm4gYSArIGRpZmYgPj0gYiAmJiBiID49IGEgLSBkaWZmO1xufVxuXG52YXIgdHJhbnNmb3JtS2V5ID0gKGZ1bmN0aW9uICgpIHtcbiAgaWYgKHR5cGVvZiBkb2N1bWVudCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICByZXR1cm4gJyc7XG4gIH1cbiAgdmFyIGVsID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG5cbiAgdmFyIHRyYW5zZm9ybXMgPSBbJ3RyYW5zZm9ybScsICdXZWJraXRUcmFuc2Zvcm0nLCAnT1RyYW5zZm9ybScsICdNb3pUcmFuc2Zvcm0nLCAnbXNUcmFuc2Zvcm0nXTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCB0cmFuc2Zvcm1zLmxlbmd0aDsgKytpKSB7XG4gICAgdmFyIGtleSA9IHRyYW5zZm9ybXNbaV07XG4gICAgaWYgKGVsLnN0eWxlW2tleV0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgcmV0dXJuIGtleTtcbiAgICB9XG4gIH1cbn0pKCk7XG5cbnZhciB0ZXRoZXJzID0gW107XG5cbnZhciBwb3NpdGlvbiA9IGZ1bmN0aW9uIHBvc2l0aW9uKCkge1xuICB0ZXRoZXJzLmZvckVhY2goZnVuY3Rpb24gKHRldGhlcikge1xuICAgIHRldGhlci5wb3NpdGlvbihmYWxzZSk7XG4gIH0pO1xuICBmbHVzaCgpO1xufTtcblxuZnVuY3Rpb24gbm93KCkge1xuICBpZiAodHlwZW9mIHBlcmZvcm1hbmNlID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgcGVyZm9ybWFuY2Uubm93ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgcmV0dXJuIHBlcmZvcm1hbmNlLm5vdygpO1xuICB9XG4gIHJldHVybiArbmV3IERhdGUoKTtcbn1cblxuKGZ1bmN0aW9uICgpIHtcbiAgdmFyIGxhc3RDYWxsID0gbnVsbDtcbiAgdmFyIGxhc3REdXJhdGlvbiA9IG51bGw7XG4gIHZhciBwZW5kaW5nVGltZW91dCA9IG51bGw7XG5cbiAgdmFyIHRpY2sgPSBmdW5jdGlvbiB0aWNrKCkge1xuICAgIGlmICh0eXBlb2YgbGFzdER1cmF0aW9uICE9PSAndW5kZWZpbmVkJyAmJiBsYXN0RHVyYXRpb24gPiAxNikge1xuICAgICAgLy8gV2Ugdm9sdW50YXJpbHkgdGhyb3R0bGUgb3Vyc2VsdmVzIGlmIHdlIGNhbid0IG1hbmFnZSA2MGZwc1xuICAgICAgbGFzdER1cmF0aW9uID0gTWF0aC5taW4obGFzdER1cmF0aW9uIC0gMTYsIDI1MCk7XG5cbiAgICAgIC8vIEp1c3QgaW4gY2FzZSB0aGlzIGlzIHRoZSBsYXN0IGV2ZW50LCByZW1lbWJlciB0byBwb3NpdGlvbiBqdXN0IG9uY2UgbW9yZVxuICAgICAgcGVuZGluZ1RpbWVvdXQgPSBzZXRUaW1lb3V0KHRpY2ssIDI1MCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBsYXN0Q2FsbCAhPT0gJ3VuZGVmaW5lZCcgJiYgbm93KCkgLSBsYXN0Q2FsbCA8IDEwKSB7XG4gICAgICAvLyBTb21lIGJyb3dzZXJzIGNhbGwgZXZlbnRzIGEgbGl0dGxlIHRvbyBmcmVxdWVudGx5LCByZWZ1c2UgdG8gcnVuIG1vcmUgdGhhbiBpcyByZWFzb25hYmxlXG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKHBlbmRpbmdUaW1lb3V0ICE9IG51bGwpIHtcbiAgICAgIGNsZWFyVGltZW91dChwZW5kaW5nVGltZW91dCk7XG4gICAgICBwZW5kaW5nVGltZW91dCA9IG51bGw7XG4gICAgfVxuXG4gICAgbGFzdENhbGwgPSBub3coKTtcbiAgICBwb3NpdGlvbigpO1xuICAgIGxhc3REdXJhdGlvbiA9IG5vdygpIC0gbGFzdENhbGw7XG4gIH07XG5cbiAgaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmIHR5cGVvZiB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lciAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICBbJ3Jlc2l6ZScsICdzY3JvbGwnLCAndG91Y2htb3ZlJ10uZm9yRWFjaChmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKGV2ZW50LCB0aWNrKTtcbiAgICB9KTtcbiAgfVxufSkoKTtcblxudmFyIE1JUlJPUl9MUiA9IHtcbiAgY2VudGVyOiAnY2VudGVyJyxcbiAgbGVmdDogJ3JpZ2h0JyxcbiAgcmlnaHQ6ICdsZWZ0J1xufTtcblxudmFyIE1JUlJPUl9UQiA9IHtcbiAgbWlkZGxlOiAnbWlkZGxlJyxcbiAgdG9wOiAnYm90dG9tJyxcbiAgYm90dG9tOiAndG9wJ1xufTtcblxudmFyIE9GRlNFVF9NQVAgPSB7XG4gIHRvcDogMCxcbiAgbGVmdDogMCxcbiAgbWlkZGxlOiAnNTAlJyxcbiAgY2VudGVyOiAnNTAlJyxcbiAgYm90dG9tOiAnMTAwJScsXG4gIHJpZ2h0OiAnMTAwJSdcbn07XG5cbnZhciBhdXRvVG9GaXhlZEF0dGFjaG1lbnQgPSBmdW5jdGlvbiBhdXRvVG9GaXhlZEF0dGFjaG1lbnQoYXR0YWNobWVudCwgcmVsYXRpdmVUb0F0dGFjaG1lbnQpIHtcbiAgdmFyIGxlZnQgPSBhdHRhY2htZW50LmxlZnQ7XG4gIHZhciB0b3AgPSBhdHRhY2htZW50LnRvcDtcblxuICBpZiAobGVmdCA9PT0gJ2F1dG8nKSB7XG4gICAgbGVmdCA9IE1JUlJPUl9MUltyZWxhdGl2ZVRvQXR0YWNobWVudC5sZWZ0XTtcbiAgfVxuXG4gIGlmICh0b3AgPT09ICdhdXRvJykge1xuICAgIHRvcCA9IE1JUlJPUl9UQltyZWxhdGl2ZVRvQXR0YWNobWVudC50b3BdO1xuICB9XG5cbiAgcmV0dXJuIHsgbGVmdDogbGVmdCwgdG9wOiB0b3AgfTtcbn07XG5cbnZhciBhdHRhY2htZW50VG9PZmZzZXQgPSBmdW5jdGlvbiBhdHRhY2htZW50VG9PZmZzZXQoYXR0YWNobWVudCkge1xuICB2YXIgbGVmdCA9IGF0dGFjaG1lbnQubGVmdDtcbiAgdmFyIHRvcCA9IGF0dGFjaG1lbnQudG9wO1xuXG4gIGlmICh0eXBlb2YgT0ZGU0VUX01BUFthdHRhY2htZW50LmxlZnRdICE9PSAndW5kZWZpbmVkJykge1xuICAgIGxlZnQgPSBPRkZTRVRfTUFQW2F0dGFjaG1lbnQubGVmdF07XG4gIH1cblxuICBpZiAodHlwZW9mIE9GRlNFVF9NQVBbYXR0YWNobWVudC50b3BdICE9PSAndW5kZWZpbmVkJykge1xuICAgIHRvcCA9IE9GRlNFVF9NQVBbYXR0YWNobWVudC50b3BdO1xuICB9XG5cbiAgcmV0dXJuIHsgbGVmdDogbGVmdCwgdG9wOiB0b3AgfTtcbn07XG5cbmZ1bmN0aW9uIGFkZE9mZnNldCgpIHtcbiAgdmFyIG91dCA9IHsgdG9wOiAwLCBsZWZ0OiAwIH07XG5cbiAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIG9mZnNldHMgPSBBcnJheShfbGVuKSwgX2tleSA9IDA7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcbiAgICBvZmZzZXRzW19rZXldID0gYXJndW1lbnRzW19rZXldO1xuICB9XG5cbiAgb2Zmc2V0cy5mb3JFYWNoKGZ1bmN0aW9uIChfcmVmKSB7XG4gICAgdmFyIHRvcCA9IF9yZWYudG9wO1xuICAgIHZhciBsZWZ0ID0gX3JlZi5sZWZ0O1xuXG4gICAgaWYgKHR5cGVvZiB0b3AgPT09ICdzdHJpbmcnKSB7XG4gICAgICB0b3AgPSBwYXJzZUZsb2F0KHRvcCwgMTApO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIGxlZnQgPT09ICdzdHJpbmcnKSB7XG4gICAgICBsZWZ0ID0gcGFyc2VGbG9hdChsZWZ0LCAxMCk7XG4gICAgfVxuXG4gICAgb3V0LnRvcCArPSB0b3A7XG4gICAgb3V0LmxlZnQgKz0gbGVmdDtcbiAgfSk7XG5cbiAgcmV0dXJuIG91dDtcbn1cblxuZnVuY3Rpb24gb2Zmc2V0VG9QeChvZmZzZXQsIHNpemUpIHtcbiAgaWYgKHR5cGVvZiBvZmZzZXQubGVmdCA9PT0gJ3N0cmluZycgJiYgb2Zmc2V0LmxlZnQuaW5kZXhPZignJScpICE9PSAtMSkge1xuICAgIG9mZnNldC5sZWZ0ID0gcGFyc2VGbG9hdChvZmZzZXQubGVmdCwgMTApIC8gMTAwICogc2l6ZS53aWR0aDtcbiAgfVxuICBpZiAodHlwZW9mIG9mZnNldC50b3AgPT09ICdzdHJpbmcnICYmIG9mZnNldC50b3AuaW5kZXhPZignJScpICE9PSAtMSkge1xuICAgIG9mZnNldC50b3AgPSBwYXJzZUZsb2F0KG9mZnNldC50b3AsIDEwKSAvIDEwMCAqIHNpemUuaGVpZ2h0O1xuICB9XG5cbiAgcmV0dXJuIG9mZnNldDtcbn1cblxudmFyIHBhcnNlT2Zmc2V0ID0gZnVuY3Rpb24gcGFyc2VPZmZzZXQodmFsdWUpIHtcbiAgdmFyIF92YWx1ZSRzcGxpdCA9IHZhbHVlLnNwbGl0KCcgJyk7XG5cbiAgdmFyIF92YWx1ZSRzcGxpdDIgPSBfc2xpY2VkVG9BcnJheShfdmFsdWUkc3BsaXQsIDIpO1xuXG4gIHZhciB0b3AgPSBfdmFsdWUkc3BsaXQyWzBdO1xuICB2YXIgbGVmdCA9IF92YWx1ZSRzcGxpdDJbMV07XG5cbiAgcmV0dXJuIHsgdG9wOiB0b3AsIGxlZnQ6IGxlZnQgfTtcbn07XG52YXIgcGFyc2VBdHRhY2htZW50ID0gcGFyc2VPZmZzZXQ7XG5cbnZhciBUZXRoZXJDbGFzcyA9IChmdW5jdGlvbiAoX0V2ZW50ZWQpIHtcbiAgX2luaGVyaXRzKFRldGhlckNsYXNzLCBfRXZlbnRlZCk7XG5cbiAgZnVuY3Rpb24gVGV0aGVyQ2xhc3Mob3B0aW9ucykge1xuICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgVGV0aGVyQ2xhc3MpO1xuXG4gICAgX2dldChPYmplY3QuZ2V0UHJvdG90eXBlT2YoVGV0aGVyQ2xhc3MucHJvdG90eXBlKSwgJ2NvbnN0cnVjdG9yJywgdGhpcykuY2FsbCh0aGlzKTtcbiAgICB0aGlzLnBvc2l0aW9uID0gdGhpcy5wb3NpdGlvbi5iaW5kKHRoaXMpO1xuXG4gICAgdGV0aGVycy5wdXNoKHRoaXMpO1xuXG4gICAgdGhpcy5oaXN0b3J5ID0gW107XG5cbiAgICB0aGlzLnNldE9wdGlvbnMob3B0aW9ucywgZmFsc2UpO1xuXG4gICAgVGV0aGVyQmFzZS5tb2R1bGVzLmZvckVhY2goZnVuY3Rpb24gKG1vZHVsZSkge1xuICAgICAgaWYgKHR5cGVvZiBtb2R1bGUuaW5pdGlhbGl6ZSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgbW9kdWxlLmluaXRpYWxpemUuY2FsbChfdGhpcyk7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICB0aGlzLnBvc2l0aW9uKCk7XG4gIH1cblxuICBfY3JlYXRlQ2xhc3MoVGV0aGVyQ2xhc3MsIFt7XG4gICAga2V5OiAnZ2V0Q2xhc3MnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRDbGFzcygpIHtcbiAgICAgIHZhciBrZXkgPSBhcmd1bWVudHMubGVuZ3RoIDw9IDAgfHwgYXJndW1lbnRzWzBdID09PSB1bmRlZmluZWQgPyAnJyA6IGFyZ3VtZW50c1swXTtcbiAgICAgIHZhciBjbGFzc2VzID0gdGhpcy5vcHRpb25zLmNsYXNzZXM7XG5cbiAgICAgIGlmICh0eXBlb2YgY2xhc3NlcyAhPT0gJ3VuZGVmaW5lZCcgJiYgY2xhc3Nlc1trZXldKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm9wdGlvbnMuY2xhc3Nlc1trZXldO1xuICAgICAgfSBlbHNlIGlmICh0aGlzLm9wdGlvbnMuY2xhc3NQcmVmaXgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMub3B0aW9ucy5jbGFzc1ByZWZpeCArICctJyArIGtleTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBrZXk7XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnc2V0T3B0aW9ucycsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNldE9wdGlvbnMob3B0aW9ucykge1xuICAgICAgdmFyIF90aGlzMiA9IHRoaXM7XG5cbiAgICAgIHZhciBwb3MgPSBhcmd1bWVudHMubGVuZ3RoIDw9IDEgfHwgYXJndW1lbnRzWzFdID09PSB1bmRlZmluZWQgPyB0cnVlIDogYXJndW1lbnRzWzFdO1xuXG4gICAgICB2YXIgZGVmYXVsdHMgPSB7XG4gICAgICAgIG9mZnNldDogJzAgMCcsXG4gICAgICAgIHRhcmdldE9mZnNldDogJzAgMCcsXG4gICAgICAgIHRhcmdldEF0dGFjaG1lbnQ6ICdhdXRvIGF1dG8nLFxuICAgICAgICBjbGFzc1ByZWZpeDogJ3RldGhlcidcbiAgICAgIH07XG5cbiAgICAgIHRoaXMub3B0aW9ucyA9IGV4dGVuZChkZWZhdWx0cywgb3B0aW9ucyk7XG5cbiAgICAgIHZhciBfb3B0aW9ucyA9IHRoaXMub3B0aW9ucztcbiAgICAgIHZhciBlbGVtZW50ID0gX29wdGlvbnMuZWxlbWVudDtcbiAgICAgIHZhciB0YXJnZXQgPSBfb3B0aW9ucy50YXJnZXQ7XG4gICAgICB2YXIgdGFyZ2V0TW9kaWZpZXIgPSBfb3B0aW9ucy50YXJnZXRNb2RpZmllcjtcblxuICAgICAgdGhpcy5lbGVtZW50ID0gZWxlbWVudDtcbiAgICAgIHRoaXMudGFyZ2V0ID0gdGFyZ2V0O1xuICAgICAgdGhpcy50YXJnZXRNb2RpZmllciA9IHRhcmdldE1vZGlmaWVyO1xuXG4gICAgICBpZiAodGhpcy50YXJnZXQgPT09ICd2aWV3cG9ydCcpIHtcbiAgICAgICAgdGhpcy50YXJnZXQgPSBkb2N1bWVudC5ib2R5O1xuICAgICAgICB0aGlzLnRhcmdldE1vZGlmaWVyID0gJ3Zpc2libGUnO1xuICAgICAgfSBlbHNlIGlmICh0aGlzLnRhcmdldCA9PT0gJ3Njcm9sbC1oYW5kbGUnKSB7XG4gICAgICAgIHRoaXMudGFyZ2V0ID0gZG9jdW1lbnQuYm9keTtcbiAgICAgICAgdGhpcy50YXJnZXRNb2RpZmllciA9ICdzY3JvbGwtaGFuZGxlJztcbiAgICAgIH1cblxuICAgICAgWydlbGVtZW50JywgJ3RhcmdldCddLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgICAgICBpZiAodHlwZW9mIF90aGlzMltrZXldID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVGV0aGVyIEVycm9yOiBCb3RoIGVsZW1lbnQgYW5kIHRhcmdldCBtdXN0IGJlIGRlZmluZWQnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2YgX3RoaXMyW2tleV0uanF1ZXJ5ICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgIF90aGlzMltrZXldID0gX3RoaXMyW2tleV1bMF07XG4gICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIF90aGlzMltrZXldID09PSAnc3RyaW5nJykge1xuICAgICAgICAgIF90aGlzMltrZXldID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcihfdGhpczJba2V5XSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuXG4gICAgICBhZGRDbGFzcyh0aGlzLmVsZW1lbnQsIHRoaXMuZ2V0Q2xhc3MoJ2VsZW1lbnQnKSk7XG4gICAgICBpZiAoISh0aGlzLm9wdGlvbnMuYWRkVGFyZ2V0Q2xhc3NlcyA9PT0gZmFsc2UpKSB7XG4gICAgICAgIGFkZENsYXNzKHRoaXMudGFyZ2V0LCB0aGlzLmdldENsYXNzKCd0YXJnZXQnKSk7XG4gICAgICB9XG5cbiAgICAgIGlmICghdGhpcy5vcHRpb25zLmF0dGFjaG1lbnQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdUZXRoZXIgRXJyb3I6IFlvdSBtdXN0IHByb3ZpZGUgYW4gYXR0YWNobWVudCcpO1xuICAgICAgfVxuXG4gICAgICB0aGlzLnRhcmdldEF0dGFjaG1lbnQgPSBwYXJzZUF0dGFjaG1lbnQodGhpcy5vcHRpb25zLnRhcmdldEF0dGFjaG1lbnQpO1xuICAgICAgdGhpcy5hdHRhY2htZW50ID0gcGFyc2VBdHRhY2htZW50KHRoaXMub3B0aW9ucy5hdHRhY2htZW50KTtcbiAgICAgIHRoaXMub2Zmc2V0ID0gcGFyc2VPZmZzZXQodGhpcy5vcHRpb25zLm9mZnNldCk7XG4gICAgICB0aGlzLnRhcmdldE9mZnNldCA9IHBhcnNlT2Zmc2V0KHRoaXMub3B0aW9ucy50YXJnZXRPZmZzZXQpO1xuXG4gICAgICBpZiAodHlwZW9mIHRoaXMuc2Nyb2xsUGFyZW50cyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgdGhpcy5kaXNhYmxlKCk7XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLnRhcmdldE1vZGlmaWVyID09PSAnc2Nyb2xsLWhhbmRsZScpIHtcbiAgICAgICAgdGhpcy5zY3JvbGxQYXJlbnRzID0gW3RoaXMudGFyZ2V0XTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuc2Nyb2xsUGFyZW50cyA9IGdldFNjcm9sbFBhcmVudHModGhpcy50YXJnZXQpO1xuICAgICAgfVxuXG4gICAgICBpZiAoISh0aGlzLm9wdGlvbnMuZW5hYmxlZCA9PT0gZmFsc2UpKSB7XG4gICAgICAgIHRoaXMuZW5hYmxlKHBvcyk7XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnZ2V0VGFyZ2V0Qm91bmRzJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0VGFyZ2V0Qm91bmRzKCkge1xuICAgICAgaWYgKHR5cGVvZiB0aGlzLnRhcmdldE1vZGlmaWVyICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICBpZiAodGhpcy50YXJnZXRNb2RpZmllciA9PT0gJ3Zpc2libGUnKSB7XG4gICAgICAgICAgaWYgKHRoaXMudGFyZ2V0ID09PSBkb2N1bWVudC5ib2R5KSB7XG4gICAgICAgICAgICByZXR1cm4geyB0b3A6IHBhZ2VZT2Zmc2V0LCBsZWZ0OiBwYWdlWE9mZnNldCwgaGVpZ2h0OiBpbm5lckhlaWdodCwgd2lkdGg6IGlubmVyV2lkdGggfTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdmFyIGJvdW5kcyA9IGdldEJvdW5kcyh0aGlzLnRhcmdldCk7XG5cbiAgICAgICAgICAgIHZhciBvdXQgPSB7XG4gICAgICAgICAgICAgIGhlaWdodDogYm91bmRzLmhlaWdodCxcbiAgICAgICAgICAgICAgd2lkdGg6IGJvdW5kcy53aWR0aCxcbiAgICAgICAgICAgICAgdG9wOiBib3VuZHMudG9wLFxuICAgICAgICAgICAgICBsZWZ0OiBib3VuZHMubGVmdFxuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgb3V0LmhlaWdodCA9IE1hdGgubWluKG91dC5oZWlnaHQsIGJvdW5kcy5oZWlnaHQgLSAocGFnZVlPZmZzZXQgLSBib3VuZHMudG9wKSk7XG4gICAgICAgICAgICBvdXQuaGVpZ2h0ID0gTWF0aC5taW4ob3V0LmhlaWdodCwgYm91bmRzLmhlaWdodCAtIChib3VuZHMudG9wICsgYm91bmRzLmhlaWdodCAtIChwYWdlWU9mZnNldCArIGlubmVySGVpZ2h0KSkpO1xuICAgICAgICAgICAgb3V0LmhlaWdodCA9IE1hdGgubWluKGlubmVySGVpZ2h0LCBvdXQuaGVpZ2h0KTtcbiAgICAgICAgICAgIG91dC5oZWlnaHQgLT0gMjtcblxuICAgICAgICAgICAgb3V0LndpZHRoID0gTWF0aC5taW4ob3V0LndpZHRoLCBib3VuZHMud2lkdGggLSAocGFnZVhPZmZzZXQgLSBib3VuZHMubGVmdCkpO1xuICAgICAgICAgICAgb3V0LndpZHRoID0gTWF0aC5taW4ob3V0LndpZHRoLCBib3VuZHMud2lkdGggLSAoYm91bmRzLmxlZnQgKyBib3VuZHMud2lkdGggLSAocGFnZVhPZmZzZXQgKyBpbm5lcldpZHRoKSkpO1xuICAgICAgICAgICAgb3V0LndpZHRoID0gTWF0aC5taW4oaW5uZXJXaWR0aCwgb3V0LndpZHRoKTtcbiAgICAgICAgICAgIG91dC53aWR0aCAtPSAyO1xuXG4gICAgICAgICAgICBpZiAob3V0LnRvcCA8IHBhZ2VZT2Zmc2V0KSB7XG4gICAgICAgICAgICAgIG91dC50b3AgPSBwYWdlWU9mZnNldDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChvdXQubGVmdCA8IHBhZ2VYT2Zmc2V0KSB7XG4gICAgICAgICAgICAgIG91dC5sZWZ0ID0gcGFnZVhPZmZzZXQ7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBvdXQ7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKHRoaXMudGFyZ2V0TW9kaWZpZXIgPT09ICdzY3JvbGwtaGFuZGxlJykge1xuICAgICAgICAgIHZhciBib3VuZHMgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgdmFyIHRhcmdldCA9IHRoaXMudGFyZ2V0O1xuICAgICAgICAgIGlmICh0YXJnZXQgPT09IGRvY3VtZW50LmJvZHkpIHtcbiAgICAgICAgICAgIHRhcmdldCA9IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudDtcblxuICAgICAgICAgICAgYm91bmRzID0ge1xuICAgICAgICAgICAgICBsZWZ0OiBwYWdlWE9mZnNldCxcbiAgICAgICAgICAgICAgdG9wOiBwYWdlWU9mZnNldCxcbiAgICAgICAgICAgICAgaGVpZ2h0OiBpbm5lckhlaWdodCxcbiAgICAgICAgICAgICAgd2lkdGg6IGlubmVyV2lkdGhcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGJvdW5kcyA9IGdldEJvdW5kcyh0YXJnZXQpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHZhciBzdHlsZSA9IGdldENvbXB1dGVkU3R5bGUodGFyZ2V0KTtcblxuICAgICAgICAgIHZhciBoYXNCb3R0b21TY3JvbGwgPSB0YXJnZXQuc2Nyb2xsV2lkdGggPiB0YXJnZXQuY2xpZW50V2lkdGggfHwgW3N0eWxlLm92ZXJmbG93LCBzdHlsZS5vdmVyZmxvd1hdLmluZGV4T2YoJ3Njcm9sbCcpID49IDAgfHwgdGhpcy50YXJnZXQgIT09IGRvY3VtZW50LmJvZHk7XG5cbiAgICAgICAgICB2YXIgc2Nyb2xsQm90dG9tID0gMDtcbiAgICAgICAgICBpZiAoaGFzQm90dG9tU2Nyb2xsKSB7XG4gICAgICAgICAgICBzY3JvbGxCb3R0b20gPSAxNTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB2YXIgaGVpZ2h0ID0gYm91bmRzLmhlaWdodCAtIHBhcnNlRmxvYXQoc3R5bGUuYm9yZGVyVG9wV2lkdGgpIC0gcGFyc2VGbG9hdChzdHlsZS5ib3JkZXJCb3R0b21XaWR0aCkgLSBzY3JvbGxCb3R0b207XG5cbiAgICAgICAgICB2YXIgb3V0ID0ge1xuICAgICAgICAgICAgd2lkdGg6IDE1LFxuICAgICAgICAgICAgaGVpZ2h0OiBoZWlnaHQgKiAwLjk3NSAqIChoZWlnaHQgLyB0YXJnZXQuc2Nyb2xsSGVpZ2h0KSxcbiAgICAgICAgICAgIGxlZnQ6IGJvdW5kcy5sZWZ0ICsgYm91bmRzLndpZHRoIC0gcGFyc2VGbG9hdChzdHlsZS5ib3JkZXJMZWZ0V2lkdGgpIC0gMTVcbiAgICAgICAgICB9O1xuXG4gICAgICAgICAgdmFyIGZpdEFkaiA9IDA7XG4gICAgICAgICAgaWYgKGhlaWdodCA8IDQwOCAmJiB0aGlzLnRhcmdldCA9PT0gZG9jdW1lbnQuYm9keSkge1xuICAgICAgICAgICAgZml0QWRqID0gLTAuMDAwMTEgKiBNYXRoLnBvdyhoZWlnaHQsIDIpIC0gMC4wMDcyNyAqIGhlaWdodCArIDIyLjU4O1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmICh0aGlzLnRhcmdldCAhPT0gZG9jdW1lbnQuYm9keSkge1xuICAgICAgICAgICAgb3V0LmhlaWdodCA9IE1hdGgubWF4KG91dC5oZWlnaHQsIDI0KTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB2YXIgc2Nyb2xsUGVyY2VudGFnZSA9IHRoaXMudGFyZ2V0LnNjcm9sbFRvcCAvICh0YXJnZXQuc2Nyb2xsSGVpZ2h0IC0gaGVpZ2h0KTtcbiAgICAgICAgICBvdXQudG9wID0gc2Nyb2xsUGVyY2VudGFnZSAqIChoZWlnaHQgLSBvdXQuaGVpZ2h0IC0gZml0QWRqKSArIGJvdW5kcy50b3AgKyBwYXJzZUZsb2F0KHN0eWxlLmJvcmRlclRvcFdpZHRoKTtcblxuICAgICAgICAgIGlmICh0aGlzLnRhcmdldCA9PT0gZG9jdW1lbnQuYm9keSkge1xuICAgICAgICAgICAgb3V0LmhlaWdodCA9IE1hdGgubWF4KG91dC5oZWlnaHQsIDI0KTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm4gb3V0O1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gZ2V0Qm91bmRzKHRoaXMudGFyZ2V0KTtcbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdjbGVhckNhY2hlJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gY2xlYXJDYWNoZSgpIHtcbiAgICAgIHRoaXMuX2NhY2hlID0ge307XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnY2FjaGUnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjYWNoZShrLCBnZXR0ZXIpIHtcbiAgICAgIC8vIE1vcmUgdGhhbiBvbmUgbW9kdWxlIHdpbGwgb2Z0ZW4gbmVlZCB0aGUgc2FtZSBET00gaW5mbywgc29cbiAgICAgIC8vIHdlIGtlZXAgYSBjYWNoZSB3aGljaCBpcyBjbGVhcmVkIG9uIGVhY2ggcG9zaXRpb24gY2FsbFxuICAgICAgaWYgKHR5cGVvZiB0aGlzLl9jYWNoZSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgdGhpcy5fY2FjaGUgPSB7fTtcbiAgICAgIH1cblxuICAgICAgaWYgKHR5cGVvZiB0aGlzLl9jYWNoZVtrXSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgdGhpcy5fY2FjaGVba10gPSBnZXR0ZXIuY2FsbCh0aGlzKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXMuX2NhY2hlW2tdO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ2VuYWJsZScsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGVuYWJsZSgpIHtcbiAgICAgIHZhciBfdGhpczMgPSB0aGlzO1xuXG4gICAgICB2YXIgcG9zID0gYXJndW1lbnRzLmxlbmd0aCA8PSAwIHx8IGFyZ3VtZW50c1swXSA9PT0gdW5kZWZpbmVkID8gdHJ1ZSA6IGFyZ3VtZW50c1swXTtcblxuICAgICAgaWYgKCEodGhpcy5vcHRpb25zLmFkZFRhcmdldENsYXNzZXMgPT09IGZhbHNlKSkge1xuICAgICAgICBhZGRDbGFzcyh0aGlzLnRhcmdldCwgdGhpcy5nZXRDbGFzcygnZW5hYmxlZCcpKTtcbiAgICAgIH1cbiAgICAgIGFkZENsYXNzKHRoaXMuZWxlbWVudCwgdGhpcy5nZXRDbGFzcygnZW5hYmxlZCcpKTtcbiAgICAgIHRoaXMuZW5hYmxlZCA9IHRydWU7XG5cbiAgICAgIHRoaXMuc2Nyb2xsUGFyZW50cy5mb3JFYWNoKGZ1bmN0aW9uIChwYXJlbnQpIHtcbiAgICAgICAgaWYgKHBhcmVudCAhPT0gX3RoaXMzLnRhcmdldC5vd25lckRvY3VtZW50KSB7XG4gICAgICAgICAgcGFyZW50LmFkZEV2ZW50TGlzdGVuZXIoJ3Njcm9sbCcsIF90aGlzMy5wb3NpdGlvbik7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuXG4gICAgICBpZiAocG9zKSB7XG4gICAgICAgIHRoaXMucG9zaXRpb24oKTtcbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdkaXNhYmxlJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gZGlzYWJsZSgpIHtcbiAgICAgIHZhciBfdGhpczQgPSB0aGlzO1xuXG4gICAgICByZW1vdmVDbGFzcyh0aGlzLnRhcmdldCwgdGhpcy5nZXRDbGFzcygnZW5hYmxlZCcpKTtcbiAgICAgIHJlbW92ZUNsYXNzKHRoaXMuZWxlbWVudCwgdGhpcy5nZXRDbGFzcygnZW5hYmxlZCcpKTtcbiAgICAgIHRoaXMuZW5hYmxlZCA9IGZhbHNlO1xuXG4gICAgICBpZiAodHlwZW9mIHRoaXMuc2Nyb2xsUGFyZW50cyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgdGhpcy5zY3JvbGxQYXJlbnRzLmZvckVhY2goZnVuY3Rpb24gKHBhcmVudCkge1xuICAgICAgICAgIHBhcmVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdzY3JvbGwnLCBfdGhpczQucG9zaXRpb24pO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdkZXN0cm95JyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gZGVzdHJveSgpIHtcbiAgICAgIHZhciBfdGhpczUgPSB0aGlzO1xuXG4gICAgICB0aGlzLmRpc2FibGUoKTtcblxuICAgICAgdGV0aGVycy5mb3JFYWNoKGZ1bmN0aW9uICh0ZXRoZXIsIGkpIHtcbiAgICAgICAgaWYgKHRldGhlciA9PT0gX3RoaXM1KSB7XG4gICAgICAgICAgdGV0aGVycy5zcGxpY2UoaSwgMSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuXG4gICAgICAvLyBSZW1vdmUgYW55IGVsZW1lbnRzIHdlIHdlcmUgdXNpbmcgZm9yIGNvbnZlbmllbmNlIGZyb20gdGhlIERPTVxuICAgICAgaWYgKHRldGhlcnMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHJlbW92ZVV0aWxFbGVtZW50cygpO1xuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ3VwZGF0ZUF0dGFjaENsYXNzZXMnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB1cGRhdGVBdHRhY2hDbGFzc2VzKGVsZW1lbnRBdHRhY2gsIHRhcmdldEF0dGFjaCkge1xuICAgICAgdmFyIF90aGlzNiA9IHRoaXM7XG5cbiAgICAgIGVsZW1lbnRBdHRhY2ggPSBlbGVtZW50QXR0YWNoIHx8IHRoaXMuYXR0YWNobWVudDtcbiAgICAgIHRhcmdldEF0dGFjaCA9IHRhcmdldEF0dGFjaCB8fCB0aGlzLnRhcmdldEF0dGFjaG1lbnQ7XG4gICAgICB2YXIgc2lkZXMgPSBbJ2xlZnQnLCAndG9wJywgJ2JvdHRvbScsICdyaWdodCcsICdtaWRkbGUnLCAnY2VudGVyJ107XG5cbiAgICAgIGlmICh0eXBlb2YgdGhpcy5fYWRkQXR0YWNoQ2xhc3NlcyAhPT0gJ3VuZGVmaW5lZCcgJiYgdGhpcy5fYWRkQXR0YWNoQ2xhc3Nlcy5sZW5ndGgpIHtcbiAgICAgICAgLy8gdXBkYXRlQXR0YWNoQ2xhc3NlcyBjYW4gYmUgY2FsbGVkIG1vcmUgdGhhbiBvbmNlIGluIGEgcG9zaXRpb24gY2FsbCwgc29cbiAgICAgICAgLy8gd2UgbmVlZCB0byBjbGVhbiB1cCBhZnRlciBvdXJzZWx2ZXMgc3VjaCB0aGF0IHdoZW4gdGhlIGxhc3QgZGVmZXIgZ2V0c1xuICAgICAgICAvLyByYW4gaXQgZG9lc24ndCBhZGQgYW55IGV4dHJhIGNsYXNzZXMgZnJvbSBwcmV2aW91cyBjYWxscy5cbiAgICAgICAgdGhpcy5fYWRkQXR0YWNoQ2xhc3Nlcy5zcGxpY2UoMCwgdGhpcy5fYWRkQXR0YWNoQ2xhc3Nlcy5sZW5ndGgpO1xuICAgICAgfVxuXG4gICAgICBpZiAodHlwZW9mIHRoaXMuX2FkZEF0dGFjaENsYXNzZXMgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIHRoaXMuX2FkZEF0dGFjaENsYXNzZXMgPSBbXTtcbiAgICAgIH1cbiAgICAgIHZhciBhZGQgPSB0aGlzLl9hZGRBdHRhY2hDbGFzc2VzO1xuXG4gICAgICBpZiAoZWxlbWVudEF0dGFjaC50b3ApIHtcbiAgICAgICAgYWRkLnB1c2godGhpcy5nZXRDbGFzcygnZWxlbWVudC1hdHRhY2hlZCcpICsgJy0nICsgZWxlbWVudEF0dGFjaC50b3ApO1xuICAgICAgfVxuICAgICAgaWYgKGVsZW1lbnRBdHRhY2gubGVmdCkge1xuICAgICAgICBhZGQucHVzaCh0aGlzLmdldENsYXNzKCdlbGVtZW50LWF0dGFjaGVkJykgKyAnLScgKyBlbGVtZW50QXR0YWNoLmxlZnQpO1xuICAgICAgfVxuICAgICAgaWYgKHRhcmdldEF0dGFjaC50b3ApIHtcbiAgICAgICAgYWRkLnB1c2godGhpcy5nZXRDbGFzcygndGFyZ2V0LWF0dGFjaGVkJykgKyAnLScgKyB0YXJnZXRBdHRhY2gudG9wKTtcbiAgICAgIH1cbiAgICAgIGlmICh0YXJnZXRBdHRhY2gubGVmdCkge1xuICAgICAgICBhZGQucHVzaCh0aGlzLmdldENsYXNzKCd0YXJnZXQtYXR0YWNoZWQnKSArICctJyArIHRhcmdldEF0dGFjaC5sZWZ0KTtcbiAgICAgIH1cblxuICAgICAgdmFyIGFsbCA9IFtdO1xuICAgICAgc2lkZXMuZm9yRWFjaChmdW5jdGlvbiAoc2lkZSkge1xuICAgICAgICBhbGwucHVzaChfdGhpczYuZ2V0Q2xhc3MoJ2VsZW1lbnQtYXR0YWNoZWQnKSArICctJyArIHNpZGUpO1xuICAgICAgICBhbGwucHVzaChfdGhpczYuZ2V0Q2xhc3MoJ3RhcmdldC1hdHRhY2hlZCcpICsgJy0nICsgc2lkZSk7XG4gICAgICB9KTtcblxuICAgICAgZGVmZXIoZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoISh0eXBlb2YgX3RoaXM2Ll9hZGRBdHRhY2hDbGFzc2VzICE9PSAndW5kZWZpbmVkJykpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB1cGRhdGVDbGFzc2VzKF90aGlzNi5lbGVtZW50LCBfdGhpczYuX2FkZEF0dGFjaENsYXNzZXMsIGFsbCk7XG4gICAgICAgIGlmICghKF90aGlzNi5vcHRpb25zLmFkZFRhcmdldENsYXNzZXMgPT09IGZhbHNlKSkge1xuICAgICAgICAgIHVwZGF0ZUNsYXNzZXMoX3RoaXM2LnRhcmdldCwgX3RoaXM2Ll9hZGRBdHRhY2hDbGFzc2VzLCBhbGwpO1xuICAgICAgICB9XG5cbiAgICAgICAgZGVsZXRlIF90aGlzNi5fYWRkQXR0YWNoQ2xhc3NlcztcbiAgICAgIH0pO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ3Bvc2l0aW9uJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gcG9zaXRpb24oKSB7XG4gICAgICB2YXIgX3RoaXM3ID0gdGhpcztcblxuICAgICAgdmFyIGZsdXNoQ2hhbmdlcyA9IGFyZ3VtZW50cy5sZW5ndGggPD0gMCB8fCBhcmd1bWVudHNbMF0gPT09IHVuZGVmaW5lZCA/IHRydWUgOiBhcmd1bWVudHNbMF07XG5cbiAgICAgIC8vIGZsdXNoQ2hhbmdlcyBjb21taXRzIHRoZSBjaGFuZ2VzIGltbWVkaWF0ZWx5LCBsZWF2ZSB0cnVlIHVubGVzcyB5b3UgYXJlIHBvc2l0aW9uaW5nIG11bHRpcGxlXG4gICAgICAvLyB0ZXRoZXJzIChpbiB3aGljaCBjYXNlIGNhbGwgVGV0aGVyLlV0aWxzLmZsdXNoIHlvdXJzZWxmIHdoZW4geW91J3JlIGRvbmUpXG5cbiAgICAgIGlmICghdGhpcy5lbmFibGVkKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgdGhpcy5jbGVhckNhY2hlKCk7XG5cbiAgICAgIC8vIFR1cm4gJ2F1dG8nIGF0dGFjaG1lbnRzIGludG8gdGhlIGFwcHJvcHJpYXRlIGNvcm5lciBvciBlZGdlXG4gICAgICB2YXIgdGFyZ2V0QXR0YWNobWVudCA9IGF1dG9Ub0ZpeGVkQXR0YWNobWVudCh0aGlzLnRhcmdldEF0dGFjaG1lbnQsIHRoaXMuYXR0YWNobWVudCk7XG5cbiAgICAgIHRoaXMudXBkYXRlQXR0YWNoQ2xhc3Nlcyh0aGlzLmF0dGFjaG1lbnQsIHRhcmdldEF0dGFjaG1lbnQpO1xuXG4gICAgICB2YXIgZWxlbWVudFBvcyA9IHRoaXMuY2FjaGUoJ2VsZW1lbnQtYm91bmRzJywgZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gZ2V0Qm91bmRzKF90aGlzNy5lbGVtZW50KTtcbiAgICAgIH0pO1xuXG4gICAgICB2YXIgd2lkdGggPSBlbGVtZW50UG9zLndpZHRoO1xuICAgICAgdmFyIGhlaWdodCA9IGVsZW1lbnRQb3MuaGVpZ2h0O1xuXG4gICAgICBpZiAod2lkdGggPT09IDAgJiYgaGVpZ2h0ID09PSAwICYmIHR5cGVvZiB0aGlzLmxhc3RTaXplICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICB2YXIgX2xhc3RTaXplID0gdGhpcy5sYXN0U2l6ZTtcblxuICAgICAgICAvLyBXZSBjYWNoZSB0aGUgaGVpZ2h0IGFuZCB3aWR0aCB0byBtYWtlIGl0IHBvc3NpYmxlIHRvIHBvc2l0aW9uIGVsZW1lbnRzIHRoYXQgYXJlXG4gICAgICAgIC8vIGdldHRpbmcgaGlkZGVuLlxuICAgICAgICB3aWR0aCA9IF9sYXN0U2l6ZS53aWR0aDtcbiAgICAgICAgaGVpZ2h0ID0gX2xhc3RTaXplLmhlaWdodDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMubGFzdFNpemUgPSB7IHdpZHRoOiB3aWR0aCwgaGVpZ2h0OiBoZWlnaHQgfTtcbiAgICAgIH1cblxuICAgICAgdmFyIHRhcmdldFBvcyA9IHRoaXMuY2FjaGUoJ3RhcmdldC1ib3VuZHMnLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBfdGhpczcuZ2V0VGFyZ2V0Qm91bmRzKCk7XG4gICAgICB9KTtcbiAgICAgIHZhciB0YXJnZXRTaXplID0gdGFyZ2V0UG9zO1xuXG4gICAgICAvLyBHZXQgYW4gYWN0dWFsIHB4IG9mZnNldCBmcm9tIHRoZSBhdHRhY2htZW50XG4gICAgICB2YXIgb2Zmc2V0ID0gb2Zmc2V0VG9QeChhdHRhY2htZW50VG9PZmZzZXQodGhpcy5hdHRhY2htZW50KSwgeyB3aWR0aDogd2lkdGgsIGhlaWdodDogaGVpZ2h0IH0pO1xuICAgICAgdmFyIHRhcmdldE9mZnNldCA9IG9mZnNldFRvUHgoYXR0YWNobWVudFRvT2Zmc2V0KHRhcmdldEF0dGFjaG1lbnQpLCB0YXJnZXRTaXplKTtcblxuICAgICAgdmFyIG1hbnVhbE9mZnNldCA9IG9mZnNldFRvUHgodGhpcy5vZmZzZXQsIHsgd2lkdGg6IHdpZHRoLCBoZWlnaHQ6IGhlaWdodCB9KTtcbiAgICAgIHZhciBtYW51YWxUYXJnZXRPZmZzZXQgPSBvZmZzZXRUb1B4KHRoaXMudGFyZ2V0T2Zmc2V0LCB0YXJnZXRTaXplKTtcblxuICAgICAgLy8gQWRkIHRoZSBtYW51YWxseSBwcm92aWRlZCBvZmZzZXRcbiAgICAgIG9mZnNldCA9IGFkZE9mZnNldChvZmZzZXQsIG1hbnVhbE9mZnNldCk7XG4gICAgICB0YXJnZXRPZmZzZXQgPSBhZGRPZmZzZXQodGFyZ2V0T2Zmc2V0LCBtYW51YWxUYXJnZXRPZmZzZXQpO1xuXG4gICAgICAvLyBJdCdzIG5vdyBvdXIgZ29hbCB0byBtYWtlIChlbGVtZW50IHBvc2l0aW9uICsgb2Zmc2V0KSA9PSAodGFyZ2V0IHBvc2l0aW9uICsgdGFyZ2V0IG9mZnNldClcbiAgICAgIHZhciBsZWZ0ID0gdGFyZ2V0UG9zLmxlZnQgKyB0YXJnZXRPZmZzZXQubGVmdCAtIG9mZnNldC5sZWZ0O1xuICAgICAgdmFyIHRvcCA9IHRhcmdldFBvcy50b3AgKyB0YXJnZXRPZmZzZXQudG9wIC0gb2Zmc2V0LnRvcDtcblxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBUZXRoZXJCYXNlLm1vZHVsZXMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgdmFyIF9tb2R1bGUyID0gVGV0aGVyQmFzZS5tb2R1bGVzW2ldO1xuICAgICAgICB2YXIgcmV0ID0gX21vZHVsZTIucG9zaXRpb24uY2FsbCh0aGlzLCB7XG4gICAgICAgICAgbGVmdDogbGVmdCxcbiAgICAgICAgICB0b3A6IHRvcCxcbiAgICAgICAgICB0YXJnZXRBdHRhY2htZW50OiB0YXJnZXRBdHRhY2htZW50LFxuICAgICAgICAgIHRhcmdldFBvczogdGFyZ2V0UG9zLFxuICAgICAgICAgIGVsZW1lbnRQb3M6IGVsZW1lbnRQb3MsXG4gICAgICAgICAgb2Zmc2V0OiBvZmZzZXQsXG4gICAgICAgICAgdGFyZ2V0T2Zmc2V0OiB0YXJnZXRPZmZzZXQsXG4gICAgICAgICAgbWFudWFsT2Zmc2V0OiBtYW51YWxPZmZzZXQsXG4gICAgICAgICAgbWFudWFsVGFyZ2V0T2Zmc2V0OiBtYW51YWxUYXJnZXRPZmZzZXQsXG4gICAgICAgICAgc2Nyb2xsYmFyU2l6ZTogc2Nyb2xsYmFyU2l6ZSxcbiAgICAgICAgICBhdHRhY2htZW50OiB0aGlzLmF0dGFjaG1lbnRcbiAgICAgICAgfSk7XG5cbiAgICAgICAgaWYgKHJldCA9PT0gZmFsc2UpIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIHJldCA9PT0gJ3VuZGVmaW5lZCcgfHwgdHlwZW9mIHJldCAhPT0gJ29iamVjdCcpIHtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0b3AgPSByZXQudG9wO1xuICAgICAgICAgIGxlZnQgPSByZXQubGVmdDtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBXZSBkZXNjcmliZSB0aGUgcG9zaXRpb24gdGhyZWUgZGlmZmVyZW50IHdheXMgdG8gZ2l2ZSB0aGUgb3B0aW1pemVyXG4gICAgICAvLyBhIGNoYW5jZSB0byBkZWNpZGUgdGhlIGJlc3QgcG9zc2libGUgd2F5IHRvIHBvc2l0aW9uIHRoZSBlbGVtZW50XG4gICAgICAvLyB3aXRoIHRoZSBmZXdlc3QgcmVwYWludHMuXG4gICAgICB2YXIgbmV4dCA9IHtcbiAgICAgICAgLy8gSXQncyBwb3NpdGlvbiByZWxhdGl2ZSB0byB0aGUgcGFnZSAoYWJzb2x1dGUgcG9zaXRpb25pbmcgd2hlblxuICAgICAgICAvLyB0aGUgZWxlbWVudCBpcyBhIGNoaWxkIG9mIHRoZSBib2R5KVxuICAgICAgICBwYWdlOiB7XG4gICAgICAgICAgdG9wOiB0b3AsXG4gICAgICAgICAgbGVmdDogbGVmdFxuICAgICAgICB9LFxuXG4gICAgICAgIC8vIEl0J3MgcG9zaXRpb24gcmVsYXRpdmUgdG8gdGhlIHZpZXdwb3J0IChmaXhlZCBwb3NpdGlvbmluZylcbiAgICAgICAgdmlld3BvcnQ6IHtcbiAgICAgICAgICB0b3A6IHRvcCAtIHBhZ2VZT2Zmc2V0LFxuICAgICAgICAgIGJvdHRvbTogcGFnZVlPZmZzZXQgLSB0b3AgLSBoZWlnaHQgKyBpbm5lckhlaWdodCxcbiAgICAgICAgICBsZWZ0OiBsZWZ0IC0gcGFnZVhPZmZzZXQsXG4gICAgICAgICAgcmlnaHQ6IHBhZ2VYT2Zmc2V0IC0gbGVmdCAtIHdpZHRoICsgaW5uZXJXaWR0aFxuICAgICAgICB9XG4gICAgICB9O1xuXG4gICAgICB2YXIgZG9jID0gdGhpcy50YXJnZXQub3duZXJEb2N1bWVudDtcbiAgICAgIHZhciB3aW4gPSBkb2MuZGVmYXVsdFZpZXc7XG5cbiAgICAgIHZhciBzY3JvbGxiYXJTaXplID0gdW5kZWZpbmVkO1xuICAgICAgaWYgKHdpbi5pbm5lckhlaWdodCA+IGRvYy5kb2N1bWVudEVsZW1lbnQuY2xpZW50SGVpZ2h0KSB7XG4gICAgICAgIHNjcm9sbGJhclNpemUgPSB0aGlzLmNhY2hlKCdzY3JvbGxiYXItc2l6ZScsIGdldFNjcm9sbEJhclNpemUpO1xuICAgICAgICBuZXh0LnZpZXdwb3J0LmJvdHRvbSAtPSBzY3JvbGxiYXJTaXplLmhlaWdodDtcbiAgICAgIH1cblxuICAgICAgaWYgKHdpbi5pbm5lcldpZHRoID4gZG9jLmRvY3VtZW50RWxlbWVudC5jbGllbnRXaWR0aCkge1xuICAgICAgICBzY3JvbGxiYXJTaXplID0gdGhpcy5jYWNoZSgnc2Nyb2xsYmFyLXNpemUnLCBnZXRTY3JvbGxCYXJTaXplKTtcbiAgICAgICAgbmV4dC52aWV3cG9ydC5yaWdodCAtPSBzY3JvbGxiYXJTaXplLndpZHRoO1xuICAgICAgfVxuXG4gICAgICBpZiAoWycnLCAnc3RhdGljJ10uaW5kZXhPZihkb2MuYm9keS5zdHlsZS5wb3NpdGlvbikgPT09IC0xIHx8IFsnJywgJ3N0YXRpYyddLmluZGV4T2YoZG9jLmJvZHkucGFyZW50RWxlbWVudC5zdHlsZS5wb3NpdGlvbikgPT09IC0xKSB7XG4gICAgICAgIC8vIEFic29sdXRlIHBvc2l0aW9uaW5nIGluIHRoZSBib2R5IHdpbGwgYmUgcmVsYXRpdmUgdG8gdGhlIHBhZ2UsIG5vdCB0aGUgJ2luaXRpYWwgY29udGFpbmluZyBibG9jaydcbiAgICAgICAgbmV4dC5wYWdlLmJvdHRvbSA9IGRvYy5ib2R5LnNjcm9sbEhlaWdodCAtIHRvcCAtIGhlaWdodDtcbiAgICAgICAgbmV4dC5wYWdlLnJpZ2h0ID0gZG9jLmJvZHkuc2Nyb2xsV2lkdGggLSBsZWZ0IC0gd2lkdGg7XG4gICAgICB9XG5cbiAgICAgIGlmICh0eXBlb2YgdGhpcy5vcHRpb25zLm9wdGltaXphdGlvbnMgIT09ICd1bmRlZmluZWQnICYmIHRoaXMub3B0aW9ucy5vcHRpbWl6YXRpb25zLm1vdmVFbGVtZW50ICE9PSBmYWxzZSAmJiAhKHR5cGVvZiB0aGlzLnRhcmdldE1vZGlmaWVyICE9PSAndW5kZWZpbmVkJykpIHtcbiAgICAgICAgKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICB2YXIgb2Zmc2V0UGFyZW50ID0gX3RoaXM3LmNhY2hlKCd0YXJnZXQtb2Zmc2V0cGFyZW50JywgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIGdldE9mZnNldFBhcmVudChfdGhpczcudGFyZ2V0KTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgICB2YXIgb2Zmc2V0UG9zaXRpb24gPSBfdGhpczcuY2FjaGUoJ3RhcmdldC1vZmZzZXRwYXJlbnQtYm91bmRzJywgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIGdldEJvdW5kcyhvZmZzZXRQYXJlbnQpO1xuICAgICAgICAgIH0pO1xuICAgICAgICAgIHZhciBvZmZzZXRQYXJlbnRTdHlsZSA9IGdldENvbXB1dGVkU3R5bGUob2Zmc2V0UGFyZW50KTtcbiAgICAgICAgICB2YXIgb2Zmc2V0UGFyZW50U2l6ZSA9IG9mZnNldFBvc2l0aW9uO1xuXG4gICAgICAgICAgdmFyIG9mZnNldEJvcmRlciA9IHt9O1xuICAgICAgICAgIFsnVG9wJywgJ0xlZnQnLCAnQm90dG9tJywgJ1JpZ2h0J10uZm9yRWFjaChmdW5jdGlvbiAoc2lkZSkge1xuICAgICAgICAgICAgb2Zmc2V0Qm9yZGVyW3NpZGUudG9Mb3dlckNhc2UoKV0gPSBwYXJzZUZsb2F0KG9mZnNldFBhcmVudFN0eWxlWydib3JkZXInICsgc2lkZSArICdXaWR0aCddKTtcbiAgICAgICAgICB9KTtcblxuICAgICAgICAgIG9mZnNldFBvc2l0aW9uLnJpZ2h0ID0gZG9jLmJvZHkuc2Nyb2xsV2lkdGggLSBvZmZzZXRQb3NpdGlvbi5sZWZ0IC0gb2Zmc2V0UGFyZW50U2l6ZS53aWR0aCArIG9mZnNldEJvcmRlci5yaWdodDtcbiAgICAgICAgICBvZmZzZXRQb3NpdGlvbi5ib3R0b20gPSBkb2MuYm9keS5zY3JvbGxIZWlnaHQgLSBvZmZzZXRQb3NpdGlvbi50b3AgLSBvZmZzZXRQYXJlbnRTaXplLmhlaWdodCArIG9mZnNldEJvcmRlci5ib3R0b207XG5cbiAgICAgICAgICBpZiAobmV4dC5wYWdlLnRvcCA+PSBvZmZzZXRQb3NpdGlvbi50b3AgKyBvZmZzZXRCb3JkZXIudG9wICYmIG5leHQucGFnZS5ib3R0b20gPj0gb2Zmc2V0UG9zaXRpb24uYm90dG9tKSB7XG4gICAgICAgICAgICBpZiAobmV4dC5wYWdlLmxlZnQgPj0gb2Zmc2V0UG9zaXRpb24ubGVmdCArIG9mZnNldEJvcmRlci5sZWZ0ICYmIG5leHQucGFnZS5yaWdodCA+PSBvZmZzZXRQb3NpdGlvbi5yaWdodCkge1xuICAgICAgICAgICAgICAvLyBXZSdyZSB3aXRoaW4gdGhlIHZpc2libGUgcGFydCBvZiB0aGUgdGFyZ2V0J3Mgc2Nyb2xsIHBhcmVudFxuICAgICAgICAgICAgICB2YXIgc2Nyb2xsVG9wID0gb2Zmc2V0UGFyZW50LnNjcm9sbFRvcDtcbiAgICAgICAgICAgICAgdmFyIHNjcm9sbExlZnQgPSBvZmZzZXRQYXJlbnQuc2Nyb2xsTGVmdDtcblxuICAgICAgICAgICAgICAvLyBJdCdzIHBvc2l0aW9uIHJlbGF0aXZlIHRvIHRoZSB0YXJnZXQncyBvZmZzZXQgcGFyZW50IChhYnNvbHV0ZSBwb3NpdGlvbmluZyB3aGVuXG4gICAgICAgICAgICAgIC8vIHRoZSBlbGVtZW50IGlzIG1vdmVkIHRvIGJlIGEgY2hpbGQgb2YgdGhlIHRhcmdldCdzIG9mZnNldCBwYXJlbnQpLlxuICAgICAgICAgICAgICBuZXh0Lm9mZnNldCA9IHtcbiAgICAgICAgICAgICAgICB0b3A6IG5leHQucGFnZS50b3AgLSBvZmZzZXRQb3NpdGlvbi50b3AgKyBzY3JvbGxUb3AgLSBvZmZzZXRCb3JkZXIudG9wLFxuICAgICAgICAgICAgICAgIGxlZnQ6IG5leHQucGFnZS5sZWZ0IC0gb2Zmc2V0UG9zaXRpb24ubGVmdCArIHNjcm9sbExlZnQgLSBvZmZzZXRCb3JkZXIubGVmdFxuICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSkoKTtcbiAgICAgIH1cblxuICAgICAgLy8gV2UgY291bGQgYWxzbyB0cmF2ZWwgdXAgdGhlIERPTSBhbmQgdHJ5IGVhY2ggY29udGFpbmluZyBjb250ZXh0LCByYXRoZXIgdGhhbiBvbmx5XG4gICAgICAvLyBsb29raW5nIGF0IHRoZSBib2R5LCBidXQgd2UncmUgZ29ubmEgZ2V0IGRpbWluaXNoaW5nIHJldHVybnMuXG5cbiAgICAgIHRoaXMubW92ZShuZXh0KTtcblxuICAgICAgdGhpcy5oaXN0b3J5LnVuc2hpZnQobmV4dCk7XG5cbiAgICAgIGlmICh0aGlzLmhpc3RvcnkubGVuZ3RoID4gMykge1xuICAgICAgICB0aGlzLmhpc3RvcnkucG9wKCk7XG4gICAgICB9XG5cbiAgICAgIGlmIChmbHVzaENoYW5nZXMpIHtcbiAgICAgICAgZmx1c2goKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgLy8gVEhFIElTU1VFXG4gIH0sIHtcbiAgICBrZXk6ICdtb3ZlJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gbW92ZShwb3MpIHtcbiAgICAgIHZhciBfdGhpczggPSB0aGlzO1xuXG4gICAgICBpZiAoISh0eXBlb2YgdGhpcy5lbGVtZW50LnBhcmVudE5vZGUgIT09ICd1bmRlZmluZWQnKSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHZhciBzYW1lID0ge307XG5cbiAgICAgIGZvciAodmFyIHR5cGUgaW4gcG9zKSB7XG4gICAgICAgIHNhbWVbdHlwZV0gPSB7fTtcblxuICAgICAgICBmb3IgKHZhciBrZXkgaW4gcG9zW3R5cGVdKSB7XG4gICAgICAgICAgdmFyIGZvdW5kID0gZmFsc2U7XG5cbiAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuaGlzdG9yeS5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgdmFyIHBvaW50ID0gdGhpcy5oaXN0b3J5W2ldO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBwb2ludFt0eXBlXSAhPT0gJ3VuZGVmaW5lZCcgJiYgIXdpdGhpbihwb2ludFt0eXBlXVtrZXldLCBwb3NbdHlwZV1ba2V5XSkpIHtcbiAgICAgICAgICAgICAgZm91bmQgPSB0cnVlO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoIWZvdW5kKSB7XG4gICAgICAgICAgICBzYW1lW3R5cGVdW2tleV0gPSB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB2YXIgY3NzID0geyB0b3A6ICcnLCBsZWZ0OiAnJywgcmlnaHQ6ICcnLCBib3R0b206ICcnIH07XG5cbiAgICAgIHZhciB0cmFuc2NyaWJlID0gZnVuY3Rpb24gdHJhbnNjcmliZShfc2FtZSwgX3Bvcykge1xuICAgICAgICB2YXIgaGFzT3B0aW1pemF0aW9ucyA9IHR5cGVvZiBfdGhpczgub3B0aW9ucy5vcHRpbWl6YXRpb25zICE9PSAndW5kZWZpbmVkJztcbiAgICAgICAgdmFyIGdwdSA9IGhhc09wdGltaXphdGlvbnMgPyBfdGhpczgub3B0aW9ucy5vcHRpbWl6YXRpb25zLmdwdSA6IG51bGw7XG4gICAgICAgIGlmIChncHUgIT09IGZhbHNlKSB7XG4gICAgICAgICAgdmFyIHlQb3MgPSB1bmRlZmluZWQsXG4gICAgICAgICAgICAgIHhQb3MgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgaWYgKF9zYW1lLnRvcCkge1xuICAgICAgICAgICAgY3NzLnRvcCA9IDA7XG4gICAgICAgICAgICB5UG9zID0gX3Bvcy50b3A7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNzcy5ib3R0b20gPSAwO1xuICAgICAgICAgICAgeVBvcyA9IC1fcG9zLmJvdHRvbTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoX3NhbWUubGVmdCkge1xuICAgICAgICAgICAgY3NzLmxlZnQgPSAwO1xuICAgICAgICAgICAgeFBvcyA9IF9wb3MubGVmdDtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY3NzLnJpZ2h0ID0gMDtcbiAgICAgICAgICAgIHhQb3MgPSAtX3Bvcy5yaWdodDtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAod2luZG93Lm1hdGNoTWVkaWEpIHtcbiAgICAgICAgICAgIC8vIEh1YlNwb3QvdGV0aGVyIzIwN1xuICAgICAgICAgICAgdmFyIHJldGluYSA9IHdpbmRvdy5tYXRjaE1lZGlhKCdvbmx5IHNjcmVlbiBhbmQgKG1pbi1yZXNvbHV0aW9uOiAxLjNkcHB4KScpLm1hdGNoZXMgfHwgd2luZG93Lm1hdGNoTWVkaWEoJ29ubHkgc2NyZWVuIGFuZCAoLXdlYmtpdC1taW4tZGV2aWNlLXBpeGVsLXJhdGlvOiAxLjMpJykubWF0Y2hlcztcbiAgICAgICAgICAgIGlmICghcmV0aW5hKSB7XG4gICAgICAgICAgICAgIHhQb3MgPSBNYXRoLnJvdW5kKHhQb3MpO1xuICAgICAgICAgICAgICB5UG9zID0gTWF0aC5yb3VuZCh5UG9zKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICBjc3NbdHJhbnNmb3JtS2V5XSA9ICd0cmFuc2xhdGVYKCcgKyB4UG9zICsgJ3B4KSB0cmFuc2xhdGVZKCcgKyB5UG9zICsgJ3B4KSc7XG5cbiAgICAgICAgICBpZiAodHJhbnNmb3JtS2V5ICE9PSAnbXNUcmFuc2Zvcm0nKSB7XG4gICAgICAgICAgICAvLyBUaGUgWiB0cmFuc2Zvcm0gd2lsbCBrZWVwIHRoaXMgaW4gdGhlIEdQVSAoZmFzdGVyLCBhbmQgcHJldmVudHMgYXJ0aWZhY3RzKSxcbiAgICAgICAgICAgIC8vIGJ1dCBJRTkgZG9lc24ndCBzdXBwb3J0IDNkIHRyYW5zZm9ybXMgYW5kIHdpbGwgY2hva2UuXG4gICAgICAgICAgICBjc3NbdHJhbnNmb3JtS2V5XSArPSBcIiB0cmFuc2xhdGVaKDApXCI7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlmIChfc2FtZS50b3ApIHtcbiAgICAgICAgICAgIGNzcy50b3AgPSBfcG9zLnRvcCArICdweCc7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNzcy5ib3R0b20gPSBfcG9zLmJvdHRvbSArICdweCc7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKF9zYW1lLmxlZnQpIHtcbiAgICAgICAgICAgIGNzcy5sZWZ0ID0gX3Bvcy5sZWZ0ICsgJ3B4JztcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY3NzLnJpZ2h0ID0gX3Bvcy5yaWdodCArICdweCc7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9O1xuXG4gICAgICB2YXIgbW92ZWQgPSBmYWxzZTtcbiAgICAgIGlmICgoc2FtZS5wYWdlLnRvcCB8fCBzYW1lLnBhZ2UuYm90dG9tKSAmJiAoc2FtZS5wYWdlLmxlZnQgfHwgc2FtZS5wYWdlLnJpZ2h0KSkge1xuICAgICAgICBjc3MucG9zaXRpb24gPSAnYWJzb2x1dGUnO1xuICAgICAgICB0cmFuc2NyaWJlKHNhbWUucGFnZSwgcG9zLnBhZ2UpO1xuICAgICAgfSBlbHNlIGlmICgoc2FtZS52aWV3cG9ydC50b3AgfHwgc2FtZS52aWV3cG9ydC5ib3R0b20pICYmIChzYW1lLnZpZXdwb3J0LmxlZnQgfHwgc2FtZS52aWV3cG9ydC5yaWdodCkpIHtcbiAgICAgICAgY3NzLnBvc2l0aW9uID0gJ2ZpeGVkJztcbiAgICAgICAgdHJhbnNjcmliZShzYW1lLnZpZXdwb3J0LCBwb3Mudmlld3BvcnQpO1xuICAgICAgfSBlbHNlIGlmICh0eXBlb2Ygc2FtZS5vZmZzZXQgIT09ICd1bmRlZmluZWQnICYmIHNhbWUub2Zmc2V0LnRvcCAmJiBzYW1lLm9mZnNldC5sZWZ0KSB7XG4gICAgICAgIChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgY3NzLnBvc2l0aW9uID0gJ2Fic29sdXRlJztcbiAgICAgICAgICB2YXIgb2Zmc2V0UGFyZW50ID0gX3RoaXM4LmNhY2hlKCd0YXJnZXQtb2Zmc2V0cGFyZW50JywgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIGdldE9mZnNldFBhcmVudChfdGhpczgudGFyZ2V0KTtcbiAgICAgICAgICB9KTtcblxuICAgICAgICAgIGlmIChnZXRPZmZzZXRQYXJlbnQoX3RoaXM4LmVsZW1lbnQpICE9PSBvZmZzZXRQYXJlbnQpIHtcbiAgICAgICAgICAgIGRlZmVyKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgX3RoaXM4LmVsZW1lbnQucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChfdGhpczguZWxlbWVudCk7XG4gICAgICAgICAgICAgIG9mZnNldFBhcmVudC5hcHBlbmRDaGlsZChfdGhpczguZWxlbWVudCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB0cmFuc2NyaWJlKHNhbWUub2Zmc2V0LCBwb3Mub2Zmc2V0KTtcbiAgICAgICAgICBtb3ZlZCA9IHRydWU7XG4gICAgICAgIH0pKCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjc3MucG9zaXRpb24gPSAnYWJzb2x1dGUnO1xuICAgICAgICB0cmFuc2NyaWJlKHsgdG9wOiB0cnVlLCBsZWZ0OiB0cnVlIH0sIHBvcy5wYWdlKTtcbiAgICAgIH1cblxuICAgICAgaWYgKCFtb3ZlZCkge1xuICAgICAgICBpZiAodGhpcy5vcHRpb25zLmJvZHlFbGVtZW50KSB7XG4gICAgICAgICAgaWYgKHRoaXMuZWxlbWVudC5wYXJlbnROb2RlICE9PSB0aGlzLm9wdGlvbnMuYm9keUVsZW1lbnQpIHtcbiAgICAgICAgICAgIHRoaXMub3B0aW9ucy5ib2R5RWxlbWVudC5hcHBlbmRDaGlsZCh0aGlzLmVsZW1lbnQpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2YXIgb2Zmc2V0UGFyZW50SXNCb2R5ID0gdHJ1ZTtcbiAgICAgICAgICB2YXIgY3VycmVudE5vZGUgPSB0aGlzLmVsZW1lbnQucGFyZW50Tm9kZTtcbiAgICAgICAgICB3aGlsZSAoY3VycmVudE5vZGUgJiYgY3VycmVudE5vZGUubm9kZVR5cGUgPT09IDEgJiYgY3VycmVudE5vZGUudGFnTmFtZSAhPT0gJ0JPRFknKSB7XG4gICAgICAgICAgICBpZiAoZ2V0Q29tcHV0ZWRTdHlsZShjdXJyZW50Tm9kZSkucG9zaXRpb24gIT09ICdzdGF0aWMnKSB7XG4gICAgICAgICAgICAgIG9mZnNldFBhcmVudElzQm9keSA9IGZhbHNlO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgY3VycmVudE5vZGUgPSBjdXJyZW50Tm9kZS5wYXJlbnROb2RlO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmICghb2Zmc2V0UGFyZW50SXNCb2R5KSB7XG4gICAgICAgICAgICB0aGlzLmVsZW1lbnQucGFyZW50Tm9kZS5yZW1vdmVDaGlsZCh0aGlzLmVsZW1lbnQpO1xuICAgICAgICAgICAgdGhpcy5lbGVtZW50Lm93bmVyRG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZCh0aGlzLmVsZW1lbnQpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBBbnkgY3NzIGNoYW5nZSB3aWxsIHRyaWdnZXIgYSByZXBhaW50LCBzbyBsZXQncyBhdm9pZCBvbmUgaWYgbm90aGluZyBjaGFuZ2VkXG4gICAgICB2YXIgd3JpdGVDU1MgPSB7fTtcbiAgICAgIHZhciB3cml0ZSA9IGZhbHNlO1xuICAgICAgZm9yICh2YXIga2V5IGluIGNzcykge1xuICAgICAgICB2YXIgdmFsID0gY3NzW2tleV07XG4gICAgICAgIHZhciBlbFZhbCA9IHRoaXMuZWxlbWVudC5zdHlsZVtrZXldO1xuXG4gICAgICAgIGlmIChlbFZhbCAhPT0gdmFsKSB7XG4gICAgICAgICAgd3JpdGUgPSB0cnVlO1xuICAgICAgICAgIHdyaXRlQ1NTW2tleV0gPSB2YWw7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKHdyaXRlKSB7XG4gICAgICAgIGRlZmVyKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBleHRlbmQoX3RoaXM4LmVsZW1lbnQuc3R5bGUsIHdyaXRlQ1NTKTtcbiAgICAgICAgICBfdGhpczgudHJpZ2dlcigncmVwb3NpdGlvbmVkJyk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBUZXRoZXJDbGFzcztcbn0pKEV2ZW50ZWQpO1xuXG5UZXRoZXJDbGFzcy5tb2R1bGVzID0gW107XG5cblRldGhlckJhc2UucG9zaXRpb24gPSBwb3NpdGlvbjtcblxudmFyIFRldGhlciA9IGV4dGVuZChUZXRoZXJDbGFzcywgVGV0aGVyQmFzZSk7XG4vKiBnbG9iYWxzIFRldGhlckJhc2UgKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgX3NsaWNlZFRvQXJyYXkgPSAoZnVuY3Rpb24gKCkgeyBmdW5jdGlvbiBzbGljZUl0ZXJhdG9yKGFyciwgaSkgeyB2YXIgX2FyciA9IFtdOyB2YXIgX24gPSB0cnVlOyB2YXIgX2QgPSBmYWxzZTsgdmFyIF9lID0gdW5kZWZpbmVkOyB0cnkgeyBmb3IgKHZhciBfaSA9IGFycltTeW1ib2wuaXRlcmF0b3JdKCksIF9zOyAhKF9uID0gKF9zID0gX2kubmV4dCgpKS5kb25lKTsgX24gPSB0cnVlKSB7IF9hcnIucHVzaChfcy52YWx1ZSk7IGlmIChpICYmIF9hcnIubGVuZ3RoID09PSBpKSBicmVhazsgfSB9IGNhdGNoIChlcnIpIHsgX2QgPSB0cnVlOyBfZSA9IGVycjsgfSBmaW5hbGx5IHsgdHJ5IHsgaWYgKCFfbiAmJiBfaVsncmV0dXJuJ10pIF9pWydyZXR1cm4nXSgpOyB9IGZpbmFsbHkgeyBpZiAoX2QpIHRocm93IF9lOyB9IH0gcmV0dXJuIF9hcnI7IH0gcmV0dXJuIGZ1bmN0aW9uIChhcnIsIGkpIHsgaWYgKEFycmF5LmlzQXJyYXkoYXJyKSkgeyByZXR1cm4gYXJyOyB9IGVsc2UgaWYgKFN5bWJvbC5pdGVyYXRvciBpbiBPYmplY3QoYXJyKSkgeyByZXR1cm4gc2xpY2VJdGVyYXRvcihhcnIsIGkpOyB9IGVsc2UgeyB0aHJvdyBuZXcgVHlwZUVycm9yKCdJbnZhbGlkIGF0dGVtcHQgdG8gZGVzdHJ1Y3R1cmUgbm9uLWl0ZXJhYmxlIGluc3RhbmNlJyk7IH0gfTsgfSkoKTtcblxudmFyIF9UZXRoZXJCYXNlJFV0aWxzID0gVGV0aGVyQmFzZS5VdGlscztcbnZhciBnZXRCb3VuZHMgPSBfVGV0aGVyQmFzZSRVdGlscy5nZXRCb3VuZHM7XG52YXIgZXh0ZW5kID0gX1RldGhlckJhc2UkVXRpbHMuZXh0ZW5kO1xudmFyIHVwZGF0ZUNsYXNzZXMgPSBfVGV0aGVyQmFzZSRVdGlscy51cGRhdGVDbGFzc2VzO1xudmFyIGRlZmVyID0gX1RldGhlckJhc2UkVXRpbHMuZGVmZXI7XG5cbnZhciBCT1VORFNfRk9STUFUID0gWydsZWZ0JywgJ3RvcCcsICdyaWdodCcsICdib3R0b20nXTtcblxuZnVuY3Rpb24gZ2V0Qm91bmRpbmdSZWN0KHRldGhlciwgdG8pIHtcbiAgaWYgKHRvID09PSAnc2Nyb2xsUGFyZW50Jykge1xuICAgIHRvID0gdGV0aGVyLnNjcm9sbFBhcmVudHNbMF07XG4gIH0gZWxzZSBpZiAodG8gPT09ICd3aW5kb3cnKSB7XG4gICAgdG8gPSBbcGFnZVhPZmZzZXQsIHBhZ2VZT2Zmc2V0LCBpbm5lcldpZHRoICsgcGFnZVhPZmZzZXQsIGlubmVySGVpZ2h0ICsgcGFnZVlPZmZzZXRdO1xuICB9XG5cbiAgaWYgKHRvID09PSBkb2N1bWVudCkge1xuICAgIHRvID0gdG8uZG9jdW1lbnRFbGVtZW50O1xuICB9XG5cbiAgaWYgKHR5cGVvZiB0by5ub2RlVHlwZSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAoZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIG5vZGUgPSB0bztcbiAgICAgIHZhciBzaXplID0gZ2V0Qm91bmRzKHRvKTtcbiAgICAgIHZhciBwb3MgPSBzaXplO1xuICAgICAgdmFyIHN0eWxlID0gZ2V0Q29tcHV0ZWRTdHlsZSh0byk7XG5cbiAgICAgIHRvID0gW3Bvcy5sZWZ0LCBwb3MudG9wLCBzaXplLndpZHRoICsgcG9zLmxlZnQsIHNpemUuaGVpZ2h0ICsgcG9zLnRvcF07XG5cbiAgICAgIC8vIEFjY291bnQgYW55IHBhcmVudCBGcmFtZXMgc2Nyb2xsIG9mZnNldFxuICAgICAgaWYgKG5vZGUub3duZXJEb2N1bWVudCAhPT0gZG9jdW1lbnQpIHtcbiAgICAgICAgdmFyIHdpbiA9IG5vZGUub3duZXJEb2N1bWVudC5kZWZhdWx0VmlldztcbiAgICAgICAgdG9bMF0gKz0gd2luLnBhZ2VYT2Zmc2V0O1xuICAgICAgICB0b1sxXSArPSB3aW4ucGFnZVlPZmZzZXQ7XG4gICAgICAgIHRvWzJdICs9IHdpbi5wYWdlWE9mZnNldDtcbiAgICAgICAgdG9bM10gKz0gd2luLnBhZ2VZT2Zmc2V0O1xuICAgICAgfVxuXG4gICAgICBCT1VORFNfRk9STUFULmZvckVhY2goZnVuY3Rpb24gKHNpZGUsIGkpIHtcbiAgICAgICAgc2lkZSA9IHNpZGVbMF0udG9VcHBlckNhc2UoKSArIHNpZGUuc3Vic3RyKDEpO1xuICAgICAgICBpZiAoc2lkZSA9PT0gJ1RvcCcgfHwgc2lkZSA9PT0gJ0xlZnQnKSB7XG4gICAgICAgICAgdG9baV0gKz0gcGFyc2VGbG9hdChzdHlsZVsnYm9yZGVyJyArIHNpZGUgKyAnV2lkdGgnXSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdG9baV0gLT0gcGFyc2VGbG9hdChzdHlsZVsnYm9yZGVyJyArIHNpZGUgKyAnV2lkdGgnXSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0pKCk7XG4gIH1cblxuICByZXR1cm4gdG87XG59XG5cblRldGhlckJhc2UubW9kdWxlcy5wdXNoKHtcbiAgcG9zaXRpb246IGZ1bmN0aW9uIHBvc2l0aW9uKF9yZWYpIHtcbiAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgdmFyIHRvcCA9IF9yZWYudG9wO1xuICAgIHZhciBsZWZ0ID0gX3JlZi5sZWZ0O1xuICAgIHZhciB0YXJnZXRBdHRhY2htZW50ID0gX3JlZi50YXJnZXRBdHRhY2htZW50O1xuXG4gICAgaWYgKCF0aGlzLm9wdGlvbnMuY29uc3RyYWludHMpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIHZhciBfY2FjaGUgPSB0aGlzLmNhY2hlKCdlbGVtZW50LWJvdW5kcycsIGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBnZXRCb3VuZHMoX3RoaXMuZWxlbWVudCk7XG4gICAgfSk7XG5cbiAgICB2YXIgaGVpZ2h0ID0gX2NhY2hlLmhlaWdodDtcbiAgICB2YXIgd2lkdGggPSBfY2FjaGUud2lkdGg7XG5cbiAgICBpZiAod2lkdGggPT09IDAgJiYgaGVpZ2h0ID09PSAwICYmIHR5cGVvZiB0aGlzLmxhc3RTaXplICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgdmFyIF9sYXN0U2l6ZSA9IHRoaXMubGFzdFNpemU7XG5cbiAgICAgIC8vIEhhbmRsZSB0aGUgaXRlbSBnZXR0aW5nIGhpZGRlbiBhcyBhIHJlc3VsdCBvZiBvdXIgcG9zaXRpb25pbmcgd2l0aG91dCBnbGl0Y2hpbmdcbiAgICAgIC8vIHRoZSBjbGFzc2VzIGluIGFuZCBvdXRcbiAgICAgIHdpZHRoID0gX2xhc3RTaXplLndpZHRoO1xuICAgICAgaGVpZ2h0ID0gX2xhc3RTaXplLmhlaWdodDtcbiAgICB9XG5cbiAgICB2YXIgdGFyZ2V0U2l6ZSA9IHRoaXMuY2FjaGUoJ3RhcmdldC1ib3VuZHMnLCBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gX3RoaXMuZ2V0VGFyZ2V0Qm91bmRzKCk7XG4gICAgfSk7XG5cbiAgICB2YXIgdGFyZ2V0SGVpZ2h0ID0gdGFyZ2V0U2l6ZS5oZWlnaHQ7XG4gICAgdmFyIHRhcmdldFdpZHRoID0gdGFyZ2V0U2l6ZS53aWR0aDtcblxuICAgIHZhciBhbGxDbGFzc2VzID0gW3RoaXMuZ2V0Q2xhc3MoJ3Bpbm5lZCcpLCB0aGlzLmdldENsYXNzKCdvdXQtb2YtYm91bmRzJyldO1xuXG4gICAgdGhpcy5vcHRpb25zLmNvbnN0cmFpbnRzLmZvckVhY2goZnVuY3Rpb24gKGNvbnN0cmFpbnQpIHtcbiAgICAgIHZhciBvdXRPZkJvdW5kc0NsYXNzID0gY29uc3RyYWludC5vdXRPZkJvdW5kc0NsYXNzO1xuICAgICAgdmFyIHBpbm5lZENsYXNzID0gY29uc3RyYWludC5waW5uZWRDbGFzcztcblxuICAgICAgaWYgKG91dE9mQm91bmRzQ2xhc3MpIHtcbiAgICAgICAgYWxsQ2xhc3Nlcy5wdXNoKG91dE9mQm91bmRzQ2xhc3MpO1xuICAgICAgfVxuICAgICAgaWYgKHBpbm5lZENsYXNzKSB7XG4gICAgICAgIGFsbENsYXNzZXMucHVzaChwaW5uZWRDbGFzcyk7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICBhbGxDbGFzc2VzLmZvckVhY2goZnVuY3Rpb24gKGNscykge1xuICAgICAgWydsZWZ0JywgJ3RvcCcsICdyaWdodCcsICdib3R0b20nXS5mb3JFYWNoKGZ1bmN0aW9uIChzaWRlKSB7XG4gICAgICAgIGFsbENsYXNzZXMucHVzaChjbHMgKyAnLScgKyBzaWRlKTtcbiAgICAgIH0pO1xuICAgIH0pO1xuXG4gICAgdmFyIGFkZENsYXNzZXMgPSBbXTtcblxuICAgIHZhciB0QXR0YWNobWVudCA9IGV4dGVuZCh7fSwgdGFyZ2V0QXR0YWNobWVudCk7XG4gICAgdmFyIGVBdHRhY2htZW50ID0gZXh0ZW5kKHt9LCB0aGlzLmF0dGFjaG1lbnQpO1xuXG4gICAgdGhpcy5vcHRpb25zLmNvbnN0cmFpbnRzLmZvckVhY2goZnVuY3Rpb24gKGNvbnN0cmFpbnQpIHtcbiAgICAgIHZhciB0byA9IGNvbnN0cmFpbnQudG87XG4gICAgICB2YXIgYXR0YWNobWVudCA9IGNvbnN0cmFpbnQuYXR0YWNobWVudDtcbiAgICAgIHZhciBwaW4gPSBjb25zdHJhaW50LnBpbjtcblxuICAgICAgaWYgKHR5cGVvZiBhdHRhY2htZW50ID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICBhdHRhY2htZW50ID0gJyc7XG4gICAgICB9XG5cbiAgICAgIHZhciBjaGFuZ2VBdHRhY2hYID0gdW5kZWZpbmVkLFxuICAgICAgICAgIGNoYW5nZUF0dGFjaFkgPSB1bmRlZmluZWQ7XG4gICAgICBpZiAoYXR0YWNobWVudC5pbmRleE9mKCcgJykgPj0gMCkge1xuICAgICAgICB2YXIgX2F0dGFjaG1lbnQkc3BsaXQgPSBhdHRhY2htZW50LnNwbGl0KCcgJyk7XG5cbiAgICAgICAgdmFyIF9hdHRhY2htZW50JHNwbGl0MiA9IF9zbGljZWRUb0FycmF5KF9hdHRhY2htZW50JHNwbGl0LCAyKTtcblxuICAgICAgICBjaGFuZ2VBdHRhY2hZID0gX2F0dGFjaG1lbnQkc3BsaXQyWzBdO1xuICAgICAgICBjaGFuZ2VBdHRhY2hYID0gX2F0dGFjaG1lbnQkc3BsaXQyWzFdO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY2hhbmdlQXR0YWNoWCA9IGNoYW5nZUF0dGFjaFkgPSBhdHRhY2htZW50O1xuICAgICAgfVxuXG4gICAgICB2YXIgYm91bmRzID0gZ2V0Qm91bmRpbmdSZWN0KF90aGlzLCB0byk7XG5cbiAgICAgIGlmIChjaGFuZ2VBdHRhY2hZID09PSAndGFyZ2V0JyB8fCBjaGFuZ2VBdHRhY2hZID09PSAnYm90aCcpIHtcbiAgICAgICAgaWYgKHRvcCA8IGJvdW5kc1sxXSAmJiB0QXR0YWNobWVudC50b3AgPT09ICd0b3AnKSB7XG4gICAgICAgICAgdG9wICs9IHRhcmdldEhlaWdodDtcbiAgICAgICAgICB0QXR0YWNobWVudC50b3AgPSAnYm90dG9tJztcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0b3AgKyBoZWlnaHQgPiBib3VuZHNbM10gJiYgdEF0dGFjaG1lbnQudG9wID09PSAnYm90dG9tJykge1xuICAgICAgICAgIHRvcCAtPSB0YXJnZXRIZWlnaHQ7XG4gICAgICAgICAgdEF0dGFjaG1lbnQudG9wID0gJ3RvcCc7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKGNoYW5nZUF0dGFjaFkgPT09ICd0b2dldGhlcicpIHtcbiAgICAgICAgaWYgKHRBdHRhY2htZW50LnRvcCA9PT0gJ3RvcCcpIHtcbiAgICAgICAgICBpZiAoZUF0dGFjaG1lbnQudG9wID09PSAnYm90dG9tJyAmJiB0b3AgPCBib3VuZHNbMV0pIHtcbiAgICAgICAgICAgIHRvcCArPSB0YXJnZXRIZWlnaHQ7XG4gICAgICAgICAgICB0QXR0YWNobWVudC50b3AgPSAnYm90dG9tJztcblxuICAgICAgICAgICAgdG9wICs9IGhlaWdodDtcbiAgICAgICAgICAgIGVBdHRhY2htZW50LnRvcCA9ICd0b3AnO1xuICAgICAgICAgIH0gZWxzZSBpZiAoZUF0dGFjaG1lbnQudG9wID09PSAndG9wJyAmJiB0b3AgKyBoZWlnaHQgPiBib3VuZHNbM10gJiYgdG9wIC0gKGhlaWdodCAtIHRhcmdldEhlaWdodCkgPj0gYm91bmRzWzFdKSB7XG4gICAgICAgICAgICB0b3AgLT0gaGVpZ2h0IC0gdGFyZ2V0SGVpZ2h0O1xuICAgICAgICAgICAgdEF0dGFjaG1lbnQudG9wID0gJ2JvdHRvbSc7XG5cbiAgICAgICAgICAgIGVBdHRhY2htZW50LnRvcCA9ICdib3R0b20nO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0QXR0YWNobWVudC50b3AgPT09ICdib3R0b20nKSB7XG4gICAgICAgICAgaWYgKGVBdHRhY2htZW50LnRvcCA9PT0gJ3RvcCcgJiYgdG9wICsgaGVpZ2h0ID4gYm91bmRzWzNdKSB7XG4gICAgICAgICAgICB0b3AgLT0gdGFyZ2V0SGVpZ2h0O1xuICAgICAgICAgICAgdEF0dGFjaG1lbnQudG9wID0gJ3RvcCc7XG5cbiAgICAgICAgICAgIHRvcCAtPSBoZWlnaHQ7XG4gICAgICAgICAgICBlQXR0YWNobWVudC50b3AgPSAnYm90dG9tJztcbiAgICAgICAgICB9IGVsc2UgaWYgKGVBdHRhY2htZW50LnRvcCA9PT0gJ2JvdHRvbScgJiYgdG9wIDwgYm91bmRzWzFdICYmIHRvcCArIChoZWlnaHQgKiAyIC0gdGFyZ2V0SGVpZ2h0KSA8PSBib3VuZHNbM10pIHtcbiAgICAgICAgICAgIHRvcCArPSBoZWlnaHQgLSB0YXJnZXRIZWlnaHQ7XG4gICAgICAgICAgICB0QXR0YWNobWVudC50b3AgPSAndG9wJztcblxuICAgICAgICAgICAgZUF0dGFjaG1lbnQudG9wID0gJ3RvcCc7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRBdHRhY2htZW50LnRvcCA9PT0gJ21pZGRsZScpIHtcbiAgICAgICAgICBpZiAodG9wICsgaGVpZ2h0ID4gYm91bmRzWzNdICYmIGVBdHRhY2htZW50LnRvcCA9PT0gJ3RvcCcpIHtcbiAgICAgICAgICAgIHRvcCAtPSBoZWlnaHQ7XG4gICAgICAgICAgICBlQXR0YWNobWVudC50b3AgPSAnYm90dG9tJztcbiAgICAgICAgICB9IGVsc2UgaWYgKHRvcCA8IGJvdW5kc1sxXSAmJiBlQXR0YWNobWVudC50b3AgPT09ICdib3R0b20nKSB7XG4gICAgICAgICAgICB0b3AgKz0gaGVpZ2h0O1xuICAgICAgICAgICAgZUF0dGFjaG1lbnQudG9wID0gJ3RvcCc7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChjaGFuZ2VBdHRhY2hYID09PSAndGFyZ2V0JyB8fCBjaGFuZ2VBdHRhY2hYID09PSAnYm90aCcpIHtcbiAgICAgICAgaWYgKGxlZnQgPCBib3VuZHNbMF0gJiYgdEF0dGFjaG1lbnQubGVmdCA9PT0gJ2xlZnQnKSB7XG4gICAgICAgICAgbGVmdCArPSB0YXJnZXRXaWR0aDtcbiAgICAgICAgICB0QXR0YWNobWVudC5sZWZ0ID0gJ3JpZ2h0JztcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChsZWZ0ICsgd2lkdGggPiBib3VuZHNbMl0gJiYgdEF0dGFjaG1lbnQubGVmdCA9PT0gJ3JpZ2h0Jykge1xuICAgICAgICAgIGxlZnQgLT0gdGFyZ2V0V2lkdGg7XG4gICAgICAgICAgdEF0dGFjaG1lbnQubGVmdCA9ICdsZWZ0JztcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoY2hhbmdlQXR0YWNoWCA9PT0gJ3RvZ2V0aGVyJykge1xuICAgICAgICBpZiAobGVmdCA8IGJvdW5kc1swXSAmJiB0QXR0YWNobWVudC5sZWZ0ID09PSAnbGVmdCcpIHtcbiAgICAgICAgICBpZiAoZUF0dGFjaG1lbnQubGVmdCA9PT0gJ3JpZ2h0Jykge1xuICAgICAgICAgICAgbGVmdCArPSB0YXJnZXRXaWR0aDtcbiAgICAgICAgICAgIHRBdHRhY2htZW50LmxlZnQgPSAncmlnaHQnO1xuXG4gICAgICAgICAgICBsZWZ0ICs9IHdpZHRoO1xuICAgICAgICAgICAgZUF0dGFjaG1lbnQubGVmdCA9ICdsZWZ0JztcbiAgICAgICAgICB9IGVsc2UgaWYgKGVBdHRhY2htZW50LmxlZnQgPT09ICdsZWZ0Jykge1xuICAgICAgICAgICAgbGVmdCArPSB0YXJnZXRXaWR0aDtcbiAgICAgICAgICAgIHRBdHRhY2htZW50LmxlZnQgPSAncmlnaHQnO1xuXG4gICAgICAgICAgICBsZWZ0IC09IHdpZHRoO1xuICAgICAgICAgICAgZUF0dGFjaG1lbnQubGVmdCA9ICdyaWdodCc7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKGxlZnQgKyB3aWR0aCA+IGJvdW5kc1syXSAmJiB0QXR0YWNobWVudC5sZWZ0ID09PSAncmlnaHQnKSB7XG4gICAgICAgICAgaWYgKGVBdHRhY2htZW50LmxlZnQgPT09ICdsZWZ0Jykge1xuICAgICAgICAgICAgbGVmdCAtPSB0YXJnZXRXaWR0aDtcbiAgICAgICAgICAgIHRBdHRhY2htZW50LmxlZnQgPSAnbGVmdCc7XG5cbiAgICAgICAgICAgIGxlZnQgLT0gd2lkdGg7XG4gICAgICAgICAgICBlQXR0YWNobWVudC5sZWZ0ID0gJ3JpZ2h0JztcbiAgICAgICAgICB9IGVsc2UgaWYgKGVBdHRhY2htZW50LmxlZnQgPT09ICdyaWdodCcpIHtcbiAgICAgICAgICAgIGxlZnQgLT0gdGFyZ2V0V2lkdGg7XG4gICAgICAgICAgICB0QXR0YWNobWVudC5sZWZ0ID0gJ2xlZnQnO1xuXG4gICAgICAgICAgICBsZWZ0ICs9IHdpZHRoO1xuICAgICAgICAgICAgZUF0dGFjaG1lbnQubGVmdCA9ICdsZWZ0JztcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAodEF0dGFjaG1lbnQubGVmdCA9PT0gJ2NlbnRlcicpIHtcbiAgICAgICAgICBpZiAobGVmdCArIHdpZHRoID4gYm91bmRzWzJdICYmIGVBdHRhY2htZW50LmxlZnQgPT09ICdsZWZ0Jykge1xuICAgICAgICAgICAgbGVmdCAtPSB3aWR0aDtcbiAgICAgICAgICAgIGVBdHRhY2htZW50LmxlZnQgPSAncmlnaHQnO1xuICAgICAgICAgIH0gZWxzZSBpZiAobGVmdCA8IGJvdW5kc1swXSAmJiBlQXR0YWNobWVudC5sZWZ0ID09PSAncmlnaHQnKSB7XG4gICAgICAgICAgICBsZWZ0ICs9IHdpZHRoO1xuICAgICAgICAgICAgZUF0dGFjaG1lbnQubGVmdCA9ICdsZWZ0JztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKGNoYW5nZUF0dGFjaFkgPT09ICdlbGVtZW50JyB8fCBjaGFuZ2VBdHRhY2hZID09PSAnYm90aCcpIHtcbiAgICAgICAgaWYgKHRvcCA8IGJvdW5kc1sxXSAmJiBlQXR0YWNobWVudC50b3AgPT09ICdib3R0b20nKSB7XG4gICAgICAgICAgdG9wICs9IGhlaWdodDtcbiAgICAgICAgICBlQXR0YWNobWVudC50b3AgPSAndG9wJztcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0b3AgKyBoZWlnaHQgPiBib3VuZHNbM10gJiYgZUF0dGFjaG1lbnQudG9wID09PSAndG9wJykge1xuICAgICAgICAgIHRvcCAtPSBoZWlnaHQ7XG4gICAgICAgICAgZUF0dGFjaG1lbnQudG9wID0gJ2JvdHRvbSc7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKGNoYW5nZUF0dGFjaFggPT09ICdlbGVtZW50JyB8fCBjaGFuZ2VBdHRhY2hYID09PSAnYm90aCcpIHtcbiAgICAgICAgaWYgKGxlZnQgPCBib3VuZHNbMF0pIHtcbiAgICAgICAgICBpZiAoZUF0dGFjaG1lbnQubGVmdCA9PT0gJ3JpZ2h0Jykge1xuICAgICAgICAgICAgbGVmdCArPSB3aWR0aDtcbiAgICAgICAgICAgIGVBdHRhY2htZW50LmxlZnQgPSAnbGVmdCc7XG4gICAgICAgICAgfSBlbHNlIGlmIChlQXR0YWNobWVudC5sZWZ0ID09PSAnY2VudGVyJykge1xuICAgICAgICAgICAgbGVmdCArPSB3aWR0aCAvIDI7XG4gICAgICAgICAgICBlQXR0YWNobWVudC5sZWZ0ID0gJ2xlZnQnO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChsZWZ0ICsgd2lkdGggPiBib3VuZHNbMl0pIHtcbiAgICAgICAgICBpZiAoZUF0dGFjaG1lbnQubGVmdCA9PT0gJ2xlZnQnKSB7XG4gICAgICAgICAgICBsZWZ0IC09IHdpZHRoO1xuICAgICAgICAgICAgZUF0dGFjaG1lbnQubGVmdCA9ICdyaWdodCc7XG4gICAgICAgICAgfSBlbHNlIGlmIChlQXR0YWNobWVudC5sZWZ0ID09PSAnY2VudGVyJykge1xuICAgICAgICAgICAgbGVmdCAtPSB3aWR0aCAvIDI7XG4gICAgICAgICAgICBlQXR0YWNobWVudC5sZWZ0ID0gJ3JpZ2h0JztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKHR5cGVvZiBwaW4gPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHBpbiA9IHBpbi5zcGxpdCgnLCcpLm1hcChmdW5jdGlvbiAocCkge1xuICAgICAgICAgIHJldHVybiBwLnRyaW0oKTtcbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2UgaWYgKHBpbiA9PT0gdHJ1ZSkge1xuICAgICAgICBwaW4gPSBbJ3RvcCcsICdsZWZ0JywgJ3JpZ2h0JywgJ2JvdHRvbSddO1xuICAgICAgfVxuXG4gICAgICBwaW4gPSBwaW4gfHwgW107XG5cbiAgICAgIHZhciBwaW5uZWQgPSBbXTtcbiAgICAgIHZhciBvb2IgPSBbXTtcblxuICAgICAgaWYgKHRvcCA8IGJvdW5kc1sxXSkge1xuICAgICAgICBpZiAocGluLmluZGV4T2YoJ3RvcCcpID49IDApIHtcbiAgICAgICAgICB0b3AgPSBib3VuZHNbMV07XG4gICAgICAgICAgcGlubmVkLnB1c2goJ3RvcCcpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG9vYi5wdXNoKCd0b3AnKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAodG9wICsgaGVpZ2h0ID4gYm91bmRzWzNdKSB7XG4gICAgICAgIGlmIChwaW4uaW5kZXhPZignYm90dG9tJykgPj0gMCkge1xuICAgICAgICAgIHRvcCA9IGJvdW5kc1szXSAtIGhlaWdodDtcbiAgICAgICAgICBwaW5uZWQucHVzaCgnYm90dG9tJyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgb29iLnB1c2goJ2JvdHRvbScpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChsZWZ0IDwgYm91bmRzWzBdKSB7XG4gICAgICAgIGlmIChwaW4uaW5kZXhPZignbGVmdCcpID49IDApIHtcbiAgICAgICAgICBsZWZ0ID0gYm91bmRzWzBdO1xuICAgICAgICAgIHBpbm5lZC5wdXNoKCdsZWZ0Jyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgb29iLnB1c2goJ2xlZnQnKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAobGVmdCArIHdpZHRoID4gYm91bmRzWzJdKSB7XG4gICAgICAgIGlmIChwaW4uaW5kZXhPZigncmlnaHQnKSA+PSAwKSB7XG4gICAgICAgICAgbGVmdCA9IGJvdW5kc1syXSAtIHdpZHRoO1xuICAgICAgICAgIHBpbm5lZC5wdXNoKCdyaWdodCcpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG9vYi5wdXNoKCdyaWdodCcpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChwaW5uZWQubGVuZ3RoKSB7XG4gICAgICAgIChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgdmFyIHBpbm5lZENsYXNzID0gdW5kZWZpbmVkO1xuICAgICAgICAgIGlmICh0eXBlb2YgX3RoaXMub3B0aW9ucy5waW5uZWRDbGFzcyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHBpbm5lZENsYXNzID0gX3RoaXMub3B0aW9ucy5waW5uZWRDbGFzcztcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcGlubmVkQ2xhc3MgPSBfdGhpcy5nZXRDbGFzcygncGlubmVkJyk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgYWRkQ2xhc3Nlcy5wdXNoKHBpbm5lZENsYXNzKTtcbiAgICAgICAgICBwaW5uZWQuZm9yRWFjaChmdW5jdGlvbiAoc2lkZSkge1xuICAgICAgICAgICAgYWRkQ2xhc3Nlcy5wdXNoKHBpbm5lZENsYXNzICsgJy0nICsgc2lkZSk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0pKCk7XG4gICAgICB9XG5cbiAgICAgIGlmIChvb2IubGVuZ3RoKSB7XG4gICAgICAgIChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgdmFyIG9vYkNsYXNzID0gdW5kZWZpbmVkO1xuICAgICAgICAgIGlmICh0eXBlb2YgX3RoaXMub3B0aW9ucy5vdXRPZkJvdW5kc0NsYXNzICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgb29iQ2xhc3MgPSBfdGhpcy5vcHRpb25zLm91dE9mQm91bmRzQ2xhc3M7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG9vYkNsYXNzID0gX3RoaXMuZ2V0Q2xhc3MoJ291dC1vZi1ib3VuZHMnKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBhZGRDbGFzc2VzLnB1c2gob29iQ2xhc3MpO1xuICAgICAgICAgIG9vYi5mb3JFYWNoKGZ1bmN0aW9uIChzaWRlKSB7XG4gICAgICAgICAgICBhZGRDbGFzc2VzLnB1c2gob29iQ2xhc3MgKyAnLScgKyBzaWRlKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSkoKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHBpbm5lZC5pbmRleE9mKCdsZWZ0JykgPj0gMCB8fCBwaW5uZWQuaW5kZXhPZigncmlnaHQnKSA+PSAwKSB7XG4gICAgICAgIGVBdHRhY2htZW50LmxlZnQgPSB0QXR0YWNobWVudC5sZWZ0ID0gZmFsc2U7XG4gICAgICB9XG4gICAgICBpZiAocGlubmVkLmluZGV4T2YoJ3RvcCcpID49IDAgfHwgcGlubmVkLmluZGV4T2YoJ2JvdHRvbScpID49IDApIHtcbiAgICAgICAgZUF0dGFjaG1lbnQudG9wID0gdEF0dGFjaG1lbnQudG9wID0gZmFsc2U7XG4gICAgICB9XG5cbiAgICAgIGlmICh0QXR0YWNobWVudC50b3AgIT09IHRhcmdldEF0dGFjaG1lbnQudG9wIHx8IHRBdHRhY2htZW50LmxlZnQgIT09IHRhcmdldEF0dGFjaG1lbnQubGVmdCB8fCBlQXR0YWNobWVudC50b3AgIT09IF90aGlzLmF0dGFjaG1lbnQudG9wIHx8IGVBdHRhY2htZW50LmxlZnQgIT09IF90aGlzLmF0dGFjaG1lbnQubGVmdCkge1xuICAgICAgICBfdGhpcy51cGRhdGVBdHRhY2hDbGFzc2VzKGVBdHRhY2htZW50LCB0QXR0YWNobWVudCk7XG4gICAgICAgIF90aGlzLnRyaWdnZXIoJ3VwZGF0ZScsIHtcbiAgICAgICAgICBhdHRhY2htZW50OiBlQXR0YWNobWVudCxcbiAgICAgICAgICB0YXJnZXRBdHRhY2htZW50OiB0QXR0YWNobWVudFxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIGRlZmVyKGZ1bmN0aW9uICgpIHtcbiAgICAgIGlmICghKF90aGlzLm9wdGlvbnMuYWRkVGFyZ2V0Q2xhc3NlcyA9PT0gZmFsc2UpKSB7XG4gICAgICAgIHVwZGF0ZUNsYXNzZXMoX3RoaXMudGFyZ2V0LCBhZGRDbGFzc2VzLCBhbGxDbGFzc2VzKTtcbiAgICAgIH1cbiAgICAgIHVwZGF0ZUNsYXNzZXMoX3RoaXMuZWxlbWVudCwgYWRkQ2xhc3NlcywgYWxsQ2xhc3Nlcyk7XG4gICAgfSk7XG5cbiAgICByZXR1cm4geyB0b3A6IHRvcCwgbGVmdDogbGVmdCB9O1xuICB9XG59KTtcbi8qIGdsb2JhbHMgVGV0aGVyQmFzZSAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBfVGV0aGVyQmFzZSRVdGlscyA9IFRldGhlckJhc2UuVXRpbHM7XG52YXIgZ2V0Qm91bmRzID0gX1RldGhlckJhc2UkVXRpbHMuZ2V0Qm91bmRzO1xudmFyIHVwZGF0ZUNsYXNzZXMgPSBfVGV0aGVyQmFzZSRVdGlscy51cGRhdGVDbGFzc2VzO1xudmFyIGRlZmVyID0gX1RldGhlckJhc2UkVXRpbHMuZGVmZXI7XG5cblRldGhlckJhc2UubW9kdWxlcy5wdXNoKHtcbiAgcG9zaXRpb246IGZ1bmN0aW9uIHBvc2l0aW9uKF9yZWYpIHtcbiAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgdmFyIHRvcCA9IF9yZWYudG9wO1xuICAgIHZhciBsZWZ0ID0gX3JlZi5sZWZ0O1xuXG4gICAgdmFyIF9jYWNoZSA9IHRoaXMuY2FjaGUoJ2VsZW1lbnQtYm91bmRzJywgZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIGdldEJvdW5kcyhfdGhpcy5lbGVtZW50KTtcbiAgICB9KTtcblxuICAgIHZhciBoZWlnaHQgPSBfY2FjaGUuaGVpZ2h0O1xuICAgIHZhciB3aWR0aCA9IF9jYWNoZS53aWR0aDtcblxuICAgIHZhciB0YXJnZXRQb3MgPSB0aGlzLmdldFRhcmdldEJvdW5kcygpO1xuXG4gICAgdmFyIGJvdHRvbSA9IHRvcCArIGhlaWdodDtcbiAgICB2YXIgcmlnaHQgPSBsZWZ0ICsgd2lkdGg7XG5cbiAgICB2YXIgYWJ1dHRlZCA9IFtdO1xuICAgIGlmICh0b3AgPD0gdGFyZ2V0UG9zLmJvdHRvbSAmJiBib3R0b20gPj0gdGFyZ2V0UG9zLnRvcCkge1xuICAgICAgWydsZWZ0JywgJ3JpZ2h0J10uZm9yRWFjaChmdW5jdGlvbiAoc2lkZSkge1xuICAgICAgICB2YXIgdGFyZ2V0UG9zU2lkZSA9IHRhcmdldFBvc1tzaWRlXTtcbiAgICAgICAgaWYgKHRhcmdldFBvc1NpZGUgPT09IGxlZnQgfHwgdGFyZ2V0UG9zU2lkZSA9PT0gcmlnaHQpIHtcbiAgICAgICAgICBhYnV0dGVkLnB1c2goc2lkZSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cblxuICAgIGlmIChsZWZ0IDw9IHRhcmdldFBvcy5yaWdodCAmJiByaWdodCA+PSB0YXJnZXRQb3MubGVmdCkge1xuICAgICAgWyd0b3AnLCAnYm90dG9tJ10uZm9yRWFjaChmdW5jdGlvbiAoc2lkZSkge1xuICAgICAgICB2YXIgdGFyZ2V0UG9zU2lkZSA9IHRhcmdldFBvc1tzaWRlXTtcbiAgICAgICAgaWYgKHRhcmdldFBvc1NpZGUgPT09IHRvcCB8fCB0YXJnZXRQb3NTaWRlID09PSBib3R0b20pIHtcbiAgICAgICAgICBhYnV0dGVkLnB1c2goc2lkZSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cblxuICAgIHZhciBhbGxDbGFzc2VzID0gW107XG4gICAgdmFyIGFkZENsYXNzZXMgPSBbXTtcblxuICAgIHZhciBzaWRlcyA9IFsnbGVmdCcsICd0b3AnLCAncmlnaHQnLCAnYm90dG9tJ107XG4gICAgYWxsQ2xhc3Nlcy5wdXNoKHRoaXMuZ2V0Q2xhc3MoJ2FidXR0ZWQnKSk7XG4gICAgc2lkZXMuZm9yRWFjaChmdW5jdGlvbiAoc2lkZSkge1xuICAgICAgYWxsQ2xhc3Nlcy5wdXNoKF90aGlzLmdldENsYXNzKCdhYnV0dGVkJykgKyAnLScgKyBzaWRlKTtcbiAgICB9KTtcblxuICAgIGlmIChhYnV0dGVkLmxlbmd0aCkge1xuICAgICAgYWRkQ2xhc3Nlcy5wdXNoKHRoaXMuZ2V0Q2xhc3MoJ2FidXR0ZWQnKSk7XG4gICAgfVxuXG4gICAgYWJ1dHRlZC5mb3JFYWNoKGZ1bmN0aW9uIChzaWRlKSB7XG4gICAgICBhZGRDbGFzc2VzLnB1c2goX3RoaXMuZ2V0Q2xhc3MoJ2FidXR0ZWQnKSArICctJyArIHNpZGUpO1xuICAgIH0pO1xuXG4gICAgZGVmZXIoZnVuY3Rpb24gKCkge1xuICAgICAgaWYgKCEoX3RoaXMub3B0aW9ucy5hZGRUYXJnZXRDbGFzc2VzID09PSBmYWxzZSkpIHtcbiAgICAgICAgdXBkYXRlQ2xhc3NlcyhfdGhpcy50YXJnZXQsIGFkZENsYXNzZXMsIGFsbENsYXNzZXMpO1xuICAgICAgfVxuICAgICAgdXBkYXRlQ2xhc3NlcyhfdGhpcy5lbGVtZW50LCBhZGRDbGFzc2VzLCBhbGxDbGFzc2VzKTtcbiAgICB9KTtcblxuICAgIHJldHVybiB0cnVlO1xuICB9XG59KTtcbi8qIGdsb2JhbHMgVGV0aGVyQmFzZSAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBfc2xpY2VkVG9BcnJheSA9IChmdW5jdGlvbiAoKSB7IGZ1bmN0aW9uIHNsaWNlSXRlcmF0b3IoYXJyLCBpKSB7IHZhciBfYXJyID0gW107IHZhciBfbiA9IHRydWU7IHZhciBfZCA9IGZhbHNlOyB2YXIgX2UgPSB1bmRlZmluZWQ7IHRyeSB7IGZvciAodmFyIF9pID0gYXJyW1N5bWJvbC5pdGVyYXRvcl0oKSwgX3M7ICEoX24gPSAoX3MgPSBfaS5uZXh0KCkpLmRvbmUpOyBfbiA9IHRydWUpIHsgX2Fyci5wdXNoKF9zLnZhbHVlKTsgaWYgKGkgJiYgX2Fyci5sZW5ndGggPT09IGkpIGJyZWFrOyB9IH0gY2F0Y2ggKGVycikgeyBfZCA9IHRydWU7IF9lID0gZXJyOyB9IGZpbmFsbHkgeyB0cnkgeyBpZiAoIV9uICYmIF9pWydyZXR1cm4nXSkgX2lbJ3JldHVybiddKCk7IH0gZmluYWxseSB7IGlmIChfZCkgdGhyb3cgX2U7IH0gfSByZXR1cm4gX2FycjsgfSByZXR1cm4gZnVuY3Rpb24gKGFyciwgaSkgeyBpZiAoQXJyYXkuaXNBcnJheShhcnIpKSB7IHJldHVybiBhcnI7IH0gZWxzZSBpZiAoU3ltYm9sLml0ZXJhdG9yIGluIE9iamVjdChhcnIpKSB7IHJldHVybiBzbGljZUl0ZXJhdG9yKGFyciwgaSk7IH0gZWxzZSB7IHRocm93IG5ldyBUeXBlRXJyb3IoJ0ludmFsaWQgYXR0ZW1wdCB0byBkZXN0cnVjdHVyZSBub24taXRlcmFibGUgaW5zdGFuY2UnKTsgfSB9OyB9KSgpO1xuXG5UZXRoZXJCYXNlLm1vZHVsZXMucHVzaCh7XG4gIHBvc2l0aW9uOiBmdW5jdGlvbiBwb3NpdGlvbihfcmVmKSB7XG4gICAgdmFyIHRvcCA9IF9yZWYudG9wO1xuICAgIHZhciBsZWZ0ID0gX3JlZi5sZWZ0O1xuXG4gICAgaWYgKCF0aGlzLm9wdGlvbnMuc2hpZnQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgc2hpZnQgPSB0aGlzLm9wdGlvbnMuc2hpZnQ7XG4gICAgaWYgKHR5cGVvZiB0aGlzLm9wdGlvbnMuc2hpZnQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHNoaWZ0ID0gdGhpcy5vcHRpb25zLnNoaWZ0LmNhbGwodGhpcywgeyB0b3A6IHRvcCwgbGVmdDogbGVmdCB9KTtcbiAgICB9XG5cbiAgICB2YXIgc2hpZnRUb3AgPSB1bmRlZmluZWQsXG4gICAgICAgIHNoaWZ0TGVmdCA9IHVuZGVmaW5lZDtcbiAgICBpZiAodHlwZW9mIHNoaWZ0ID09PSAnc3RyaW5nJykge1xuICAgICAgc2hpZnQgPSBzaGlmdC5zcGxpdCgnICcpO1xuICAgICAgc2hpZnRbMV0gPSBzaGlmdFsxXSB8fCBzaGlmdFswXTtcblxuICAgICAgdmFyIF9zaGlmdCA9IHNoaWZ0O1xuXG4gICAgICB2YXIgX3NoaWZ0MiA9IF9zbGljZWRUb0FycmF5KF9zaGlmdCwgMik7XG5cbiAgICAgIHNoaWZ0VG9wID0gX3NoaWZ0MlswXTtcbiAgICAgIHNoaWZ0TGVmdCA9IF9zaGlmdDJbMV07XG5cbiAgICAgIHNoaWZ0VG9wID0gcGFyc2VGbG9hdChzaGlmdFRvcCwgMTApO1xuICAgICAgc2hpZnRMZWZ0ID0gcGFyc2VGbG9hdChzaGlmdExlZnQsIDEwKTtcbiAgICB9IGVsc2Uge1xuICAgICAgc2hpZnRUb3AgPSBzaGlmdC50b3A7XG4gICAgICBzaGlmdExlZnQgPSBzaGlmdC5sZWZ0O1xuICAgIH1cblxuICAgIHRvcCArPSBzaGlmdFRvcDtcbiAgICBsZWZ0ICs9IHNoaWZ0TGVmdDtcblxuICAgIHJldHVybiB7IHRvcDogdG9wLCBsZWZ0OiBsZWZ0IH07XG4gIH1cbn0pO1xucmV0dXJuIFRldGhlcjtcblxufSkpO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9fdGV0aGVyQDEuNC4zQHRldGhlci9kaXN0L2pzL3RldGhlci5qcyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///391\n");

/***/ }),

/***/ 392:
/***/ (function(module, exports, __webpack_require__) {

eval("var apply = Function.prototype.apply;\n\n// DOM APIs, for completeness\n\nexports.setTimeout = function () {\n  return new Timeout(apply.call(setTimeout, window, arguments), clearTimeout);\n};\nexports.setInterval = function () {\n  return new Timeout(apply.call(setInterval, window, arguments), clearInterval);\n};\nexports.clearTimeout = exports.clearInterval = function (timeout) {\n  if (timeout) {\n    timeout.close();\n  }\n};\n\nfunction Timeout(id, clearFn) {\n  this._id = id;\n  this._clearFn = clearFn;\n}\nTimeout.prototype.unref = Timeout.prototype.ref = function () {};\nTimeout.prototype.close = function () {\n  this._clearFn.call(window, this._id);\n};\n\n// Does not start the time, just sets up the members needed.\nexports.enroll = function (item, msecs) {\n  clearTimeout(item._idleTimeoutId);\n  item._idleTimeout = msecs;\n};\n\nexports.unenroll = function (item) {\n  clearTimeout(item._idleTimeoutId);\n  item._idleTimeout = -1;\n};\n\nexports._unrefActive = exports.active = function (item) {\n  clearTimeout(item._idleTimeoutId);\n\n  var msecs = item._idleTimeout;\n  if (msecs >= 0) {\n    item._idleTimeoutId = setTimeout(function onTimeout() {\n      if (item._onTimeout) item._onTimeout();\n    }, msecs);\n  }\n};\n\n// setimmediate attaches itself to the global object\n__webpack_require__(389);\nexports.setImmediate = setImmediate;\nexports.clearImmediate = clearImmediate;\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L190aW1lcnMtYnJvd3NlcmlmeUAyLjAuNEB0aW1lcnMtYnJvd3NlcmlmeS9tYWluLmpzPzJiZjciXSwibmFtZXMiOlsiYXBwbHkiLCJGdW5jdGlvbiIsInByb3RvdHlwZSIsImV4cG9ydHMiLCJzZXRUaW1lb3V0IiwiVGltZW91dCIsImNhbGwiLCJ3aW5kb3ciLCJhcmd1bWVudHMiLCJjbGVhclRpbWVvdXQiLCJzZXRJbnRlcnZhbCIsImNsZWFySW50ZXJ2YWwiLCJ0aW1lb3V0IiwiY2xvc2UiLCJpZCIsImNsZWFyRm4iLCJfaWQiLCJfY2xlYXJGbiIsInVucmVmIiwicmVmIiwiZW5yb2xsIiwiaXRlbSIsIm1zZWNzIiwiX2lkbGVUaW1lb3V0SWQiLCJfaWRsZVRpbWVvdXQiLCJ1bmVucm9sbCIsIl91bnJlZkFjdGl2ZSIsImFjdGl2ZSIsIm9uVGltZW91dCIsIl9vblRpbWVvdXQiLCJyZXF1aXJlIiwic2V0SW1tZWRpYXRlIiwiY2xlYXJJbW1lZGlhdGUiXSwibWFwcGluZ3MiOiJBQUFBLElBQUlBLFFBQVFDLFNBQVNDLFNBQVQsQ0FBbUJGLEtBQS9COztBQUVBOztBQUVBRyxRQUFRQyxVQUFSLEdBQXFCLFlBQVc7QUFDOUIsU0FBTyxJQUFJQyxPQUFKLENBQVlMLE1BQU1NLElBQU4sQ0FBV0YsVUFBWCxFQUF1QkcsTUFBdkIsRUFBK0JDLFNBQS9CLENBQVosRUFBdURDLFlBQXZELENBQVA7QUFDRCxDQUZEO0FBR0FOLFFBQVFPLFdBQVIsR0FBc0IsWUFBVztBQUMvQixTQUFPLElBQUlMLE9BQUosQ0FBWUwsTUFBTU0sSUFBTixDQUFXSSxXQUFYLEVBQXdCSCxNQUF4QixFQUFnQ0MsU0FBaEMsQ0FBWixFQUF3REcsYUFBeEQsQ0FBUDtBQUNELENBRkQ7QUFHQVIsUUFBUU0sWUFBUixHQUNBTixRQUFRUSxhQUFSLEdBQXdCLFVBQVNDLE9BQVQsRUFBa0I7QUFDeEMsTUFBSUEsT0FBSixFQUFhO0FBQ1hBLFlBQVFDLEtBQVI7QUFDRDtBQUNGLENBTEQ7O0FBT0EsU0FBU1IsT0FBVCxDQUFpQlMsRUFBakIsRUFBcUJDLE9BQXJCLEVBQThCO0FBQzVCLE9BQUtDLEdBQUwsR0FBV0YsRUFBWDtBQUNBLE9BQUtHLFFBQUwsR0FBZ0JGLE9BQWhCO0FBQ0Q7QUFDRFYsUUFBUUgsU0FBUixDQUFrQmdCLEtBQWxCLEdBQTBCYixRQUFRSCxTQUFSLENBQWtCaUIsR0FBbEIsR0FBd0IsWUFBVyxDQUFFLENBQS9EO0FBQ0FkLFFBQVFILFNBQVIsQ0FBa0JXLEtBQWxCLEdBQTBCLFlBQVc7QUFDbkMsT0FBS0ksUUFBTCxDQUFjWCxJQUFkLENBQW1CQyxNQUFuQixFQUEyQixLQUFLUyxHQUFoQztBQUNELENBRkQ7O0FBSUE7QUFDQWIsUUFBUWlCLE1BQVIsR0FBaUIsVUFBU0MsSUFBVCxFQUFlQyxLQUFmLEVBQXNCO0FBQ3JDYixlQUFhWSxLQUFLRSxjQUFsQjtBQUNBRixPQUFLRyxZQUFMLEdBQW9CRixLQUFwQjtBQUNELENBSEQ7O0FBS0FuQixRQUFRc0IsUUFBUixHQUFtQixVQUFTSixJQUFULEVBQWU7QUFDaENaLGVBQWFZLEtBQUtFLGNBQWxCO0FBQ0FGLE9BQUtHLFlBQUwsR0FBb0IsQ0FBQyxDQUFyQjtBQUNELENBSEQ7O0FBS0FyQixRQUFRdUIsWUFBUixHQUF1QnZCLFFBQVF3QixNQUFSLEdBQWlCLFVBQVNOLElBQVQsRUFBZTtBQUNyRFosZUFBYVksS0FBS0UsY0FBbEI7O0FBRUEsTUFBSUQsUUFBUUQsS0FBS0csWUFBakI7QUFDQSxNQUFJRixTQUFTLENBQWIsRUFBZ0I7QUFDZEQsU0FBS0UsY0FBTCxHQUFzQm5CLFdBQVcsU0FBU3dCLFNBQVQsR0FBcUI7QUFDcEQsVUFBSVAsS0FBS1EsVUFBVCxFQUNFUixLQUFLUSxVQUFMO0FBQ0gsS0FIcUIsRUFHbkJQLEtBSG1CLENBQXRCO0FBSUQ7QUFDRixDQVZEOztBQVlBO0FBQ0EsbUJBQUFRLENBQVEsR0FBUjtBQUNBM0IsUUFBUTRCLFlBQVIsR0FBdUJBLFlBQXZCO0FBQ0E1QixRQUFRNkIsY0FBUixHQUF5QkEsY0FBekIiLCJmaWxlIjoiMzkyLmpzIiwic291cmNlc0NvbnRlbnQiOlsidmFyIGFwcGx5ID0gRnVuY3Rpb24ucHJvdG90eXBlLmFwcGx5O1xuXG4vLyBET00gQVBJcywgZm9yIGNvbXBsZXRlbmVzc1xuXG5leHBvcnRzLnNldFRpbWVvdXQgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIG5ldyBUaW1lb3V0KGFwcGx5LmNhbGwoc2V0VGltZW91dCwgd2luZG93LCBhcmd1bWVudHMpLCBjbGVhclRpbWVvdXQpO1xufTtcbmV4cG9ydHMuc2V0SW50ZXJ2YWwgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIG5ldyBUaW1lb3V0KGFwcGx5LmNhbGwoc2V0SW50ZXJ2YWwsIHdpbmRvdywgYXJndW1lbnRzKSwgY2xlYXJJbnRlcnZhbCk7XG59O1xuZXhwb3J0cy5jbGVhclRpbWVvdXQgPVxuZXhwb3J0cy5jbGVhckludGVydmFsID0gZnVuY3Rpb24odGltZW91dCkge1xuICBpZiAodGltZW91dCkge1xuICAgIHRpbWVvdXQuY2xvc2UoKTtcbiAgfVxufTtcblxuZnVuY3Rpb24gVGltZW91dChpZCwgY2xlYXJGbikge1xuICB0aGlzLl9pZCA9IGlkO1xuICB0aGlzLl9jbGVhckZuID0gY2xlYXJGbjtcbn1cblRpbWVvdXQucHJvdG90eXBlLnVucmVmID0gVGltZW91dC5wcm90b3R5cGUucmVmID0gZnVuY3Rpb24oKSB7fTtcblRpbWVvdXQucHJvdG90eXBlLmNsb3NlID0gZnVuY3Rpb24oKSB7XG4gIHRoaXMuX2NsZWFyRm4uY2FsbCh3aW5kb3csIHRoaXMuX2lkKTtcbn07XG5cbi8vIERvZXMgbm90IHN0YXJ0IHRoZSB0aW1lLCBqdXN0IHNldHMgdXAgdGhlIG1lbWJlcnMgbmVlZGVkLlxuZXhwb3J0cy5lbnJvbGwgPSBmdW5jdGlvbihpdGVtLCBtc2Vjcykge1xuICBjbGVhclRpbWVvdXQoaXRlbS5faWRsZVRpbWVvdXRJZCk7XG4gIGl0ZW0uX2lkbGVUaW1lb3V0ID0gbXNlY3M7XG59O1xuXG5leHBvcnRzLnVuZW5yb2xsID0gZnVuY3Rpb24oaXRlbSkge1xuICBjbGVhclRpbWVvdXQoaXRlbS5faWRsZVRpbWVvdXRJZCk7XG4gIGl0ZW0uX2lkbGVUaW1lb3V0ID0gLTE7XG59O1xuXG5leHBvcnRzLl91bnJlZkFjdGl2ZSA9IGV4cG9ydHMuYWN0aXZlID0gZnVuY3Rpb24oaXRlbSkge1xuICBjbGVhclRpbWVvdXQoaXRlbS5faWRsZVRpbWVvdXRJZCk7XG5cbiAgdmFyIG1zZWNzID0gaXRlbS5faWRsZVRpbWVvdXQ7XG4gIGlmIChtc2VjcyA+PSAwKSB7XG4gICAgaXRlbS5faWRsZVRpbWVvdXRJZCA9IHNldFRpbWVvdXQoZnVuY3Rpb24gb25UaW1lb3V0KCkge1xuICAgICAgaWYgKGl0ZW0uX29uVGltZW91dClcbiAgICAgICAgaXRlbS5fb25UaW1lb3V0KCk7XG4gICAgfSwgbXNlY3MpO1xuICB9XG59O1xuXG4vLyBzZXRpbW1lZGlhdGUgYXR0YWNoZXMgaXRzZWxmIHRvIHRoZSBnbG9iYWwgb2JqZWN0XG5yZXF1aXJlKFwic2V0aW1tZWRpYXRlXCIpO1xuZXhwb3J0cy5zZXRJbW1lZGlhdGUgPSBzZXRJbW1lZGlhdGU7XG5leHBvcnRzLmNsZWFySW1tZWRpYXRlID0gY2xlYXJJbW1lZGlhdGU7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L190aW1lcnMtYnJvd3NlcmlmeUAyLjAuNEB0aW1lcnMtYnJvd3NlcmlmeS9tYWluLmpzIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///392\n");

/***/ }),

/***/ 403:
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(44);
__webpack_require__(99);
__webpack_require__(68);
module.exports = __webpack_require__(67);


/***/ }),

/***/ 43:
/***/ (function(module, exports) {

eval("// shim for using process in browser\nvar process = module.exports = {};\n\n// cached from whatever global is present so that test runners that stub it\n// don't break things.  But we need to wrap it in a try catch in case it is\n// wrapped in strict mode code which doesn't define any globals.  It's inside a\n// function because try/catches deoptimize in certain engines.\n\nvar cachedSetTimeout;\nvar cachedClearTimeout;\n\nfunction defaultSetTimout() {\n    throw new Error('setTimeout has not been defined');\n}\nfunction defaultClearTimeout() {\n    throw new Error('clearTimeout has not been defined');\n}\n(function () {\n    try {\n        if (typeof setTimeout === 'function') {\n            cachedSetTimeout = setTimeout;\n        } else {\n            cachedSetTimeout = defaultSetTimout;\n        }\n    } catch (e) {\n        cachedSetTimeout = defaultSetTimout;\n    }\n    try {\n        if (typeof clearTimeout === 'function') {\n            cachedClearTimeout = clearTimeout;\n        } else {\n            cachedClearTimeout = defaultClearTimeout;\n        }\n    } catch (e) {\n        cachedClearTimeout = defaultClearTimeout;\n    }\n})();\nfunction runTimeout(fun) {\n    if (cachedSetTimeout === setTimeout) {\n        //normal enviroments in sane situations\n        return setTimeout(fun, 0);\n    }\n    // if setTimeout wasn't available but was latter defined\n    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {\n        cachedSetTimeout = setTimeout;\n        return setTimeout(fun, 0);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedSetTimeout(fun, 0);\n    } catch (e) {\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally\n            return cachedSetTimeout.call(null, fun, 0);\n        } catch (e) {\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error\n            return cachedSetTimeout.call(this, fun, 0);\n        }\n    }\n}\nfunction runClearTimeout(marker) {\n    if (cachedClearTimeout === clearTimeout) {\n        //normal enviroments in sane situations\n        return clearTimeout(marker);\n    }\n    // if clearTimeout wasn't available but was latter defined\n    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {\n        cachedClearTimeout = clearTimeout;\n        return clearTimeout(marker);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedClearTimeout(marker);\n    } catch (e) {\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally\n            return cachedClearTimeout.call(null, marker);\n        } catch (e) {\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.\n            // Some versions of I.E. have different rules for clearTimeout vs setTimeout\n            return cachedClearTimeout.call(this, marker);\n        }\n    }\n}\nvar queue = [];\nvar draining = false;\nvar currentQueue;\nvar queueIndex = -1;\n\nfunction cleanUpNextTick() {\n    if (!draining || !currentQueue) {\n        return;\n    }\n    draining = false;\n    if (currentQueue.length) {\n        queue = currentQueue.concat(queue);\n    } else {\n        queueIndex = -1;\n    }\n    if (queue.length) {\n        drainQueue();\n    }\n}\n\nfunction drainQueue() {\n    if (draining) {\n        return;\n    }\n    var timeout = runTimeout(cleanUpNextTick);\n    draining = true;\n\n    var len = queue.length;\n    while (len) {\n        currentQueue = queue;\n        queue = [];\n        while (++queueIndex < len) {\n            if (currentQueue) {\n                currentQueue[queueIndex].run();\n            }\n        }\n        queueIndex = -1;\n        len = queue.length;\n    }\n    currentQueue = null;\n    draining = false;\n    runClearTimeout(timeout);\n}\n\nprocess.nextTick = function (fun) {\n    var args = new Array(arguments.length - 1);\n    if (arguments.length > 1) {\n        for (var i = 1; i < arguments.length; i++) {\n            args[i - 1] = arguments[i];\n        }\n    }\n    queue.push(new Item(fun, args));\n    if (queue.length === 1 && !draining) {\n        runTimeout(drainQueue);\n    }\n};\n\n// v8 likes predictible objects\nfunction Item(fun, array) {\n    this.fun = fun;\n    this.array = array;\n}\nItem.prototype.run = function () {\n    this.fun.apply(null, this.array);\n};\nprocess.title = 'browser';\nprocess.browser = true;\nprocess.env = {};\nprocess.argv = [];\nprocess.version = ''; // empty string to avoid regexp issues\nprocess.versions = {};\n\nfunction noop() {}\n\nprocess.on = noop;\nprocess.addListener = noop;\nprocess.once = noop;\nprocess.off = noop;\nprocess.removeListener = noop;\nprocess.removeAllListeners = noop;\nprocess.emit = noop;\nprocess.prependListener = noop;\nprocess.prependOnceListener = noop;\n\nprocess.listeners = function (name) {\n    return [];\n};\n\nprocess.binding = function (name) {\n    throw new Error('process.binding is not supported');\n};\n\nprocess.cwd = function () {\n    return '/';\n};\nprocess.chdir = function (dir) {\n    throw new Error('process.chdir is not supported');\n};\nprocess.umask = function () {\n    return 0;\n};\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L19wcm9jZXNzQDAuMTEuMTBAcHJvY2Vzcy9icm93c2VyLmpzPzExZmEiXSwibmFtZXMiOlsicHJvY2VzcyIsIm1vZHVsZSIsImV4cG9ydHMiLCJjYWNoZWRTZXRUaW1lb3V0IiwiY2FjaGVkQ2xlYXJUaW1lb3V0IiwiZGVmYXVsdFNldFRpbW91dCIsIkVycm9yIiwiZGVmYXVsdENsZWFyVGltZW91dCIsInNldFRpbWVvdXQiLCJlIiwiY2xlYXJUaW1lb3V0IiwicnVuVGltZW91dCIsImZ1biIsImNhbGwiLCJydW5DbGVhclRpbWVvdXQiLCJtYXJrZXIiLCJxdWV1ZSIsImRyYWluaW5nIiwiY3VycmVudFF1ZXVlIiwicXVldWVJbmRleCIsImNsZWFuVXBOZXh0VGljayIsImxlbmd0aCIsImNvbmNhdCIsImRyYWluUXVldWUiLCJ0aW1lb3V0IiwibGVuIiwicnVuIiwibmV4dFRpY2siLCJhcmdzIiwiQXJyYXkiLCJhcmd1bWVudHMiLCJpIiwicHVzaCIsIkl0ZW0iLCJhcnJheSIsInByb3RvdHlwZSIsImFwcGx5IiwidGl0bGUiLCJicm93c2VyIiwiZW52IiwiYXJndiIsInZlcnNpb24iLCJ2ZXJzaW9ucyIsIm5vb3AiLCJvbiIsImFkZExpc3RlbmVyIiwib25jZSIsIm9mZiIsInJlbW92ZUxpc3RlbmVyIiwicmVtb3ZlQWxsTGlzdGVuZXJzIiwiZW1pdCIsInByZXBlbmRMaXN0ZW5lciIsInByZXBlbmRPbmNlTGlzdGVuZXIiLCJsaXN0ZW5lcnMiLCJuYW1lIiwiYmluZGluZyIsImN3ZCIsImNoZGlyIiwiZGlyIiwidW1hc2siXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0EsSUFBSUEsVUFBVUMsT0FBT0MsT0FBUCxHQUFpQixFQUEvQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxJQUFJQyxnQkFBSjtBQUNBLElBQUlDLGtCQUFKOztBQUVBLFNBQVNDLGdCQUFULEdBQTRCO0FBQ3hCLFVBQU0sSUFBSUMsS0FBSixDQUFVLGlDQUFW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QUFSLEdBQWdCLFVBQVVDLEdBQVYsRUFBZTtBQUMzQixVQUFNLElBQUlwRCxLQUFKLENBQVUsZ0NBQVYsQ0FBTjtBQUNILENBRkQ7QUFHQU4sUUFBUTJELEtBQVIsR0FBZ0IsWUFBVztBQUFFLFdBQU8sQ0FBUDtBQUFXLENBQXhDIiwiZmlsZSI6IjQzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiLy8gc2hpbSBmb3IgdXNpbmcgcHJvY2VzcyBpbiBicm93c2VyXG52YXIgcHJvY2VzcyA9IG1vZHVsZS5leHBvcnRzID0ge307XG5cbi8vIGNhY2hlZCBmcm9tIHdoYXRldmVyIGdsb2JhbCBpcyBwcmVzZW50IHNvIHRoYXQgdGVzdCBydW5uZXJzIHRoYXQgc3R1YiBpdFxuLy8gZG9uJ3QgYnJlYWsgdGhpbmdzLiAgQnV0IHdlIG5lZWQgdG8gd3JhcCBpdCBpbiBhIHRyeSBjYXRjaCBpbiBjYXNlIGl0IGlzXG4vLyB3cmFwcGVkIGluIHN0cmljdCBtb2RlIGNvZGUgd2hpY2ggZG9lc24ndCBkZWZpbmUgYW55IGdsb2JhbHMuICBJdCdzIGluc2lkZSBhXG4vLyBmdW5jdGlvbiBiZWNhdXNlIHRyeS9jYXRjaGVzIGRlb3B0aW1pemUgaW4gY2VydGFpbiBlbmdpbmVzLlxuXG52YXIgY2FjaGVkU2V0VGltZW91dDtcbnZhciBjYWNoZWRDbGVhclRpbWVvdXQ7XG5cbmZ1bmN0aW9uIGRlZmF1bHRTZXRUaW1vdXQoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdzZXRUaW1lb3V0IGhhcyBub3QgYmVlbiBkZWZpbmVkJyk7XG59XG5mdW5jdGlvbiBkZWZhdWx0Q2xlYXJUaW1lb3V0ICgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2NsZWFyVGltZW91dCBoYXMgbm90IGJlZW4gZGVmaW5lZCcpO1xufVxuKGZ1bmN0aW9uICgpIHtcbiAgICB0cnkge1xuICAgICAgICBpZiAodHlwZW9mIHNldFRpbWVvdXQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIGNhY2hlZFNldFRpbWVvdXQgPSBzZXRUaW1lb3V0O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY2FjaGVkU2V0VGltZW91dCA9IGRlZmF1bHRTZXRUaW1vdXQ7XG4gICAgICAgIH1cbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIGNhY2hlZFNldFRpbWVvdXQgPSBkZWZhdWx0U2V0VGltb3V0O1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgICBpZiAodHlwZW9mIGNsZWFyVGltZW91dCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgY2FjaGVkQ2xlYXJUaW1lb3V0ID0gY2xlYXJUaW1lb3V0O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY2FjaGVkQ2xlYXJUaW1lb3V0ID0gZGVmYXVsdENsZWFyVGltZW91dDtcbiAgICAgICAgfVxuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgY2FjaGVkQ2xlYXJUaW1lb3V0ID0gZGVmYXVsdENsZWFyVGltZW91dDtcbiAgICB9XG59ICgpKVxuZnVuY3Rpb24gcnVuVGltZW91dChmdW4pIHtcbiAgICBpZiAoY2FjaGVkU2V0VGltZW91dCA9PT0gc2V0VGltZW91dCkge1xuICAgICAgICAvL25vcm1hbCBlbnZpcm9tZW50cyBpbiBzYW5lIHNpdHVhdGlvbnNcbiAgICAgICAgcmV0dXJuIHNldFRpbWVvdXQoZnVuLCAwKTtcbiAgICB9XG4gICAgLy8gaWYgc2V0VGltZW91dCB3YXNuJ3QgYXZhaWxhYmxlIGJ1dCB3YXMgbGF0dGVyIGRlZmluZWRcbiAgICBpZiAoKGNhY2hlZFNldFRpbWVvdXQgPT09IGRlZmF1bHRTZXRUaW1vdXQgfHwgIWNhY2hlZFNldFRpbWVvdXQpICYmIHNldFRpbWVvdXQpIHtcbiAgICAgICAgY2FjaGVkU2V0VGltZW91dCA9IHNldFRpbWVvdXQ7XG4gICAgICAgIHJldHVybiBzZXRUaW1lb3V0KGZ1biwgMCk7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICAgIC8vIHdoZW4gd2hlbiBzb21lYm9keSBoYXMgc2NyZXdlZCB3aXRoIHNldFRpbWVvdXQgYnV0IG5vIEkuRS4gbWFkZG5lc3NcbiAgICAgICAgcmV0dXJuIGNhY2hlZFNldFRpbWVvdXQoZnVuLCAwKTtcbiAgICB9IGNhdGNoKGUpe1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgLy8gV2hlbiB3ZSBhcmUgaW4gSS5FLiBidXQgdGhlIHNjcmlwdCBoYXMgYmVlbiBldmFsZWQgc28gSS5FLiBkb2Vzbid0IHRydXN0IHRoZSBnbG9iYWwgb2JqZWN0IHdoZW4gY2FsbGVkIG5vcm1hbGx5XG4gICAgICAgICAgICByZXR1cm4gY2FjaGVkU2V0VGltZW91dC5jYWxsKG51bGwsIGZ1biwgMCk7XG4gICAgICAgIH0gY2F0Y2goZSl7XG4gICAgICAgICAgICAvLyBzYW1lIGFzIGFib3ZlIGJ1dCB3aGVuIGl0J3MgYSB2ZXJzaW9uIG9mIEkuRS4gdGhhdCBtdXN0IGhhdmUgdGhlIGdsb2JhbCBvYmplY3QgZm9yICd0aGlzJywgaG9wZnVsbHkgb3VyIGNvbnRleHQgY29ycmVjdCBvdGhlcndpc2UgaXQgd2lsbCB0aHJvdyBhIGdsb2JhbCBlcnJvclxuICAgICAgICAgICAgcmV0dXJuIGNhY2hlZFNldFRpbWVvdXQuY2FsbCh0aGlzLCBmdW4sIDApO1xuICAgICAgICB9XG4gICAgfVxuXG5cbn1cbmZ1bmN0aW9uIHJ1bkNsZWFyVGltZW91dChtYXJrZXIpIHtcbiAgICBpZiAoY2FjaGVkQ2xlYXJUaW1lb3V0ID09PSBjbGVhclRpbWVvdXQpIHtcbiAgICAgICAgLy9ub3JtYWwgZW52aXJvbWVudHMgaW4gc2FuZSBzaXR1YXRpb25zXG4gICAgICAgIHJldHVybiBjbGVhclRpbWVvdXQobWFya2VyKTtcbiAgICB9XG4gICAgLy8gaWYgY2xlYXJUaW1lb3V0IHdhc24ndCBhdmFpbGFibGUgYnV0IHdhcyBsYXR0ZXIgZGVmaW5lZFxuICAgIGlmICgoY2FjaGVkQ2xlYXJUaW1lb3V0ID09PSBkZWZhdWx0Q2xlYXJUaW1lb3V0IHx8ICFjYWNoZWRDbGVhclRpbWVvdXQpICYmIGNsZWFyVGltZW91dCkge1xuICAgICAgICBjYWNoZWRDbGVhclRpbWVvdXQgPSBjbGVhclRpbWVvdXQ7XG4gICAgICAgIHJldHVybiBjbGVhclRpbWVvdXQobWFya2VyKTtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgICAgLy8gd2hlbiB3aGVuIHNvbWVib2R5IGhhcyBzY3Jld2VkIHdpdGggc2V0VGltZW91dCBidXQgbm8gSS5FLiBtYWRkbmVzc1xuICAgICAgICByZXR1cm4gY2FjaGVkQ2xlYXJUaW1lb3V0KG1hcmtlcik7XG4gICAgfSBjYXRjaCAoZSl7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICAvLyBXaGVuIHdlIGFyZSBpbiBJLkUuIGJ1dCB0aGUgc2NyaXB0IGhhcyBiZWVuIGV2YWxlZCBzbyBJLkUuIGRvZXNuJ3QgIHRydXN0IHRoZSBnbG9iYWwgb2JqZWN0IHdoZW4gY2FsbGVkIG5vcm1hbGx5XG4gICAgICAgICAgICByZXR1cm4gY2FjaGVkQ2xlYXJUaW1lb3V0LmNhbGwobnVsbCwgbWFya2VyKTtcbiAgICAgICAgfSBjYXRjaCAoZSl7XG4gICAgICAgICAgICAvLyBzYW1lIGFzIGFib3ZlIGJ1dCB3aGVuIGl0J3MgYSB2ZXJzaW9uIG9mIEkuRS4gdGhhdCBtdXN0IGhhdmUgdGhlIGdsb2JhbCBvYmplY3QgZm9yICd0aGlzJywgaG9wZnVsbHkgb3VyIGNvbnRleHQgY29ycmVjdCBvdGhlcndpc2UgaXQgd2lsbCB0aHJvdyBhIGdsb2JhbCBlcnJvci5cbiAgICAgICAgICAgIC8vIFNvbWUgdmVyc2lvbnMgb2YgSS5FLiBoYXZlIGRpZmZlcmVudCBydWxlcyBmb3IgY2xlYXJUaW1lb3V0IHZzIHNldFRpbWVvdXRcbiAgICAgICAgICAgIHJldHVybiBjYWNoZWRDbGVhclRpbWVvdXQuY2FsbCh0aGlzLCBtYXJrZXIpO1xuICAgICAgICB9XG4gICAgfVxuXG5cblxufVxudmFyIHF1ZXVlID0gW107XG52YXIgZHJhaW5pbmcgPSBmYWxzZTtcbnZhciBjdXJyZW50UXVldWU7XG52YXIgcXVldWVJbmRleCA9IC0xO1xuXG5mdW5jdGlvbiBjbGVhblVwTmV4dFRpY2soKSB7XG4gICAgaWYgKCFkcmFpbmluZyB8fCAhY3VycmVudFF1ZXVlKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgZHJhaW5pbmcgPSBmYWxzZTtcbiAgICBpZiAoY3VycmVudFF1ZXVlLmxlbmd0aCkge1xuICAgICAgICBxdWV1ZSA9IGN1cnJlbnRRdWV1ZS5jb25jYXQocXVldWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHF1ZXVlSW5kZXggPSAtMTtcbiAgICB9XG4gICAgaWYgKHF1ZXVlLmxlbmd0aCkge1xuICAgICAgICBkcmFpblF1ZXVlKCk7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBkcmFpblF1ZXVlKCkge1xuICAgIGlmIChkcmFpbmluZykge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIHZhciB0aW1lb3V0ID0gcnVuVGltZW91dChjbGVhblVwTmV4dFRpY2spO1xuICAgIGRyYWluaW5nID0gdHJ1ZTtcblxuICAgIHZhciBsZW4gPSBxdWV1ZS5sZW5ndGg7XG4gICAgd2hpbGUobGVuKSB7XG4gICAgICAgIGN1cnJlbnRRdWV1ZSA9IHF1ZXVlO1xuICAgICAgICBxdWV1ZSA9IFtdO1xuICAgICAgICB3aGlsZSAoKytxdWV1ZUluZGV4IDwgbGVuKSB7XG4gICAgICAgICAgICBpZiAoY3VycmVudFF1ZXVlKSB7XG4gICAgICAgICAgICAgICAgY3VycmVudFF1ZXVlW3F1ZXVlSW5kZXhdLnJ1bigpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHF1ZXVlSW5kZXggPSAtMTtcbiAgICAgICAgbGVuID0gcXVldWUubGVuZ3RoO1xuICAgIH1cbiAgICBjdXJyZW50UXVldWUgPSBudWxsO1xuICAgIGRyYWluaW5nID0gZmFsc2U7XG4gICAgcnVuQ2xlYXJUaW1lb3V0KHRpbWVvdXQpO1xufVxuXG5wcm9jZXNzLm5leHRUaWNrID0gZnVuY3Rpb24gKGZ1bikge1xuICAgIHZhciBhcmdzID0gbmV3IEFycmF5KGFyZ3VtZW50cy5sZW5ndGggLSAxKTtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGFyZ3NbaSAtIDFdID0gYXJndW1lbnRzW2ldO1xuICAgICAgICB9XG4gICAgfVxuICAgIHF1ZXVlLnB1c2gobmV3IEl0ZW0oZnVuLCBhcmdzKSk7XG4gICAgaWYgKHF1ZXVlLmxlbmd0aCA9PT0gMSAmJiAhZHJhaW5pbmcpIHtcbiAgICAgICAgcnVuVGltZW91dChkcmFpblF1ZXVlKTtcbiAgICB9XG59O1xuXG4vLyB2OCBsaWtlcyBwcmVkaWN0aWJsZSBvYmplY3RzXG5mdW5jdGlvbiBJdGVtKGZ1biwgYXJyYXkpIHtcbiAgICB0aGlzLmZ1biA9IGZ1bjtcbiAgICB0aGlzLmFycmF5ID0gYXJyYXk7XG59XG5JdGVtLnByb3RvdHlwZS5ydW4gPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5mdW4uYXBwbHkobnVsbCwgdGhpcy5hcnJheSk7XG59O1xucHJvY2Vzcy50aXRsZSA9ICdicm93c2VyJztcbnByb2Nlc3MuYnJvd3NlciA9IHRydWU7XG5wcm9jZXNzLmVudiA9IHt9O1xucHJvY2Vzcy5hcmd2ID0gW107XG5wcm9jZXNzLnZlcnNpb24gPSAnJzsgLy8gZW1wdHkgc3RyaW5nIHRvIGF2b2lkIHJlZ2V4cCBpc3N1ZXNcbnByb2Nlc3MudmVyc2lvbnMgPSB7fTtcblxuZnVuY3Rpb24gbm9vcCgpIHt9XG5cbnByb2Nlc3Mub24gPSBub29wO1xucHJvY2Vzcy5hZGRMaXN0ZW5lciA9IG5vb3A7XG5wcm9jZXNzLm9uY2UgPSBub29wO1xucHJvY2Vzcy5vZmYgPSBub29wO1xucHJvY2Vzcy5yZW1vdmVMaXN0ZW5lciA9IG5vb3A7XG5wcm9jZXNzLnJlbW92ZUFsbExpc3RlbmVycyA9IG5vb3A7XG5wcm9jZXNzLmVtaXQgPSBub29wO1xucHJvY2Vzcy5wcmVwZW5kTGlzdGVuZXIgPSBub29wO1xucHJvY2Vzcy5wcmVwZW5kT25jZUxpc3RlbmVyID0gbm9vcDtcblxucHJvY2Vzcy5saXN0ZW5lcnMgPSBmdW5jdGlvbiAobmFtZSkgeyByZXR1cm4gW10gfVxuXG5wcm9jZXNzLmJpbmRpbmcgPSBmdW5jdGlvbiAobmFtZSkge1xuICAgIHRocm93IG5ldyBFcnJvcigncHJvY2Vzcy5iaW5kaW5nIGlzIG5vdCBzdXBwb3J0ZWQnKTtcbn07XG5cbnByb2Nlc3MuY3dkID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gJy8nIH07XG5wcm9jZXNzLmNoZGlyID0gZnVuY3Rpb24gKGRpcikge1xuICAgIHRocm93IG5ldyBFcnJvcigncHJvY2Vzcy5jaGRpciBpcyBub3Qgc3VwcG9ydGVkJyk7XG59O1xucHJvY2Vzcy51bWFzayA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gMDsgfTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vX3Byb2Nlc3NAMC4xMS4xMEBwcm9jZXNzL2Jyb3dzZXIuanMiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///43\n");

/***/ }),

/***/ 44:
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/* WEBPACK VAR INJECTION */(function(process, global, setImmediate) {/*!\n * Vue.js v2.5.11\n * (c) 2014-2017 Evan You\n * Released under the MIT License.\n */\n\n\n/*  */\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\nvar emptyObject = Object.freeze({});\n\n// these helpers produces better vm code in JS engines due to their\n// explicitness and function inlining\nfunction isUndef(v) {\n  return v === undefined || v === null;\n}\n\nfunction isDef(v) {\n  return v !== undefined && v !== null;\n}\n\nfunction isTrue(v) {\n  return v === true;\n}\n\nfunction isFalse(v) {\n  return v === false;\n}\n\n/**\n * Check if value is primitive\n */\nfunction isPrimitive(value) {\n  return typeof value === 'string' || typeof value === 'number' || typeof value === 'boolean';\n}\n\n/**\n * Quick object check - this is primarily used to tell\n * Objects from primitive values when we know the value\n * is a JSON-compliant type.\n */\nfunction isObject(obj) {\n  return obj !== null && (typeof obj === 'undefined' ? 'undefined' : _typeof(obj)) === 'object';\n}\n\n/**\n * Get the raw type string of a value e.g. [object Object]\n */\nvar _toString = Object.prototype.toString;\n\nfunction toRawType(value) {\n  return _toString.call(value).slice(8, -1);\n}\n\n/**\n * Strict object type check. Only returns true\n * for plain JavaScript objects.\n */\nfunction isPlainObject(obj) {\n  return _toString.call(obj) === '[object Object]';\n}\n\nfunction isRegExp(v) {\n  return _toString.call(v) === '[object RegExp]';\n}\n\n/**\n * Check if val is a valid array index.\n */\nfunction isValidArrayIndex(val) {\n  var n = parseFloat(String(val));\n  return n >= 0 && Math.floor(n) === n && isFinite(val);\n}\n\n/**\n * Convert a value to a string that is actually rendered.\n */\nfunction toString(val) {\n  return val == null ? '' : (typeof val === 'undefined' ? 'undefined' : _typeof(val)) === 'object' ? JSON.stringify(val, null, 2) : String(val);\n}\n\n/**\n * Convert a input value to a number for persistence.\n * If the conversion fails, return original string.\n */\nfunction toNumber(val) {\n  var n = parseFloat(val);\n  return isNaN(n) ? val : n;\n}\n\n/**\n * Make a map and return a function for checking if a key\n * is in that map.\n */\nfunction makeMap(str, expectsLowerCase) {\n  var map = Object.create(null);\n  var list = str.split(',');\n  for (var i = 0; i < list.length; i++) {\n    map[list[i]] = true;\n  }\n  return expectsLowerCase ? function (val) {\n    return map[val.toLowerCase()];\n  } : function (val) {\n    return map[val];\n  };\n}\n\n/**\n * Check if a tag is a built-in tag.\n */\nvar isBuiltInTag = makeMap('slot,component', true);\n\n/**\n * Check if a attribute is a reserved attribute.\n */\nvar isReservedAttribute = makeMap('key,ref,slot,slot-scope,is');\n\n/**\n * Remove an item from an array\n */\nfunction remove(arr, item) {\n  if (arr.length) {\n    var index = arr.indexOf(item);\n    if (index > -1) {\n      return arr.splice(index, 1);\n    }\n  }\n}\n\n/**\n * Check whether the object has the property.\n */\nvar hasOwnProperty = Object.prototype.hasOwnProperty;\nfunction hasOwn(obj, key) {\n  return hasOwnProperty.call(obj, key);\n}\n\n/**\n * Create a cached version of a pure function.\n */\nfunction cached(fn) {\n  var cache = Object.create(null);\n  return function cachedFn(str) {\n    var hit = cache[str];\n    return hit || (cache[str] = fn(str));\n  };\n}\n\n/**\n * Camelize a hyphen-delimited string.\n */\nvar camelizeRE = /-(\\w)/g;\nvar camelize = cached(function (str) {\n  return str.replace(camelizeRE, function (_, c) {\n    return c ? c.toUpperCase() : '';\n  });\n});\n\n/**\n * Capitalize a string.\n */\nvar capitalize = cached(function (str) {\n  return str.charAt(0).toUpperCase() + str.slice(1);\n});\n\n/**\n * Hyphenate a camelCase string.\n */\nvar hyphenateRE = /\\B([A-Z])/g;\nvar hyphenate = cached(function (str) {\n  return str.replace(hyphenateRE, '-$1').toLowerCase();\n});\n\n/**\n * Simple bind, faster than native\n */\nfunction bind(fn, ctx) {\n  function boundFn(a) {\n    var l = arguments.length;\n    return l ? l > 1 ? fn.apply(ctx, arguments) : fn.call(ctx, a) : fn.call(ctx);\n  }\n  // record original fn length\n  boundFn._length = fn.length;\n  return boundFn;\n}\n\n/**\n * Convert an Array-like object to a real Array.\n */\nfunction toArray(list, start) {\n  start = start || 0;\n  var i = list.length - start;\n  var ret = new Array(i);\n  while (i--) {\n    ret[i] = list[i + start];\n  }\n  return ret;\n}\n\n/**\n * Mix properties into target object.\n */\nfunction extend(to, _from) {\n  for (var key in _from) {\n    to[key] = _from[key];\n  }\n  return to;\n}\n\n/**\n * Merge an Array of Objects into a single Object.\n */\nfunction toObject(arr) {\n  var res = {};\n  for (var i = 0; i < arr.length; i++) {\n    if (arr[i]) {\n      extend(res, arr[i]);\n    }\n  }\n  return res;\n}\n\n/**\n * Perform no operation.\n * Stubbing args to make Flow happy without leaving useless transpiled code\n * with ...rest (https://flow.org/blog/2017/05/07/Strict-Function-Call-Arity/)\n */\nfunction noop(a, b, c) {}\n\n/**\n * Always return false.\n */\nvar no = function no(a, b, c) {\n  return false;\n};\n\n/**\n * Return same value\n */\nvar identity = function identity(_) {\n  return _;\n};\n\n/**\n * Generate a static keys string from compiler modules.\n */\nfunction genStaticKeys(modules) {\n  return modules.reduce(function (keys, m) {\n    return keys.concat(m.staticKeys || []);\n  }, []).join(',');\n}\n\n/**\n * Check if two values are loosely equal - that is,\n * if they are plain objects, do they have the same shape?\n */\nfunction looseEqual(a, b) {\n  if (a === b) {\n    return true;\n  }\n  var isObjectA = isObject(a);\n  var isObjectB = isObject(b);\n  if (isObjectA && isObjectB) {\n    try {\n      var isArrayA = Array.isArray(a);\n      var isArrayB = Array.isArray(b);\n      if (isArrayA && isArrayB) {\n        return a.length === b.length && a.every(function (e, i) {\n          return looseEqual(e, b[i]);\n        });\n      } else if (!isArrayA && !isArrayB) {\n        var keysA = Object.keys(a);\n        var keysB = Object.keys(b);\n        return keysA.length === keysB.length && keysA.every(function (key) {\n          return looseEqual(a[key], b[key]);\n        });\n      } else {\n        /* istanbul ignore next */\n        return false;\n      }\n    } catch (e) {\n      /* istanbul ignore next */\n      return false;\n    }\n  } else if (!isObjectA && !isObjectB) {\n    return String(a) === String(b);\n  } else {\n    return false;\n  }\n}\n\nfunction looseIndexOf(arr, val) {\n  for (var i = 0; i < arr.length; i++) {\n    if (looseEqual(arr[i], val)) {\n      return i;\n    }\n  }\n  return -1;\n}\n\n/**\n * Ensure a function is called only once.\n */\nfunction once(fn) {\n  var called = false;\n  return function () {\n    if (!called) {\n      called = true;\n      fn.apply(this, arguments);\n    }\n  };\n}\n\nvar SSR_ATTR = 'data-server-rendered';\n\nvar ASSET_TYPES = ['component', 'directive', 'filter'];\n\nvar LIFECYCLE_HOOKS = ['beforeCreate', 'created', 'beforeMount', 'mounted', 'beforeUpdate', 'updated', 'beforeDestroy', 'destroyed', 'activated', 'deactivated', 'errorCaptured'];\n\n/*  */\n\nvar config = {\n  /**\n   * Option merge strategies (used in core/util/options)\n   */\n  // $flow-disable-line\n  optionMergeStrategies: Object.create(null),\n\n  /**\n   * Whether to suppress warnings.\n   */\n  silent: false,\n\n  /**\n   * Show production mode tip message on boot?\n   */\n  productionTip: process.env.NODE_ENV !== 'production',\n\n  /**\n   * Whether to enable devtools\n   */\n  devtools: process.env.NODE_ENV !== 'production',\n\n  /**\n   * Whether to record perf\n   */\n  performance: false,\n\n  /**\n   * Error handler for watcher errors\n   */\n  errorHandler: null,\n\n  /**\n   * Warn handler for watcher warns\n   */\n  warnHandler: null,\n\n  /**\n   * Ignore certain custom elements\n   */\n  ignoredElements: [],\n\n  /**\n   * Custom user key aliases for v-on\n   */\n  // $flow-disable-line\n  keyCodes: Object.create(null),\n\n  /**\n   * Check if a tag is reserved so that it cannot be registered as a\n   * component. This is platform-dependent and may be overwritten.\n   */\n  isReservedTag: no,\n\n  /**\n   * Check if an attribute is reserved so that it cannot be used as a component\n   * prop. This is platform-dependent and may be overwritten.\n   */\n  isReservedAttr: no,\n\n  /**\n   * Check if a tag is an unknown element.\n   * Platform-dependent.\n   */\n  isUnknownElement: no,\n\n  /**\n   * Get the namespace of an element\n   */\n  getTagNamespace: noop,\n\n  /**\n   * Parse the real tag name for the specific platform.\n   */\n  parsePlatformTagName: identity,\n\n  /**\n   * Check if an attribute must be bound using property, e.g. value\n   * Platform-dependent.\n   */\n  mustUseProp: no,\n\n  /**\n   * Exposed for legacy reasons\n   */\n  _lifecycleHooks: LIFECYCLE_HOOKS\n};\n\n/*  */\n\n/**\n * Check if a string starts with $ or _\n */\nfunction isReserved(str) {\n  var c = (str + '').charCodeAt(0);\n  return c === 0x24 || c === 0x5F;\n}\n\n/**\n * Define a property.\n */\nfunction def(obj, key, val, enumerable) {\n  Object.defineProperty(obj, key, {\n    value: val,\n    enumerable: !!enumerable,\n    writable: true,\n    configurable: true\n  });\n}\n\n/**\n * Parse simple path.\n */\nvar bailRE = /[^\\w.$]/;\nfunction parsePath(path) {\n  if (bailRE.test(path)) {\n    return;\n  }\n  var segments = path.split('.');\n  return function (obj) {\n    for (var i = 0; i < segments.length; i++) {\n      if (!obj) {\n        return;\n      }\n      obj = obj[segments[i]];\n    }\n    return obj;\n  };\n}\n\n/*  */\n\n// can we use __proto__?\nvar hasProto = '__proto__' in {};\n\n// Browser environment sniffing\nvar inBrowser = typeof window !== 'undefined';\nvar inWeex = typeof WXEnvironment !== 'undefined' && !!WXEnvironment.platform;\nvar weexPlatform = inWeex && WXEnvironment.platform.toLowerCase();\nvar UA = inBrowser && window.navigator.userAgent.toLowerCase();\nvar isIE = UA && /msie|trident/.test(UA);\nvar isIE9 = UA && UA.indexOf('msie 9.0') > 0;\nvar isEdge = UA && UA.indexOf('edge/') > 0;\nvar isAndroid = UA && UA.indexOf('android') > 0 || weexPlatform === 'android';\nvar isIOS = UA && /iphone|ipad|ipod|ios/.test(UA) || weexPlatform === 'ios';\nvar isChrome = UA && /chrome\\/\\d+/.test(UA) && !isEdge;\n\n// Firefox has a \"watch\" function on Object.prototype...\nvar nativeWatch = {}.watch;\n\nvar supportsPassive = false;\nif (inBrowser) {\n  try {\n    var opts = {};\n    Object.defineProperty(opts, 'passive', {\n      get: function get() {\n        /* istanbul ignore next */\n        supportsPassive = true;\n      }\n    }); // https://github.com/facebook/flow/issues/285\n    window.addEventListener('test-passive', null, opts);\n  } catch (e) {}\n}\n\n// this needs to be lazy-evaled because vue may be required before\n// vue-server-renderer can set VUE_ENV\nvar _isServer;\nvar isServerRendering = function isServerRendering() {\n  if (_isServer === undefined) {\n    /* istanbul ignore if */\n    if (!inBrowser && typeof global !== 'undefined') {\n      // detect presence of vue-server-renderer and avoid\n      // Webpack shimming the process\n      _isServer = global['process'].env.VUE_ENV === 'server';\n    } else {\n      _isServer = false;\n    }\n  }\n  return _isServer;\n};\n\n// detect devtools\nvar devtools = inBrowser && window.__VUE_DEVTOOLS_GLOBAL_HOOK__;\n\n/* istanbul ignore next */\nfunction isNative(Ctor) {\n  return typeof Ctor === 'function' && /native code/.test(Ctor.toString());\n}\n\nvar hasSymbol = typeof Symbol !== 'undefined' && isNative(Symbol) && typeof Reflect !== 'undefined' && isNative(Reflect.ownKeys);\n\nvar _Set;\n/* istanbul ignore if */ // $flow-disable-line\nif (typeof Set !== 'undefined' && isNative(Set)) {\n  // use native Set when available.\n  _Set = Set;\n} else {\n  // a non-standard Set polyfill that only works with primitive keys.\n  _Set = function () {\n    function Set() {\n      this.set = Object.create(null);\n    }\n    Set.prototype.has = function has(key) {\n      return this.set[key] === true;\n    };\n    Set.prototype.add = function add(key) {\n      this.set[key] = true;\n    };\n    Set.prototype.clear = function clear() {\n      this.set = Object.create(null);\n    };\n\n    return Set;\n  }();\n}\n\n/*  */\n\nvar warn = noop;\nvar tip = noop;\nvar generateComponentTrace = noop; // work around flow check\nvar formatComponentName = noop;\n\nif (process.env.NODE_ENV !== 'production') {\n  var hasConsole = typeof console !== 'undefined';\n  var classifyRE = /(?:^|[-_])(\\w)/g;\n  var classify = function classify(str) {\n    return str.replace(classifyRE, function (c) {\n      return c.toUpperCase();\n    }).replace(/[-_]/g, '');\n  };\n\n  warn = function warn(msg, vm) {\n    var trace = vm ? generateComponentTrace(vm) : '';\n\n    if (config.warnHandler) {\n      config.warnHandler.call(null, msg, vm, trace);\n    } else if (hasConsole && !config.silent) {\n      console.error(\"[Vue warn]: \" + msg + trace);\n    }\n  };\n\n  tip = function tip(msg, vm) {\n    if (hasConsole && !config.silent) {\n      console.warn(\"[Vue tip]: \" + msg + (vm ? generateComponentTrace(vm) : ''));\n    }\n  };\n\n  formatComponentName = function formatComponentName(vm, includeFile) {\n    if (vm.$root === vm) {\n      return '<Root>';\n    }\n    var options = typeof vm === 'function' && vm.cid != null ? vm.options : vm._isVue ? vm.$options || vm.constructor.options : vm || {};\n    var name = options.name || options._componentTag;\n    var file = options.__file;\n    if (!name && file) {\n      var match = file.match(/([^/\\\\]+)\\.vue$/);\n      name = match && match[1];\n    }\n\n    return (name ? \"<\" + classify(name) + \">\" : \"<Anonymous>\") + (file && includeFile !== false ? \" at \" + file : '');\n  };\n\n  var repeat = function repeat(str, n) {\n    var res = '';\n    while (n) {\n      if (n % 2 === 1) {\n        res += str;\n      }\n      if (n > 1) {\n        str += str;\n      }\n      n >>= 1;\n    }\n    return res;\n  };\n\n  generateComponentTrace = function generateComponentTrace(vm) {\n    if (vm._isVue && vm.$parent) {\n      var tree = [];\n      var currentRecursiveSequence = 0;\n      while (vm) {\n        if (tree.length > 0) {\n          var last = tree[tree.length - 1];\n          if (last.constructor === vm.constructor) {\n            currentRecursiveSequence++;\n            vm = vm.$parent;\n            continue;\n          } else if (currentRecursiveSequence > 0) {\n            tree[tree.length - 1] = [last, currentRecursiveSequence];\n            currentRecursiveSequence = 0;\n          }\n        }\n        tree.push(vm);\n        vm = vm.$parent;\n      }\n      return '\\n\\nfound in\\n\\n' + tree.map(function (vm, i) {\n        return \"\" + (i === 0 ? '---> ' : repeat(' ', 5 + i * 2)) + (Array.isArray(vm) ? formatComponentName(vm[0]) + \"... (\" + vm[1] + \" recursive calls)\" : formatComponentName(vm));\n      }).join('\\n');\n    } else {\n      return \"\\n\\n(found in \" + formatComponentName(vm) + \")\";\n    }\n  };\n}\n\n/*  */\n\nvar uid = 0;\n\n/**\n * A dep is an observable that can have multiple\n * directives subscribing to it.\n */\nvar Dep = function Dep() {\n  this.id = uid++;\n  this.subs = [];\n};\n\nDep.prototype.addSub = function addSub(sub) {\n  this.subs.push(sub);\n};\n\nDep.prototype.removeSub = function removeSub(sub) {\n  remove(this.subs, sub);\n};\n\nDep.prototype.depend = function depend() {\n  if (Dep.target) {\n    Dep.target.addDep(this);\n  }\n};\n\nDep.prototype.notify = function notify() {\n  // stabilize the subscriber list first\n  var subs = this.subs.slice();\n  for (var i = 0, l = subs.length; i < l; i++) {\n    subs[i].update();\n  }\n};\n\n// the current target watcher being evaluated.\n// this is globally unique because there could be only one\n// watcher being evaluated at any time.\nDep.target = null;\nvar targetStack = [];\n\nfunction pushTarget(_target) {\n  if (Dep.target) {\n    targetStack.push(Dep.target);\n  }\n  Dep.target = _target;\n}\n\nfunction popTarget() {\n  Dep.target = targetStack.pop();\n}\n\n/*  */\n\nvar VNode = function VNode(tag, data, children, text, elm, context, componentOptions, asyncFactory) {\n  this.tag = tag;\n  this.data = data;\n  this.children = children;\n  this.text = text;\n  this.elm = elm;\n  this.ns = undefined;\n  this.context = context;\n  this.fnContext = undefined;\n  this.fnOptions = undefined;\n  this.fnScopeId = undefined;\n  this.key = data && data.key;\n  this.componentOptions = componentOptions;\n  this.componentInstance = undefined;\n  this.parent = undefined;\n  this.raw = false;\n  this.isStatic = false;\n  this.isRootInsert = true;\n  this.isComment = false;\n  this.isCloned = false;\n  this.isOnce = false;\n  this.asyncFactory = asyncFactory;\n  this.asyncMeta = undefined;\n  this.isAsyncPlaceholder = false;\n};\n\nvar prototypeAccessors = { child: { configurable: true } };\n\n// DEPRECATED: alias for componentInstance for backwards compat.\n/* istanbul ignore next */\nprototypeAccessors.child.get = function () {\n  return this.componentInstance;\n};\n\nObject.defineProperties(VNode.prototype, prototypeAccessors);\n\nvar createEmptyVNode = function createEmptyVNode(text) {\n  if (text === void 0) text = '';\n\n  var node = new VNode();\n  node.text = text;\n  node.isComment = true;\n  return node;\n};\n\nfunction createTextVNode(val) {\n  return new VNode(undefined, undefined, undefined, String(val));\n}\n\n// optimized shallow clone\n// used for static nodes and slot nodes because they may be reused across\n// multiple renders, cloning them avoids errors when DOM manipulations rely\n// on their elm reference.\nfunction cloneVNode(vnode, deep) {\n  var componentOptions = vnode.componentOptions;\n  var cloned = new VNode(vnode.tag, vnode.data, vnode.children, vnode.text, vnode.elm, vnode.context, componentOptions, vnode.asyncFactory);\n  cloned.ns = vnode.ns;\n  cloned.isStatic = vnode.isStatic;\n  cloned.key = vnode.key;\n  cloned.isComment = vnode.isComment;\n  cloned.fnContext = vnode.fnContext;\n  cloned.fnOptions = vnode.fnOptions;\n  cloned.fnScopeId = vnode.fnScopeId;\n  cloned.isCloned = true;\n  if (deep) {\n    if (vnode.children) {\n      cloned.children = cloneVNodes(vnode.children, true);\n    }\n    if (componentOptions && componentOptions.children) {\n      componentOptions.children = cloneVNodes(componentOptions.children, true);\n    }\n  }\n  return cloned;\n}\n\nfunction cloneVNodes(vnodes, deep) {\n  var len = vnodes.length;\n  var res = new Array(len);\n  for (var i = 0; i < len; i++) {\n    res[i] = cloneVNode(vnodes[i], deep);\n  }\n  return res;\n}\n\n/*\n * not type checking this file because flow doesn't play well with\n * dynamically accessing methods on Array prototype\n */\n\nvar arrayProto = Array.prototype;\nvar arrayMethods = Object.create(arrayProto);['push', 'pop', 'shift', 'unshift', 'splice', 'sort', 'reverse'].forEach(function (method) {\n  // cache original method\n  var original = arrayProto[method];\n  def(arrayMethods, method, function mutator() {\n    var args = [],\n        len = arguments.length;\n    while (len--) {\n      args[len] = arguments[len];\n    }var result = original.apply(this, args);\n    var ob = this.__ob__;\n    var inserted;\n    switch (method) {\n      case 'push':\n      case 'unshift':\n        inserted = args;\n        break;\n      case 'splice':\n        inserted = args.slice(2);\n        break;\n    }\n    if (inserted) {\n      ob.observeArray(inserted);\n    }\n    // notify change\n    ob.dep.notify();\n    return result;\n  });\n});\n\n/*  */\n\nvar arrayKeys = Object.getOwnPropertyNames(arrayMethods);\n\n/**\n * By default, when a reactive property is set, the new value is\n * also converted to become reactive. However when passing down props,\n * we don't want to force conversion because the value may be a nested value\n * under a frozen data structure. Converting it would defeat the optimization.\n */\nvar observerState = {\n  shouldConvert: true\n};\n\n/**\n * Observer class that are attached to each observed\n * object. Once attached, the observer converts target\n * object's property keys into getter/setters that\n * collect dependencies and dispatches updates.\n */\nvar Observer = function Observer(value) {\n  this.value = value;\n  this.dep = new Dep();\n  this.vmCount = 0;\n  def(value, '__ob__', this);\n  if (Array.isArray(value)) {\n    var augment = hasProto ? protoAugment : copyAugment;\n    augment(value, arrayMethods, arrayKeys);\n    this.observeArray(value);\n  } else {\n    this.walk(value);\n  }\n};\n\n/**\n * Walk through each property and convert them into\n * getter/setters. This method should only be called when\n * value type is Object.\n */\nObserver.prototype.walk = function walk(obj) {\n  var keys = Object.keys(obj);\n  for (var i = 0; i < keys.length; i++) {\n    defineReactive(obj, keys[i], obj[keys[i]]);\n  }\n};\n\n/**\n * Observe a list of Array items.\n */\nObserver.prototype.observeArray = function observeArray(items) {\n  for (var i = 0, l = items.length; i < l; i++) {\n    observe(items[i]);\n  }\n};\n\n// helpers\n\n/**\n * Augment an target Object or Array by intercepting\n * the prototype chain using __proto__\n */\nfunction protoAugment(target, src, keys) {\n  /* eslint-disable no-proto */\n  target.__proto__ = src;\n  /* eslint-enable no-proto */\n}\n\n/**\n * Augment an target Object or Array by defining\n * hidden properties.\n */\n/* istanbul ignore next */\nfunction copyAugment(target, src, keys) {\n  for (var i = 0, l = keys.length; i < l; i++) {\n    var key = keys[i];\n    def(target, key, src[key]);\n  }\n}\n\n/**\n * Attempt to create an observer instance for a value,\n * returns the new observer if successfully observed,\n * or the existing observer if the value already has one.\n */\nfunction observe(value, asRootData) {\n  if (!isObject(value) || value instanceof VNode) {\n    return;\n  }\n  var ob;\n  if (hasOwn(value, '__ob__') && value.__ob__ instanceof Observer) {\n    ob = value.__ob__;\n  } else if (observerState.shouldConvert && !isServerRendering() && (Array.isArray(value) || isPlainObject(value)) && Object.isExtensible(value) && !value._isVue) {\n    ob = new Observer(value);\n  }\n  if (asRootData && ob) {\n    ob.vmCount++;\n  }\n  return ob;\n}\n\n/**\n * Define a reactive property on an Object.\n */\nfunction defineReactive(obj, key, val, customSetter, shallow) {\n  var dep = new Dep();\n\n  var property = Object.getOwnPropertyDescriptor(obj, key);\n  if (property && property.configurable === false) {\n    return;\n  }\n\n  // cater for pre-defined getter/setters\n  var getter = property && property.get;\n  var setter = property && property.set;\n\n  var childOb = !shallow && observe(val);\n  Object.defineProperty(obj, key, {\n    enumerable: true,\n    configurable: true,\n    get: function reactiveGetter() {\n      var value = getter ? getter.call(obj) : val;\n      if (Dep.target) {\n        dep.depend();\n        if (childOb) {\n          childOb.dep.depend();\n          if (Array.isArray(value)) {\n            dependArray(value);\n          }\n        }\n      }\n      return value;\n    },\n    set: function reactiveSetter(newVal) {\n      var value = getter ? getter.call(obj) : val;\n      /* eslint-disable no-self-compare */\n      if (newVal === value || newVal !== newVal && value !== value) {\n        return;\n      }\n      /* eslint-enable no-self-compare */\n      if (process.env.NODE_ENV !== 'production' && customSetter) {\n        customSetter();\n      }\n      if (setter) {\n        setter.call(obj, newVal);\n      } else {\n        val = newVal;\n      }\n      childOb = !shallow && observe(newVal);\n      dep.notify();\n    }\n  });\n}\n\n/**\n * Set a property on an object. Adds the new property and\n * triggers change notification if the property doesn't\n * already exist.\n */\nfunction set(target, key, val) {\n  if (Array.isArray(target) && isValidArrayIndex(key)) {\n    target.length = Math.max(target.length, key);\n    target.splice(key, 1, val);\n    return val;\n  }\n  if (key in target && !(key in Object.prototype)) {\n    target[key] = val;\n    return val;\n  }\n  var ob = target.__ob__;\n  if (target._isVue || ob && ob.vmCount) {\n    process.env.NODE_ENV !== 'production' && warn('Avoid adding reactive properties to a Vue instance or its root $data ' + 'at runtime - declare it upfront in the data option.');\n    return val;\n  }\n  if (!ob) {\n    target[key] = val;\n    return val;\n  }\n  defineReactive(ob.value, key, val);\n  ob.dep.notify();\n  return val;\n}\n\n/**\n * Delete a property and trigger change if necessary.\n */\nfunction del(target, key) {\n  if (Array.isArray(target) && isValidArrayIndex(key)) {\n    target.splice(key, 1);\n    return;\n  }\n  var ob = target.__ob__;\n  if (target._isVue || ob && ob.vmCount) {\n    process.env.NODE_ENV !== 'production' && warn('Avoid deleting properties on a Vue instance or its root $data ' + '- just set it to null.');\n    return;\n  }\n  if (!hasOwn(target, key)) {\n    return;\n  }\n  delete target[key];\n  if (!ob) {\n    return;\n  }\n  ob.dep.notify();\n}\n\n/**\n * Collect dependencies on array elements when the array is touched, since\n * we cannot intercept array element access like property getters.\n */\nfunction dependArray(value) {\n  for (var e = void 0, i = 0, l = value.length; i < l; i++) {\n    e = value[i];\n    e && e.__ob__ && e.__ob__.dep.depend();\n    if (Array.isArray(e)) {\n      dependArray(e);\n    }\n  }\n}\n\n/*  */\n\n/**\n * Option overwriting strategies are functions that handle\n * how to merge a parent option value and a child option\n * value into the final value.\n */\nvar strats = config.optionMergeStrategies;\n\n/**\n * Options with restrictions\n */\nif (process.env.NODE_ENV !== 'production') {\n  strats.el = strats.propsData = function (parent, child, vm, key) {\n    if (!vm) {\n      warn(\"option \\\"\" + key + \"\\\" can only be used during instance \" + 'creation with the `new` keyword.');\n    }\n    return defaultStrat(parent, child);\n  };\n}\n\n/**\n * Helper that recursively merges two data objects together.\n */\nfunction mergeData(to, from) {\n  if (!from) {\n    return to;\n  }\n  var key, toVal, fromVal;\n  var keys = Object.keys(from);\n  for (var i = 0; i < keys.length; i++) {\n    key = keys[i];\n    toVal = to[key];\n    fromVal = from[key];\n    if (!hasOwn(to, key)) {\n      set(to, key, fromVal);\n    } else if (isPlainObject(toVal) && isPlainObject(fromVal)) {\n      mergeData(toVal, fromVal);\n    }\n  }\n  return to;\n}\n\n/**\n * Data\n */\nfunction mergeDataOrFn(parentVal, childVal, vm) {\n  if (!vm) {\n    // in a Vue.extend merge, both should be functions\n    if (!childVal) {\n      return parentVal;\n    }\n    if (!parentVal) {\n      return childVal;\n    }\n    // when parentVal & childVal are both present,\n    // we need to return a function that returns the\n    // merged result of both functions... no need to\n    // check if parentVal is a function here because\n    // it has to be a function to pass previous merges.\n    return function mergedDataFn() {\n      return mergeData(typeof childVal === 'function' ? childVal.call(this, this) : childVal, typeof parentVal === 'function' ? parentVal.call(this, this) : parentVal);\n    };\n  } else {\n    return function mergedInstanceDataFn() {\n      // instance merge\n      var instanceData = typeof childVal === 'function' ? childVal.call(vm, vm) : childVal;\n      var defaultData = typeof parentVal === 'function' ? parentVal.call(vm, vm) : parentVal;\n      if (instanceData) {\n        return mergeData(instanceData, defaultData);\n      } else {\n        return defaultData;\n      }\n    };\n  }\n}\n\nstrats.data = function (parentVal, childVal, vm) {\n  if (!vm) {\n    if (childVal && typeof childVal !== 'function') {\n      process.env.NODE_ENV !== 'production' && warn('The \"data\" option should be a function ' + 'that returns a per-instance value in component ' + 'definitions.', vm);\n\n      return parentVal;\n    }\n    return mergeDataOrFn(parentVal, childVal);\n  }\n\n  return mergeDataOrFn(parentVal, childVal, vm);\n};\n\n/**\n * Hooks and props are merged as arrays.\n */\nfunction mergeHook(parentVal, childVal) {\n  return childVal ? parentVal ? parentVal.concat(childVal) : Array.isArray(childVal) ? childVal : [childVal] : parentVal;\n}\n\nLIFECYCLE_HOOKS.forEach(function (hook) {\n  strats[hook] = mergeHook;\n});\n\n/**\n * Assets\n *\n * When a vm is present (instance creation), we need to do\n * a three-way merge between constructor options, instance\n * options and parent options.\n */\nfunction mergeAssets(parentVal, childVal, vm, key) {\n  var res = Object.create(parentVal || null);\n  if (childVal) {\n    process.env.NODE_ENV !== 'production' && assertObjectType(key, childVal, vm);\n    return extend(res, childVal);\n  } else {\n    return res;\n  }\n}\n\nASSET_TYPES.forEach(function (type) {\n  strats[type + 's'] = mergeAssets;\n});\n\n/**\n * Watchers.\n *\n * Watchers hashes should not overwrite one\n * another, so we merge them as arrays.\n */\nstrats.watch = function (parentVal, childVal, vm, key) {\n  // work around Firefox's Object.prototype.watch...\n  if (parentVal === nativeWatch) {\n    parentVal = undefined;\n  }\n  if (childVal === nativeWatch) {\n    childVal = undefined;\n  }\n  /* istanbul ignore if */\n  if (!childVal) {\n    return Object.create(parentVal || null);\n  }\n  if (process.env.NODE_ENV !== 'production') {\n    assertObjectType(key, childVal, vm);\n  }\n  if (!parentVal) {\n    return childVal;\n  }\n  var ret = {};\n  extend(ret, parentVal);\n  for (var key$1 in childVal) {\n    var parent = ret[key$1];\n    var child = childVal[key$1];\n    if (parent && !Array.isArray(parent)) {\n      parent = [parent];\n    }\n    ret[key$1] = parent ? parent.concat(child) : Array.isArray(child) ? child : [child];\n  }\n  return ret;\n};\n\n/**\n * Other object hashes.\n */\nstrats.props = strats.methods = strats.inject = strats.computed = function (parentVal, childVal, vm, key) {\n  if (childVal && process.env.NODE_ENV !== 'production') {\n    assertObjectType(key, childVal, vm);\n  }\n  if (!parentVal) {\n    return childVal;\n  }\n  var ret = Object.create(null);\n  extend(ret, parentVal);\n  if (childVal) {\n    extend(ret, childVal);\n  }\n  return ret;\n};\nstrats.provide = mergeDataOrFn;\n\n/**\n * Default strategy.\n */\nvar defaultStrat = function defaultStrat(parentVal, childVal) {\n  return childVal === undefined ? parentVal : childVal;\n};\n\n/**\n * Validate component names\n */\nfunction checkComponents(options) {\n  for (var key in options.components) {\n    validateComponentName(key);\n  }\n}\n\nfunction validateComponentName(name) {\n  if (!/^[a-zA-Z][\\w-]*$/.test(name)) {\n    warn('Invalid component name: \"' + name + '\". Component names ' + 'can only contain alphanumeric characters and the hyphen, ' + 'and must start with a letter.');\n  }\n  if (isBuiltInTag(name) || config.isReservedTag(name)) {\n    warn('Do not use built-in or reserved HTML elements as component ' + 'id: ' + name);\n  }\n}\n\n/**\n * Ensure all props option syntax are normalized into the\n * Object-based format.\n */\nfunction normalizeProps(options, vm) {\n  var props = options.props;\n  if (!props) {\n    return;\n  }\n  var res = {};\n  var i, val, name;\n  if (Array.isArray(props)) {\n    i = props.length;\n    while (i--) {\n      val = props[i];\n      if (typeof val === 'string') {\n        name = camelize(val);\n        res[name] = { type: null };\n      } else if (process.env.NODE_ENV !== 'production') {\n        warn('props must be strings when using array syntax.');\n      }\n    }\n  } else if (isPlainObject(props)) {\n    for (var key in props) {\n      val = props[key];\n      name = camelize(key);\n      if (process.env.NODE_ENV !== 'production' && isPlainObject(val)) {\n        validatePropObject(name, val, vm);\n      }\n      res[name] = isPlainObject(val) ? val : { type: val };\n    }\n  } else if (process.env.NODE_ENV !== 'production') {\n    warn(\"Invalid value for option \\\"props\\\": expected an Array or an Object, \" + \"but got \" + toRawType(props) + \".\", vm);\n  }\n  options.props = res;\n}\n\n/**\n * Validate whether a prop object keys are valid.\n */\nvar propOptionsRE = /^(type|default|required|validator)$/;\n\nfunction validatePropObject(propName, prop, vm) {\n  for (var key in prop) {\n    if (!propOptionsRE.test(key)) {\n      warn(\"Invalid key \\\"\" + key + \"\\\" in validation rules object for prop \\\"\" + propName + \"\\\".\", vm);\n    }\n  }\n}\n\n/**\n * Normalize all injections into Object-based format\n */\nfunction normalizeInject(options, vm) {\n  var inject = options.inject;\n  var normalized = options.inject = {};\n  if (Array.isArray(inject)) {\n    for (var i = 0; i < inject.length; i++) {\n      normalized[inject[i]] = { from: inject[i] };\n    }\n  } else if (isPlainObject(inject)) {\n    for (var key in inject) {\n      var val = inject[key];\n      normalized[key] = isPlainObject(val) ? extend({ from: key }, val) : { from: val };\n    }\n  } else if (process.env.NODE_ENV !== 'production' && inject) {\n    warn(\"Invalid value for option \\\"inject\\\": expected an Array or an Object, \" + \"but got \" + toRawType(inject) + \".\", vm);\n  }\n}\n\n/**\n * Normalize raw function directives into object format.\n */\nfunction normalizeDirectives(options) {\n  var dirs = options.directives;\n  if (dirs) {\n    for (var key in dirs) {\n      var def = dirs[key];\n      if (typeof def === 'function') {\n        dirs[key] = { bind: def, update: def };\n      }\n    }\n  }\n}\n\nfunction assertObjectType(name, value, vm) {\n  if (!isPlainObject(value)) {\n    warn(\"Invalid value for option \\\"\" + name + \"\\\": expected an Object, \" + \"but got \" + toRawType(value) + \".\", vm);\n  }\n}\n\n/**\n * Merge two option objects into a new one.\n * Core utility used in both instantiation and inheritance.\n */\nfunction mergeOptions(parent, child, vm) {\n  if (process.env.NODE_ENV !== 'production') {\n    checkComponents(child);\n  }\n\n  if (typeof child === 'function') {\n    child = child.options;\n  }\n\n  normalizeProps(child, vm);\n  normalizeInject(child, vm);\n  normalizeDirectives(child);\n  var extendsFrom = child.extends;\n  if (extendsFrom) {\n    parent = mergeOptions(parent, extendsFrom, vm);\n  }\n  if (child.mixins) {\n    for (var i = 0, l = child.mixins.length; i < l; i++) {\n      parent = mergeOptions(parent, child.mixins[i], vm);\n    }\n  }\n  var options = {};\n  var key;\n  for (key in parent) {\n    mergeField(key);\n  }\n  for (key in child) {\n    if (!hasOwn(parent, key)) {\n      mergeField(key);\n    }\n  }\n  function mergeField(key) {\n    var strat = strats[key] || defaultStrat;\n    options[key] = strat(parent[key], child[key], vm, key);\n  }\n  return options;\n}\n\n/**\n * Resolve an asset.\n * This function is used because child instances need access\n * to assets defined in its ancestor chain.\n */\nfunction resolveAsset(options, type, id, warnMissing) {\n  /* istanbul ignore if */\n  if (typeof id !== 'string') {\n    return;\n  }\n  var assets = options[type];\n  // check local registration variations first\n  if (hasOwn(assets, id)) {\n    return assets[id];\n  }\n  var camelizedId = camelize(id);\n  if (hasOwn(assets, camelizedId)) {\n    return assets[camelizedId];\n  }\n  var PascalCaseId = capitalize(camelizedId);\n  if (hasOwn(assets, PascalCaseId)) {\n    return assets[PascalCaseId];\n  }\n  // fallback to prototype chain\n  var res = assets[id] || assets[camelizedId] || assets[PascalCaseId];\n  if (process.env.NODE_ENV !== 'production' && warnMissing && !res) {\n    warn('Failed to resolve ' + type.slice(0, -1) + ': ' + id, options);\n  }\n  return res;\n}\n\n/*  */\n\nfunction validateProp(key, propOptions, propsData, vm) {\n  var prop = propOptions[key];\n  var absent = !hasOwn(propsData, key);\n  var value = propsData[key];\n  // handle boolean props\n  if (isType(Boolean, prop.type)) {\n    if (absent && !hasOwn(prop, 'default')) {\n      value = false;\n    } else if (!isType(String, prop.type) && (value === '' || value === hyphenate(key))) {\n      value = true;\n    }\n  }\n  // check default value\n  if (value === undefined) {\n    value = getPropDefaultValue(vm, prop, key);\n    // since the default value is a fresh copy,\n    // make sure to observe it.\n    var prevShouldConvert = observerState.shouldConvert;\n    observerState.shouldConvert = true;\n    observe(value);\n    observerState.shouldConvert = prevShouldConvert;\n  }\n  if (process.env.NODE_ENV !== 'production') {\n    assertProp(prop, key, value, vm, absent);\n  }\n  return value;\n}\n\n/**\n * Get the default value of a prop.\n */\nfunction getPropDefaultValue(vm, prop, key) {\n  // no default, return undefined\n  if (!hasOwn(prop, 'default')) {\n    return undefined;\n  }\n  var def = prop.default;\n  // warn against non-factory defaults for Object & Array\n  if (process.env.NODE_ENV !== 'production' && isObject(def)) {\n    warn('Invalid default value for prop \"' + key + '\": ' + 'Props with type Object/Array must use a factory function ' + 'to return the default value.', vm);\n  }\n  // the raw prop value was also undefined from previous render,\n  // return previous default value to avoid unnecessary watcher trigger\n  if (vm && vm.$options.propsData && vm.$options.propsData[key] === undefined && vm._props[key] !== undefined) {\n    return vm._props[key];\n  }\n  // call factory function for non-Function types\n  // a value is Function if its prototype is function even across different execution context\n  return typeof def === 'function' && getType(prop.type) !== 'Function' ? def.call(vm) : def;\n}\n\n/**\n * Assert whether a prop is valid.\n */\nfunction assertProp(prop, name, value, vm, absent) {\n  if (prop.required && absent) {\n    warn('Missing required prop: \"' + name + '\"', vm);\n    return;\n  }\n  if (value == null && !prop.required) {\n    return;\n  }\n  var type = prop.type;\n  var valid = !type || type === true;\n  var expectedTypes = [];\n  if (type) {\n    if (!Array.isArray(type)) {\n      type = [type];\n    }\n    for (var i = 0; i < type.length && !valid; i++) {\n      var assertedType = assertType(value, type[i]);\n      expectedTypes.push(assertedType.expectedType || '');\n      valid = assertedType.valid;\n    }\n  }\n  if (!valid) {\n    warn(\"Invalid prop: type check failed for prop \\\"\" + name + \"\\\".\" + \" Expected \" + expectedTypes.map(capitalize).join(', ') + \", got \" + toRawType(value) + \".\", vm);\n    return;\n  }\n  var validator = prop.validator;\n  if (validator) {\n    if (!validator(value)) {\n      warn('Invalid prop: custom validator check failed for prop \"' + name + '\".', vm);\n    }\n  }\n}\n\nvar simpleCheckRE = /^(String|Number|Boolean|Function|Symbol)$/;\n\nfunction assertType(value, type) {\n  var valid;\n  var expectedType = getType(type);\n  if (simpleCheckRE.test(expectedType)) {\n    var t = typeof value === 'undefined' ? 'undefined' : _typeof(value);\n    valid = t === expectedType.toLowerCase();\n    // for primitive wrapper objects\n    if (!valid && t === 'object') {\n      valid = value instanceof type;\n    }\n  } else if (expectedType === 'Object') {\n    valid = isPlainObject(value);\n  } else if (expectedType === 'Array') {\n    valid = Array.isArray(value);\n  } else {\n    valid = value instanceof type;\n  }\n  return {\n    valid: valid,\n    expectedType: expectedType\n  };\n}\n\n/**\n * Use function string name to check built-in types,\n * because a simple equality check will fail when running\n * across different vms / iframes.\n */\nfunction getType(fn) {\n  var match = fn && fn.toString().match(/^\\s*function (\\w+)/);\n  return match ? match[1] : '';\n}\n\nfunction isType(type, fn) {\n  if (!Array.isArray(fn)) {\n    return getType(fn) === getType(type);\n  }\n  for (var i = 0, len = fn.length; i < len; i++) {\n    if (getType(fn[i]) === getType(type)) {\n      return true;\n    }\n  }\n  /* istanbul ignore next */\n  return false;\n}\n\n/*  */\n\nfunction handleError(err, vm, info) {\n  if (vm) {\n    var cur = vm;\n    while (cur = cur.$parent) {\n      var hooks = cur.$options.errorCaptured;\n      if (hooks) {\n        for (var i = 0; i < hooks.length; i++) {\n          try {\n            var capture = hooks[i].call(cur, err, vm, info) === false;\n            if (capture) {\n              return;\n            }\n          } catch (e) {\n            globalHandleError(e, cur, 'errorCaptured hook');\n          }\n        }\n      }\n    }\n  }\n  globalHandleError(err, vm, info);\n}\n\nfunction globalHandleError(err, vm, info) {\n  if (config.errorHandler) {\n    try {\n      return config.errorHandler.call(null, err, vm, info);\n    } catch (e) {\n      logError(e, null, 'config.errorHandler');\n    }\n  }\n  logError(err, vm, info);\n}\n\nfunction logError(err, vm, info) {\n  if (process.env.NODE_ENV !== 'production') {\n    warn(\"Error in \" + info + \": \\\"\" + err.toString() + \"\\\"\", vm);\n  }\n  /* istanbul ignore else */\n  if ((inBrowser || inWeex) && typeof console !== 'undefined') {\n    console.error(err);\n  } else {\n    throw err;\n  }\n}\n\n/*  */\n/* globals MessageChannel */\n\nvar callbacks = [];\nvar pending = false;\n\nfunction flushCallbacks() {\n  pending = false;\n  var copies = callbacks.slice(0);\n  callbacks.length = 0;\n  for (var i = 0; i < copies.length; i++) {\n    copies[i]();\n  }\n}\n\n// Here we have async deferring wrappers using both micro and macro tasks.\n// In < 2.4 we used micro tasks everywhere, but there are some scenarios where\n// micro tasks have too high a priority and fires in between supposedly\n// sequential events (e.g. #4521, #6690) or even between bubbling of the same\n// event (#6566). However, using macro tasks everywhere also has subtle problems\n// when state is changed right before repaint (e.g. #6813, out-in transitions).\n// Here we use micro task by default, but expose a way to force macro task when\n// needed (e.g. in event handlers attached by v-on).\nvar microTimerFunc;\nvar macroTimerFunc;\nvar useMacroTask = false;\n\n// Determine (macro) Task defer implementation.\n// Technically setImmediate should be the ideal choice, but it's only available\n// in IE. The only polyfill that consistently queues the callback after all DOM\n// events triggered in the same loop is by using MessageChannel.\n/* istanbul ignore if */\nif (typeof setImmediate !== 'undefined' && isNative(setImmediate)) {\n  macroTimerFunc = function macroTimerFunc() {\n    setImmediate(flushCallbacks);\n  };\n} else if (typeof MessageChannel !== 'undefined' && (isNative(MessageChannel) ||\n// PhantomJS\nMessageChannel.toString() === '[object MessageChannelConstructor]')) {\n  var channel = new MessageChannel();\n  var port = channel.port2;\n  channel.port1.onmessage = flushCallbacks;\n  macroTimerFunc = function macroTimerFunc() {\n    port.postMessage(1);\n  };\n} else {\n  /* istanbul ignore next */\n  macroTimerFunc = function macroTimerFunc() {\n    setTimeout(flushCallbacks, 0);\n  };\n}\n\n// Determine MicroTask defer implementation.\n/* istanbul ignore next, $flow-disable-line */\nif (typeof Promise !== 'undefined' && isNative(Promise)) {\n  var p = Promise.resolve();\n  microTimerFunc = function microTimerFunc() {\n    p.then(flushCallbacks);\n    // in problematic UIWebViews, Promise.then doesn't completely break, but\n    // it can get stuck in a weird state where callbacks are pushed into the\n    // microtask queue but the queue isn't being flushed, until the browser\n    // needs to do some other work, e.g. handle a timer. Therefore we can\n    // \"force\" the microtask queue to be flushed by adding an empty timer.\n    if (isIOS) {\n      setTimeout(noop);\n    }\n  };\n} else {\n  // fallback to macro\n  microTimerFunc = macroTimerFunc;\n}\n\n/**\n * Wrap a function so that if any code inside triggers state change,\n * the changes are queued using a Task instead of a MicroTask.\n */\nfunction withMacroTask(fn) {\n  return fn._withTask || (fn._withTask = function () {\n    useMacroTask = true;\n    var res = fn.apply(null, arguments);\n    useMacroTask = false;\n    return res;\n  });\n}\n\nfunction nextTick(cb, ctx) {\n  var _resolve;\n  callbacks.push(function () {\n    if (cb) {\n      try {\n        cb.call(ctx);\n      } catch (e) {\n        handleError(e, ctx, 'nextTick');\n      }\n    } else if (_resolve) {\n      _resolve(ctx);\n    }\n  });\n  if (!pending) {\n    pending = true;\n    if (useMacroTask) {\n      macroTimerFunc();\n    } else {\n      microTimerFunc();\n    }\n  }\n  // $flow-disable-line\n  if (!cb && typeof Promise !== 'undefined') {\n    return new Promise(function (resolve) {\n      _resolve = resolve;\n    });\n  }\n}\n\n/*  */\n\nvar mark;\nvar measure;\n\nif (process.env.NODE_ENV !== 'production') {\n  var perf = inBrowser && window.performance;\n  /* istanbul ignore if */\n  if (perf && perf.mark && perf.measure && perf.clearMarks && perf.clearMeasures) {\n    mark = function mark(tag) {\n      return perf.mark(tag);\n    };\n    measure = function measure(name, startTag, endTag) {\n      perf.measure(name, startTag, endTag);\n      perf.clearMarks(startTag);\n      perf.clearMarks(endTag);\n      perf.clearMeasures(name);\n    };\n  }\n}\n\n/* not type checking this file because flow doesn't play well with Proxy */\n\nvar initProxy;\n\nif (process.env.NODE_ENV !== 'production') {\n  var allowedGlobals = makeMap('Infinity,undefined,NaN,isFinite,isNaN,' + 'parseFloat,parseInt,decodeURI,decodeURIComponent,encodeURI,encodeURIComponent,' + 'Math,Number,Date,Array,Object,Boolean,String,RegExp,Map,Set,JSON,Intl,' + 'require' // for Webpack/Browserify\n  );\n\n  var warnNonPresent = function warnNonPresent(target, key) {\n    warn(\"Property or method \\\"\" + key + \"\\\" is not defined on the instance but \" + 'referenced during render. Make sure that this property is reactive, ' + 'either in the data option, or for class-based components, by ' + 'initializing the property. ' + 'See: https://vuejs.org/v2/guide/reactivity.html#Declaring-Reactive-Properties.', target);\n  };\n\n  var hasProxy = typeof Proxy !== 'undefined' && Proxy.toString().match(/native code/);\n\n  if (hasProxy) {\n    var isBuiltInModifier = makeMap('stop,prevent,self,ctrl,shift,alt,meta,exact');\n    config.keyCodes = new Proxy(config.keyCodes, {\n      set: function set(target, key, value) {\n        if (isBuiltInModifier(key)) {\n          warn(\"Avoid overwriting built-in modifier in config.keyCodes: .\" + key);\n          return false;\n        } else {\n          target[key] = value;\n          return true;\n        }\n      }\n    });\n  }\n\n  var hasHandler = {\n    has: function has(target, key) {\n      var has = key in target;\n      var isAllowed = allowedGlobals(key) || key.charAt(0) === '_';\n      if (!has && !isAllowed) {\n        warnNonPresent(target, key);\n      }\n      return has || !isAllowed;\n    }\n  };\n\n  var getHandler = {\n    get: function get(target, key) {\n      if (typeof key === 'string' && !(key in target)) {\n        warnNonPresent(target, key);\n      }\n      return target[key];\n    }\n  };\n\n  initProxy = function initProxy(vm) {\n    if (hasProxy) {\n      // determine which proxy handler to use\n      var options = vm.$options;\n      var handlers = options.render && options.render._withStripped ? getHandler : hasHandler;\n      vm._renderProxy = new Proxy(vm, handlers);\n    } else {\n      vm._renderProxy = vm;\n    }\n  };\n}\n\n/*  */\n\nvar seenObjects = new _Set();\n\n/**\n * Recursively traverse an object to evoke all converted\n * getters, so that every nested property inside the object\n * is collected as a \"deep\" dependency.\n */\nfunction traverse(val) {\n  _traverse(val, seenObjects);\n  seenObjects.clear();\n}\n\nfunction _traverse(val, seen) {\n  var i, keys;\n  var isA = Array.isArray(val);\n  if (!isA && !isObject(val) || Object.isFrozen(val)) {\n    return;\n  }\n  if (val.__ob__) {\n    var depId = val.__ob__.dep.id;\n    if (seen.has(depId)) {\n      return;\n    }\n    seen.add(depId);\n  }\n  if (isA) {\n    i = val.length;\n    while (i--) {\n      _traverse(val[i], seen);\n    }\n  } else {\n    keys = Object.keys(val);\n    i = keys.length;\n    while (i--) {\n      _traverse(val[keys[i]], seen);\n    }\n  }\n}\n\n/*  */\n\nvar normalizeEvent = cached(function (name) {\n  var passive = name.charAt(0) === '&';\n  name = passive ? name.slice(1) : name;\n  var once$$1 = name.charAt(0) === '~'; // Prefixed last, checked first\n  name = once$$1 ? name.slice(1) : name;\n  var capture = name.charAt(0) === '!';\n  name = capture ? name.slice(1) : name;\n  return {\n    name: name,\n    once: once$$1,\n    capture: capture,\n    passive: passive\n  };\n});\n\nfunction createFnInvoker(fns) {\n  function invoker() {\n    var arguments$1 = arguments;\n\n    var fns = invoker.fns;\n    if (Array.isArray(fns)) {\n      var cloned = fns.slice();\n      for (var i = 0; i < cloned.length; i++) {\n        cloned[i].apply(null, arguments$1);\n      }\n    } else {\n      // return handler return value for single handlers\n      return fns.apply(null, arguments);\n    }\n  }\n  invoker.fns = fns;\n  return invoker;\n}\n\nfunction updateListeners(on, oldOn, add, remove$$1, vm) {\n  var name, cur, old, event;\n  for (name in on) {\n    cur = on[name];\n    old = oldOn[name];\n    event = normalizeEvent(name);\n    if (isUndef(cur)) {\n      process.env.NODE_ENV !== 'production' && warn(\"Invalid handler for event \\\"\" + event.name + \"\\\": got \" + String(cur), vm);\n    } else if (isUndef(old)) {\n      if (isUndef(cur.fns)) {\n        cur = on[name] = createFnInvoker(cur);\n      }\n      add(event.name, cur, event.once, event.capture, event.passive);\n    } else if (cur !== old) {\n      old.fns = cur;\n      on[name] = old;\n    }\n  }\n  for (name in oldOn) {\n    if (isUndef(on[name])) {\n      event = normalizeEvent(name);\n      remove$$1(event.name, oldOn[name], event.capture);\n    }\n  }\n}\n\n/*  */\n\nfunction mergeVNodeHook(def, hookKey, hook) {\n  if (def instanceof VNode) {\n    def = def.data.hook || (def.data.hook = {});\n  }\n  var invoker;\n  var oldHook = def[hookKey];\n\n  function wrappedHook() {\n    hook.apply(this, arguments);\n    // important: remove merged hook to ensure it's called only once\n    // and prevent memory leak\n    remove(invoker.fns, wrappedHook);\n  }\n\n  if (isUndef(oldHook)) {\n    // no existing hook\n    invoker = createFnInvoker([wrappedHook]);\n  } else {\n    /* istanbul ignore if */\n    if (isDef(oldHook.fns) && isTrue(oldHook.merged)) {\n      // already a merged invoker\n      invoker = oldHook;\n      invoker.fns.push(wrappedHook);\n    } else {\n      // existing plain hook\n      invoker = createFnInvoker([oldHook, wrappedHook]);\n    }\n  }\n\n  invoker.merged = true;\n  def[hookKey] = invoker;\n}\n\n/*  */\n\nfunction extractPropsFromVNodeData(data, Ctor, tag) {\n  // we are only extracting raw values here.\n  // validation and default values are handled in the child\n  // component itself.\n  var propOptions = Ctor.options.props;\n  if (isUndef(propOptions)) {\n    return;\n  }\n  var res = {};\n  var attrs = data.attrs;\n  var props = data.props;\n  if (isDef(attrs) || isDef(props)) {\n    for (var key in propOptions) {\n      var altKey = hyphenate(key);\n      if (process.env.NODE_ENV !== 'production') {\n        var keyInLowerCase = key.toLowerCase();\n        if (key !== keyInLowerCase && attrs && hasOwn(attrs, keyInLowerCase)) {\n          tip(\"Prop \\\"\" + keyInLowerCase + \"\\\" is passed to component \" + formatComponentName(tag || Ctor) + \", but the declared prop name is\" + \" \\\"\" + key + \"\\\". \" + \"Note that HTML attributes are case-insensitive and camelCased \" + \"props need to use their kebab-case equivalents when using in-DOM \" + \"templates. You should probably use \\\"\" + altKey + \"\\\" instead of \\\"\" + key + \"\\\".\");\n        }\n      }\n      checkProp(res, props, key, altKey, true) || checkProp(res, attrs, key, altKey, false);\n    }\n  }\n  return res;\n}\n\nfunction checkProp(res, hash, key, altKey, preserve) {\n  if (isDef(hash)) {\n    if (hasOwn(hash, key)) {\n      res[key] = hash[key];\n      if (!preserve) {\n        delete hash[key];\n      }\n      return true;\n    } else if (hasOwn(hash, altKey)) {\n      res[key] = hash[altKey];\n      if (!preserve) {\n        delete hash[altKey];\n      }\n      return true;\n    }\n  }\n  return false;\n}\n\n/*  */\n\n// The template compiler attempts to minimize the need for normalization by\n// statically analyzing the template at compile time.\n//\n// For plain HTML markup, normalization can be completely skipped because the\n// generated render function is guaranteed to return Array<VNode>. There are\n// two cases where extra normalization is needed:\n\n// 1. When the children contains components - because a functional component\n// may return an Array instead of a single root. In this case, just a simple\n// normalization is needed - if any child is an Array, we flatten the whole\n// thing with Array.prototype.concat. It is guaranteed to be only 1-level deep\n// because functional components already normalize their own children.\nfunction simpleNormalizeChildren(children) {\n  for (var i = 0; i < children.length; i++) {\n    if (Array.isArray(children[i])) {\n      return Array.prototype.concat.apply([], children);\n    }\n  }\n  return children;\n}\n\n// 2. When the children contains constructs that always generated nested Arrays,\n// e.g. <template>, <slot>, v-for, or when the children is provided by user\n// with hand-written render functions / JSX. In such cases a full normalization\n// is needed to cater to all possible types of children values.\nfunction normalizeChildren(children) {\n  return isPrimitive(children) ? [createTextVNode(children)] : Array.isArray(children) ? normalizeArrayChildren(children) : undefined;\n}\n\nfunction isTextNode(node) {\n  return isDef(node) && isDef(node.text) && isFalse(node.isComment);\n}\n\nfunction normalizeArrayChildren(children, nestedIndex) {\n  var res = [];\n  var i, c, lastIndex, last;\n  for (i = 0; i < children.length; i++) {\n    c = children[i];\n    if (isUndef(c) || typeof c === 'boolean') {\n      continue;\n    }\n    lastIndex = res.length - 1;\n    last = res[lastIndex];\n    //  nested\n    if (Array.isArray(c)) {\n      if (c.length > 0) {\n        c = normalizeArrayChildren(c, (nestedIndex || '') + \"_\" + i);\n        // merge adjacent text nodes\n        if (isTextNode(c[0]) && isTextNode(last)) {\n          res[lastIndex] = createTextVNode(last.text + c[0].text);\n          c.shift();\n        }\n        res.push.apply(res, c);\n      }\n    } else if (isPrimitive(c)) {\n      if (isTextNode(last)) {\n        // merge adjacent text nodes\n        // this is necessary for SSR hydration because text nodes are\n        // essentially merged when rendered to HTML strings\n        res[lastIndex] = createTextVNode(last.text + c);\n      } else if (c !== '') {\n        // convert primitive to vnode\n        res.push(createTextVNode(c));\n      }\n    } else {\n      if (isTextNode(c) && isTextNode(last)) {\n        // merge adjacent text nodes\n        res[lastIndex] = createTextVNode(last.text + c.text);\n      } else {\n        // default key for nested array children (likely generated by v-for)\n        if (isTrue(children._isVList) && isDef(c.tag) && isUndef(c.key) && isDef(nestedIndex)) {\n          c.key = \"__vlist\" + nestedIndex + \"_\" + i + \"__\";\n        }\n        res.push(c);\n      }\n    }\n  }\n  return res;\n}\n\n/*  */\n\nfunction ensureCtor(comp, base) {\n  if (comp.__esModule || hasSymbol && comp[Symbol.toStringTag] === 'Module') {\n    comp = comp.default;\n  }\n  return isObject(comp) ? base.extend(comp) : comp;\n}\n\nfunction createAsyncPlaceholder(factory, data, context, children, tag) {\n  var node = createEmptyVNode();\n  node.asyncFactory = factory;\n  node.asyncMeta = { data: data, context: context, children: children, tag: tag };\n  return node;\n}\n\nfunction resolveAsyncComponent(factory, baseCtor, context) {\n  if (isTrue(factory.error) && isDef(factory.errorComp)) {\n    return factory.errorComp;\n  }\n\n  if (isDef(factory.resolved)) {\n    return factory.resolved;\n  }\n\n  if (isTrue(factory.loading) && isDef(factory.loadingComp)) {\n    return factory.loadingComp;\n  }\n\n  if (isDef(factory.contexts)) {\n    // already pending\n    factory.contexts.push(context);\n  } else {\n    var contexts = factory.contexts = [context];\n    var sync = true;\n\n    var forceRender = function forceRender() {\n      for (var i = 0, l = contexts.length; i < l; i++) {\n        contexts[i].$forceUpdate();\n      }\n    };\n\n    var resolve = once(function (res) {\n      // cache resolved\n      factory.resolved = ensureCtor(res, baseCtor);\n      // invoke callbacks only if this is not a synchronous resolve\n      // (async resolves are shimmed as synchronous during SSR)\n      if (!sync) {\n        forceRender();\n      }\n    });\n\n    var reject = once(function (reason) {\n      process.env.NODE_ENV !== 'production' && warn(\"Failed to resolve async component: \" + String(factory) + (reason ? \"\\nReason: \" + reason : ''));\n      if (isDef(factory.errorComp)) {\n        factory.error = true;\n        forceRender();\n      }\n    });\n\n    var res = factory(resolve, reject);\n\n    if (isObject(res)) {\n      if (typeof res.then === 'function') {\n        // () => Promise\n        if (isUndef(factory.resolved)) {\n          res.then(resolve, reject);\n        }\n      } else if (isDef(res.component) && typeof res.component.then === 'function') {\n        res.component.then(resolve, reject);\n\n        if (isDef(res.error)) {\n          factory.errorComp = ensureCtor(res.error, baseCtor);\n        }\n\n        if (isDef(res.loading)) {\n          factory.loadingComp = ensureCtor(res.loading, baseCtor);\n          if (res.delay === 0) {\n            factory.loading = true;\n          } else {\n            setTimeout(function () {\n              if (isUndef(factory.resolved) && isUndef(factory.error)) {\n                factory.loading = true;\n                forceRender();\n              }\n            }, res.delay || 200);\n          }\n        }\n\n        if (isDef(res.timeout)) {\n          setTimeout(function () {\n            if (isUndef(factory.resolved)) {\n              reject(process.env.NODE_ENV !== 'production' ? \"timeout (\" + res.timeout + \"ms)\" : null);\n            }\n          }, res.timeout);\n        }\n      }\n    }\n\n    sync = false;\n    // return in case resolved synchronously\n    return factory.loading ? factory.loadingComp : factory.resolved;\n  }\n}\n\n/*  */\n\nfunction isAsyncPlaceholder(node) {\n  return node.isComment && node.asyncFactory;\n}\n\n/*  */\n\nfunction getFirstComponentChild(children) {\n  if (Array.isArray(children)) {\n    for (var i = 0; i < children.length; i++) {\n      var c = children[i];\n      if (isDef(c) && (isDef(c.componentOptions) || isAsyncPlaceholder(c))) {\n        return c;\n      }\n    }\n  }\n}\n\n/*  */\n\n/*  */\n\nfunction initEvents(vm) {\n  vm._events = Object.create(null);\n  vm._hasHookEvent = false;\n  // init parent attached events\n  var listeners = vm.$options._parentListeners;\n  if (listeners) {\n    updateComponentListeners(vm, listeners);\n  }\n}\n\nvar target;\n\nfunction add(event, fn, once) {\n  if (once) {\n    target.$once(event, fn);\n  } else {\n    target.$on(event, fn);\n  }\n}\n\nfunction remove$1(event, fn) {\n  target.$off(event, fn);\n}\n\nfunction updateComponentListeners(vm, listeners, oldListeners) {\n  target = vm;\n  updateListeners(listeners, oldListeners || {}, add, remove$1, vm);\n  target = undefined;\n}\n\nfunction eventsMixin(Vue) {\n  var hookRE = /^hook:/;\n  Vue.prototype.$on = function (event, fn) {\n    var this$1 = this;\n\n    var vm = this;\n    if (Array.isArray(event)) {\n      for (var i = 0, l = event.length; i < l; i++) {\n        this$1.$on(event[i], fn);\n      }\n    } else {\n      (vm._events[event] || (vm._events[event] = [])).push(fn);\n      // optimize hook:event cost by using a boolean flag marked at registration\n      // instead of a hash lookup\n      if (hookRE.test(event)) {\n        vm._hasHookEvent = true;\n      }\n    }\n    return vm;\n  };\n\n  Vue.prototype.$once = function (event, fn) {\n    var vm = this;\n    function on() {\n      vm.$off(event, on);\n      fn.apply(vm, arguments);\n    }\n    on.fn = fn;\n    vm.$on(event, on);\n    return vm;\n  };\n\n  Vue.prototype.$off = function (event, fn) {\n    var this$1 = this;\n\n    var vm = this;\n    // all\n    if (!arguments.length) {\n      vm._events = Object.create(null);\n      return vm;\n    }\n    // array of events\n    if (Array.isArray(event)) {\n      for (var i = 0, l = event.length; i < l; i++) {\n        this$1.$off(event[i], fn);\n      }\n      return vm;\n    }\n    // specific event\n    var cbs = vm._events[event];\n    if (!cbs) {\n      return vm;\n    }\n    if (!fn) {\n      vm._events[event] = null;\n      return vm;\n    }\n    if (fn) {\n      // specific handler\n      var cb;\n      var i$1 = cbs.length;\n      while (i$1--) {\n        cb = cbs[i$1];\n        if (cb === fn || cb.fn === fn) {\n          cbs.splice(i$1, 1);\n          break;\n        }\n      }\n    }\n    return vm;\n  };\n\n  Vue.prototype.$emit = function (event) {\n    var vm = this;\n    if (process.env.NODE_ENV !== 'production') {\n      var lowerCaseEvent = event.toLowerCase();\n      if (lowerCaseEvent !== event && vm._events[lowerCaseEvent]) {\n        tip(\"Event \\\"\" + lowerCaseEvent + \"\\\" is emitted in component \" + formatComponentName(vm) + \" but the handler is registered for \\\"\" + event + \"\\\". \" + \"Note that HTML attributes are case-insensitive and you cannot use \" + \"v-on to listen to camelCase events when using in-DOM templates. \" + \"You should probably use \\\"\" + hyphenate(event) + \"\\\" instead of \\\"\" + event + \"\\\".\");\n      }\n    }\n    var cbs = vm._events[event];\n    if (cbs) {\n      cbs = cbs.length > 1 ? toArray(cbs) : cbs;\n      var args = toArray(arguments, 1);\n      for (var i = 0, l = cbs.length; i < l; i++) {\n        try {\n          cbs[i].apply(vm, args);\n        } catch (e) {\n          handleError(e, vm, \"event handler for \\\"\" + event + \"\\\"\");\n        }\n      }\n    }\n    return vm;\n  };\n}\n\n/*  */\n\n/**\n * Runtime helper for resolving raw children VNodes into a slot object.\n */\nfunction resolveSlots(children, context) {\n  var slots = {};\n  if (!children) {\n    return slots;\n  }\n  for (var i = 0, l = children.length; i < l; i++) {\n    var child = children[i];\n    var data = child.data;\n    // remove slot attribute if the node is resolved as a Vue slot node\n    if (data && data.attrs && data.attrs.slot) {\n      delete data.attrs.slot;\n    }\n    // named slots should only be respected if the vnode was rendered in the\n    // same context.\n    if ((child.context === context || child.fnContext === context) && data && data.slot != null) {\n      var name = data.slot;\n      var slot = slots[name] || (slots[name] = []);\n      if (child.tag === 'template') {\n        slot.push.apply(slot, child.children || []);\n      } else {\n        slot.push(child);\n      }\n    } else {\n      (slots.default || (slots.default = [])).push(child);\n    }\n  }\n  // ignore slots that contains only whitespace\n  for (var name$1 in slots) {\n    if (slots[name$1].every(isWhitespace)) {\n      delete slots[name$1];\n    }\n  }\n  return slots;\n}\n\nfunction isWhitespace(node) {\n  return node.isComment && !node.asyncFactory || node.text === ' ';\n}\n\nfunction resolveScopedSlots(fns, // see flow/vnode\nres) {\n  res = res || {};\n  for (var i = 0; i < fns.length; i++) {\n    if (Array.isArray(fns[i])) {\n      resolveScopedSlots(fns[i], res);\n    } else {\n      res[fns[i].key] = fns[i].fn;\n    }\n  }\n  return res;\n}\n\n/*  */\n\nvar activeInstance = null;\nvar isUpdatingChildComponent = false;\n\nfunction initLifecycle(vm) {\n  var options = vm.$options;\n\n  // locate first non-abstract parent\n  var parent = options.parent;\n  if (parent && !options.abstract) {\n    while (parent.$options.abstract && parent.$parent) {\n      parent = parent.$parent;\n    }\n    parent.$children.push(vm);\n  }\n\n  vm.$parent = parent;\n  vm.$root = parent ? parent.$root : vm;\n\n  vm.$children = [];\n  vm.$refs = {};\n\n  vm._watcher = null;\n  vm._inactive = null;\n  vm._directInactive = false;\n  vm._isMounted = false;\n  vm._isDestroyed = false;\n  vm._isBeingDestroyed = false;\n}\n\nfunction lifecycleMixin(Vue) {\n  Vue.prototype._update = function (vnode, hydrating) {\n    var vm = this;\n    if (vm._isMounted) {\n      callHook(vm, 'beforeUpdate');\n    }\n    var prevEl = vm.$el;\n    var prevVnode = vm._vnode;\n    var prevActiveInstance = activeInstance;\n    activeInstance = vm;\n    vm._vnode = vnode;\n    // Vue.prototype.__patch__ is injected in entry points\n    // based on the rendering backend used.\n    if (!prevVnode) {\n      // initial render\n      vm.$el = vm.__patch__(vm.$el, vnode, hydrating, false /* removeOnly */\n      , vm.$options._parentElm, vm.$options._refElm);\n      // no need for the ref nodes after initial patch\n      // this prevents keeping a detached DOM tree in memory (#5851)\n      vm.$options._parentElm = vm.$options._refElm = null;\n    } else {\n      // updates\n      vm.$el = vm.__patch__(prevVnode, vnode);\n    }\n    activeInstance = prevActiveInstance;\n    // update __vue__ reference\n    if (prevEl) {\n      prevEl.__vue__ = null;\n    }\n    if (vm.$el) {\n      vm.$el.__vue__ = vm;\n    }\n    // if parent is an HOC, update its $el as well\n    if (vm.$vnode && vm.$parent && vm.$vnode === vm.$parent._vnode) {\n      vm.$parent.$el = vm.$el;\n    }\n    // updated hook is called by the scheduler to ensure that children are\n    // updated in a parent's updated hook.\n  };\n\n  Vue.prototype.$forceUpdate = function () {\n    var vm = this;\n    if (vm._watcher) {\n      vm._watcher.update();\n    }\n  };\n\n  Vue.prototype.$destroy = function () {\n    var vm = this;\n    if (vm._isBeingDestroyed) {\n      return;\n    }\n    callHook(vm, 'beforeDestroy');\n    vm._isBeingDestroyed = true;\n    // remove self from parent\n    var parent = vm.$parent;\n    if (parent && !parent._isBeingDestroyed && !vm.$options.abstract) {\n      remove(parent.$children, vm);\n    }\n    // teardown watchers\n    if (vm._watcher) {\n      vm._watcher.teardown();\n    }\n    var i = vm._watchers.length;\n    while (i--) {\n      vm._watchers[i].teardown();\n    }\n    // remove reference from data ob\n    // frozen object may not have observer.\n    if (vm._data.__ob__) {\n      vm._data.__ob__.vmCount--;\n    }\n    // call the last hook...\n    vm._isDestroyed = true;\n    // invoke destroy hooks on current rendered tree\n    vm.__patch__(vm._vnode, null);\n    // fire destroyed hook\n    callHook(vm, 'destroyed');\n    // turn off all instance listeners.\n    vm.$off();\n    // remove __vue__ reference\n    if (vm.$el) {\n      vm.$el.__vue__ = null;\n    }\n    // release circular reference (#6759)\n    if (vm.$vnode) {\n      vm.$vnode.parent = null;\n    }\n  };\n}\n\nfunction mountComponent(vm, el, hydrating) {\n  vm.$el = el;\n  if (!vm.$options.render) {\n    vm.$options.render = createEmptyVNode;\n    if (process.env.NODE_ENV !== 'production') {\n      /* istanbul ignore if */\n      if (vm.$options.template && vm.$options.template.charAt(0) !== '#' || vm.$options.el || el) {\n        warn('You are using the runtime-only build of Vue where the template ' + 'compiler is not available. Either pre-compile the templates into ' + 'render functions, or use the compiler-included build.', vm);\n      } else {\n        warn('Failed to mount component: template or render function not defined.', vm);\n      }\n    }\n  }\n  callHook(vm, 'beforeMount');\n\n  var updateComponent;\n  /* istanbul ignore if */\n  if (process.env.NODE_ENV !== 'production' && config.performance && mark) {\n    updateComponent = function updateComponent() {\n      var name = vm._name;\n      var id = vm._uid;\n      var startTag = \"vue-perf-start:\" + id;\n      var endTag = \"vue-perf-end:\" + id;\n\n      mark(startTag);\n      var vnode = vm._render();\n      mark(endTag);\n      measure(\"vue \" + name + \" render\", startTag, endTag);\n\n      mark(startTag);\n      vm._update(vnode, hydrating);\n      mark(endTag);\n      measure(\"vue \" + name + \" patch\", startTag, endTag);\n    };\n  } else {\n    updateComponent = function updateComponent() {\n      vm._update(vm._render(), hydrating);\n    };\n  }\n\n  // we set this to vm._watcher inside the watcher's constructor\n  // since the watcher's initial patch may call $forceUpdate (e.g. inside child\n  // component's mounted hook), which relies on vm._watcher being already defined\n  new Watcher(vm, updateComponent, noop, null, true /* isRenderWatcher */);\n  hydrating = false;\n\n  // manually mounted instance, call mounted on self\n  // mounted is called for render-created child components in its inserted hook\n  if (vm.$vnode == null) {\n    vm._isMounted = true;\n    callHook(vm, 'mounted');\n  }\n  return vm;\n}\n\nfunction updateChildComponent(vm, propsData, listeners, parentVnode, renderChildren) {\n  if (process.env.NODE_ENV !== 'production') {\n    isUpdatingChildComponent = true;\n  }\n\n  // determine whether component has slot children\n  // we need to do this before overwriting $options._renderChildren\n  var hasChildren = !!(renderChildren || // has new static slots\n  vm.$options._renderChildren || // has old static slots\n  parentVnode.data.scopedSlots || // has new scoped slots\n  vm.$scopedSlots !== emptyObject // has old scoped slots\n  );\n\n  vm.$options._parentVnode = parentVnode;\n  vm.$vnode = parentVnode; // update vm's placeholder node without re-render\n\n  if (vm._vnode) {\n    // update child tree's parent\n    vm._vnode.parent = parentVnode;\n  }\n  vm.$options._renderChildren = renderChildren;\n\n  // update $attrs and $listeners hash\n  // these are also reactive so they may trigger child update if the child\n  // used them during render\n  vm.$attrs = parentVnode.data && parentVnode.data.attrs || emptyObject;\n  vm.$listeners = listeners || emptyObject;\n\n  // update props\n  if (propsData && vm.$options.props) {\n    observerState.shouldConvert = false;\n    var props = vm._props;\n    var propKeys = vm.$options._propKeys || [];\n    for (var i = 0; i < propKeys.length; i++) {\n      var key = propKeys[i];\n      props[key] = validateProp(key, vm.$options.props, propsData, vm);\n    }\n    observerState.shouldConvert = true;\n    // keep a copy of raw propsData\n    vm.$options.propsData = propsData;\n  }\n\n  // update listeners\n  if (listeners) {\n    var oldListeners = vm.$options._parentListeners;\n    vm.$options._parentListeners = listeners;\n    updateComponentListeners(vm, listeners, oldListeners);\n  }\n  // resolve slots + force update if has children\n  if (hasChildren) {\n    vm.$slots = resolveSlots(renderChildren, parentVnode.context);\n    vm.$forceUpdate();\n  }\n\n  if (process.env.NODE_ENV !== 'production') {\n    isUpdatingChildComponent = false;\n  }\n}\n\nfunction isInInactiveTree(vm) {\n  while (vm && (vm = vm.$parent)) {\n    if (vm._inactive) {\n      return true;\n    }\n  }\n  return false;\n}\n\nfunction activateChildComponent(vm, direct) {\n  if (direct) {\n    vm._directInactive = false;\n    if (isInInactiveTree(vm)) {\n      return;\n    }\n  } else if (vm._directInactive) {\n    return;\n  }\n  if (vm._inactive || vm._inactive === null) {\n    vm._inactive = false;\n    for (var i = 0; i < vm.$children.length; i++) {\n      activateChildComponent(vm.$children[i]);\n    }\n    callHook(vm, 'activated');\n  }\n}\n\nfunction deactivateChildComponent(vm, direct) {\n  if (direct) {\n    vm._directInactive = true;\n    if (isInInactiveTree(vm)) {\n      return;\n    }\n  }\n  if (!vm._inactive) {\n    vm._inactive = true;\n    for (var i = 0; i < vm.$children.length; i++) {\n      deactivateChildComponent(vm.$children[i]);\n    }\n    callHook(vm, 'deactivated');\n  }\n}\n\nfunction callHook(vm, hook) {\n  var handlers = vm.$options[hook];\n  if (handlers) {\n    for (var i = 0, j = handlers.length; i < j; i++) {\n      try {\n        handlers[i].call(vm);\n      } catch (e) {\n        handleError(e, vm, hook + \" hook\");\n      }\n    }\n  }\n  if (vm._hasHookEvent) {\n    vm.$emit('hook:' + hook);\n  }\n}\n\n/*  */\n\nvar MAX_UPDATE_COUNT = 100;\n\nvar queue = [];\nvar activatedChildren = [];\nvar has = {};\nvar circular = {};\nvar waiting = false;\nvar flushing = false;\nvar index = 0;\n\n/**\n * Reset the scheduler's state.\n */\nfunction resetSchedulerState() {\n  index = queue.length = activatedChildren.length = 0;\n  has = {};\n  if (process.env.NODE_ENV !== 'production') {\n    circular = {};\n  }\n  waiting = flushing = false;\n}\n\n/**\n * Flush both queues and run the watchers.\n */\nfunction flushSchedulerQueue() {\n  flushing = true;\n  var watcher, id;\n\n  // Sort queue before flush.\n  // This ensures that:\n  // 1. Components are updated from parent to child. (because parent is always\n  //    created before the child)\n  // 2. A component's user watchers are run before its render watcher (because\n  //    user watchers are created before the render watcher)\n  // 3. If a component is destroyed during a parent component's watcher run,\n  //    its watchers can be skipped.\n  queue.sort(function (a, b) {\n    return a.id - b.id;\n  });\n\n  // do not cache length because more watchers might be pushed\n  // as we run existing watchers\n  for (index = 0; index < queue.length; index++) {\n    watcher = queue[index];\n    id = watcher.id;\n    has[id] = null;\n    watcher.run();\n    // in dev build, check and stop circular updates.\n    if (process.env.NODE_ENV !== 'production' && has[id] != null) {\n      circular[id] = (circular[id] || 0) + 1;\n      if (circular[id] > MAX_UPDATE_COUNT) {\n        warn('You may have an infinite update loop ' + (watcher.user ? \"in watcher with expression \\\"\" + watcher.expression + \"\\\"\" : \"in a component render function.\"), watcher.vm);\n        break;\n      }\n    }\n  }\n\n  // keep copies of post queues before resetting state\n  var activatedQueue = activatedChildren.slice();\n  var updatedQueue = queue.slice();\n\n  resetSchedulerState();\n\n  // call component updated and activated hooks\n  callActivatedHooks(activatedQueue);\n  callUpdatedHooks(updatedQueue);\n\n  // devtool hook\n  /* istanbul ignore if */\n  if (devtools && config.devtools) {\n    devtools.emit('flush');\n  }\n}\n\nfunction callUpdatedHooks(queue) {\n  var i = queue.length;\n  while (i--) {\n    var watcher = queue[i];\n    var vm = watcher.vm;\n    if (vm._watcher === watcher && vm._isMounted) {\n      callHook(vm, 'updated');\n    }\n  }\n}\n\n/**\n * Queue a kept-alive component that was activated during patch.\n * The queue will be processed after the entire tree has been patched.\n */\nfunction queueActivatedComponent(vm) {\n  // setting _inactive to false here so that a render function can\n  // rely on checking whether it's in an inactive tree (e.g. router-view)\n  vm._inactive = false;\n  activatedChildren.push(vm);\n}\n\nfunction callActivatedHooks(queue) {\n  for (var i = 0; i < queue.length; i++) {\n    queue[i]._inactive = true;\n    activateChildComponent(queue[i], true /* true */);\n  }\n}\n\n/**\n * Push a watcher into the watcher queue.\n * Jobs with duplicate IDs will be skipped unless it's\n * pushed when the queue is being flushed.\n */\nfunction queueWatcher(watcher) {\n  var id = watcher.id;\n  if (has[id] == null) {\n    has[id] = true;\n    if (!flushing) {\n      queue.push(watcher);\n    } else {\n      // if already flushing, splice the watcher based on its id\n      // if already past its id, it will be run next immediately.\n      var i = queue.length - 1;\n      while (i > index && queue[i].id > watcher.id) {\n        i--;\n      }\n      queue.splice(i + 1, 0, watcher);\n    }\n    // queue the flush\n    if (!waiting) {\n      waiting = true;\n      nextTick(flushSchedulerQueue);\n    }\n  }\n}\n\n/*  */\n\nvar uid$2 = 0;\n\n/**\n * A watcher parses an expression, collects dependencies,\n * and fires callback when the expression value changes.\n * This is used for both the $watch() api and directives.\n */\nvar Watcher = function Watcher(vm, expOrFn, cb, options, isRenderWatcher) {\n  this.vm = vm;\n  if (isRenderWatcher) {\n    vm._watcher = this;\n  }\n  vm._watchers.push(this);\n  // options\n  if (options) {\n    this.deep = !!options.deep;\n    this.user = !!options.user;\n    this.lazy = !!options.lazy;\n    this.sync = !!options.sync;\n  } else {\n    this.deep = this.user = this.lazy = this.sync = false;\n  }\n  this.cb = cb;\n  this.id = ++uid$2; // uid for batching\n  this.active = true;\n  this.dirty = this.lazy; // for lazy watchers\n  this.deps = [];\n  this.newDeps = [];\n  this.depIds = new _Set();\n  this.newDepIds = new _Set();\n  this.expression = process.env.NODE_ENV !== 'production' ? expOrFn.toString() : '';\n  // parse expression for getter\n  if (typeof expOrFn === 'function') {\n    this.getter = expOrFn;\n  } else {\n    this.getter = parsePath(expOrFn);\n    if (!this.getter) {\n      this.getter = function () {};\n      process.env.NODE_ENV !== 'production' && warn(\"Failed watching path: \\\"\" + expOrFn + \"\\\" \" + 'Watcher only accepts simple dot-delimited paths. ' + 'For full control, use a function instead.', vm);\n    }\n  }\n  this.value = this.lazy ? undefined : this.get();\n};\n\n/**\n * Evaluate the getter, and re-collect dependencies.\n */\nWatcher.prototype.get = function get() {\n  pushTarget(this);\n  var value;\n  var vm = this.vm;\n  try {\n    value = this.getter.call(vm, vm);\n  } catch (e) {\n    if (this.user) {\n      handleError(e, vm, \"getter for watcher \\\"\" + this.expression + \"\\\"\");\n    } else {\n      throw e;\n    }\n  } finally {\n    // \"touch\" every property so they are all tracked as\n    // dependencies for deep watching\n    if (this.deep) {\n      traverse(value);\n    }\n    popTarget();\n    this.cleanupDeps();\n  }\n  return value;\n};\n\n/**\n * Add a dependency to this directive.\n */\nWatcher.prototype.addDep = function addDep(dep) {\n  var id = dep.id;\n  if (!this.newDepIds.has(id)) {\n    this.newDepIds.add(id);\n    this.newDeps.push(dep);\n    if (!this.depIds.has(id)) {\n      dep.addSub(this);\n    }\n  }\n};\n\n/**\n * Clean up for dependency collection.\n */\nWatcher.prototype.cleanupDeps = function cleanupDeps() {\n  var this$1 = this;\n\n  var i = this.deps.length;\n  while (i--) {\n    var dep = this$1.deps[i];\n    if (!this$1.newDepIds.has(dep.id)) {\n      dep.removeSub(this$1);\n    }\n  }\n  var tmp = this.depIds;\n  this.depIds = this.newDepIds;\n  this.newDepIds = tmp;\n  this.newDepIds.clear();\n  tmp = this.deps;\n  this.deps = this.newDeps;\n  this.newDeps = tmp;\n  this.newDeps.length = 0;\n};\n\n/**\n * Subscriber interface.\n * Will be called when a dependency changes.\n */\nWatcher.prototype.update = function update() {\n  /* istanbul ignore else */\n  if (this.lazy) {\n    this.dirty = true;\n  } else if (this.sync) {\n    this.run();\n  } else {\n    queueWatcher(this);\n  }\n};\n\n/**\n * Scheduler job interface.\n * Will be called by the scheduler.\n */\nWatcher.prototype.run = function run() {\n  if (this.active) {\n    var value = this.get();\n    if (value !== this.value ||\n    // Deep watchers and watchers on Object/Arrays should fire even\n    // when the value is the same, because the value may\n    // have mutated.\n    isObject(value) || this.deep) {\n      // set new value\n      var oldValue = this.value;\n      this.value = value;\n      if (this.user) {\n        try {\n          this.cb.call(this.vm, value, oldValue);\n        } catch (e) {\n          handleError(e, this.vm, \"callback for watcher \\\"\" + this.expression + \"\\\"\");\n        }\n      } else {\n        this.cb.call(this.vm, value, oldValue);\n      }\n    }\n  }\n};\n\n/**\n * Evaluate the value of the watcher.\n * This only gets called for lazy watchers.\n */\nWatcher.prototype.evaluate = function evaluate() {\n  this.value = this.get();\n  this.dirty = false;\n};\n\n/**\n * Depend on all deps collected by this watcher.\n */\nWatcher.prototype.depend = function depend() {\n  var this$1 = this;\n\n  var i = this.deps.length;\n  while (i--) {\n    this$1.deps[i].depend();\n  }\n};\n\n/**\n * Remove self from all dependencies' subscriber list.\n */\nWatcher.prototype.teardown = function teardown() {\n  var this$1 = this;\n\n  if (this.active) {\n    // remove self from vm's watcher list\n    // this is a somewhat expensive operation so we skip it\n    // if the vm is being destroyed.\n    if (!this.vm._isBeingDestroyed) {\n      remove(this.vm._watchers, this);\n    }\n    var i = this.deps.length;\n    while (i--) {\n      this$1.deps[i].removeSub(this$1);\n    }\n    this.active = false;\n  }\n};\n\n/*  */\n\nvar sharedPropertyDefinition = {\n  enumerable: true,\n  configurable: true,\n  get: noop,\n  set: noop\n};\n\nfunction proxy(target, sourceKey, key) {\n  sharedPropertyDefinition.get = function proxyGetter() {\n    return this[sourceKey][key];\n  };\n  sharedPropertyDefinition.set = function proxySetter(val) {\n    this[sourceKey][key] = val;\n  };\n  Object.defineProperty(target, key, sharedPropertyDefinition);\n}\n\nfunction initState(vm) {\n  vm._watchers = [];\n  var opts = vm.$options;\n  if (opts.props) {\n    initProps(vm, opts.props);\n  }\n  if (opts.methods) {\n    initMethods(vm, opts.methods);\n  }\n  if (opts.data) {\n    initData(vm);\n  } else {\n    observe(vm._data = {}, true /* asRootData */);\n  }\n  if (opts.computed) {\n    initComputed(vm, opts.computed);\n  }\n  if (opts.watch && opts.watch !== nativeWatch) {\n    initWatch(vm, opts.watch);\n  }\n}\n\nfunction initProps(vm, propsOptions) {\n  var propsData = vm.$options.propsData || {};\n  var props = vm._props = {};\n  // cache prop keys so that future props updates can iterate using Array\n  // instead of dynamic object key enumeration.\n  var keys = vm.$options._propKeys = [];\n  var isRoot = !vm.$parent;\n  // root instance props should be converted\n  observerState.shouldConvert = isRoot;\n  var loop = function loop(key) {\n    keys.push(key);\n    var value = validateProp(key, propsOptions, propsData, vm);\n    /* istanbul ignore else */\n    if (process.env.NODE_ENV !== 'production') {\n      var hyphenatedKey = hyphenate(key);\n      if (isReservedAttribute(hyphenatedKey) || config.isReservedAttr(hyphenatedKey)) {\n        warn(\"\\\"\" + hyphenatedKey + \"\\\" is a reserved attribute and cannot be used as component prop.\", vm);\n      }\n      defineReactive(props, key, value, function () {\n        if (vm.$parent && !isUpdatingChildComponent) {\n          warn(\"Avoid mutating a prop directly since the value will be \" + \"overwritten whenever the parent component re-renders. \" + \"Instead, use a data or computed property based on the prop's \" + \"value. Prop being mutated: \\\"\" + key + \"\\\"\", vm);\n        }\n      });\n    } else {\n      defineReactive(props, key, value);\n    }\n    // static props are already proxied on the component's prototype\n    // during Vue.extend(). We only need to proxy props defined at\n    // instantiation here.\n    if (!(key in vm)) {\n      proxy(vm, \"_props\", key);\n    }\n  };\n\n  for (var key in propsOptions) {\n    loop(key);\n  }observerState.shouldConvert = true;\n}\n\nfunction initData(vm) {\n  var data = vm.$options.data;\n  data = vm._data = typeof data === 'function' ? getData(data, vm) : data || {};\n  if (!isPlainObject(data)) {\n    data = {};\n    process.env.NODE_ENV !== 'production' && warn('data functions should return an object:\\n' + 'https://vuejs.org/v2/guide/components.html#data-Must-Be-a-Function', vm);\n  }\n  // proxy data on instance\n  var keys = Object.keys(data);\n  var props = vm.$options.props;\n  var methods = vm.$options.methods;\n  var i = keys.length;\n  while (i--) {\n    var key = keys[i];\n    if (process.env.NODE_ENV !== 'production') {\n      if (methods && hasOwn(methods, key)) {\n        warn(\"Method \\\"\" + key + \"\\\" has already been defined as a data property.\", vm);\n      }\n    }\n    if (props && hasOwn(props, key)) {\n      process.env.NODE_ENV !== 'production' && warn(\"The data property \\\"\" + key + \"\\\" is already declared as a prop. \" + \"Use prop default value instead.\", vm);\n    } else if (!isReserved(key)) {\n      proxy(vm, \"_data\", key);\n    }\n  }\n  // observe data\n  observe(data, true /* asRootData */);\n}\n\nfunction getData(data, vm) {\n  try {\n    return data.call(vm, vm);\n  } catch (e) {\n    handleError(e, vm, \"data()\");\n    return {};\n  }\n}\n\nvar computedWatcherOptions = { lazy: true };\n\nfunction initComputed(vm, computed) {\n  // $flow-disable-line\n  var watchers = vm._computedWatchers = Object.create(null);\n  // computed properties are just getters during SSR\n  var isSSR = isServerRendering();\n\n  for (var key in computed) {\n    var userDef = computed[key];\n    var getter = typeof userDef === 'function' ? userDef : userDef.get;\n    if (process.env.NODE_ENV !== 'production' && getter == null) {\n      warn(\"Getter is missing for computed property \\\"\" + key + \"\\\".\", vm);\n    }\n\n    if (!isSSR) {\n      // create internal watcher for the computed property.\n      watchers[key] = new Watcher(vm, getter || noop, noop, computedWatcherOptions);\n    }\n\n    // component-defined computed properties are already defined on the\n    // component prototype. We only need to define computed properties defined\n    // at instantiation here.\n    if (!(key in vm)) {\n      defineComputed(vm, key, userDef);\n    } else if (process.env.NODE_ENV !== 'production') {\n      if (key in vm.$data) {\n        warn(\"The computed property \\\"\" + key + \"\\\" is already defined in data.\", vm);\n      } else if (vm.$options.props && key in vm.$options.props) {\n        warn(\"The computed property \\\"\" + key + \"\\\" is already defined as a prop.\", vm);\n      }\n    }\n  }\n}\n\nfunction defineComputed(target, key, userDef) {\n  var shouldCache = !isServerRendering();\n  if (typeof userDef === 'function') {\n    sharedPropertyDefinition.get = shouldCache ? createComputedGetter(key) : userDef;\n    sharedPropertyDefinition.set = noop;\n  } else {\n    sharedPropertyDefinition.get = userDef.get ? shouldCache && userDef.cache !== false ? createComputedGetter(key) : userDef.get : noop;\n    sharedPropertyDefinition.set = userDef.set ? userDef.set : noop;\n  }\n  if (process.env.NODE_ENV !== 'production' && sharedPropertyDefinition.set === noop) {\n    sharedPropertyDefinition.set = function () {\n      warn(\"Computed property \\\"\" + key + \"\\\" was assigned to but it has no setter.\", this);\n    };\n  }\n  Object.defineProperty(target, key, sharedPropertyDefinition);\n}\n\nfunction createComputedGetter(key) {\n  return function computedGetter() {\n    var watcher = this._computedWatchers && this._computedWatchers[key];\n    if (watcher) {\n      if (watcher.dirty) {\n        watcher.evaluate();\n      }\n      if (Dep.target) {\n        watcher.depend();\n      }\n      return watcher.value;\n    }\n  };\n}\n\nfunction initMethods(vm, methods) {\n  var props = vm.$options.props;\n  for (var key in methods) {\n    if (process.env.NODE_ENV !== 'production') {\n      if (methods[key] == null) {\n        warn(\"Method \\\"\" + key + \"\\\" has an undefined value in the component definition. \" + \"Did you reference the function correctly?\", vm);\n      }\n      if (props && hasOwn(props, key)) {\n        warn(\"Method \\\"\" + key + \"\\\" has already been defined as a prop.\", vm);\n      }\n      if (key in vm && isReserved(key)) {\n        warn(\"Method \\\"\" + key + \"\\\" conflicts with an existing Vue instance method. \" + \"Avoid defining component methods that start with _ or $.\");\n      }\n    }\n    vm[key] = methods[key] == null ? noop : bind(methods[key], vm);\n  }\n}\n\nfunction initWatch(vm, watch) {\n  for (var key in watch) {\n    var handler = watch[key];\n    if (Array.isArray(handler)) {\n      for (var i = 0; i < handler.length; i++) {\n        createWatcher(vm, key, handler[i]);\n      }\n    } else {\n      createWatcher(vm, key, handler);\n    }\n  }\n}\n\nfunction createWatcher(vm, keyOrFn, handler, options) {\n  if (isPlainObject(handler)) {\n    options = handler;\n    handler = handler.handler;\n  }\n  if (typeof handler === 'string') {\n    handler = vm[handler];\n  }\n  return vm.$watch(keyOrFn, handler, options);\n}\n\nfunction stateMixin(Vue) {\n  // flow somehow has problems with directly declared definition object\n  // when using Object.defineProperty, so we have to procedurally build up\n  // the object here.\n  var dataDef = {};\n  dataDef.get = function () {\n    return this._data;\n  };\n  var propsDef = {};\n  propsDef.get = function () {\n    return this._props;\n  };\n  if (process.env.NODE_ENV !== 'production') {\n    dataDef.set = function (newData) {\n      warn('Avoid replacing instance root $data. ' + 'Use nested data properties instead.', this);\n    };\n    propsDef.set = function () {\n      warn(\"$props is readonly.\", this);\n    };\n  }\n  Object.defineProperty(Vue.prototype, '$data', dataDef);\n  Object.defineProperty(Vue.prototype, '$props', propsDef);\n\n  Vue.prototype.$set = set;\n  Vue.prototype.$delete = del;\n\n  Vue.prototype.$watch = function (expOrFn, cb, options) {\n    var vm = this;\n    if (isPlainObject(cb)) {\n      return createWatcher(vm, expOrFn, cb, options);\n    }\n    options = options || {};\n    options.user = true;\n    var watcher = new Watcher(vm, expOrFn, cb, options);\n    if (options.immediate) {\n      cb.call(vm, watcher.value);\n    }\n    return function unwatchFn() {\n      watcher.teardown();\n    };\n  };\n}\n\n/*  */\n\nfunction initProvide(vm) {\n  var provide = vm.$options.provide;\n  if (provide) {\n    vm._provided = typeof provide === 'function' ? provide.call(vm) : provide;\n  }\n}\n\nfunction initInjections(vm) {\n  var result = resolveInject(vm.$options.inject, vm);\n  if (result) {\n    observerState.shouldConvert = false;\n    Object.keys(result).forEach(function (key) {\n      /* istanbul ignore else */\n      if (process.env.NODE_ENV !== 'production') {\n        defineReactive(vm, key, result[key], function () {\n          warn(\"Avoid mutating an injected value directly since the changes will be \" + \"overwritten whenever the provided component re-renders. \" + \"injection being mutated: \\\"\" + key + \"\\\"\", vm);\n        });\n      } else {\n        defineReactive(vm, key, result[key]);\n      }\n    });\n    observerState.shouldConvert = true;\n  }\n}\n\nfunction resolveInject(inject, vm) {\n  if (inject) {\n    // inject is :any because flow is not smart enough to figure out cached\n    var result = Object.create(null);\n    var keys = hasSymbol ? Reflect.ownKeys(inject).filter(function (key) {\n      /* istanbul ignore next */\n      return Object.getOwnPropertyDescriptor(inject, key).enumerable;\n    }) : Object.keys(inject);\n\n    for (var i = 0; i < keys.length; i++) {\n      var key = keys[i];\n      var provideKey = inject[key].from;\n      var source = vm;\n      while (source) {\n        if (source._provided && provideKey in source._provided) {\n          result[key] = source._provided[provideKey];\n          break;\n        }\n        source = source.$parent;\n      }\n      if (!source) {\n        if ('default' in inject[key]) {\n          var provideDefault = inject[key].default;\n          result[key] = typeof provideDefault === 'function' ? provideDefault.call(vm) : provideDefault;\n        } else if (process.env.NODE_ENV !== 'production') {\n          warn(\"Injection \\\"\" + key + \"\\\" not found\", vm);\n        }\n      }\n    }\n    return result;\n  }\n}\n\n/*  */\n\n/**\n * Runtime helper for rendering v-for lists.\n */\nfunction renderList(val, render) {\n  var ret, i, l, keys, key;\n  if (Array.isArray(val) || typeof val === 'string') {\n    ret = new Array(val.length);\n    for (i = 0, l = val.length; i < l; i++) {\n      ret[i] = render(val[i], i);\n    }\n  } else if (typeof val === 'number') {\n    ret = new Array(val);\n    for (i = 0; i < val; i++) {\n      ret[i] = render(i + 1, i);\n    }\n  } else if (isObject(val)) {\n    keys = Object.keys(val);\n    ret = new Array(keys.length);\n    for (i = 0, l = keys.length; i < l; i++) {\n      key = keys[i];\n      ret[i] = render(val[key], key, i);\n    }\n  }\n  if (isDef(ret)) {\n    ret._isVList = true;\n  }\n  return ret;\n}\n\n/*  */\n\n/**\n * Runtime helper for rendering <slot>\n */\nfunction renderSlot(name, fallback, props, bindObject) {\n  var scopedSlotFn = this.$scopedSlots[name];\n  var nodes;\n  if (scopedSlotFn) {\n    // scoped slot\n    props = props || {};\n    if (bindObject) {\n      if (process.env.NODE_ENV !== 'production' && !isObject(bindObject)) {\n        warn('slot v-bind without argument expects an Object', this);\n      }\n      props = extend(extend({}, bindObject), props);\n    }\n    nodes = scopedSlotFn(props) || fallback;\n  } else {\n    var slotNodes = this.$slots[name];\n    // warn duplicate slot usage\n    if (slotNodes) {\n      if (process.env.NODE_ENV !== 'production' && slotNodes._rendered) {\n        warn(\"Duplicate presence of slot \\\"\" + name + \"\\\" found in the same render tree \" + \"- this will likely cause render errors.\", this);\n      }\n      slotNodes._rendered = true;\n    }\n    nodes = slotNodes || fallback;\n  }\n\n  var target = props && props.slot;\n  if (target) {\n    return this.$createElement('template', { slot: target }, nodes);\n  } else {\n    return nodes;\n  }\n}\n\n/*  */\n\n/**\n * Runtime helper for resolving filters\n */\nfunction resolveFilter(id) {\n  return resolveAsset(this.$options, 'filters', id, true) || identity;\n}\n\n/*  */\n\n/**\n * Runtime helper for checking keyCodes from config.\n * exposed as Vue.prototype._k\n * passing in eventKeyName as last argument separately for backwards compat\n */\nfunction checkKeyCodes(eventKeyCode, key, builtInAlias, eventKeyName) {\n  var keyCodes = config.keyCodes[key] || builtInAlias;\n  if (keyCodes) {\n    if (Array.isArray(keyCodes)) {\n      return keyCodes.indexOf(eventKeyCode) === -1;\n    } else {\n      return keyCodes !== eventKeyCode;\n    }\n  } else if (eventKeyName) {\n    return hyphenate(eventKeyName) !== key;\n  }\n}\n\n/*  */\n\n/**\n * Runtime helper for merging v-bind=\"object\" into a VNode's data.\n */\nfunction bindObjectProps(data, tag, value, asProp, isSync) {\n  if (value) {\n    if (!isObject(value)) {\n      process.env.NODE_ENV !== 'production' && warn('v-bind without argument expects an Object or Array value', this);\n    } else {\n      if (Array.isArray(value)) {\n        value = toObject(value);\n      }\n      var hash;\n      var loop = function loop(key) {\n        if (key === 'class' || key === 'style' || isReservedAttribute(key)) {\n          hash = data;\n        } else {\n          var type = data.attrs && data.attrs.type;\n          hash = asProp || config.mustUseProp(tag, type, key) ? data.domProps || (data.domProps = {}) : data.attrs || (data.attrs = {});\n        }\n        if (!(key in hash)) {\n          hash[key] = value[key];\n\n          if (isSync) {\n            var on = data.on || (data.on = {});\n            on[\"update:\" + key] = function ($event) {\n              value[key] = $event;\n            };\n          }\n        }\n      };\n\n      for (var key in value) {\n        loop(key);\n      }\n    }\n  }\n  return data;\n}\n\n/*  */\n\n/**\n * Runtime helper for rendering static trees.\n */\nfunction renderStatic(index, isInFor) {\n  var cached = this._staticTrees || (this._staticTrees = []);\n  var tree = cached[index];\n  // if has already-rendered static tree and not inside v-for,\n  // we can reuse the same tree by doing a shallow clone.\n  if (tree && !isInFor) {\n    return Array.isArray(tree) ? cloneVNodes(tree) : cloneVNode(tree);\n  }\n  // otherwise, render a fresh tree.\n  tree = cached[index] = this.$options.staticRenderFns[index].call(this._renderProxy, null, this // for render fns generated for functional component templates\n  );\n  markStatic(tree, \"__static__\" + index, false);\n  return tree;\n}\n\n/**\n * Runtime helper for v-once.\n * Effectively it means marking the node as static with a unique key.\n */\nfunction markOnce(tree, index, key) {\n  markStatic(tree, \"__once__\" + index + (key ? \"_\" + key : \"\"), true);\n  return tree;\n}\n\nfunction markStatic(tree, key, isOnce) {\n  if (Array.isArray(tree)) {\n    for (var i = 0; i < tree.length; i++) {\n      if (tree[i] && typeof tree[i] !== 'string') {\n        markStaticNode(tree[i], key + \"_\" + i, isOnce);\n      }\n    }\n  } else {\n    markStaticNode(tree, key, isOnce);\n  }\n}\n\nfunction markStaticNode(node, key, isOnce) {\n  node.isStatic = true;\n  node.key = key;\n  node.isOnce = isOnce;\n}\n\n/*  */\n\nfunction bindObjectListeners(data, value) {\n  if (value) {\n    if (!isPlainObject(value)) {\n      process.env.NODE_ENV !== 'production' && warn('v-on without argument expects an Object value', this);\n    } else {\n      var on = data.on = data.on ? extend({}, data.on) : {};\n      for (var key in value) {\n        var existing = on[key];\n        var ours = value[key];\n        on[key] = existing ? [].concat(existing, ours) : ours;\n      }\n    }\n  }\n  return data;\n}\n\n/*  */\n\nfunction installRenderHelpers(target) {\n  target._o = markOnce;\n  target._n = toNumber;\n  target._s = toString;\n  target._l = renderList;\n  target._t = renderSlot;\n  target._q = looseEqual;\n  target._i = looseIndexOf;\n  target._m = renderStatic;\n  target._f = resolveFilter;\n  target._k = checkKeyCodes;\n  target._b = bindObjectProps;\n  target._v = createTextVNode;\n  target._e = createEmptyVNode;\n  target._u = resolveScopedSlots;\n  target._g = bindObjectListeners;\n}\n\n/*  */\n\nfunction FunctionalRenderContext(data, props, children, parent, Ctor) {\n  var options = Ctor.options;\n  this.data = data;\n  this.props = props;\n  this.children = children;\n  this.parent = parent;\n  this.listeners = data.on || emptyObject;\n  this.injections = resolveInject(options.inject, parent);\n  this.slots = function () {\n    return resolveSlots(children, parent);\n  };\n\n  // ensure the createElement function in functional components\n  // gets a unique context - this is necessary for correct named slot check\n  var contextVm = Object.create(parent);\n  var isCompiled = isTrue(options._compiled);\n  var needNormalization = !isCompiled;\n\n  // support for compiled functional template\n  if (isCompiled) {\n    // exposing $options for renderStatic()\n    this.$options = options;\n    // pre-resolve slots for renderSlot()\n    this.$slots = this.slots();\n    this.$scopedSlots = data.scopedSlots || emptyObject;\n  }\n\n  if (options._scopeId) {\n    this._c = function (a, b, c, d) {\n      var vnode = createElement(contextVm, a, b, c, d, needNormalization);\n      if (vnode) {\n        vnode.fnScopeId = options._scopeId;\n        vnode.fnContext = parent;\n      }\n      return vnode;\n    };\n  } else {\n    this._c = function (a, b, c, d) {\n      return createElement(contextVm, a, b, c, d, needNormalization);\n    };\n  }\n}\n\ninstallRenderHelpers(FunctionalRenderContext.prototype);\n\nfunction createFunctionalComponent(Ctor, propsData, data, contextVm, children) {\n  var options = Ctor.options;\n  var props = {};\n  var propOptions = options.props;\n  if (isDef(propOptions)) {\n    for (var key in propOptions) {\n      props[key] = validateProp(key, propOptions, propsData || emptyObject);\n    }\n  } else {\n    if (isDef(data.attrs)) {\n      mergeProps(props, data.attrs);\n    }\n    if (isDef(data.props)) {\n      mergeProps(props, data.props);\n    }\n  }\n\n  var renderContext = new FunctionalRenderContext(data, props, children, contextVm, Ctor);\n\n  var vnode = options.render.call(null, renderContext._c, renderContext);\n\n  if (vnode instanceof VNode) {\n    vnode.fnContext = contextVm;\n    vnode.fnOptions = options;\n    if (data.slot) {\n      (vnode.data || (vnode.data = {})).slot = data.slot;\n    }\n  }\n\n  return vnode;\n}\n\nfunction mergeProps(to, from) {\n  for (var key in from) {\n    to[camelize(key)] = from[key];\n  }\n}\n\n/*  */\n\n// hooks to be invoked on component VNodes during patch\nvar componentVNodeHooks = {\n  init: function init(vnode, hydrating, parentElm, refElm) {\n    if (!vnode.componentInstance || vnode.componentInstance._isDestroyed) {\n      var child = vnode.componentInstance = createComponentInstanceForVnode(vnode, activeInstance, parentElm, refElm);\n      child.$mount(hydrating ? vnode.elm : undefined, hydrating);\n    } else if (vnode.data.keepAlive) {\n      // kept-alive components, treat as a patch\n      var mountedNode = vnode; // work around flow\n      componentVNodeHooks.prepatch(mountedNode, mountedNode);\n    }\n  },\n\n  prepatch: function prepatch(oldVnode, vnode) {\n    var options = vnode.componentOptions;\n    var child = vnode.componentInstance = oldVnode.componentInstance;\n    updateChildComponent(child, options.propsData, // updated props\n    options.listeners, // updated listeners\n    vnode, // new parent vnode\n    options.children // new children\n    );\n  },\n\n  insert: function insert(vnode) {\n    var context = vnode.context;\n    var componentInstance = vnode.componentInstance;\n    if (!componentInstance._isMounted) {\n      componentInstance._isMounted = true;\n      callHook(componentInstance, 'mounted');\n    }\n    if (vnode.data.keepAlive) {\n      if (context._isMounted) {\n        // vue-router#1212\n        // During updates, a kept-alive component's child components may\n        // change, so directly walking the tree here may call activated hooks\n        // on incorrect children. Instead we push them into a queue which will\n        // be processed after the whole patch process ended.\n        queueActivatedComponent(componentInstance);\n      } else {\n        activateChildComponent(componentInstance, true /* direct */);\n      }\n    }\n  },\n\n  destroy: function destroy(vnode) {\n    var componentInstance = vnode.componentInstance;\n    if (!componentInstance._isDestroyed) {\n      if (!vnode.data.keepAlive) {\n        componentInstance.$destroy();\n      } else {\n        deactivateChildComponent(componentInstance, true /* direct */);\n      }\n    }\n  }\n};\n\nvar hooksToMerge = Object.keys(componentVNodeHooks);\n\nfunction createComponent(Ctor, data, context, children, tag) {\n  if (isUndef(Ctor)) {\n    return;\n  }\n\n  var baseCtor = context.$options._base;\n\n  // plain options object: turn it into a constructor\n  if (isObject(Ctor)) {\n    Ctor = baseCtor.extend(Ctor);\n  }\n\n  // if at this stage it's not a constructor or an async component factory,\n  // reject.\n  if (typeof Ctor !== 'function') {\n    if (process.env.NODE_ENV !== 'production') {\n      warn(\"Invalid Component definition: \" + String(Ctor), context);\n    }\n    return;\n  }\n\n  // async component\n  var asyncFactory;\n  if (isUndef(Ctor.cid)) {\n    asyncFactory = Ctor;\n    Ctor = resolveAsyncComponent(asyncFactory, baseCtor, context);\n    if (Ctor === undefined) {\n      // return a placeholder node for async component, which is rendered\n      // as a comment node but preserves all the raw information for the node.\n      // the information will be used for async server-rendering and hydration.\n      return createAsyncPlaceholder(asyncFactory, data, context, children, tag);\n    }\n  }\n\n  data = data || {};\n\n  // resolve constructor options in case global mixins are applied after\n  // component constructor creation\n  resolveConstructorOptions(Ctor);\n\n  // transform component v-model data into props & events\n  if (isDef(data.model)) {\n    transformModel(Ctor.options, data);\n  }\n\n  // extract props\n  var propsData = extractPropsFromVNodeData(data, Ctor, tag);\n\n  // functional component\n  if (isTrue(Ctor.options.functional)) {\n    return createFunctionalComponent(Ctor, propsData, data, context, children);\n  }\n\n  // extract listeners, since these needs to be treated as\n  // child component listeners instead of DOM listeners\n  var listeners = data.on;\n  // replace with listeners with .native modifier\n  // so it gets processed during parent component patch.\n  data.on = data.nativeOn;\n\n  if (isTrue(Ctor.options.abstract)) {\n    // abstract components do not keep anything\n    // other than props & listeners & slot\n\n    // work around flow\n    var slot = data.slot;\n    data = {};\n    if (slot) {\n      data.slot = slot;\n    }\n  }\n\n  // merge component management hooks onto the placeholder node\n  mergeHooks(data);\n\n  // return a placeholder vnode\n  var name = Ctor.options.name || tag;\n  var vnode = new VNode(\"vue-component-\" + Ctor.cid + (name ? \"-\" + name : ''), data, undefined, undefined, undefined, context, { Ctor: Ctor, propsData: propsData, listeners: listeners, tag: tag, children: children }, asyncFactory);\n  return vnode;\n}\n\nfunction createComponentInstanceForVnode(vnode, // we know it's MountedComponentVNode but flow doesn't\nparent, // activeInstance in lifecycle state\nparentElm, refElm) {\n  var options = {\n    _isComponent: true,\n    parent: parent,\n    _parentVnode: vnode,\n    _parentElm: parentElm || null,\n    _refElm: refElm || null\n  };\n  // check inline-template render functions\n  var inlineTemplate = vnode.data.inlineTemplate;\n  if (isDef(inlineTemplate)) {\n    options.render = inlineTemplate.render;\n    options.staticRenderFns = inlineTemplate.staticRenderFns;\n  }\n  return new vnode.componentOptions.Ctor(options);\n}\n\nfunction mergeHooks(data) {\n  if (!data.hook) {\n    data.hook = {};\n  }\n  for (var i = 0; i < hooksToMerge.length; i++) {\n    var key = hooksToMerge[i];\n    var fromParent = data.hook[key];\n    var ours = componentVNodeHooks[key];\n    data.hook[key] = fromParent ? mergeHook$1(ours, fromParent) : ours;\n  }\n}\n\nfunction mergeHook$1(one, two) {\n  return function (a, b, c, d) {\n    one(a, b, c, d);\n    two(a, b, c, d);\n  };\n}\n\n// transform component v-model info (value and callback) into\n// prop and event handler respectively.\nfunction transformModel(options, data) {\n  var prop = options.model && options.model.prop || 'value';\n  var event = options.model && options.model.event || 'input';(data.props || (data.props = {}))[prop] = data.model.value;\n  var on = data.on || (data.on = {});\n  if (isDef(on[event])) {\n    on[event] = [data.model.callback].concat(on[event]);\n  } else {\n    on[event] = data.model.callback;\n  }\n}\n\n/*  */\n\nvar SIMPLE_NORMALIZE = 1;\nvar ALWAYS_NORMALIZE = 2;\n\n// wrapper function for providing a more flexible interface\n// without getting yelled at by flow\nfunction createElement(context, tag, data, children, normalizationType, alwaysNormalize) {\n  if (Array.isArray(data) || isPrimitive(data)) {\n    normalizationType = children;\n    children = data;\n    data = undefined;\n  }\n  if (isTrue(alwaysNormalize)) {\n    normalizationType = ALWAYS_NORMALIZE;\n  }\n  return _createElement(context, tag, data, children, normalizationType);\n}\n\nfunction _createElement(context, tag, data, children, normalizationType) {\n  if (isDef(data) && isDef(data.__ob__)) {\n    process.env.NODE_ENV !== 'production' && warn(\"Avoid using observed data object as vnode data: \" + JSON.stringify(data) + \"\\n\" + 'Always create fresh vnode data objects in each render!', context);\n    return createEmptyVNode();\n  }\n  // object syntax in v-bind\n  if (isDef(data) && isDef(data.is)) {\n    tag = data.is;\n  }\n  if (!tag) {\n    // in case of component :is set to falsy value\n    return createEmptyVNode();\n  }\n  // warn against non-primitive key\n  if (process.env.NODE_ENV !== 'production' && isDef(data) && isDef(data.key) && !isPrimitive(data.key)) {\n    warn('Avoid using non-primitive value as key, ' + 'use string/number value instead.', context);\n  }\n  // support single function children as default scoped slot\n  if (Array.isArray(children) && typeof children[0] === 'function') {\n    data = data || {};\n    data.scopedSlots = { default: children[0] };\n    children.length = 0;\n  }\n  if (normalizationType === ALWAYS_NORMALIZE) {\n    children = normalizeChildren(children);\n  } else if (normalizationType === SIMPLE_NORMALIZE) {\n    children = simpleNormalizeChildren(children);\n  }\n  var vnode, ns;\n  if (typeof tag === 'string') {\n    var Ctor;\n    ns = context.$vnode && context.$vnode.ns || config.getTagNamespace(tag);\n    if (config.isReservedTag(tag)) {\n      // platform built-in elements\n      vnode = new VNode(config.parsePlatformTagName(tag), data, children, undefined, undefined, context);\n    } else if (isDef(Ctor = resolveAsset(context.$options, 'components', tag))) {\n      // component\n      vnode = createComponent(Ctor, data, context, children, tag);\n    } else {\n      // unknown or unlisted namespaced elements\n      // check at runtime because it may get assigned a namespace when its\n      // parent normalizes children\n      vnode = new VNode(tag, data, children, undefined, undefined, context);\n    }\n  } else {\n    // direct component options / constructor\n    vnode = createComponent(tag, data, context, children);\n  }\n  if (isDef(vnode)) {\n    if (ns) {\n      applyNS(vnode, ns);\n    }\n    return vnode;\n  } else {\n    return createEmptyVNode();\n  }\n}\n\nfunction applyNS(vnode, ns, force) {\n  vnode.ns = ns;\n  if (vnode.tag === 'foreignObject') {\n    // use default namespace inside foreignObject\n    ns = undefined;\n    force = true;\n  }\n  if (isDef(vnode.children)) {\n    for (var i = 0, l = vnode.children.length; i < l; i++) {\n      var child = vnode.children[i];\n      if (isDef(child.tag) && (isUndef(child.ns) || isTrue(force))) {\n        applyNS(child, ns, force);\n      }\n    }\n  }\n}\n\n/*  */\n\nfunction initRender(vm) {\n  vm._vnode = null; // the root of the child tree\n  vm._staticTrees = null; // v-once cached trees\n  var options = vm.$options;\n  var parentVnode = vm.$vnode = options._parentVnode; // the placeholder node in parent tree\n  var renderContext = parentVnode && parentVnode.context;\n  vm.$slots = resolveSlots(options._renderChildren, renderContext);\n  vm.$scopedSlots = emptyObject;\n  // bind the createElement fn to this instance\n  // so that we get proper render context inside it.\n  // args order: tag, data, children, normalizationType, alwaysNormalize\n  // internal version is used by render functions compiled from templates\n  vm._c = function (a, b, c, d) {\n    return createElement(vm, a, b, c, d, false);\n  };\n  // normalization is always applied for the public version, used in\n  // user-written render functions.\n  vm.$createElement = function (a, b, c, d) {\n    return createElement(vm, a, b, c, d, true);\n  };\n\n  // $attrs & $listeners are exposed for easier HOC creation.\n  // they need to be reactive so that HOCs using them are always updated\n  var parentData = parentVnode && parentVnode.data;\n\n  /* istanbul ignore else */\n  if (process.env.NODE_ENV !== 'production') {\n    defineReactive(vm, '$attrs', parentData && parentData.attrs || emptyObject, function () {\n      !isUpdatingChildComponent && warn(\"$attrs is readonly.\", vm);\n    }, true);\n    defineReactive(vm, '$listeners', options._parentListeners || emptyObject, function () {\n      !isUpdatingChildComponent && warn(\"$listeners is readonly.\", vm);\n    }, true);\n  } else {\n    defineReactive(vm, '$attrs', parentData && parentData.attrs || emptyObject, null, true);\n    defineReactive(vm, '$listeners', options._parentListeners || emptyObject, null, true);\n  }\n}\n\nfunction renderMixin(Vue) {\n  // install runtime convenience helpers\n  installRenderHelpers(Vue.prototype);\n\n  Vue.prototype.$nextTick = function (fn) {\n    return nextTick(fn, this);\n  };\n\n  Vue.prototype._render = function () {\n    var vm = this;\n    var ref = vm.$options;\n    var render = ref.render;\n    var _parentVnode = ref._parentVnode;\n\n    if (vm._isMounted) {\n      // if the parent didn't update, the slot nodes will be the ones from\n      // last render. They need to be cloned to ensure \"freshness\" for this render.\n      for (var key in vm.$slots) {\n        var slot = vm.$slots[key];\n        // _rendered is a flag added by renderSlot, but may not be present\n        // if the slot is passed from manually written render functions\n        if (slot._rendered || slot[0] && slot[0].elm) {\n          vm.$slots[key] = cloneVNodes(slot, true /* deep */);\n        }\n      }\n    }\n\n    vm.$scopedSlots = _parentVnode && _parentVnode.data.scopedSlots || emptyObject;\n\n    // set parent vnode. this allows render functions to have access\n    // to the data on the placeholder node.\n    vm.$vnode = _parentVnode;\n    // render self\n    var vnode;\n    try {\n      vnode = render.call(vm._renderProxy, vm.$createElement);\n    } catch (e) {\n      handleError(e, vm, \"render\");\n      // return error render result,\n      // or previous vnode to prevent render error causing blank component\n      /* istanbul ignore else */\n      if (process.env.NODE_ENV !== 'production') {\n        if (vm.$options.renderError) {\n          try {\n            vnode = vm.$options.renderError.call(vm._renderProxy, vm.$createElement, e);\n          } catch (e) {\n            handleError(e, vm, \"renderError\");\n            vnode = vm._vnode;\n          }\n        } else {\n          vnode = vm._vnode;\n        }\n      } else {\n        vnode = vm._vnode;\n      }\n    }\n    // return empty vnode in case the render function errored out\n    if (!(vnode instanceof VNode)) {\n      if (process.env.NODE_ENV !== 'production' && Array.isArray(vnode)) {\n        warn('Multiple root nodes returned from render function. Render function ' + 'should return a single root node.', vm);\n      }\n      vnode = createEmptyVNode();\n    }\n    // set parent\n    vnode.parent = _parentVnode;\n    return vnode;\n  };\n}\n\n/*  */\n\nvar uid$1 = 0;\n\nfunction initMixin(Vue) {\n  Vue.prototype._init = function (options) {\n    var vm = this;\n    // a uid\n    vm._uid = uid$1++;\n\n    var startTag, endTag;\n    /* istanbul ignore if */\n    if (process.env.NODE_ENV !== 'production' && config.performance && mark) {\n      startTag = \"vue-perf-start:\" + vm._uid;\n      endTag = \"vue-perf-end:\" + vm._uid;\n      mark(startTag);\n    }\n\n    // a flag to avoid this being observed\n    vm._isVue = true;\n    // merge options\n    if (options && options._isComponent) {\n      // optimize internal component instantiation\n      // since dynamic options merging is pretty slow, and none of the\n      // internal component options needs special treatment.\n      initInternalComponent(vm, options);\n    } else {\n      vm.$options = mergeOptions(resolveConstructorOptions(vm.constructor), options || {}, vm);\n    }\n    /* istanbul ignore else */\n    if (process.env.NODE_ENV !== 'production') {\n      initProxy(vm);\n    } else {\n      vm._renderProxy = vm;\n    }\n    // expose real self\n    vm._self = vm;\n    initLifecycle(vm);\n    initEvents(vm);\n    initRender(vm);\n    callHook(vm, 'beforeCreate');\n    initInjections(vm); // resolve injections before data/props\n    initState(vm);\n    initProvide(vm); // resolve provide after data/props\n    callHook(vm, 'created');\n\n    /* istanbul ignore if */\n    if (process.env.NODE_ENV !== 'production' && config.performance && mark) {\n      vm._name = formatComponentName(vm, false);\n      mark(endTag);\n      measure(\"vue \" + vm._name + \" init\", startTag, endTag);\n    }\n\n    if (vm.$options.el) {\n      vm.$mount(vm.$options.el);\n    }\n  };\n}\n\nfunction initInternalComponent(vm, options) {\n  var opts = vm.$options = Object.create(vm.constructor.options);\n  // doing this because it's faster than dynamic enumeration.\n  var parentVnode = options._parentVnode;\n  opts.parent = options.parent;\n  opts._parentVnode = parentVnode;\n  opts._parentElm = options._parentElm;\n  opts._refElm = options._refElm;\n\n  var vnodeComponentOptions = parentVnode.componentOptions;\n  opts.propsData = vnodeComponentOptions.propsData;\n  opts._parentListeners = vnodeComponentOptions.listeners;\n  opts._renderChildren = vnodeComponentOptions.children;\n  opts._componentTag = vnodeComponentOptions.tag;\n\n  if (options.render) {\n    opts.render = options.render;\n    opts.staticRenderFns = options.staticRenderFns;\n  }\n}\n\nfunction resolveConstructorOptions(Ctor) {\n  var options = Ctor.options;\n  if (Ctor.super) {\n    var superOptions = resolveConstructorOptions(Ctor.super);\n    var cachedSuperOptions = Ctor.superOptions;\n    if (superOptions !== cachedSuperOptions) {\n      // super option changed,\n      // need to resolve new options.\n      Ctor.superOptions = superOptions;\n      // check if there are any late-modified/attached options (#4976)\n      var modifiedOptions = resolveModifiedOptions(Ctor);\n      // update base extend options\n      if (modifiedOptions) {\n        extend(Ctor.extendOptions, modifiedOptions);\n      }\n      options = Ctor.options = mergeOptions(superOptions, Ctor.extendOptions);\n      if (options.name) {\n        options.components[options.name] = Ctor;\n      }\n    }\n  }\n  return options;\n}\n\nfunction resolveModifiedOptions(Ctor) {\n  var modified;\n  var latest = Ctor.options;\n  var extended = Ctor.extendOptions;\n  var sealed = Ctor.sealedOptions;\n  for (var key in latest) {\n    if (latest[key] !== sealed[key]) {\n      if (!modified) {\n        modified = {};\n      }\n      modified[key] = dedupe(latest[key], extended[key], sealed[key]);\n    }\n  }\n  return modified;\n}\n\nfunction dedupe(latest, extended, sealed) {\n  // compare latest and sealed to ensure lifecycle hooks won't be duplicated\n  // between merges\n  if (Array.isArray(latest)) {\n    var res = [];\n    sealed = Array.isArray(sealed) ? sealed : [sealed];\n    extended = Array.isArray(extended) ? extended : [extended];\n    for (var i = 0; i < latest.length; i++) {\n      // push original options and not sealed options to exclude duplicated options\n      if (extended.indexOf(latest[i]) >= 0 || sealed.indexOf(latest[i]) < 0) {\n        res.push(latest[i]);\n      }\n    }\n    return res;\n  } else {\n    return latest;\n  }\n}\n\nfunction Vue$3(options) {\n  if (process.env.NODE_ENV !== 'production' && !(this instanceof Vue$3)) {\n    warn('Vue is a constructor and should be called with the `new` keyword');\n  }\n  this._init(options);\n}\n\ninitMixin(Vue$3);\nstateMixin(Vue$3);\neventsMixin(Vue$3);\nlifecycleMixin(Vue$3);\nrenderMixin(Vue$3);\n\n/*  */\n\nfunction initUse(Vue) {\n  Vue.use = function (plugin) {\n    var installedPlugins = this._installedPlugins || (this._installedPlugins = []);\n    if (installedPlugins.indexOf(plugin) > -1) {\n      return this;\n    }\n\n    // additional parameters\n    var args = toArray(arguments, 1);\n    args.unshift(this);\n    if (typeof plugin.install === 'function') {\n      plugin.install.apply(plugin, args);\n    } else if (typeof plugin === 'function') {\n      plugin.apply(null, args);\n    }\n    installedPlugins.push(plugin);\n    return this;\n  };\n}\n\n/*  */\n\nfunction initMixin$1(Vue) {\n  Vue.mixin = function (mixin) {\n    this.options = mergeOptions(this.options, mixin);\n    return this;\n  };\n}\n\n/*  */\n\nfunction initExtend(Vue) {\n  /**\n   * Each instance constructor, including Vue, has a unique\n   * cid. This enables us to create wrapped \"child\n   * constructors\" for prototypal inheritance and cache them.\n   */\n  Vue.cid = 0;\n  var cid = 1;\n\n  /**\n   * Class inheritance\n   */\n  Vue.extend = function (extendOptions) {\n    extendOptions = extendOptions || {};\n    var Super = this;\n    var SuperId = Super.cid;\n    var cachedCtors = extendOptions._Ctor || (extendOptions._Ctor = {});\n    if (cachedCtors[SuperId]) {\n      return cachedCtors[SuperId];\n    }\n\n    var name = extendOptions.name || Super.options.name;\n    if (process.env.NODE_ENV !== 'production' && name) {\n      validateComponentName(name);\n    }\n\n    var Sub = function VueComponent(options) {\n      this._init(options);\n    };\n    Sub.prototype = Object.create(Super.prototype);\n    Sub.prototype.constructor = Sub;\n    Sub.cid = cid++;\n    Sub.options = mergeOptions(Super.options, extendOptions);\n    Sub['super'] = Super;\n\n    // For props and computed properties, we define the proxy getters on\n    // the Vue instances at extension time, on the extended prototype. This\n    // avoids Object.defineProperty calls for each instance created.\n    if (Sub.options.props) {\n      initProps$1(Sub);\n    }\n    if (Sub.options.computed) {\n      initComputed$1(Sub);\n    }\n\n    // allow further extension/mixin/plugin usage\n    Sub.extend = Super.extend;\n    Sub.mixin = Super.mixin;\n    Sub.use = Super.use;\n\n    // create asset registers, so extended classes\n    // can have their private assets too.\n    ASSET_TYPES.forEach(function (type) {\n      Sub[type] = Super[type];\n    });\n    // enable recursive self-lookup\n    if (name) {\n      Sub.options.components[name] = Sub;\n    }\n\n    // keep a reference to the super options at extension time.\n    // later at instantiation we can check if Super's options have\n    // been updated.\n    Sub.superOptions = Super.options;\n    Sub.extendOptions = extendOptions;\n    Sub.sealedOptions = extend({}, Sub.options);\n\n    // cache constructor\n    cachedCtors[SuperId] = Sub;\n    return Sub;\n  };\n}\n\nfunction initProps$1(Comp) {\n  var props = Comp.options.props;\n  for (var key in props) {\n    proxy(Comp.prototype, \"_props\", key);\n  }\n}\n\nfunction initComputed$1(Comp) {\n  var computed = Comp.options.computed;\n  for (var key in computed) {\n    defineComputed(Comp.prototype, key, computed[key]);\n  }\n}\n\n/*  */\n\nfunction initAssetRegisters(Vue) {\n  /**\n   * Create asset registration methods.\n   */\n  ASSET_TYPES.forEach(function (type) {\n    Vue[type] = function (id, definition) {\n      if (!definition) {\n        return this.options[type + 's'][id];\n      } else {\n        /* istanbul ignore if */\n        if (process.env.NODE_ENV !== 'production' && type === 'component') {\n          validateComponentName(id);\n        }\n        if (type === 'component' && isPlainObject(definition)) {\n          definition.name = definition.name || id;\n          definition = this.options._base.extend(definition);\n        }\n        if (type === 'directive' && typeof definition === 'function') {\n          definition = { bind: definition, update: definition };\n        }\n        this.options[type + 's'][id] = definition;\n        return definition;\n      }\n    };\n  });\n}\n\n/*  */\n\nfunction getComponentName(opts) {\n  return opts && (opts.Ctor.options.name || opts.tag);\n}\n\nfunction matches(pattern, name) {\n  if (Array.isArray(pattern)) {\n    return pattern.indexOf(name) > -1;\n  } else if (typeof pattern === 'string') {\n    return pattern.split(',').indexOf(name) > -1;\n  } else if (isRegExp(pattern)) {\n    return pattern.test(name);\n  }\n  /* istanbul ignore next */\n  return false;\n}\n\nfunction pruneCache(keepAliveInstance, filter) {\n  var cache = keepAliveInstance.cache;\n  var keys = keepAliveInstance.keys;\n  var _vnode = keepAliveInstance._vnode;\n  for (var key in cache) {\n    var cachedNode = cache[key];\n    if (cachedNode) {\n      var name = getComponentName(cachedNode.componentOptions);\n      if (name && !filter(name)) {\n        pruneCacheEntry(cache, key, keys, _vnode);\n      }\n    }\n  }\n}\n\nfunction pruneCacheEntry(cache, key, keys, current) {\n  var cached$$1 = cache[key];\n  if (cached$$1 && (!current || cached$$1.tag !== current.tag)) {\n    cached$$1.componentInstance.$destroy();\n  }\n  cache[key] = null;\n  remove(keys, key);\n}\n\nvar patternTypes = [String, RegExp, Array];\n\nvar KeepAlive = {\n  name: 'keep-alive',\n  abstract: true,\n\n  props: {\n    include: patternTypes,\n    exclude: patternTypes,\n    max: [String, Number]\n  },\n\n  created: function created() {\n    this.cache = Object.create(null);\n    this.keys = [];\n  },\n\n  destroyed: function destroyed() {\n    var this$1 = this;\n\n    for (var key in this$1.cache) {\n      pruneCacheEntry(this$1.cache, key, this$1.keys);\n    }\n  },\n\n  watch: {\n    include: function include(val) {\n      pruneCache(this, function (name) {\n        return matches(val, name);\n      });\n    },\n    exclude: function exclude(val) {\n      pruneCache(this, function (name) {\n        return !matches(val, name);\n      });\n    }\n  },\n\n  render: function render() {\n    var slot = this.$slots.default;\n    var vnode = getFirstComponentChild(slot);\n    var componentOptions = vnode && vnode.componentOptions;\n    if (componentOptions) {\n      // check pattern\n      var name = getComponentName(componentOptions);\n      var ref = this;\n      var include = ref.include;\n      var exclude = ref.exclude;\n      if (\n      // not included\n      include && (!name || !matches(include, name)) ||\n      // excluded\n      exclude && name && matches(exclude, name)) {\n        return vnode;\n      }\n\n      var ref$1 = this;\n      var cache = ref$1.cache;\n      var keys = ref$1.keys;\n      var key = vnode.key == null\n      // same constructor may get registered as different local components\n      // so cid alone is not enough (#3269)\n      ? componentOptions.Ctor.cid + (componentOptions.tag ? \"::\" + componentOptions.tag : '') : vnode.key;\n      if (cache[key]) {\n        vnode.componentInstance = cache[key].componentInstance;\n        // make current key freshest\n        remove(keys, key);\n        keys.push(key);\n      } else {\n        cache[key] = vnode;\n        keys.push(key);\n        // prune oldest entry\n        if (this.max && keys.length > parseInt(this.max)) {\n          pruneCacheEntry(cache, keys[0], keys, this._vnode);\n        }\n      }\n\n      vnode.data.keepAlive = true;\n    }\n    return vnode || slot && slot[0];\n  }\n};\n\nvar builtInComponents = {\n  KeepAlive: KeepAlive\n};\n\n/*  */\n\nfunction initGlobalAPI(Vue) {\n  // config\n  var configDef = {};\n  configDef.get = function () {\n    return config;\n  };\n  if (process.env.NODE_ENV !== 'production') {\n    configDef.set = function () {\n      warn('Do not replace the Vue.config object, set individual fields instead.');\n    };\n  }\n  Object.defineProperty(Vue, 'config', configDef);\n\n  // exposed util methods.\n  // NOTE: these are not considered part of the public API - avoid relying on\n  // them unless you are aware of the risk.\n  Vue.util = {\n    warn: warn,\n    extend: extend,\n    mergeOptions: mergeOptions,\n    defineReactive: defineReactive\n  };\n\n  Vue.set = set;\n  Vue.delete = del;\n  Vue.nextTick = nextTick;\n\n  Vue.options = Object.create(null);\n  ASSET_TYPES.forEach(function (type) {\n    Vue.options[type + 's'] = Object.create(null);\n  });\n\n  // this is used to identify the \"base\" constructor to extend all plain-object\n  // components with in Weex's multi-instance scenarios.\n  Vue.options._base = Vue;\n\n  extend(Vue.options.components, builtInComponents);\n\n  initUse(Vue);\n  initMixin$1(Vue);\n  initExtend(Vue);\n  initAssetRegisters(Vue);\n}\n\ninitGlobalAPI(Vue$3);\n\nObject.defineProperty(Vue$3.prototype, '$isServer', {\n  get: isServerRendering\n});\n\nObject.defineProperty(Vue$3.prototype, '$ssrContext', {\n  get: function get() {\n    /* istanbul ignore next */\n    return this.$vnode && this.$vnode.ssrContext;\n  }\n});\n\nVue$3.version = '2.5.11';\n\n/*  */\n\n// these are reserved for web because they are directly compiled away\n// during template compilation\nvar isReservedAttr = makeMap('style,class');\n\n// attributes that should be using props for binding\nvar acceptValue = makeMap('input,textarea,option,select,progress');\nvar mustUseProp = function mustUseProp(tag, type, attr) {\n  return attr === 'value' && acceptValue(tag) && type !== 'button' || attr === 'selected' && tag === 'option' || attr === 'checked' && tag === 'input' || attr === 'muted' && tag === 'video';\n};\n\nvar isEnumeratedAttr = makeMap('contenteditable,draggable,spellcheck');\n\nvar isBooleanAttr = makeMap('allowfullscreen,async,autofocus,autoplay,checked,compact,controls,declare,' + 'default,defaultchecked,defaultmuted,defaultselected,defer,disabled,' + 'enabled,formnovalidate,hidden,indeterminate,inert,ismap,itemscope,loop,multiple,' + 'muted,nohref,noresize,noshade,novalidate,nowrap,open,pauseonexit,readonly,' + 'required,reversed,scoped,seamless,selected,sortable,translate,' + 'truespeed,typemustmatch,visible');\n\nvar xlinkNS = 'http://www.w3.org/1999/xlink';\n\nvar isXlink = function isXlink(name) {\n  return name.charAt(5) === ':' && name.slice(0, 5) === 'xlink';\n};\n\nvar getXlinkProp = function getXlinkProp(name) {\n  return isXlink(name) ? name.slice(6, name.length) : '';\n};\n\nvar isFalsyAttrValue = function isFalsyAttrValue(val) {\n  return val == null || val === false;\n};\n\n/*  */\n\nfunction genClassForVnode(vnode) {\n  var data = vnode.data;\n  var parentNode = vnode;\n  var childNode = vnode;\n  while (isDef(childNode.componentInstance)) {\n    childNode = childNode.componentInstance._vnode;\n    if (childNode && childNode.data) {\n      data = mergeClassData(childNode.data, data);\n    }\n  }\n  while (isDef(parentNode = parentNode.parent)) {\n    if (parentNode && parentNode.data) {\n      data = mergeClassData(data, parentNode.data);\n    }\n  }\n  return renderClass(data.staticClass, data.class);\n}\n\nfunction mergeClassData(child, parent) {\n  return {\n    staticClass: concat(child.staticClass, parent.staticClass),\n    class: isDef(child.class) ? [child.class, parent.class] : parent.class\n  };\n}\n\nfunction renderClass(staticClass, dynamicClass) {\n  if (isDef(staticClass) || isDef(dynamicClass)) {\n    return concat(staticClass, stringifyClass(dynamicClass));\n  }\n  /* istanbul ignore next */\n  return '';\n}\n\nfunction concat(a, b) {\n  return a ? b ? a + ' ' + b : a : b || '';\n}\n\nfunction stringifyClass(value) {\n  if (Array.isArray(value)) {\n    return stringifyArray(value);\n  }\n  if (isObject(value)) {\n    return stringifyObject(value);\n  }\n  if (typeof value === 'string') {\n    return value;\n  }\n  /* istanbul ignore next */\n  return '';\n}\n\nfunction stringifyArray(value) {\n  var res = '';\n  var stringified;\n  for (var i = 0, l = value.length; i < l; i++) {\n    if (isDef(stringified = stringifyClass(value[i])) && stringified !== '') {\n      if (res) {\n        res += ' ';\n      }\n      res += stringified;\n    }\n  }\n  return res;\n}\n\nfunction stringifyObject(value) {\n  var res = '';\n  for (var key in value) {\n    if (value[key]) {\n      if (res) {\n        res += ' ';\n      }\n      res += key;\n    }\n  }\n  return res;\n}\n\n/*  */\n\nvar namespaceMap = {\n  svg: 'http://www.w3.org/2000/svg',\n  math: 'http://www.w3.org/1998/Math/MathML'\n};\n\nvar isHTMLTag = makeMap('html,body,base,head,link,meta,style,title,' + 'address,article,aside,footer,header,h1,h2,h3,h4,h5,h6,hgroup,nav,section,' + 'div,dd,dl,dt,figcaption,figure,picture,hr,img,li,main,ol,p,pre,ul,' + 'a,b,abbr,bdi,bdo,br,cite,code,data,dfn,em,i,kbd,mark,q,rp,rt,rtc,ruby,' + 's,samp,small,span,strong,sub,sup,time,u,var,wbr,area,audio,map,track,video,' + 'embed,object,param,source,canvas,script,noscript,del,ins,' + 'caption,col,colgroup,table,thead,tbody,td,th,tr,' + 'button,datalist,fieldset,form,input,label,legend,meter,optgroup,option,' + 'output,progress,select,textarea,' + 'details,dialog,menu,menuitem,summary,' + 'content,element,shadow,template,blockquote,iframe,tfoot');\n\n// this map is intentionally selective, only covering SVG elements that may\n// contain child elements.\nvar isSVG = makeMap('svg,animate,circle,clippath,cursor,defs,desc,ellipse,filter,font-face,' + 'foreignObject,g,glyph,image,line,marker,mask,missing-glyph,path,pattern,' + 'polygon,polyline,rect,switch,symbol,text,textpath,tspan,use,view', true);\n\nvar isPreTag = function isPreTag(tag) {\n  return tag === 'pre';\n};\n\nvar isReservedTag = function isReservedTag(tag) {\n  return isHTMLTag(tag) || isSVG(tag);\n};\n\nfunction getTagNamespace(tag) {\n  if (isSVG(tag)) {\n    return 'svg';\n  }\n  // basic support for MathML\n  // note it doesn't support other MathML elements being component roots\n  if (tag === 'math') {\n    return 'math';\n  }\n}\n\nvar unknownElementCache = Object.create(null);\nfunction isUnknownElement(tag) {\n  /* istanbul ignore if */\n  if (!inBrowser) {\n    return true;\n  }\n  if (isReservedTag(tag)) {\n    return false;\n  }\n  tag = tag.toLowerCase();\n  /* istanbul ignore if */\n  if (unknownElementCache[tag] != null) {\n    return unknownElementCache[tag];\n  }\n  var el = document.createElement(tag);\n  if (tag.indexOf('-') > -1) {\n    // http://stackoverflow.com/a/28210364/1070244\n    return unknownElementCache[tag] = el.constructor === window.HTMLUnknownElement || el.constructor === window.HTMLElement;\n  } else {\n    return unknownElementCache[tag] = /HTMLUnknownElement/.test(el.toString());\n  }\n}\n\nvar isTextInputType = makeMap('text,number,password,search,email,tel,url');\n\n/*  */\n\n/**\n * Query an element selector if it's not an element already.\n */\nfunction query(el) {\n  if (typeof el === 'string') {\n    var selected = document.querySelector(el);\n    if (!selected) {\n      process.env.NODE_ENV !== 'production' && warn('Cannot find element: ' + el);\n      return document.createElement('div');\n    }\n    return selected;\n  } else {\n    return el;\n  }\n}\n\n/*  */\n\nfunction createElement$1(tagName, vnode) {\n  var elm = document.createElement(tagName);\n  if (tagName !== 'select') {\n    return elm;\n  }\n  // false or null will remove the attribute but undefined will not\n  if (vnode.data && vnode.data.attrs && vnode.data.attrs.multiple !== undefined) {\n    elm.setAttribute('multiple', 'multiple');\n  }\n  return elm;\n}\n\nfunction createElementNS(namespace, tagName) {\n  return document.createElementNS(namespaceMap[namespace], tagName);\n}\n\nfunction createTextNode(text) {\n  return document.createTextNode(text);\n}\n\nfunction createComment(text) {\n  return document.createComment(text);\n}\n\nfunction insertBefore(parentNode, newNode, referenceNode) {\n  parentNode.insertBefore(newNode, referenceNode);\n}\n\nfunction removeChild(node, child) {\n  node.removeChild(child);\n}\n\nfunction appendChild(node, child) {\n  node.appendChild(child);\n}\n\nfunction parentNode(node) {\n  return node.parentNode;\n}\n\nfunction nextSibling(node) {\n  return node.nextSibling;\n}\n\nfunction tagName(node) {\n  return node.tagName;\n}\n\nfunction setTextContent(node, text) {\n  node.textContent = text;\n}\n\nfunction setAttribute(node, key, val) {\n  node.setAttribute(key, val);\n}\n\nvar nodeOps = Object.freeze({\n  createElement: createElement$1,\n  createElementNS: createElementNS,\n  createTextNode: createTextNode,\n  createComment: createComment,\n  insertBefore: insertBefore,\n  removeChild: removeChild,\n  appendChild: appendChild,\n  parentNode: parentNode,\n  nextSibling: nextSibling,\n  tagName: tagName,\n  setTextContent: setTextContent,\n  setAttribute: setAttribute\n});\n\n/*  */\n\nvar ref = {\n  create: function create(_, vnode) {\n    registerRef(vnode);\n  },\n  update: function update(oldVnode, vnode) {\n    if (oldVnode.data.ref !== vnode.data.ref) {\n      registerRef(oldVnode, true);\n      registerRef(vnode);\n    }\n  },\n  destroy: function destroy(vnode) {\n    registerRef(vnode, true);\n  }\n};\n\nfunction registerRef(vnode, isRemoval) {\n  var key = vnode.data.ref;\n  if (!key) {\n    return;\n  }\n\n  var vm = vnode.context;\n  var ref = vnode.componentInstance || vnode.elm;\n  var refs = vm.$refs;\n  if (isRemoval) {\n    if (Array.isArray(refs[key])) {\n      remove(refs[key], ref);\n    } else if (refs[key] === ref) {\n      refs[key] = undefined;\n    }\n  } else {\n    if (vnode.data.refInFor) {\n      if (!Array.isArray(refs[key])) {\n        refs[key] = [ref];\n      } else if (refs[key].indexOf(ref) < 0) {\n        // $flow-disable-line\n        refs[key].push(ref);\n      }\n    } else {\n      refs[key] = ref;\n    }\n  }\n}\n\n/**\n * Virtual DOM patching algorithm based on Snabbdom by\n * Simon Friis Vindum (@paldepind)\n * Licensed under the MIT License\n * https://github.com/paldepind/snabbdom/blob/master/LICENSE\n *\n * modified by Evan You (@yyx990803)\n *\n * Not type-checking this because this file is perf-critical and the cost\n * of making flow understand it is not worth it.\n */\n\nvar emptyNode = new VNode('', {}, []);\n\nvar hooks = ['create', 'activate', 'update', 'remove', 'destroy'];\n\nfunction sameVnode(a, b) {\n  return a.key === b.key && (a.tag === b.tag && a.isComment === b.isComment && isDef(a.data) === isDef(b.data) && sameInputType(a, b) || isTrue(a.isAsyncPlaceholder) && a.asyncFactory === b.asyncFactory && isUndef(b.asyncFactory.error));\n}\n\nfunction sameInputType(a, b) {\n  if (a.tag !== 'input') {\n    return true;\n  }\n  var i;\n  var typeA = isDef(i = a.data) && isDef(i = i.attrs) && i.type;\n  var typeB = isDef(i = b.data) && isDef(i = i.attrs) && i.type;\n  return typeA === typeB || isTextInputType(typeA) && isTextInputType(typeB);\n}\n\nfunction createKeyToOldIdx(children, beginIdx, endIdx) {\n  var i, key;\n  var map = {};\n  for (i = beginIdx; i <= endIdx; ++i) {\n    key = children[i].key;\n    if (isDef(key)) {\n      map[key] = i;\n    }\n  }\n  return map;\n}\n\nfunction createPatchFunction(backend) {\n  var i, j;\n  var cbs = {};\n\n  var modules = backend.modules;\n  var nodeOps = backend.nodeOps;\n\n  for (i = 0; i < hooks.length; ++i) {\n    cbs[hooks[i]] = [];\n    for (j = 0; j < modules.length; ++j) {\n      if (isDef(modules[j][hooks[i]])) {\n        cbs[hooks[i]].push(modules[j][hooks[i]]);\n      }\n    }\n  }\n\n  function emptyNodeAt(elm) {\n    return new VNode(nodeOps.tagName(elm).toLowerCase(), {}, [], undefined, elm);\n  }\n\n  function createRmCb(childElm, listeners) {\n    function remove() {\n      if (--remove.listeners === 0) {\n        removeNode(childElm);\n      }\n    }\n    remove.listeners = listeners;\n    return remove;\n  }\n\n  function removeNode(el) {\n    var parent = nodeOps.parentNode(el);\n    // element may have already been removed due to v-html / v-text\n    if (isDef(parent)) {\n      nodeOps.removeChild(parent, el);\n    }\n  }\n\n  function isUnknownElement$$1(vnode, inVPre) {\n    return !inVPre && !vnode.ns && !(config.ignoredElements.length && config.ignoredElements.some(function (ignore) {\n      return isRegExp(ignore) ? ignore.test(vnode.tag) : ignore === vnode.tag;\n    })) && config.isUnknownElement(vnode.tag);\n  }\n\n  var creatingElmInVPre = 0;\n  function createElm(vnode, insertedVnodeQueue, parentElm, refElm, nested) {\n    vnode.isRootInsert = !nested; // for transition enter check\n    if (createComponent(vnode, insertedVnodeQueue, parentElm, refElm)) {\n      return;\n    }\n\n    var data = vnode.data;\n    var children = vnode.children;\n    var tag = vnode.tag;\n    if (isDef(tag)) {\n      if (process.env.NODE_ENV !== 'production') {\n        if (data && data.pre) {\n          creatingElmInVPre++;\n        }\n        if (isUnknownElement$$1(vnode, creatingElmInVPre)) {\n          warn('Unknown custom element: <' + tag + '> - did you ' + 'register the component correctly? For recursive components, ' + 'make sure to provide the \"name\" option.', vnode.context);\n        }\n      }\n      vnode.elm = vnode.ns ? nodeOps.createElementNS(vnode.ns, tag) : nodeOps.createElement(tag, vnode);\n      setScope(vnode);\n\n      /* istanbul ignore if */\n      {\n        createChildren(vnode, children, insertedVnodeQueue);\n        if (isDef(data)) {\n          invokeCreateHooks(vnode, insertedVnodeQueue);\n        }\n        insert(parentElm, vnode.elm, refElm);\n      }\n\n      if (process.env.NODE_ENV !== 'production' && data && data.pre) {\n        creatingElmInVPre--;\n      }\n    } else if (isTrue(vnode.isComment)) {\n      vnode.elm = nodeOps.createComment(vnode.text);\n      insert(parentElm, vnode.elm, refElm);\n    } else {\n      vnode.elm = nodeOps.createTextNode(vnode.text);\n      insert(parentElm, vnode.elm, refElm);\n    }\n  }\n\n  function createComponent(vnode, insertedVnodeQueue, parentElm, refElm) {\n    var i = vnode.data;\n    if (isDef(i)) {\n      var isReactivated = isDef(vnode.componentInstance) && i.keepAlive;\n      if (isDef(i = i.hook) && isDef(i = i.init)) {\n        i(vnode, false /* hydrating */, parentElm, refElm);\n      }\n      // after calling the init hook, if the vnode is a child component\n      // it should've created a child instance and mounted it. the child\n      // component also has set the placeholder vnode's elm.\n      // in that case we can just return the element and be done.\n      if (isDef(vnode.componentInstance)) {\n        initComponent(vnode, insertedVnodeQueue);\n        if (isTrue(isReactivated)) {\n          reactivateComponent(vnode, insertedVnodeQueue, parentElm, refElm);\n        }\n        return true;\n      }\n    }\n  }\n\n  function initComponent(vnode, insertedVnodeQueue) {\n    if (isDef(vnode.data.pendingInsert)) {\n      insertedVnodeQueue.push.apply(insertedVnodeQueue, vnode.data.pendingInsert);\n      vnode.data.pendingInsert = null;\n    }\n    vnode.elm = vnode.componentInstance.$el;\n    if (isPatchable(vnode)) {\n      invokeCreateHooks(vnode, insertedVnodeQueue);\n      setScope(vnode);\n    } else {\n      // empty component root.\n      // skip all element-related modules except for ref (#3455)\n      registerRef(vnode);\n      // make sure to invoke the insert hook\n      insertedVnodeQueue.push(vnode);\n    }\n  }\n\n  function reactivateComponent(vnode, insertedVnodeQueue, parentElm, refElm) {\n    var i;\n    // hack for #4339: a reactivated component with inner transition\n    // does not trigger because the inner node's created hooks are not called\n    // again. It's not ideal to involve module-specific logic in here but\n    // there doesn't seem to be a better way to do it.\n    var innerNode = vnode;\n    while (innerNode.componentInstance) {\n      innerNode = innerNode.componentInstance._vnode;\n      if (isDef(i = innerNode.data) && isDef(i = i.transition)) {\n        for (i = 0; i < cbs.activate.length; ++i) {\n          cbs.activate[i](emptyNode, innerNode);\n        }\n        insertedVnodeQueue.push(innerNode);\n        break;\n      }\n    }\n    // unlike a newly created component,\n    // a reactivated keep-alive component doesn't insert itself\n    insert(parentElm, vnode.elm, refElm);\n  }\n\n  function insert(parent, elm, ref$$1) {\n    if (isDef(parent)) {\n      if (isDef(ref$$1)) {\n        if (ref$$1.parentNode === parent) {\n          nodeOps.insertBefore(parent, elm, ref$$1);\n        }\n      } else {\n        nodeOps.appendChild(parent, elm);\n      }\n    }\n  }\n\n  function createChildren(vnode, children, insertedVnodeQueue) {\n    if (Array.isArray(children)) {\n      if (process.env.NODE_ENV !== 'production') {\n        checkDuplicateKeys(children);\n      }\n      for (var i = 0; i < children.length; ++i) {\n        createElm(children[i], insertedVnodeQueue, vnode.elm, null, true);\n      }\n    } else if (isPrimitive(vnode.text)) {\n      nodeOps.appendChild(vnode.elm, nodeOps.createTextNode(vnode.text));\n    }\n  }\n\n  function isPatchable(vnode) {\n    while (vnode.componentInstance) {\n      vnode = vnode.componentInstance._vnode;\n    }\n    return isDef(vnode.tag);\n  }\n\n  function invokeCreateHooks(vnode, insertedVnodeQueue) {\n    for (var i$1 = 0; i$1 < cbs.create.length; ++i$1) {\n      cbs.create[i$1](emptyNode, vnode);\n    }\n    i = vnode.data.hook; // Reuse variable\n    if (isDef(i)) {\n      if (isDef(i.create)) {\n        i.create(emptyNode, vnode);\n      }\n      if (isDef(i.insert)) {\n        insertedVnodeQueue.push(vnode);\n      }\n    }\n  }\n\n  // set scope id attribute for scoped CSS.\n  // this is implemented as a special case to avoid the overhead\n  // of going through the normal attribute patching process.\n  function setScope(vnode) {\n    var i;\n    if (isDef(i = vnode.fnScopeId)) {\n      nodeOps.setAttribute(vnode.elm, i, '');\n    } else {\n      var ancestor = vnode;\n      while (ancestor) {\n        if (isDef(i = ancestor.context) && isDef(i = i.$options._scopeId)) {\n          nodeOps.setAttribute(vnode.elm, i, '');\n        }\n        ancestor = ancestor.parent;\n      }\n    }\n    // for slot content they should also get the scopeId from the host instance.\n    if (isDef(i = activeInstance) && i !== vnode.context && i !== vnode.fnContext && isDef(i = i.$options._scopeId)) {\n      nodeOps.setAttribute(vnode.elm, i, '');\n    }\n  }\n\n  function addVnodes(parentElm, refElm, vnodes, startIdx, endIdx, insertedVnodeQueue) {\n    for (; startIdx <= endIdx; ++startIdx) {\n      createElm(vnodes[startIdx], insertedVnodeQueue, parentElm, refElm);\n    }\n  }\n\n  function invokeDestroyHook(vnode) {\n    var i, j;\n    var data = vnode.data;\n    if (isDef(data)) {\n      if (isDef(i = data.hook) && isDef(i = i.destroy)) {\n        i(vnode);\n      }\n      for (i = 0; i < cbs.destroy.length; ++i) {\n        cbs.destroy[i](vnode);\n      }\n    }\n    if (isDef(i = vnode.children)) {\n      for (j = 0; j < vnode.children.length; ++j) {\n        invokeDestroyHook(vnode.children[j]);\n      }\n    }\n  }\n\n  function removeVnodes(parentElm, vnodes, startIdx, endIdx) {\n    for (; startIdx <= endIdx; ++startIdx) {\n      var ch = vnodes[startIdx];\n      if (isDef(ch)) {\n        if (isDef(ch.tag)) {\n          removeAndInvokeRemoveHook(ch);\n          invokeDestroyHook(ch);\n        } else {\n          // Text node\n          removeNode(ch.elm);\n        }\n      }\n    }\n  }\n\n  function removeAndInvokeRemoveHook(vnode, rm) {\n    if (isDef(rm) || isDef(vnode.data)) {\n      var i;\n      var listeners = cbs.remove.length + 1;\n      if (isDef(rm)) {\n        // we have a recursively passed down rm callback\n        // increase the listeners count\n        rm.listeners += listeners;\n      } else {\n        // directly removing\n        rm = createRmCb(vnode.elm, listeners);\n      }\n      // recursively invoke hooks on child component root node\n      if (isDef(i = vnode.componentInstance) && isDef(i = i._vnode) && isDef(i.data)) {\n        removeAndInvokeRemoveHook(i, rm);\n      }\n      for (i = 0; i < cbs.remove.length; ++i) {\n        cbs.remove[i](vnode, rm);\n      }\n      if (isDef(i = vnode.data.hook) && isDef(i = i.remove)) {\n        i(vnode, rm);\n      } else {\n        rm();\n      }\n    } else {\n      removeNode(vnode.elm);\n    }\n  }\n\n  function updateChildren(parentElm, oldCh, newCh, insertedVnodeQueue, removeOnly) {\n    var oldStartIdx = 0;\n    var newStartIdx = 0;\n    var oldEndIdx = oldCh.length - 1;\n    var oldStartVnode = oldCh[0];\n    var oldEndVnode = oldCh[oldEndIdx];\n    var newEndIdx = newCh.length - 1;\n    var newStartVnode = newCh[0];\n    var newEndVnode = newCh[newEndIdx];\n    var oldKeyToIdx, idxInOld, vnodeToMove, refElm;\n\n    // removeOnly is a special flag used only by <transition-group>\n    // to ensure removed elements stay in correct relative positions\n    // during leaving transitions\n    var canMove = !removeOnly;\n\n    if (process.env.NODE_ENV !== 'production') {\n      checkDuplicateKeys(newCh);\n    }\n\n    while (oldStartIdx <= oldEndIdx && newStartIdx <= newEndIdx) {\n      if (isUndef(oldStartVnode)) {\n        oldStartVnode = oldCh[++oldStartIdx]; // Vnode has been moved left\n      } else if (isUndef(oldEndVnode)) {\n        oldEndVnode = oldCh[--oldEndIdx];\n      } else if (sameVnode(oldStartVnode, newStartVnode)) {\n        patchVnode(oldStartVnode, newStartVnode, insertedVnodeQueue);\n        oldStartVnode = oldCh[++oldStartIdx];\n        newStartVnode = newCh[++newStartIdx];\n      } else if (sameVnode(oldEndVnode, newEndVnode)) {\n        patchVnode(oldEndVnode, newEndVnode, insertedVnodeQueue);\n        oldEndVnode = oldCh[--oldEndIdx];\n        newEndVnode = newCh[--newEndIdx];\n      } else if (sameVnode(oldStartVnode, newEndVnode)) {\n        // Vnode moved right\n        patchVnode(oldStartVnode, newEndVnode, insertedVnodeQueue);\n        canMove && nodeOps.insertBefore(parentElm, oldStartVnode.elm, nodeOps.nextSibling(oldEndVnode.elm));\n        oldStartVnode = oldCh[++oldStartIdx];\n        newEndVnode = newCh[--newEndIdx];\n      } else if (sameVnode(oldEndVnode, newStartVnode)) {\n        // Vnode moved left\n        patchVnode(oldEndVnode, newStartVnode, insertedVnodeQueue);\n        canMove && nodeOps.insertBefore(parentElm, oldEndVnode.elm, oldStartVnode.elm);\n        oldEndVnode = oldCh[--oldEndIdx];\n        newStartVnode = newCh[++newStartIdx];\n      } else {\n        if (isUndef(oldKeyToIdx)) {\n          oldKeyToIdx = createKeyToOldIdx(oldCh, oldStartIdx, oldEndIdx);\n        }\n        idxInOld = isDef(newStartVnode.key) ? oldKeyToIdx[newStartVnode.key] : findIdxInOld(newStartVnode, oldCh, oldStartIdx, oldEndIdx);\n        if (isUndef(idxInOld)) {\n          // New element\n          createElm(newStartVnode, insertedVnodeQueue, parentElm, oldStartVnode.elm);\n        } else {\n          vnodeToMove = oldCh[idxInOld];\n          if (sameVnode(vnodeToMove, newStartVnode)) {\n            patchVnode(vnodeToMove, newStartVnode, insertedVnodeQueue);\n            oldCh[idxInOld] = undefined;\n            canMove && nodeOps.insertBefore(parentElm, vnodeToMove.elm, oldStartVnode.elm);\n          } else {\n            // same key but different element. treat as new element\n            createElm(newStartVnode, insertedVnodeQueue, parentElm, oldStartVnode.elm);\n          }\n        }\n        newStartVnode = newCh[++newStartIdx];\n      }\n    }\n    if (oldStartIdx > oldEndIdx) {\n      refElm = isUndef(newCh[newEndIdx + 1]) ? null : newCh[newEndIdx + 1].elm;\n      addVnodes(parentElm, refElm, newCh, newStartIdx, newEndIdx, insertedVnodeQueue);\n    } else if (newStartIdx > newEndIdx) {\n      removeVnodes(parentElm, oldCh, oldStartIdx, oldEndIdx);\n    }\n  }\n\n  function checkDuplicateKeys(children) {\n    var seenKeys = {};\n    for (var i = 0; i < children.length; i++) {\n      var vnode = children[i];\n      var key = vnode.key;\n      if (isDef(key)) {\n        if (seenKeys[key]) {\n          warn(\"Duplicate keys detected: '\" + key + \"'. This may cause an update error.\", vnode.context);\n        } else {\n          seenKeys[key] = true;\n        }\n      }\n    }\n  }\n\n  function findIdxInOld(node, oldCh, start, end) {\n    for (var i = start; i < end; i++) {\n      var c = oldCh[i];\n      if (isDef(c) && sameVnode(node, c)) {\n        return i;\n      }\n    }\n  }\n\n  function patchVnode(oldVnode, vnode, insertedVnodeQueue, removeOnly) {\n    if (oldVnode === vnode) {\n      return;\n    }\n\n    var elm = vnode.elm = oldVnode.elm;\n\n    if (isTrue(oldVnode.isAsyncPlaceholder)) {\n      if (isDef(vnode.asyncFactory.resolved)) {\n        hydrate(oldVnode.elm, vnode, insertedVnodeQueue);\n      } else {\n        vnode.isAsyncPlaceholder = true;\n      }\n      return;\n    }\n\n    // reuse element for static trees.\n    // note we only do this if the vnode is cloned -\n    // if the new node is not cloned it means the render functions have been\n    // reset by the hot-reload-api and we need to do a proper re-render.\n    if (isTrue(vnode.isStatic) && isTrue(oldVnode.isStatic) && vnode.key === oldVnode.key && (isTrue(vnode.isCloned) || isTrue(vnode.isOnce))) {\n      vnode.componentInstance = oldVnode.componentInstance;\n      return;\n    }\n\n    var i;\n    var data = vnode.data;\n    if (isDef(data) && isDef(i = data.hook) && isDef(i = i.prepatch)) {\n      i(oldVnode, vnode);\n    }\n\n    var oldCh = oldVnode.children;\n    var ch = vnode.children;\n    if (isDef(data) && isPatchable(vnode)) {\n      for (i = 0; i < cbs.update.length; ++i) {\n        cbs.update[i](oldVnode, vnode);\n      }\n      if (isDef(i = data.hook) && isDef(i = i.update)) {\n        i(oldVnode, vnode);\n      }\n    }\n    if (isUndef(vnode.text)) {\n      if (isDef(oldCh) && isDef(ch)) {\n        if (oldCh !== ch) {\n          updateChildren(elm, oldCh, ch, insertedVnodeQueue, removeOnly);\n        }\n      } else if (isDef(ch)) {\n        if (isDef(oldVnode.text)) {\n          nodeOps.setTextContent(elm, '');\n        }\n        addVnodes(elm, null, ch, 0, ch.length - 1, insertedVnodeQueue);\n      } else if (isDef(oldCh)) {\n        removeVnodes(elm, oldCh, 0, oldCh.length - 1);\n      } else if (isDef(oldVnode.text)) {\n        nodeOps.setTextContent(elm, '');\n      }\n    } else if (oldVnode.text !== vnode.text) {\n      nodeOps.setTextContent(elm, vnode.text);\n    }\n    if (isDef(data)) {\n      if (isDef(i = data.hook) && isDef(i = i.postpatch)) {\n        i(oldVnode, vnode);\n      }\n    }\n  }\n\n  function invokeInsertHook(vnode, queue, initial) {\n    // delay insert hooks for component root nodes, invoke them after the\n    // element is really inserted\n    if (isTrue(initial) && isDef(vnode.parent)) {\n      vnode.parent.data.pendingInsert = queue;\n    } else {\n      for (var i = 0; i < queue.length; ++i) {\n        queue[i].data.hook.insert(queue[i]);\n      }\n    }\n  }\n\n  var hydrationBailed = false;\n  // list of modules that can skip create hook during hydration because they\n  // are already rendered on the client or has no need for initialization\n  // Note: style is excluded because it relies on initial clone for future\n  // deep updates (#7063).\n  var isRenderedModule = makeMap('attrs,class,staticClass,staticStyle,key');\n\n  // Note: this is a browser-only function so we can assume elms are DOM nodes.\n  function hydrate(elm, vnode, insertedVnodeQueue, inVPre) {\n    var i;\n    var tag = vnode.tag;\n    var data = vnode.data;\n    var children = vnode.children;\n    inVPre = inVPre || data && data.pre;\n    vnode.elm = elm;\n\n    if (isTrue(vnode.isComment) && isDef(vnode.asyncFactory)) {\n      vnode.isAsyncPlaceholder = true;\n      return true;\n    }\n    // assert node match\n    if (process.env.NODE_ENV !== 'production') {\n      if (!assertNodeMatch(elm, vnode, inVPre)) {\n        return false;\n      }\n    }\n    if (isDef(data)) {\n      if (isDef(i = data.hook) && isDef(i = i.init)) {\n        i(vnode, true /* hydrating */);\n      }\n      if (isDef(i = vnode.componentInstance)) {\n        // child component. it should have hydrated its own tree.\n        initComponent(vnode, insertedVnodeQueue);\n        return true;\n      }\n    }\n    if (isDef(tag)) {\n      if (isDef(children)) {\n        // empty element, allow client to pick up and populate children\n        if (!elm.hasChildNodes()) {\n          createChildren(vnode, children, insertedVnodeQueue);\n        } else {\n          // v-html and domProps: innerHTML\n          if (isDef(i = data) && isDef(i = i.domProps) && isDef(i = i.innerHTML)) {\n            if (i !== elm.innerHTML) {\n              /* istanbul ignore if */\n              if (process.env.NODE_ENV !== 'production' && typeof console !== 'undefined' && !hydrationBailed) {\n                hydrationBailed = true;\n                console.warn('Parent: ', elm);\n                console.warn('server innerHTML: ', i);\n                console.warn('client innerHTML: ', elm.innerHTML);\n              }\n              return false;\n            }\n          } else {\n            // iterate and compare children lists\n            var childrenMatch = true;\n            var childNode = elm.firstChild;\n            for (var i$1 = 0; i$1 < children.length; i$1++) {\n              if (!childNode || !hydrate(childNode, children[i$1], insertedVnodeQueue, inVPre)) {\n                childrenMatch = false;\n                break;\n              }\n              childNode = childNode.nextSibling;\n            }\n            // if childNode is not null, it means the actual childNodes list is\n            // longer than the virtual children list.\n            if (!childrenMatch || childNode) {\n              /* istanbul ignore if */\n              if (process.env.NODE_ENV !== 'production' && typeof console !== 'undefined' && !hydrationBailed) {\n                hydrationBailed = true;\n                console.warn('Parent: ', elm);\n                console.warn('Mismatching childNodes vs. VNodes: ', elm.childNodes, children);\n              }\n              return false;\n            }\n          }\n        }\n      }\n      if (isDef(data)) {\n        var fullInvoke = false;\n        for (var key in data) {\n          if (!isRenderedModule(key)) {\n            fullInvoke = true;\n            invokeCreateHooks(vnode, insertedVnodeQueue);\n            break;\n          }\n        }\n        if (!fullInvoke && data['class']) {\n          // ensure collecting deps for deep class bindings for future updates\n          traverse(data['class']);\n        }\n      }\n    } else if (elm.data !== vnode.text) {\n      elm.data = vnode.text;\n    }\n    return true;\n  }\n\n  function assertNodeMatch(node, vnode, inVPre) {\n    if (isDef(vnode.tag)) {\n      return vnode.tag.indexOf('vue-component') === 0 || !isUnknownElement$$1(vnode, inVPre) && vnode.tag.toLowerCase() === (node.tagName && node.tagName.toLowerCase());\n    } else {\n      return node.nodeType === (vnode.isComment ? 8 : 3);\n    }\n  }\n\n  return function patch(oldVnode, vnode, hydrating, removeOnly, parentElm, refElm) {\n    if (isUndef(vnode)) {\n      if (isDef(oldVnode)) {\n        invokeDestroyHook(oldVnode);\n      }\n      return;\n    }\n\n    var isInitialPatch = false;\n    var insertedVnodeQueue = [];\n\n    if (isUndef(oldVnode)) {\n      // empty mount (likely as component), create new root element\n      isInitialPatch = true;\n      createElm(vnode, insertedVnodeQueue, parentElm, refElm);\n    } else {\n      var isRealElement = isDef(oldVnode.nodeType);\n      if (!isRealElement && sameVnode(oldVnode, vnode)) {\n        // patch existing root node\n        patchVnode(oldVnode, vnode, insertedVnodeQueue, removeOnly);\n      } else {\n        if (isRealElement) {\n          // mounting to a real element\n          // check if this is server-rendered content and if we can perform\n          // a successful hydration.\n          if (oldVnode.nodeType === 1 && oldVnode.hasAttribute(SSR_ATTR)) {\n            oldVnode.removeAttribute(SSR_ATTR);\n            hydrating = true;\n          }\n          if (isTrue(hydrating)) {\n            if (hydrate(oldVnode, vnode, insertedVnodeQueue)) {\n              invokeInsertHook(vnode, insertedVnodeQueue, true);\n              return oldVnode;\n            } else if (process.env.NODE_ENV !== 'production') {\n              warn('The client-side rendered virtual DOM tree is not matching ' + 'server-rendered content. This is likely caused by incorrect ' + 'HTML markup, for example nesting block-level elements inside ' + '<p>, or missing <tbody>. Bailing hydration and performing ' + 'full client-side render.');\n            }\n          }\n          // either not server-rendered, or hydration failed.\n          // create an empty node and replace it\n          oldVnode = emptyNodeAt(oldVnode);\n        }\n\n        // replacing existing element\n        var oldElm = oldVnode.elm;\n        var parentElm$1 = nodeOps.parentNode(oldElm);\n\n        // create new node\n        createElm(vnode, insertedVnodeQueue,\n        // extremely rare edge case: do not insert if old element is in a\n        // leaving transition. Only happens when combining transition +\n        // keep-alive + HOCs. (#4590)\n        oldElm._leaveCb ? null : parentElm$1, nodeOps.nextSibling(oldElm));\n\n        // update parent placeholder node element, recursively\n        if (isDef(vnode.parent)) {\n          var ancestor = vnode.parent;\n          var patchable = isPatchable(vnode);\n          while (ancestor) {\n            for (var i = 0; i < cbs.destroy.length; ++i) {\n              cbs.destroy[i](ancestor);\n            }\n            ancestor.elm = vnode.elm;\n            if (patchable) {\n              for (var i$1 = 0; i$1 < cbs.create.length; ++i$1) {\n                cbs.create[i$1](emptyNode, ancestor);\n              }\n              // #6513\n              // invoke insert hooks that may have been merged by create hooks.\n              // e.g. for directives that uses the \"inserted\" hook.\n              var insert = ancestor.data.hook.insert;\n              if (insert.merged) {\n                // start at index 1 to avoid re-invoking component mounted hook\n                for (var i$2 = 1; i$2 < insert.fns.length; i$2++) {\n                  insert.fns[i$2]();\n                }\n              }\n            } else {\n              registerRef(ancestor);\n            }\n            ancestor = ancestor.parent;\n          }\n        }\n\n        // destroy old node\n        if (isDef(parentElm$1)) {\n          removeVnodes(parentElm$1, [oldVnode], 0, 0);\n        } else if (isDef(oldVnode.tag)) {\n          invokeDestroyHook(oldVnode);\n        }\n      }\n    }\n\n    invokeInsertHook(vnode, insertedVnodeQueue, isInitialPatch);\n    return vnode.elm;\n  };\n}\n\n/*  */\n\nvar directives = {\n  create: updateDirectives,\n  update: updateDirectives,\n  destroy: function unbindDirectives(vnode) {\n    updateDirectives(vnode, emptyNode);\n  }\n};\n\nfunction updateDirectives(oldVnode, vnode) {\n  if (oldVnode.data.directives || vnode.data.directives) {\n    _update(oldVnode, vnode);\n  }\n}\n\nfunction _update(oldVnode, vnode) {\n  var isCreate = oldVnode === emptyNode;\n  var isDestroy = vnode === emptyNode;\n  var oldDirs = normalizeDirectives$1(oldVnode.data.directives, oldVnode.context);\n  var newDirs = normalizeDirectives$1(vnode.data.directives, vnode.context);\n\n  var dirsWithInsert = [];\n  var dirsWithPostpatch = [];\n\n  var key, oldDir, dir;\n  for (key in newDirs) {\n    oldDir = oldDirs[key];\n    dir = newDirs[key];\n    if (!oldDir) {\n      // new directive, bind\n      callHook$1(dir, 'bind', vnode, oldVnode);\n      if (dir.def && dir.def.inserted) {\n        dirsWithInsert.push(dir);\n      }\n    } else {\n      // existing directive, update\n      dir.oldValue = oldDir.value;\n      callHook$1(dir, 'update', vnode, oldVnode);\n      if (dir.def && dir.def.componentUpdated) {\n        dirsWithPostpatch.push(dir);\n      }\n    }\n  }\n\n  if (dirsWithInsert.length) {\n    var callInsert = function callInsert() {\n      for (var i = 0; i < dirsWithInsert.length; i++) {\n        callHook$1(dirsWithInsert[i], 'inserted', vnode, oldVnode);\n      }\n    };\n    if (isCreate) {\n      mergeVNodeHook(vnode, 'insert', callInsert);\n    } else {\n      callInsert();\n    }\n  }\n\n  if (dirsWithPostpatch.length) {\n    mergeVNodeHook(vnode, 'postpatch', function () {\n      for (var i = 0; i < dirsWithPostpatch.length; i++) {\n        callHook$1(dirsWithPostpatch[i], 'componentUpdated', vnode, oldVnode);\n      }\n    });\n  }\n\n  if (!isCreate) {\n    for (key in oldDirs) {\n      if (!newDirs[key]) {\n        // no longer present, unbind\n        callHook$1(oldDirs[key], 'unbind', oldVnode, oldVnode, isDestroy);\n      }\n    }\n  }\n}\n\nvar emptyModifiers = Object.create(null);\n\nfunction normalizeDirectives$1(dirs, vm) {\n  var res = Object.create(null);\n  if (!dirs) {\n    // $flow-disable-line\n    return res;\n  }\n  var i, dir;\n  for (i = 0; i < dirs.length; i++) {\n    dir = dirs[i];\n    if (!dir.modifiers) {\n      // $flow-disable-line\n      dir.modifiers = emptyModifiers;\n    }\n    res[getRawDirName(dir)] = dir;\n    dir.def = resolveAsset(vm.$options, 'directives', dir.name, true);\n  }\n  // $flow-disable-line\n  return res;\n}\n\nfunction getRawDirName(dir) {\n  return dir.rawName || dir.name + \".\" + Object.keys(dir.modifiers || {}).join('.');\n}\n\nfunction callHook$1(dir, hook, vnode, oldVnode, isDestroy) {\n  var fn = dir.def && dir.def[hook];\n  if (fn) {\n    try {\n      fn(vnode.elm, dir, vnode, oldVnode, isDestroy);\n    } catch (e) {\n      handleError(e, vnode.context, \"directive \" + dir.name + \" \" + hook + \" hook\");\n    }\n  }\n}\n\nvar baseModules = [ref, directives];\n\n/*  */\n\nfunction updateAttrs(oldVnode, vnode) {\n  var opts = vnode.componentOptions;\n  if (isDef(opts) && opts.Ctor.options.inheritAttrs === false) {\n    return;\n  }\n  if (isUndef(oldVnode.data.attrs) && isUndef(vnode.data.attrs)) {\n    return;\n  }\n  var key, cur, old;\n  var elm = vnode.elm;\n  var oldAttrs = oldVnode.data.attrs || {};\n  var attrs = vnode.data.attrs || {};\n  // clone observed objects, as the user probably wants to mutate it\n  if (isDef(attrs.__ob__)) {\n    attrs = vnode.data.attrs = extend({}, attrs);\n  }\n\n  for (key in attrs) {\n    cur = attrs[key];\n    old = oldAttrs[key];\n    if (old !== cur) {\n      setAttr(elm, key, cur);\n    }\n  }\n  // #4391: in IE9, setting type can reset value for input[type=radio]\n  // #6666: IE/Edge forces progress value down to 1 before setting a max\n  /* istanbul ignore if */\n  if ((isIE || isEdge) && attrs.value !== oldAttrs.value) {\n    setAttr(elm, 'value', attrs.value);\n  }\n  for (key in oldAttrs) {\n    if (isUndef(attrs[key])) {\n      if (isXlink(key)) {\n        elm.removeAttributeNS(xlinkNS, getXlinkProp(key));\n      } else if (!isEnumeratedAttr(key)) {\n        elm.removeAttribute(key);\n      }\n    }\n  }\n}\n\nfunction setAttr(el, key, value) {\n  if (isBooleanAttr(key)) {\n    // set attribute for blank value\n    // e.g. <option disabled>Select one</option>\n    if (isFalsyAttrValue(value)) {\n      el.removeAttribute(key);\n    } else {\n      // technically allowfullscreen is a boolean attribute for <iframe>,\n      // but Flash expects a value of \"true\" when used on <embed> tag\n      value = key === 'allowfullscreen' && el.tagName === 'EMBED' ? 'true' : key;\n      el.setAttribute(key, value);\n    }\n  } else if (isEnumeratedAttr(key)) {\n    el.setAttribute(key, isFalsyAttrValue(value) || value === 'false' ? 'false' : 'true');\n  } else if (isXlink(key)) {\n    if (isFalsyAttrValue(value)) {\n      el.removeAttributeNS(xlinkNS, getXlinkProp(key));\n    } else {\n      el.setAttributeNS(xlinkNS, key, value);\n    }\n  } else {\n    if (isFalsyAttrValue(value)) {\n      el.removeAttribute(key);\n    } else {\n      // #7138: IE10 & 11 fires input event when setting placeholder on\n      // <textarea>... block the first input event and remove the blocker\n      // immediately.\n      /* istanbul ignore if */\n      if (isIE && !isIE9 && el.tagName === 'TEXTAREA' && key === 'placeholder' && !el.__ieph) {\n        var blocker = function blocker(e) {\n          e.stopImmediatePropagation();\n          el.removeEventListener('input', blocker);\n        };\n        el.addEventListener('input', blocker);\n        // $flow-disable-line\n        el.__ieph = true; /* IE placeholder patched */\n      }\n      el.setAttribute(key, value);\n    }\n  }\n}\n\nvar attrs = {\n  create: updateAttrs,\n  update: updateAttrs\n};\n\n/*  */\n\nfunction updateClass(oldVnode, vnode) {\n  var el = vnode.elm;\n  var data = vnode.data;\n  var oldData = oldVnode.data;\n  if (isUndef(data.staticClass) && isUndef(data.class) && (isUndef(oldData) || isUndef(oldData.staticClass) && isUndef(oldData.class))) {\n    return;\n  }\n\n  var cls = genClassForVnode(vnode);\n\n  // handle transition classes\n  var transitionClass = el._transitionClasses;\n  if (isDef(transitionClass)) {\n    cls = concat(cls, stringifyClass(transitionClass));\n  }\n\n  // set the class\n  if (cls !== el._prevClass) {\n    el.setAttribute('class', cls);\n    el._prevClass = cls;\n  }\n}\n\nvar klass = {\n  create: updateClass,\n  update: updateClass\n};\n\n/*  */\n\nvar validDivisionCharRE = /[\\w).+\\-_$\\]]/;\n\nfunction parseFilters(exp) {\n  var inSingle = false;\n  var inDouble = false;\n  var inTemplateString = false;\n  var inRegex = false;\n  var curly = 0;\n  var square = 0;\n  var paren = 0;\n  var lastFilterIndex = 0;\n  var c, prev, i, expression, filters;\n\n  for (i = 0; i < exp.length; i++) {\n    prev = c;\n    c = exp.charCodeAt(i);\n    if (inSingle) {\n      if (c === 0x27 && prev !== 0x5C) {\n        inSingle = false;\n      }\n    } else if (inDouble) {\n      if (c === 0x22 && prev !== 0x5C) {\n        inDouble = false;\n      }\n    } else if (inTemplateString) {\n      if (c === 0x60 && prev !== 0x5C) {\n        inTemplateString = false;\n      }\n    } else if (inRegex) {\n      if (c === 0x2f && prev !== 0x5C) {\n        inRegex = false;\n      }\n    } else if (c === 0x7C && // pipe\n    exp.charCodeAt(i + 1) !== 0x7C && exp.charCodeAt(i - 1) !== 0x7C && !curly && !square && !paren) {\n      if (expression === undefined) {\n        // first filter, end of expression\n        lastFilterIndex = i + 1;\n        expression = exp.slice(0, i).trim();\n      } else {\n        pushFilter();\n      }\n    } else {\n      switch (c) {\n        case 0x22:\n          inDouble = true;break; // \"\n        case 0x27:\n          inSingle = true;break; // '\n        case 0x60:\n          inTemplateString = true;break; // `\n        case 0x28:\n          paren++;break; // (\n        case 0x29:\n          paren--;break; // )\n        case 0x5B:\n          square++;break; // [\n        case 0x5D:\n          square--;break; // ]\n        case 0x7B:\n          curly++;break; // {\n        case 0x7D:\n          curly--;break; // }\n      }\n      if (c === 0x2f) {\n        // /\n        var j = i - 1;\n        var p = void 0;\n        // find first non-whitespace prev char\n        for (; j >= 0; j--) {\n          p = exp.charAt(j);\n          if (p !== ' ') {\n            break;\n          }\n        }\n        if (!p || !validDivisionCharRE.test(p)) {\n          inRegex = true;\n        }\n      }\n    }\n  }\n\n  if (expression === undefined) {\n    expression = exp.slice(0, i).trim();\n  } else if (lastFilterIndex !== 0) {\n    pushFilter();\n  }\n\n  function pushFilter() {\n    (filters || (filters = [])).push(exp.slice(lastFilterIndex, i).trim());\n    lastFilterIndex = i + 1;\n  }\n\n  if (filters) {\n    for (i = 0; i < filters.length; i++) {\n      expression = wrapFilter(expression, filters[i]);\n    }\n  }\n\n  return expression;\n}\n\nfunction wrapFilter(exp, filter) {\n  var i = filter.indexOf('(');\n  if (i < 0) {\n    // _f: resolveFilter\n    return \"_f(\\\"\" + filter + \"\\\")(\" + exp + \")\";\n  } else {\n    var name = filter.slice(0, i);\n    var args = filter.slice(i + 1);\n    return \"_f(\\\"\" + name + \"\\\")(\" + exp + \",\" + args;\n  }\n}\n\n/*  */\n\nfunction baseWarn(msg) {\n  console.error(\"[Vue compiler]: \" + msg);\n}\n\nfunction pluckModuleFunction(modules, key) {\n  return modules ? modules.map(function (m) {\n    return m[key];\n  }).filter(function (_) {\n    return _;\n  }) : [];\n}\n\nfunction addProp(el, name, value) {\n  (el.props || (el.props = [])).push({ name: name, value: value });\n}\n\nfunction addAttr(el, name, value) {\n  (el.attrs || (el.attrs = [])).push({ name: name, value: value });\n}\n\nfunction addDirective(el, name, rawName, value, arg, modifiers) {\n  (el.directives || (el.directives = [])).push({ name: name, rawName: rawName, value: value, arg: arg, modifiers: modifiers });\n}\n\nfunction addHandler(el, name, value, modifiers, important, warn) {\n  modifiers = modifiers || emptyObject;\n  // warn prevent and passive modifier\n  /* istanbul ignore if */\n  if (process.env.NODE_ENV !== 'production' && warn && modifiers.prevent && modifiers.passive) {\n    warn('passive and prevent can\\'t be used together. ' + 'Passive handler can\\'t prevent default event.');\n  }\n\n  // check capture modifier\n  if (modifiers.capture) {\n    delete modifiers.capture;\n    name = '!' + name; // mark the event as captured\n  }\n  if (modifiers.once) {\n    delete modifiers.once;\n    name = '~' + name; // mark the event as once\n  }\n  /* istanbul ignore if */\n  if (modifiers.passive) {\n    delete modifiers.passive;\n    name = '&' + name; // mark the event as passive\n  }\n\n  // normalize click.right and click.middle since they don't actually fire\n  // this is technically browser-specific, but at least for now browsers are\n  // the only target envs that have right/middle clicks.\n  if (name === 'click') {\n    if (modifiers.right) {\n      name = 'contextmenu';\n      delete modifiers.right;\n    } else if (modifiers.middle) {\n      name = 'mouseup';\n    }\n  }\n\n  var events;\n  if (modifiers.native) {\n    delete modifiers.native;\n    events = el.nativeEvents || (el.nativeEvents = {});\n  } else {\n    events = el.events || (el.events = {});\n  }\n\n  var newHandler = { value: value };\n  if (modifiers !== emptyObject) {\n    newHandler.modifiers = modifiers;\n  }\n\n  var handlers = events[name];\n  /* istanbul ignore if */\n  if (Array.isArray(handlers)) {\n    important ? handlers.unshift(newHandler) : handlers.push(newHandler);\n  } else if (handlers) {\n    events[name] = important ? [newHandler, handlers] : [handlers, newHandler];\n  } else {\n    events[name] = newHandler;\n  }\n}\n\nfunction getBindingAttr(el, name, getStatic) {\n  var dynamicValue = getAndRemoveAttr(el, ':' + name) || getAndRemoveAttr(el, 'v-bind:' + name);\n  if (dynamicValue != null) {\n    return parseFilters(dynamicValue);\n  } else if (getStatic !== false) {\n    var staticValue = getAndRemoveAttr(el, name);\n    if (staticValue != null) {\n      return JSON.stringify(staticValue);\n    }\n  }\n}\n\n// note: this only removes the attr from the Array (attrsList) so that it\n// doesn't get processed by processAttrs.\n// By default it does NOT remove it from the map (attrsMap) because the map is\n// needed during codegen.\nfunction getAndRemoveAttr(el, name, removeFromMap) {\n  var val;\n  if ((val = el.attrsMap[name]) != null) {\n    var list = el.attrsList;\n    for (var i = 0, l = list.length; i < l; i++) {\n      if (list[i].name === name) {\n        list.splice(i, 1);\n        break;\n      }\n    }\n  }\n  if (removeFromMap) {\n    delete el.attrsMap[name];\n  }\n  return val;\n}\n\n/*  */\n\n/**\n * Cross-platform code generation for component v-model\n */\nfunction genComponentModel(el, value, modifiers) {\n  var ref = modifiers || {};\n  var number = ref.number;\n  var trim = ref.trim;\n\n  var baseValueExpression = '$$v';\n  var valueExpression = baseValueExpression;\n  if (trim) {\n    valueExpression = \"(typeof \" + baseValueExpression + \" === 'string'\" + \"? \" + baseValueExpression + \".trim()\" + \": \" + baseValueExpression + \")\";\n  }\n  if (number) {\n    valueExpression = \"_n(\" + valueExpression + \")\";\n  }\n  var assignment = genAssignmentCode(value, valueExpression);\n\n  el.model = {\n    value: \"(\" + value + \")\",\n    expression: \"\\\"\" + value + \"\\\"\",\n    callback: \"function (\" + baseValueExpression + \") {\" + assignment + \"}\"\n  };\n}\n\n/**\n * Cross-platform codegen helper for generating v-model value assignment code.\n */\nfunction genAssignmentCode(value, assignment) {\n  var res = parseModel(value);\n  if (res.key === null) {\n    return value + \"=\" + assignment;\n  } else {\n    return \"$set(\" + res.exp + \", \" + res.key + \", \" + assignment + \")\";\n  }\n}\n\n/**\n * Parse a v-model expression into a base path and a final key segment.\n * Handles both dot-path and possible square brackets.\n *\n * Possible cases:\n *\n * - test\n * - test[key]\n * - test[test1[key]]\n * - test[\"a\"][key]\n * - xxx.test[a[a].test1[key]]\n * - test.xxx.a[\"asa\"][test1[key]]\n *\n */\n\nvar len;\nvar str;\nvar chr;\nvar index$1;\nvar expressionPos;\nvar expressionEndPos;\n\nfunction parseModel(val) {\n  len = val.length;\n\n  if (val.indexOf('[') < 0 || val.lastIndexOf(']') < len - 1) {\n    index$1 = val.lastIndexOf('.');\n    if (index$1 > -1) {\n      return {\n        exp: val.slice(0, index$1),\n        key: '\"' + val.slice(index$1 + 1) + '\"'\n      };\n    } else {\n      return {\n        exp: val,\n        key: null\n      };\n    }\n  }\n\n  str = val;\n  index$1 = expressionPos = expressionEndPos = 0;\n\n  while (!eof()) {\n    chr = next();\n    /* istanbul ignore if */\n    if (isStringStart(chr)) {\n      parseString(chr);\n    } else if (chr === 0x5B) {\n      parseBracket(chr);\n    }\n  }\n\n  return {\n    exp: val.slice(0, expressionPos),\n    key: val.slice(expressionPos + 1, expressionEndPos)\n  };\n}\n\nfunction next() {\n  return str.charCodeAt(++index$1);\n}\n\nfunction eof() {\n  return index$1 >= len;\n}\n\nfunction isStringStart(chr) {\n  return chr === 0x22 || chr === 0x27;\n}\n\nfunction parseBracket(chr) {\n  var inBracket = 1;\n  expressionPos = index$1;\n  while (!eof()) {\n    chr = next();\n    if (isStringStart(chr)) {\n      parseString(chr);\n      continue;\n    }\n    if (chr === 0x5B) {\n      inBracket++;\n    }\n    if (chr === 0x5D) {\n      inBracket--;\n    }\n    if (inBracket === 0) {\n      expressionEndPos = index$1;\n      break;\n    }\n  }\n}\n\nfunction parseString(chr) {\n  var stringQuote = chr;\n  while (!eof()) {\n    chr = next();\n    if (chr === stringQuote) {\n      break;\n    }\n  }\n}\n\n/*  */\n\nvar warn$1;\n\n// in some cases, the event used has to be determined at runtime\n// so we used some reserved tokens during compile.\nvar RANGE_TOKEN = '__r';\nvar CHECKBOX_RADIO_TOKEN = '__c';\n\nfunction model(el, dir, _warn) {\n  warn$1 = _warn;\n  var value = dir.value;\n  var modifiers = dir.modifiers;\n  var tag = el.tag;\n  var type = el.attrsMap.type;\n\n  if (process.env.NODE_ENV !== 'production') {\n    // inputs with type=\"file\" are read only and setting the input's\n    // value will throw an error.\n    if (tag === 'input' && type === 'file') {\n      warn$1(\"<\" + el.tag + \" v-model=\\\"\" + value + \"\\\" type=\\\"file\\\">:\\n\" + \"File inputs are read only. Use a v-on:change listener instead.\");\n    }\n  }\n\n  if (el.component) {\n    genComponentModel(el, value, modifiers);\n    // component v-model doesn't need extra runtime\n    return false;\n  } else if (tag === 'select') {\n    genSelect(el, value, modifiers);\n  } else if (tag === 'input' && type === 'checkbox') {\n    genCheckboxModel(el, value, modifiers);\n  } else if (tag === 'input' && type === 'radio') {\n    genRadioModel(el, value, modifiers);\n  } else if (tag === 'input' || tag === 'textarea') {\n    genDefaultModel(el, value, modifiers);\n  } else if (!config.isReservedTag(tag)) {\n    genComponentModel(el, value, modifiers);\n    // component v-model doesn't need extra runtime\n    return false;\n  } else if (process.env.NODE_ENV !== 'production') {\n    warn$1(\"<\" + el.tag + \" v-model=\\\"\" + value + \"\\\">: \" + \"v-model is not supported on this element type. \" + 'If you are working with contenteditable, it\\'s recommended to ' + 'wrap a library dedicated for that purpose inside a custom component.');\n  }\n\n  // ensure runtime directive metadata\n  return true;\n}\n\nfunction genCheckboxModel(el, value, modifiers) {\n  var number = modifiers && modifiers.number;\n  var valueBinding = getBindingAttr(el, 'value') || 'null';\n  var trueValueBinding = getBindingAttr(el, 'true-value') || 'true';\n  var falseValueBinding = getBindingAttr(el, 'false-value') || 'false';\n  addProp(el, 'checked', \"Array.isArray(\" + value + \")\" + \"?_i(\" + value + \",\" + valueBinding + \")>-1\" + (trueValueBinding === 'true' ? \":(\" + value + \")\" : \":_q(\" + value + \",\" + trueValueBinding + \")\"));\n  addHandler(el, 'change', \"var $$a=\" + value + \",\" + '$$el=$event.target,' + \"$$c=$$el.checked?(\" + trueValueBinding + \"):(\" + falseValueBinding + \");\" + 'if(Array.isArray($$a)){' + \"var $$v=\" + (number ? '_n(' + valueBinding + ')' : valueBinding) + \",\" + '$$i=_i($$a,$$v);' + \"if($$el.checked){$$i<0&&(\" + value + \"=$$a.concat([$$v]))}\" + \"else{$$i>-1&&(\" + value + \"=$$a.slice(0,$$i).concat($$a.slice($$i+1)))}\" + \"}else{\" + genAssignmentCode(value, '$$c') + \"}\", null, true);\n}\n\nfunction genRadioModel(el, value, modifiers) {\n  var number = modifiers && modifiers.number;\n  var valueBinding = getBindingAttr(el, 'value') || 'null';\n  valueBinding = number ? \"_n(\" + valueBinding + \")\" : valueBinding;\n  addProp(el, 'checked', \"_q(\" + value + \",\" + valueBinding + \")\");\n  addHandler(el, 'change', genAssignmentCode(value, valueBinding), null, true);\n}\n\nfunction genSelect(el, value, modifiers) {\n  var number = modifiers && modifiers.number;\n  var selectedVal = \"Array.prototype.filter\" + \".call($event.target.options,function(o){return o.selected})\" + \".map(function(o){var val = \\\"_value\\\" in o ? o._value : o.value;\" + \"return \" + (number ? '_n(val)' : 'val') + \"})\";\n\n  var assignment = '$event.target.multiple ? $$selectedVal : $$selectedVal[0]';\n  var code = \"var $$selectedVal = \" + selectedVal + \";\";\n  code = code + \" \" + genAssignmentCode(value, assignment);\n  addHandler(el, 'change', code, null, true);\n}\n\nfunction genDefaultModel(el, value, modifiers) {\n  var type = el.attrsMap.type;\n\n  // warn if v-bind:value conflicts with v-model\n  if (process.env.NODE_ENV !== 'production') {\n    var value$1 = el.attrsMap['v-bind:value'] || el.attrsMap[':value'];\n    if (value$1) {\n      var binding = el.attrsMap['v-bind:value'] ? 'v-bind:value' : ':value';\n      warn$1(binding + \"=\\\"\" + value$1 + \"\\\" conflicts with v-model on the same element \" + 'because the latter already expands to a value binding internally');\n    }\n  }\n\n  var ref = modifiers || {};\n  var lazy = ref.lazy;\n  var number = ref.number;\n  var trim = ref.trim;\n  var needCompositionGuard = !lazy && type !== 'range';\n  var event = lazy ? 'change' : type === 'range' ? RANGE_TOKEN : 'input';\n\n  var valueExpression = '$event.target.value';\n  if (trim) {\n    valueExpression = \"$event.target.value.trim()\";\n  }\n  if (number) {\n    valueExpression = \"_n(\" + valueExpression + \")\";\n  }\n\n  var code = genAssignmentCode(value, valueExpression);\n  if (needCompositionGuard) {\n    code = \"if($event.target.composing)return;\" + code;\n  }\n\n  addProp(el, 'value', \"(\" + value + \")\");\n  addHandler(el, event, code, null, true);\n  if (trim || number) {\n    addHandler(el, 'blur', '$forceUpdate()');\n  }\n}\n\n/*  */\n\n// normalize v-model event tokens that can only be determined at runtime.\n// it's important to place the event as the first in the array because\n// the whole point is ensuring the v-model callback gets called before\n// user-attached handlers.\nfunction normalizeEvents(on) {\n  /* istanbul ignore if */\n  if (isDef(on[RANGE_TOKEN])) {\n    // IE input[type=range] only supports `change` event\n    var event = isIE ? 'change' : 'input';\n    on[event] = [].concat(on[RANGE_TOKEN], on[event] || []);\n    delete on[RANGE_TOKEN];\n  }\n  // This was originally intended to fix #4521 but no longer necessary\n  // after 2.5. Keeping it for backwards compat with generated code from < 2.4\n  /* istanbul ignore if */\n  if (isDef(on[CHECKBOX_RADIO_TOKEN])) {\n    on.change = [].concat(on[CHECKBOX_RADIO_TOKEN], on.change || []);\n    delete on[CHECKBOX_RADIO_TOKEN];\n  }\n}\n\nvar target$1;\n\nfunction createOnceHandler(handler, event, capture) {\n  var _target = target$1; // save current target element in closure\n  return function onceHandler() {\n    var res = handler.apply(null, arguments);\n    if (res !== null) {\n      remove$2(event, onceHandler, capture, _target);\n    }\n  };\n}\n\nfunction add$1(event, handler, once$$1, capture, passive) {\n  handler = withMacroTask(handler);\n  if (once$$1) {\n    handler = createOnceHandler(handler, event, capture);\n  }\n  target$1.addEventListener(event, handler, supportsPassive ? { capture: capture, passive: passive } : capture);\n}\n\nfunction remove$2(event, handler, capture, _target) {\n  (_target || target$1).removeEventListener(event, handler._withTask || handler, capture);\n}\n\nfunction updateDOMListeners(oldVnode, vnode) {\n  if (isUndef(oldVnode.data.on) && isUndef(vnode.data.on)) {\n    return;\n  }\n  var on = vnode.data.on || {};\n  var oldOn = oldVnode.data.on || {};\n  target$1 = vnode.elm;\n  normalizeEvents(on);\n  updateListeners(on, oldOn, add$1, remove$2, vnode.context);\n  target$1 = undefined;\n}\n\nvar events = {\n  create: updateDOMListeners,\n  update: updateDOMListeners\n};\n\n/*  */\n\nfunction updateDOMProps(oldVnode, vnode) {\n  if (isUndef(oldVnode.data.domProps) && isUndef(vnode.data.domProps)) {\n    return;\n  }\n  var key, cur;\n  var elm = vnode.elm;\n  var oldProps = oldVnode.data.domProps || {};\n  var props = vnode.data.domProps || {};\n  // clone observed objects, as the user probably wants to mutate it\n  if (isDef(props.__ob__)) {\n    props = vnode.data.domProps = extend({}, props);\n  }\n\n  for (key in oldProps) {\n    if (isUndef(props[key])) {\n      elm[key] = '';\n    }\n  }\n  for (key in props) {\n    cur = props[key];\n    // ignore children if the node has textContent or innerHTML,\n    // as these will throw away existing DOM nodes and cause removal errors\n    // on subsequent patches (#3360)\n    if (key === 'textContent' || key === 'innerHTML') {\n      if (vnode.children) {\n        vnode.children.length = 0;\n      }\n      if (cur === oldProps[key]) {\n        continue;\n      }\n      // #6601 work around Chrome version <= 55 bug where single textNode\n      // replaced by innerHTML/textContent retains its parentNode property\n      if (elm.childNodes.length === 1) {\n        elm.removeChild(elm.childNodes[0]);\n      }\n    }\n\n    if (key === 'value') {\n      // store value as _value as well since\n      // non-string values will be stringified\n      elm._value = cur;\n      // avoid resetting cursor position when value is the same\n      var strCur = isUndef(cur) ? '' : String(cur);\n      if (shouldUpdateValue(elm, strCur)) {\n        elm.value = strCur;\n      }\n    } else {\n      elm[key] = cur;\n    }\n  }\n}\n\n// check platforms/web/util/attrs.js acceptValue\n\n\nfunction shouldUpdateValue(elm, checkVal) {\n  return !elm.composing && (elm.tagName === 'OPTION' || isNotInFocusAndDirty(elm, checkVal) || isDirtyWithModifiers(elm, checkVal));\n}\n\nfunction isNotInFocusAndDirty(elm, checkVal) {\n  // return true when textbox (.number and .trim) loses focus and its value is\n  // not equal to the updated value\n  var notInFocus = true;\n  // #6157\n  // work around IE bug when accessing document.activeElement in an iframe\n  try {\n    notInFocus = document.activeElement !== elm;\n  } catch (e) {}\n  return notInFocus && elm.value !== checkVal;\n}\n\nfunction isDirtyWithModifiers(elm, newVal) {\n  var value = elm.value;\n  var modifiers = elm._vModifiers; // injected by v-model runtime\n  if (isDef(modifiers)) {\n    if (modifiers.lazy) {\n      // inputs with lazy should only be updated when not in focus\n      return false;\n    }\n    if (modifiers.number) {\n      return toNumber(value) !== toNumber(newVal);\n    }\n    if (modifiers.trim) {\n      return value.trim() !== newVal.trim();\n    }\n  }\n  return value !== newVal;\n}\n\nvar domProps = {\n  create: updateDOMProps,\n  update: updateDOMProps\n};\n\n/*  */\n\nvar parseStyleText = cached(function (cssText) {\n  var res = {};\n  var listDelimiter = /;(?![^(]*\\))/g;\n  var propertyDelimiter = /:(.+)/;\n  cssText.split(listDelimiter).forEach(function (item) {\n    if (item) {\n      var tmp = item.split(propertyDelimiter);\n      tmp.length > 1 && (res[tmp[0].trim()] = tmp[1].trim());\n    }\n  });\n  return res;\n});\n\n// merge static and dynamic style data on the same vnode\nfunction normalizeStyleData(data) {\n  var style = normalizeStyleBinding(data.style);\n  // static style is pre-processed into an object during compilation\n  // and is always a fresh object, so it's safe to merge into it\n  return data.staticStyle ? extend(data.staticStyle, style) : style;\n}\n\n// normalize possible array / string values into Object\nfunction normalizeStyleBinding(bindingStyle) {\n  if (Array.isArray(bindingStyle)) {\n    return toObject(bindingStyle);\n  }\n  if (typeof bindingStyle === 'string') {\n    return parseStyleText(bindingStyle);\n  }\n  return bindingStyle;\n}\n\n/**\n * parent component style should be after child's\n * so that parent component's style could override it\n */\nfunction getStyle(vnode, checkChild) {\n  var res = {};\n  var styleData;\n\n  if (checkChild) {\n    var childNode = vnode;\n    while (childNode.componentInstance) {\n      childNode = childNode.componentInstance._vnode;\n      if (childNode && childNode.data && (styleData = normalizeStyleData(childNode.data))) {\n        extend(res, styleData);\n      }\n    }\n  }\n\n  if (styleData = normalizeStyleData(vnode.data)) {\n    extend(res, styleData);\n  }\n\n  var parentNode = vnode;\n  while (parentNode = parentNode.parent) {\n    if (parentNode.data && (styleData = normalizeStyleData(parentNode.data))) {\n      extend(res, styleData);\n    }\n  }\n  return res;\n}\n\n/*  */\n\nvar cssVarRE = /^--/;\nvar importantRE = /\\s*!important$/;\nvar setProp = function setProp(el, name, val) {\n  /* istanbul ignore if */\n  if (cssVarRE.test(name)) {\n    el.style.setProperty(name, val);\n  } else if (importantRE.test(val)) {\n    el.style.setProperty(name, val.replace(importantRE, ''), 'important');\n  } else {\n    var normalizedName = normalize(name);\n    if (Array.isArray(val)) {\n      // Support values array created by autoprefixer, e.g.\n      // {display: [\"-webkit-box\", \"-ms-flexbox\", \"flex\"]}\n      // Set them one by one, and the browser will only set those it can recognize\n      for (var i = 0, len = val.length; i < len; i++) {\n        el.style[normalizedName] = val[i];\n      }\n    } else {\n      el.style[normalizedName] = val;\n    }\n  }\n};\n\nvar vendorNames = ['Webkit', 'Moz', 'ms'];\n\nvar emptyStyle;\nvar normalize = cached(function (prop) {\n  emptyStyle = emptyStyle || document.createElement('div').style;\n  prop = camelize(prop);\n  if (prop !== 'filter' && prop in emptyStyle) {\n    return prop;\n  }\n  var capName = prop.charAt(0).toUpperCase() + prop.slice(1);\n  for (var i = 0; i < vendorNames.length; i++) {\n    var name = vendorNames[i] + capName;\n    if (name in emptyStyle) {\n      return name;\n    }\n  }\n});\n\nfunction updateStyle(oldVnode, vnode) {\n  var data = vnode.data;\n  var oldData = oldVnode.data;\n\n  if (isUndef(data.staticStyle) && isUndef(data.style) && isUndef(oldData.staticStyle) && isUndef(oldData.style)) {\n    return;\n  }\n\n  var cur, name;\n  var el = vnode.elm;\n  var oldStaticStyle = oldData.staticStyle;\n  var oldStyleBinding = oldData.normalizedStyle || oldData.style || {};\n\n  // if static style exists, stylebinding already merged into it when doing normalizeStyleData\n  var oldStyle = oldStaticStyle || oldStyleBinding;\n\n  var style = normalizeStyleBinding(vnode.data.style) || {};\n\n  // store normalized style under a different key for next diff\n  // make sure to clone it if it's reactive, since the user likely wants\n  // to mutate it.\n  vnode.data.normalizedStyle = isDef(style.__ob__) ? extend({}, style) : style;\n\n  var newStyle = getStyle(vnode, true);\n\n  for (name in oldStyle) {\n    if (isUndef(newStyle[name])) {\n      setProp(el, name, '');\n    }\n  }\n  for (name in newStyle) {\n    cur = newStyle[name];\n    if (cur !== oldStyle[name]) {\n      // ie9 setting to null has no effect, must use empty string\n      setProp(el, name, cur == null ? '' : cur);\n    }\n  }\n}\n\nvar style = {\n  create: updateStyle,\n  update: updateStyle\n};\n\n/*  */\n\n/**\n * Add class with compatibility for SVG since classList is not supported on\n * SVG elements in IE\n */\nfunction addClass(el, cls) {\n  /* istanbul ignore if */\n  if (!cls || !(cls = cls.trim())) {\n    return;\n  }\n\n  /* istanbul ignore else */\n  if (el.classList) {\n    if (cls.indexOf(' ') > -1) {\n      cls.split(/\\s+/).forEach(function (c) {\n        return el.classList.add(c);\n      });\n    } else {\n      el.classList.add(cls);\n    }\n  } else {\n    var cur = \" \" + (el.getAttribute('class') || '') + \" \";\n    if (cur.indexOf(' ' + cls + ' ') < 0) {\n      el.setAttribute('class', (cur + cls).trim());\n    }\n  }\n}\n\n/**\n * Remove class with compatibility for SVG since classList is not supported on\n * SVG elements in IE\n */\nfunction removeClass(el, cls) {\n  /* istanbul ignore if */\n  if (!cls || !(cls = cls.trim())) {\n    return;\n  }\n\n  /* istanbul ignore else */\n  if (el.classList) {\n    if (cls.indexOf(' ') > -1) {\n      cls.split(/\\s+/).forEach(function (c) {\n        return el.classList.remove(c);\n      });\n    } else {\n      el.classList.remove(cls);\n    }\n    if (!el.classList.length) {\n      el.removeAttribute('class');\n    }\n  } else {\n    var cur = \" \" + (el.getAttribute('class') || '') + \" \";\n    var tar = ' ' + cls + ' ';\n    while (cur.indexOf(tar) >= 0) {\n      cur = cur.replace(tar, ' ');\n    }\n    cur = cur.trim();\n    if (cur) {\n      el.setAttribute('class', cur);\n    } else {\n      el.removeAttribute('class');\n    }\n  }\n}\n\n/*  */\n\nfunction resolveTransition(def) {\n  if (!def) {\n    return;\n  }\n  /* istanbul ignore else */\n  if ((typeof def === 'undefined' ? 'undefined' : _typeof(def)) === 'object') {\n    var res = {};\n    if (def.css !== false) {\n      extend(res, autoCssTransition(def.name || 'v'));\n    }\n    extend(res, def);\n    return res;\n  } else if (typeof def === 'string') {\n    return autoCssTransition(def);\n  }\n}\n\nvar autoCssTransition = cached(function (name) {\n  return {\n    enterClass: name + \"-enter\",\n    enterToClass: name + \"-enter-to\",\n    enterActiveClass: name + \"-enter-active\",\n    leaveClass: name + \"-leave\",\n    leaveToClass: name + \"-leave-to\",\n    leaveActiveClass: name + \"-leave-active\"\n  };\n});\n\nvar hasTransition = inBrowser && !isIE9;\nvar TRANSITION = 'transition';\nvar ANIMATION = 'animation';\n\n// Transition property/event sniffing\nvar transitionProp = 'transition';\nvar transitionEndEvent = 'transitionend';\nvar animationProp = 'animation';\nvar animationEndEvent = 'animationend';\nif (hasTransition) {\n  /* istanbul ignore if */\n  if (window.ontransitionend === undefined && window.onwebkittransitionend !== undefined) {\n    transitionProp = 'WebkitTransition';\n    transitionEndEvent = 'webkitTransitionEnd';\n  }\n  if (window.onanimationend === undefined && window.onwebkitanimationend !== undefined) {\n    animationProp = 'WebkitAnimation';\n    animationEndEvent = 'webkitAnimationEnd';\n  }\n}\n\n// binding to window is necessary to make hot reload work in IE in strict mode\nvar raf = inBrowser ? window.requestAnimationFrame ? window.requestAnimationFrame.bind(window) : setTimeout : /* istanbul ignore next */function (fn) {\n  return fn();\n};\n\nfunction nextFrame(fn) {\n  raf(function () {\n    raf(fn);\n  });\n}\n\nfunction addTransitionClass(el, cls) {\n  var transitionClasses = el._transitionClasses || (el._transitionClasses = []);\n  if (transitionClasses.indexOf(cls) < 0) {\n    transitionClasses.push(cls);\n    addClass(el, cls);\n  }\n}\n\nfunction removeTransitionClass(el, cls) {\n  if (el._transitionClasses) {\n    remove(el._transitionClasses, cls);\n  }\n  removeClass(el, cls);\n}\n\nfunction whenTransitionEnds(el, expectedType, cb) {\n  var ref = getTransitionInfo(el, expectedType);\n  var type = ref.type;\n  var timeout = ref.timeout;\n  var propCount = ref.propCount;\n  if (!type) {\n    return cb();\n  }\n  var event = type === TRANSITION ? transitionEndEvent : animationEndEvent;\n  var ended = 0;\n  var end = function end() {\n    el.removeEventListener(event, onEnd);\n    cb();\n  };\n  var onEnd = function onEnd(e) {\n    if (e.target === el) {\n      if (++ended >= propCount) {\n        end();\n      }\n    }\n  };\n  setTimeout(function () {\n    if (ended < propCount) {\n      end();\n    }\n  }, timeout + 1);\n  el.addEventListener(event, onEnd);\n}\n\nvar transformRE = /\\b(transform|all)(,|$)/;\n\nfunction getTransitionInfo(el, expectedType) {\n  var styles = window.getComputedStyle(el);\n  var transitionDelays = styles[transitionProp + 'Delay'].split(', ');\n  var transitionDurations = styles[transitionProp + 'Duration'].split(', ');\n  var transitionTimeout = getTimeout(transitionDelays, transitionDurations);\n  var animationDelays = styles[animationProp + 'Delay'].split(', ');\n  var animationDurations = styles[animationProp + 'Duration'].split(', ');\n  var animationTimeout = getTimeout(animationDelays, animationDurations);\n\n  var type;\n  var timeout = 0;\n  var propCount = 0;\n  /* istanbul ignore if */\n  if (expectedType === TRANSITION) {\n    if (transitionTimeout > 0) {\n      type = TRANSITION;\n      timeout = transitionTimeout;\n      propCount = transitionDurations.length;\n    }\n  } else if (expectedType === ANIMATION) {\n    if (animationTimeout > 0) {\n      type = ANIMATION;\n      timeout = animationTimeout;\n      propCount = animationDurations.length;\n    }\n  } else {\n    timeout = Math.max(transitionTimeout, animationTimeout);\n    type = timeout > 0 ? transitionTimeout > animationTimeout ? TRANSITION : ANIMATION : null;\n    propCount = type ? type === TRANSITION ? transitionDurations.length : animationDurations.length : 0;\n  }\n  var hasTransform = type === TRANSITION && transformRE.test(styles[transitionProp + 'Property']);\n  return {\n    type: type,\n    timeout: timeout,\n    propCount: propCount,\n    hasTransform: hasTransform\n  };\n}\n\nfunction getTimeout(delays, durations) {\n  /* istanbul ignore next */\n  while (delays.length < durations.length) {\n    delays = delays.concat(delays);\n  }\n\n  return Math.max.apply(null, durations.map(function (d, i) {\n    return toMs(d) + toMs(delays[i]);\n  }));\n}\n\nfunction toMs(s) {\n  return Number(s.slice(0, -1)) * 1000;\n}\n\n/*  */\n\nfunction enter(vnode, toggleDisplay) {\n  var el = vnode.elm;\n\n  // call leave callback now\n  if (isDef(el._leaveCb)) {\n    el._leaveCb.cancelled = true;\n    el._leaveCb();\n  }\n\n  var data = resolveTransition(vnode.data.transition);\n  if (isUndef(data)) {\n    return;\n  }\n\n  /* istanbul ignore if */\n  if (isDef(el._enterCb) || el.nodeType !== 1) {\n    return;\n  }\n\n  var css = data.css;\n  var type = data.type;\n  var enterClass = data.enterClass;\n  var enterToClass = data.enterToClass;\n  var enterActiveClass = data.enterActiveClass;\n  var appearClass = data.appearClass;\n  var appearToClass = data.appearToClass;\n  var appearActiveClass = data.appearActiveClass;\n  var beforeEnter = data.beforeEnter;\n  var enter = data.enter;\n  var afterEnter = data.afterEnter;\n  var enterCancelled = data.enterCancelled;\n  var beforeAppear = data.beforeAppear;\n  var appear = data.appear;\n  var afterAppear = data.afterAppear;\n  var appearCancelled = data.appearCancelled;\n  var duration = data.duration;\n\n  // activeInstance will always be the <transition> component managing this\n  // transition. One edge case to check is when the <transition> is placed\n  // as the root node of a child component. In that case we need to check\n  // <transition>'s parent for appear check.\n  var context = activeInstance;\n  var transitionNode = activeInstance.$vnode;\n  while (transitionNode && transitionNode.parent) {\n    transitionNode = transitionNode.parent;\n    context = transitionNode.context;\n  }\n\n  var isAppear = !context._isMounted || !vnode.isRootInsert;\n\n  if (isAppear && !appear && appear !== '') {\n    return;\n  }\n\n  var startClass = isAppear && appearClass ? appearClass : enterClass;\n  var activeClass = isAppear && appearActiveClass ? appearActiveClass : enterActiveClass;\n  var toClass = isAppear && appearToClass ? appearToClass : enterToClass;\n\n  var beforeEnterHook = isAppear ? beforeAppear || beforeEnter : beforeEnter;\n  var enterHook = isAppear ? typeof appear === 'function' ? appear : enter : enter;\n  var afterEnterHook = isAppear ? afterAppear || afterEnter : afterEnter;\n  var enterCancelledHook = isAppear ? appearCancelled || enterCancelled : enterCancelled;\n\n  var explicitEnterDuration = toNumber(isObject(duration) ? duration.enter : duration);\n\n  if (process.env.NODE_ENV !== 'production' && explicitEnterDuration != null) {\n    checkDuration(explicitEnterDuration, 'enter', vnode);\n  }\n\n  var expectsCSS = css !== false && !isIE9;\n  var userWantsControl = getHookArgumentsLength(enterHook);\n\n  var cb = el._enterCb = once(function () {\n    if (expectsCSS) {\n      removeTransitionClass(el, toClass);\n      removeTransitionClass(el, activeClass);\n    }\n    if (cb.cancelled) {\n      if (expectsCSS) {\n        removeTransitionClass(el, startClass);\n      }\n      enterCancelledHook && enterCancelledHook(el);\n    } else {\n      afterEnterHook && afterEnterHook(el);\n    }\n    el._enterCb = null;\n  });\n\n  if (!vnode.data.show) {\n    // remove pending leave element on enter by injecting an insert hook\n    mergeVNodeHook(vnode, 'insert', function () {\n      var parent = el.parentNode;\n      var pendingNode = parent && parent._pending && parent._pending[vnode.key];\n      if (pendingNode && pendingNode.tag === vnode.tag && pendingNode.elm._leaveCb) {\n        pendingNode.elm._leaveCb();\n      }\n      enterHook && enterHook(el, cb);\n    });\n  }\n\n  // start enter transition\n  beforeEnterHook && beforeEnterHook(el);\n  if (expectsCSS) {\n    addTransitionClass(el, startClass);\n    addTransitionClass(el, activeClass);\n    nextFrame(function () {\n      addTransitionClass(el, toClass);\n      removeTransitionClass(el, startClass);\n      if (!cb.cancelled && !userWantsControl) {\n        if (isValidDuration(explicitEnterDuration)) {\n          setTimeout(cb, explicitEnterDuration);\n        } else {\n          whenTransitionEnds(el, type, cb);\n        }\n      }\n    });\n  }\n\n  if (vnode.data.show) {\n    toggleDisplay && toggleDisplay();\n    enterHook && enterHook(el, cb);\n  }\n\n  if (!expectsCSS && !userWantsControl) {\n    cb();\n  }\n}\n\nfunction leave(vnode, rm) {\n  var el = vnode.elm;\n\n  // call enter callback now\n  if (isDef(el._enterCb)) {\n    el._enterCb.cancelled = true;\n    el._enterCb();\n  }\n\n  var data = resolveTransition(vnode.data.transition);\n  if (isUndef(data) || el.nodeType !== 1) {\n    return rm();\n  }\n\n  /* istanbul ignore if */\n  if (isDef(el._leaveCb)) {\n    return;\n  }\n\n  var css = data.css;\n  var type = data.type;\n  var leaveClass = data.leaveClass;\n  var leaveToClass = data.leaveToClass;\n  var leaveActiveClass = data.leaveActiveClass;\n  var beforeLeave = data.beforeLeave;\n  var leave = data.leave;\n  var afterLeave = data.afterLeave;\n  var leaveCancelled = data.leaveCancelled;\n  var delayLeave = data.delayLeave;\n  var duration = data.duration;\n\n  var expectsCSS = css !== false && !isIE9;\n  var userWantsControl = getHookArgumentsLength(leave);\n\n  var explicitLeaveDuration = toNumber(isObject(duration) ? duration.leave : duration);\n\n  if (process.env.NODE_ENV !== 'production' && isDef(explicitLeaveDuration)) {\n    checkDuration(explicitLeaveDuration, 'leave', vnode);\n  }\n\n  var cb = el._leaveCb = once(function () {\n    if (el.parentNode && el.parentNode._pending) {\n      el.parentNode._pending[vnode.key] = null;\n    }\n    if (expectsCSS) {\n      removeTransitionClass(el, leaveToClass);\n      removeTransitionClass(el, leaveActiveClass);\n    }\n    if (cb.cancelled) {\n      if (expectsCSS) {\n        removeTransitionClass(el, leaveClass);\n      }\n      leaveCancelled && leaveCancelled(el);\n    } else {\n      rm();\n      afterLeave && afterLeave(el);\n    }\n    el._leaveCb = null;\n  });\n\n  if (delayLeave) {\n    delayLeave(performLeave);\n  } else {\n    performLeave();\n  }\n\n  function performLeave() {\n    // the delayed leave may have already been cancelled\n    if (cb.cancelled) {\n      return;\n    }\n    // record leaving element\n    if (!vnode.data.show) {\n      (el.parentNode._pending || (el.parentNode._pending = {}))[vnode.key] = vnode;\n    }\n    beforeLeave && beforeLeave(el);\n    if (expectsCSS) {\n      addTransitionClass(el, leaveClass);\n      addTransitionClass(el, leaveActiveClass);\n      nextFrame(function () {\n        addTransitionClass(el, leaveToClass);\n        removeTransitionClass(el, leaveClass);\n        if (!cb.cancelled && !userWantsControl) {\n          if (isValidDuration(explicitLeaveDuration)) {\n            setTimeout(cb, explicitLeaveDuration);\n          } else {\n            whenTransitionEnds(el, type, cb);\n          }\n        }\n      });\n    }\n    leave && leave(el, cb);\n    if (!expectsCSS && !userWantsControl) {\n      cb();\n    }\n  }\n}\n\n// only used in dev mode\nfunction checkDuration(val, name, vnode) {\n  if (typeof val !== 'number') {\n    warn(\"<transition> explicit \" + name + \" duration is not a valid number - \" + \"got \" + JSON.stringify(val) + \".\", vnode.context);\n  } else if (isNaN(val)) {\n    warn(\"<transition> explicit \" + name + \" duration is NaN - \" + 'the duration expression might be incorrect.', vnode.context);\n  }\n}\n\nfunction isValidDuration(val) {\n  return typeof val === 'number' && !isNaN(val);\n}\n\n/**\n * Normalize a transition hook's argument length. The hook may be:\n * - a merged hook (invoker) with the original in .fns\n * - a wrapped component method (check ._length)\n * - a plain function (.length)\n */\nfunction getHookArgumentsLength(fn) {\n  if (isUndef(fn)) {\n    return false;\n  }\n  var invokerFns = fn.fns;\n  if (isDef(invokerFns)) {\n    // invoker\n    return getHookArgumentsLength(Array.isArray(invokerFns) ? invokerFns[0] : invokerFns);\n  } else {\n    return (fn._length || fn.length) > 1;\n  }\n}\n\nfunction _enter(_, vnode) {\n  if (vnode.data.show !== true) {\n    enter(vnode);\n  }\n}\n\nvar transition = inBrowser ? {\n  create: _enter,\n  activate: _enter,\n  remove: function remove$$1(vnode, rm) {\n    /* istanbul ignore else */\n    if (vnode.data.show !== true) {\n      leave(vnode, rm);\n    } else {\n      rm();\n    }\n  }\n} : {};\n\nvar platformModules = [attrs, klass, events, domProps, style, transition];\n\n/*  */\n\n// the directive module should be applied last, after all\n// built-in modules have been applied.\nvar modules = platformModules.concat(baseModules);\n\nvar patch = createPatchFunction({ nodeOps: nodeOps, modules: modules });\n\n/**\n * Not type checking this file because flow doesn't like attaching\n * properties to Elements.\n */\n\n/* istanbul ignore if */\nif (isIE9) {\n  // http://www.matts411.com/post/internet-explorer-9-oninput/\n  document.addEventListener('selectionchange', function () {\n    var el = document.activeElement;\n    if (el && el.vmodel) {\n      trigger(el, 'input');\n    }\n  });\n}\n\nvar directive = {\n  inserted: function inserted(el, binding, vnode, oldVnode) {\n    if (vnode.tag === 'select') {\n      // #6903\n      if (oldVnode.elm && !oldVnode.elm._vOptions) {\n        mergeVNodeHook(vnode, 'postpatch', function () {\n          directive.componentUpdated(el, binding, vnode);\n        });\n      } else {\n        setSelected(el, binding, vnode.context);\n      }\n      el._vOptions = [].map.call(el.options, getValue);\n    } else if (vnode.tag === 'textarea' || isTextInputType(el.type)) {\n      el._vModifiers = binding.modifiers;\n      if (!binding.modifiers.lazy) {\n        // Safari < 10.2 & UIWebView doesn't fire compositionend when\n        // switching focus before confirming composition choice\n        // this also fixes the issue where some browsers e.g. iOS Chrome\n        // fires \"change\" instead of \"input\" on autocomplete.\n        el.addEventListener('change', onCompositionEnd);\n        if (!isAndroid) {\n          el.addEventListener('compositionstart', onCompositionStart);\n          el.addEventListener('compositionend', onCompositionEnd);\n        }\n        /* istanbul ignore if */\n        if (isIE9) {\n          el.vmodel = true;\n        }\n      }\n    }\n  },\n\n  componentUpdated: function componentUpdated(el, binding, vnode) {\n    if (vnode.tag === 'select') {\n      setSelected(el, binding, vnode.context);\n      // in case the options rendered by v-for have changed,\n      // it's possible that the value is out-of-sync with the rendered options.\n      // detect such cases and filter out values that no longer has a matching\n      // option in the DOM.\n      var prevOptions = el._vOptions;\n      var curOptions = el._vOptions = [].map.call(el.options, getValue);\n      if (curOptions.some(function (o, i) {\n        return !looseEqual(o, prevOptions[i]);\n      })) {\n        // trigger change event if\n        // no matching option found for at least one value\n        var needReset = el.multiple ? binding.value.some(function (v) {\n          return hasNoMatchingOption(v, curOptions);\n        }) : binding.value !== binding.oldValue && hasNoMatchingOption(binding.value, curOptions);\n        if (needReset) {\n          trigger(el, 'change');\n        }\n      }\n    }\n  }\n};\n\nfunction setSelected(el, binding, vm) {\n  actuallySetSelected(el, binding, vm);\n  /* istanbul ignore if */\n  if (isIE || isEdge) {\n    setTimeout(function () {\n      actuallySetSelected(el, binding, vm);\n    }, 0);\n  }\n}\n\nfunction actuallySetSelected(el, binding, vm) {\n  var value = binding.value;\n  var isMultiple = el.multiple;\n  if (isMultiple && !Array.isArray(value)) {\n    process.env.NODE_ENV !== 'production' && warn(\"<select multiple v-model=\\\"\" + binding.expression + \"\\\"> \" + \"expects an Array value for its binding, but got \" + Object.prototype.toString.call(value).slice(8, -1), vm);\n    return;\n  }\n  var selected, option;\n  for (var i = 0, l = el.options.length; i < l; i++) {\n    option = el.options[i];\n    if (isMultiple) {\n      selected = looseIndexOf(value, getValue(option)) > -1;\n      if (option.selected !== selected) {\n        option.selected = selected;\n      }\n    } else {\n      if (looseEqual(getValue(option), value)) {\n        if (el.selectedIndex !== i) {\n          el.selectedIndex = i;\n        }\n        return;\n      }\n    }\n  }\n  if (!isMultiple) {\n    el.selectedIndex = -1;\n  }\n}\n\nfunction hasNoMatchingOption(value, options) {\n  return options.every(function (o) {\n    return !looseEqual(o, value);\n  });\n}\n\nfunction getValue(option) {\n  return '_value' in option ? option._value : option.value;\n}\n\nfunction onCompositionStart(e) {\n  e.target.composing = true;\n}\n\nfunction onCompositionEnd(e) {\n  // prevent triggering an input event for no reason\n  if (!e.target.composing) {\n    return;\n  }\n  e.target.composing = false;\n  trigger(e.target, 'input');\n}\n\nfunction trigger(el, type) {\n  var e = document.createEvent('HTMLEvents');\n  e.initEvent(type, true, true);\n  el.dispatchEvent(e);\n}\n\n/*  */\n\n// recursively search for possible transition defined inside the component root\nfunction locateNode(vnode) {\n  return vnode.componentInstance && (!vnode.data || !vnode.data.transition) ? locateNode(vnode.componentInstance._vnode) : vnode;\n}\n\nvar show = {\n  bind: function bind(el, ref, vnode) {\n    var value = ref.value;\n\n    vnode = locateNode(vnode);\n    var transition$$1 = vnode.data && vnode.data.transition;\n    var originalDisplay = el.__vOriginalDisplay = el.style.display === 'none' ? '' : el.style.display;\n    if (value && transition$$1) {\n      vnode.data.show = true;\n      enter(vnode, function () {\n        el.style.display = originalDisplay;\n      });\n    } else {\n      el.style.display = value ? originalDisplay : 'none';\n    }\n  },\n\n  update: function update(el, ref, vnode) {\n    var value = ref.value;\n    var oldValue = ref.oldValue;\n\n    /* istanbul ignore if */\n    if (value === oldValue) {\n      return;\n    }\n    vnode = locateNode(vnode);\n    var transition$$1 = vnode.data && vnode.data.transition;\n    if (transition$$1) {\n      vnode.data.show = true;\n      if (value) {\n        enter(vnode, function () {\n          el.style.display = el.__vOriginalDisplay;\n        });\n      } else {\n        leave(vnode, function () {\n          el.style.display = 'none';\n        });\n      }\n    } else {\n      el.style.display = value ? el.__vOriginalDisplay : 'none';\n    }\n  },\n\n  unbind: function unbind(el, binding, vnode, oldVnode, isDestroy) {\n    if (!isDestroy) {\n      el.style.display = el.__vOriginalDisplay;\n    }\n  }\n};\n\nvar platformDirectives = {\n  model: directive,\n  show: show\n};\n\n/*  */\n\n// Provides transition support for a single element/component.\n// supports transition mode (out-in / in-out)\n\nvar transitionProps = {\n  name: String,\n  appear: Boolean,\n  css: Boolean,\n  mode: String,\n  type: String,\n  enterClass: String,\n  leaveClass: String,\n  enterToClass: String,\n  leaveToClass: String,\n  enterActiveClass: String,\n  leaveActiveClass: String,\n  appearClass: String,\n  appearActiveClass: String,\n  appearToClass: String,\n  duration: [Number, String, Object]\n};\n\n// in case the child is also an abstract component, e.g. <keep-alive>\n// we want to recursively retrieve the real component to be rendered\nfunction getRealChild(vnode) {\n  var compOptions = vnode && vnode.componentOptions;\n  if (compOptions && compOptions.Ctor.options.abstract) {\n    return getRealChild(getFirstComponentChild(compOptions.children));\n  } else {\n    return vnode;\n  }\n}\n\nfunction extractTransitionData(comp) {\n  var data = {};\n  var options = comp.$options;\n  // props\n  for (var key in options.propsData) {\n    data[key] = comp[key];\n  }\n  // events.\n  // extract listeners and pass them directly to the transition methods\n  var listeners = options._parentListeners;\n  for (var key$1 in listeners) {\n    data[camelize(key$1)] = listeners[key$1];\n  }\n  return data;\n}\n\nfunction placeholder(h, rawChild) {\n  if (/\\d-keep-alive$/.test(rawChild.tag)) {\n    return h('keep-alive', {\n      props: rawChild.componentOptions.propsData\n    });\n  }\n}\n\nfunction hasParentTransition(vnode) {\n  while (vnode = vnode.parent) {\n    if (vnode.data.transition) {\n      return true;\n    }\n  }\n}\n\nfunction isSameChild(child, oldChild) {\n  return oldChild.key === child.key && oldChild.tag === child.tag;\n}\n\nvar Transition = {\n  name: 'transition',\n  props: transitionProps,\n  abstract: true,\n\n  render: function render(h) {\n    var this$1 = this;\n\n    var children = this.$slots.default;\n    if (!children) {\n      return;\n    }\n\n    // filter out text nodes (possible whitespaces)\n    children = children.filter(function (c) {\n      return c.tag || isAsyncPlaceholder(c);\n    });\n    /* istanbul ignore if */\n    if (!children.length) {\n      return;\n    }\n\n    // warn multiple elements\n    if (process.env.NODE_ENV !== 'production' && children.length > 1) {\n      warn('<transition> can only be used on a single element. Use ' + '<transition-group> for lists.', this.$parent);\n    }\n\n    var mode = this.mode;\n\n    // warn invalid mode\n    if (process.env.NODE_ENV !== 'production' && mode && mode !== 'in-out' && mode !== 'out-in') {\n      warn('invalid <transition> mode: ' + mode, this.$parent);\n    }\n\n    var rawChild = children[0];\n\n    // if this is a component root node and the component's\n    // parent container node also has transition, skip.\n    if (hasParentTransition(this.$vnode)) {\n      return rawChild;\n    }\n\n    // apply transition data to child\n    // use getRealChild() to ignore abstract components e.g. keep-alive\n    var child = getRealChild(rawChild);\n    /* istanbul ignore if */\n    if (!child) {\n      return rawChild;\n    }\n\n    if (this._leaving) {\n      return placeholder(h, rawChild);\n    }\n\n    // ensure a key that is unique to the vnode type and to this transition\n    // component instance. This key will be used to remove pending leaving nodes\n    // during entering.\n    var id = \"__transition-\" + this._uid + \"-\";\n    child.key = child.key == null ? child.isComment ? id + 'comment' : id + child.tag : isPrimitive(child.key) ? String(child.key).indexOf(id) === 0 ? child.key : id + child.key : child.key;\n\n    var data = (child.data || (child.data = {})).transition = extractTransitionData(this);\n    var oldRawChild = this._vnode;\n    var oldChild = getRealChild(oldRawChild);\n\n    // mark v-show\n    // so that the transition module can hand over the control to the directive\n    if (child.data.directives && child.data.directives.some(function (d) {\n      return d.name === 'show';\n    })) {\n      child.data.show = true;\n    }\n\n    if (oldChild && oldChild.data && !isSameChild(child, oldChild) && !isAsyncPlaceholder(oldChild) &&\n    // #6687 component root is a comment node\n    !(oldChild.componentInstance && oldChild.componentInstance._vnode.isComment)) {\n      // replace old child transition data with fresh one\n      // important for dynamic transitions!\n      var oldData = oldChild.data.transition = extend({}, data);\n      // handle transition mode\n      if (mode === 'out-in') {\n        // return placeholder node and queue update when leave finishes\n        this._leaving = true;\n        mergeVNodeHook(oldData, 'afterLeave', function () {\n          this$1._leaving = false;\n          this$1.$forceUpdate();\n        });\n        return placeholder(h, rawChild);\n      } else if (mode === 'in-out') {\n        if (isAsyncPlaceholder(child)) {\n          return oldRawChild;\n        }\n        var delayedLeave;\n        var performLeave = function performLeave() {\n          delayedLeave();\n        };\n        mergeVNodeHook(data, 'afterEnter', performLeave);\n        mergeVNodeHook(data, 'enterCancelled', performLeave);\n        mergeVNodeHook(oldData, 'delayLeave', function (leave) {\n          delayedLeave = leave;\n        });\n      }\n    }\n\n    return rawChild;\n  }\n};\n\n/*  */\n\n// Provides transition support for list items.\n// supports move transitions using the FLIP technique.\n\n// Because the vdom's children update algorithm is \"unstable\" - i.e.\n// it doesn't guarantee the relative positioning of removed elements,\n// we force transition-group to update its children into two passes:\n// in the first pass, we remove all nodes that need to be removed,\n// triggering their leaving transition; in the second pass, we insert/move\n// into the final desired state. This way in the second pass removed\n// nodes will remain where they should be.\n\nvar props = extend({\n  tag: String,\n  moveClass: String\n}, transitionProps);\n\ndelete props.mode;\n\nvar TransitionGroup = {\n  props: props,\n\n  render: function render(h) {\n    var tag = this.tag || this.$vnode.data.tag || 'span';\n    var map = Object.create(null);\n    var prevChildren = this.prevChildren = this.children;\n    var rawChildren = this.$slots.default || [];\n    var children = this.children = [];\n    var transitionData = extractTransitionData(this);\n\n    for (var i = 0; i < rawChildren.length; i++) {\n      var c = rawChildren[i];\n      if (c.tag) {\n        if (c.key != null && String(c.key).indexOf('__vlist') !== 0) {\n          children.push(c);\n          map[c.key] = c;(c.data || (c.data = {})).transition = transitionData;\n        } else if (process.env.NODE_ENV !== 'production') {\n          var opts = c.componentOptions;\n          var name = opts ? opts.Ctor.options.name || opts.tag || '' : c.tag;\n          warn(\"<transition-group> children must be keyed: <\" + name + \">\");\n        }\n      }\n    }\n\n    if (prevChildren) {\n      var kept = [];\n      var removed = [];\n      for (var i$1 = 0; i$1 < prevChildren.length; i$1++) {\n        var c$1 = prevChildren[i$1];\n        c$1.data.transition = transitionData;\n        c$1.data.pos = c$1.elm.getBoundingClientRect();\n        if (map[c$1.key]) {\n          kept.push(c$1);\n        } else {\n          removed.push(c$1);\n        }\n      }\n      this.kept = h(tag, null, kept);\n      this.removed = removed;\n    }\n\n    return h(tag, null, children);\n  },\n\n  beforeUpdate: function beforeUpdate() {\n    // force removing pass\n    this.__patch__(this._vnode, this.kept, false, // hydrating\n    true // removeOnly (!important avoids unnecessary moves)\n    );\n    this._vnode = this.kept;\n  },\n\n  updated: function updated() {\n    var children = this.prevChildren;\n    var moveClass = this.moveClass || (this.name || 'v') + '-move';\n    if (!children.length || !this.hasMove(children[0].elm, moveClass)) {\n      return;\n    }\n\n    // we divide the work into three loops to avoid mixing DOM reads and writes\n    // in each iteration - which helps prevent layout thrashing.\n    children.forEach(callPendingCbs);\n    children.forEach(recordPosition);\n    children.forEach(applyTranslation);\n\n    // force reflow to put everything in position\n    // assign to this to avoid being removed in tree-shaking\n    // $flow-disable-line\n    this._reflow = document.body.offsetHeight;\n\n    children.forEach(function (c) {\n      if (c.data.moved) {\n        var el = c.elm;\n        var s = el.style;\n        addTransitionClass(el, moveClass);\n        s.transform = s.WebkitTransform = s.transitionDuration = '';\n        el.addEventListener(transitionEndEvent, el._moveCb = function cb(e) {\n          if (!e || /transform$/.test(e.propertyName)) {\n            el.removeEventListener(transitionEndEvent, cb);\n            el._moveCb = null;\n            removeTransitionClass(el, moveClass);\n          }\n        });\n      }\n    });\n  },\n\n  methods: {\n    hasMove: function hasMove(el, moveClass) {\n      /* istanbul ignore if */\n      if (!hasTransition) {\n        return false;\n      }\n      /* istanbul ignore if */\n      if (this._hasMove) {\n        return this._hasMove;\n      }\n      // Detect whether an element with the move class applied has\n      // CSS transitions. Since the element may be inside an entering\n      // transition at this very moment, we make a clone of it and remove\n      // all other transition classes applied to ensure only the move class\n      // is applied.\n      var clone = el.cloneNode();\n      if (el._transitionClasses) {\n        el._transitionClasses.forEach(function (cls) {\n          removeClass(clone, cls);\n        });\n      }\n      addClass(clone, moveClass);\n      clone.style.display = 'none';\n      this.$el.appendChild(clone);\n      var info = getTransitionInfo(clone);\n      this.$el.removeChild(clone);\n      return this._hasMove = info.hasTransform;\n    }\n  }\n};\n\nfunction callPendingCbs(c) {\n  /* istanbul ignore if */\n  if (c.elm._moveCb) {\n    c.elm._moveCb();\n  }\n  /* istanbul ignore if */\n  if (c.elm._enterCb) {\n    c.elm._enterCb();\n  }\n}\n\nfunction recordPosition(c) {\n  c.data.newPos = c.elm.getBoundingClientRect();\n}\n\nfunction applyTranslation(c) {\n  var oldPos = c.data.pos;\n  var newPos = c.data.newPos;\n  var dx = oldPos.left - newPos.left;\n  var dy = oldPos.top - newPos.top;\n  if (dx || dy) {\n    c.data.moved = true;\n    var s = c.elm.style;\n    s.transform = s.WebkitTransform = \"translate(\" + dx + \"px,\" + dy + \"px)\";\n    s.transitionDuration = '0s';\n  }\n}\n\nvar platformComponents = {\n  Transition: Transition,\n  TransitionGroup: TransitionGroup\n};\n\n/*  */\n\n// install platform specific utils\nVue$3.config.mustUseProp = mustUseProp;\nVue$3.config.isReservedTag = isReservedTag;\nVue$3.config.isReservedAttr = isReservedAttr;\nVue$3.config.getTagNamespace = getTagNamespace;\nVue$3.config.isUnknownElement = isUnknownElement;\n\n// install platform runtime directives & components\nextend(Vue$3.options.directives, platformDirectives);\nextend(Vue$3.options.components, platformComponents);\n\n// install platform patch function\nVue$3.prototype.__patch__ = inBrowser ? patch : noop;\n\n// public mount method\nVue$3.prototype.$mount = function (el, hydrating) {\n  el = el && inBrowser ? query(el) : undefined;\n  return mountComponent(this, el, hydrating);\n};\n\n// devtools global hook\n/* istanbul ignore next */\nVue$3.nextTick(function () {\n  if (config.devtools) {\n    if (devtools) {\n      devtools.emit('init', Vue$3);\n    } else if (process.env.NODE_ENV !== 'production' && isChrome) {\n      console[console.info ? 'info' : 'log']('Download the Vue Devtools extension for a better development experience:\\n' + 'https://github.com/vuejs/vue-devtools');\n    }\n  }\n  if (process.env.NODE_ENV !== 'production' && config.productionTip !== false && inBrowser && typeof console !== 'undefined') {\n    console[console.info ? 'info' : 'log'](\"You are running Vue in development mode.\\n\" + \"Make sure to turn on production mode when deploying for production.\\n\" + \"See more tips at https://vuejs.org/guide/deployment.html\");\n  }\n}, 0);\n\n/*  */\n\nvar defaultTagRE = /\\{\\{((?:.|\\n)+?)\\}\\}/g;\nvar regexEscapeRE = /[-.*+?^${}()|[\\]\\/\\\\]/g;\n\nvar buildRegex = cached(function (delimiters) {\n  var open = delimiters[0].replace(regexEscapeRE, '\\\\$&');\n  var close = delimiters[1].replace(regexEscapeRE, '\\\\$&');\n  return new RegExp(open + '((?:.|\\\\n)+?)' + close, 'g');\n});\n\nfunction parseText(text, delimiters) {\n  var tagRE = delimiters ? buildRegex(delimiters) : defaultTagRE;\n  if (!tagRE.test(text)) {\n    return;\n  }\n  var tokens = [];\n  var lastIndex = tagRE.lastIndex = 0;\n  var match, index;\n  while (match = tagRE.exec(text)) {\n    index = match.index;\n    // push text token\n    if (index > lastIndex) {\n      tokens.push(JSON.stringify(text.slice(lastIndex, index)));\n    }\n    // tag token\n    var exp = parseFilters(match[1].trim());\n    tokens.push(\"_s(\" + exp + \")\");\n    lastIndex = index + match[0].length;\n  }\n  if (lastIndex < text.length) {\n    tokens.push(JSON.stringify(text.slice(lastIndex)));\n  }\n  return tokens.join('+');\n}\n\n/*  */\n\nfunction transformNode(el, options) {\n  var warn = options.warn || baseWarn;\n  var staticClass = getAndRemoveAttr(el, 'class');\n  if (process.env.NODE_ENV !== 'production' && staticClass) {\n    var expression = parseText(staticClass, options.delimiters);\n    if (expression) {\n      warn(\"class=\\\"\" + staticClass + \"\\\": \" + 'Interpolation inside attributes has been removed. ' + 'Use v-bind or the colon shorthand instead. For example, ' + 'instead of <div class=\"{{ val }}\">, use <div :class=\"val\">.');\n    }\n  }\n  if (staticClass) {\n    el.staticClass = JSON.stringify(staticClass);\n  }\n  var classBinding = getBindingAttr(el, 'class', false /* getStatic */);\n  if (classBinding) {\n    el.classBinding = classBinding;\n  }\n}\n\nfunction genData(el) {\n  var data = '';\n  if (el.staticClass) {\n    data += \"staticClass:\" + el.staticClass + \",\";\n  }\n  if (el.classBinding) {\n    data += \"class:\" + el.classBinding + \",\";\n  }\n  return data;\n}\n\nvar klass$1 = {\n  staticKeys: ['staticClass'],\n  transformNode: transformNode,\n  genData: genData\n};\n\n/*  */\n\nfunction transformNode$1(el, options) {\n  var warn = options.warn || baseWarn;\n  var staticStyle = getAndRemoveAttr(el, 'style');\n  if (staticStyle) {\n    /* istanbul ignore if */\n    if (process.env.NODE_ENV !== 'production') {\n      var expression = parseText(staticStyle, options.delimiters);\n      if (expression) {\n        warn(\"style=\\\"\" + staticStyle + \"\\\": \" + 'Interpolation inside attributes has been removed. ' + 'Use v-bind or the colon shorthand instead. For example, ' + 'instead of <div style=\"{{ val }}\">, use <div :style=\"val\">.');\n      }\n    }\n    el.staticStyle = JSON.stringify(parseStyleText(staticStyle));\n  }\n\n  var styleBinding = getBindingAttr(el, 'style', false /* getStatic */);\n  if (styleBinding) {\n    el.styleBinding = styleBinding;\n  }\n}\n\nfunction genData$1(el) {\n  var data = '';\n  if (el.staticStyle) {\n    data += \"staticStyle:\" + el.staticStyle + \",\";\n  }\n  if (el.styleBinding) {\n    data += \"style:(\" + el.styleBinding + \"),\";\n  }\n  return data;\n}\n\nvar style$1 = {\n  staticKeys: ['staticStyle'],\n  transformNode: transformNode$1,\n  genData: genData$1\n};\n\n/*  */\n\nvar decoder;\n\nvar he = {\n  decode: function decode(html) {\n    decoder = decoder || document.createElement('div');\n    decoder.innerHTML = html;\n    return decoder.textContent;\n  }\n};\n\n/*  */\n\nvar isUnaryTag = makeMap('area,base,br,col,embed,frame,hr,img,input,isindex,keygen,' + 'link,meta,param,source,track,wbr');\n\n// Elements that you can, intentionally, leave open\n// (and which close themselves)\nvar canBeLeftOpenTag = makeMap('colgroup,dd,dt,li,options,p,td,tfoot,th,thead,tr,source');\n\n// HTML5 tags https://html.spec.whatwg.org/multipage/indices.html#elements-3\n// Phrasing Content https://html.spec.whatwg.org/multipage/dom.html#phrasing-content\nvar isNonPhrasingTag = makeMap('address,article,aside,base,blockquote,body,caption,col,colgroup,dd,' + 'details,dialog,div,dl,dt,fieldset,figcaption,figure,footer,form,' + 'h1,h2,h3,h4,h5,h6,head,header,hgroup,hr,html,legend,li,menuitem,meta,' + 'optgroup,option,param,rp,rt,source,style,summary,tbody,td,tfoot,th,thead,' + 'title,tr,track');\n\n/**\n * Not type-checking this file because it's mostly vendor code.\n */\n\n/*!\n * HTML Parser By John Resig (ejohn.org)\n * Modified by Juriy \"kangax\" Zaytsev\n * Original code by Erik Arvidsson, Mozilla Public License\n * http://erik.eae.net/simplehtmlparser/simplehtmlparser.js\n */\n\n// Regular Expressions for parsing tags and attributes\nvar attribute = /^\\s*([^\\s\"'<>\\/=]+)(?:\\s*(=)\\s*(?:\"([^\"]*)\"+|'([^']*)'+|([^\\s\"'=<>`]+)))?/;\n// could use https://www.w3.org/TR/1999/REC-xml-names-19990114/#NT-QName\n// but for Vue templates we can enforce a simple charset\nvar ncname = '[a-zA-Z_][\\\\w\\\\-\\\\.]*';\nvar qnameCapture = \"((?:\" + ncname + \"\\\\:)?\" + ncname + \")\";\nvar startTagOpen = new RegExp(\"^<\" + qnameCapture);\nvar startTagClose = /^\\s*(\\/?)>/;\nvar endTag = new RegExp(\"^<\\\\/\" + qnameCapture + \"[^>]*>\");\nvar doctype = /^<!DOCTYPE [^>]+>/i;\nvar comment = /^<!--/;\nvar conditionalComment = /^<!\\[/;\n\nvar IS_REGEX_CAPTURING_BROKEN = false;\n'x'.replace(/x(.)?/g, function (m, g) {\n  IS_REGEX_CAPTURING_BROKEN = g === '';\n});\n\n// Special Elements (can contain anything)\nvar isPlainTextElement = makeMap('script,style,textarea', true);\nvar reCache = {};\n\nvar decodingMap = {\n  '&lt;': '<',\n  '&gt;': '>',\n  '&quot;': '\"',\n  '&amp;': '&',\n  '&#10;': '\\n',\n  '&#9;': '\\t'\n};\nvar encodedAttr = /&(?:lt|gt|quot|amp);/g;\nvar encodedAttrWithNewLines = /&(?:lt|gt|quot|amp|#10|#9);/g;\n\n// #5992\nvar isIgnoreNewlineTag = makeMap('pre,textarea', true);\nvar shouldIgnoreFirstNewline = function shouldIgnoreFirstNewline(tag, html) {\n  return tag && isIgnoreNewlineTag(tag) && html[0] === '\\n';\n};\n\nfunction decodeAttr(value, shouldDecodeNewlines) {\n  var re = shouldDecodeNewlines ? encodedAttrWithNewLines : encodedAttr;\n  return value.replace(re, function (match) {\n    return decodingMap[match];\n  });\n}\n\nfunction parseHTML(html, options) {\n  var stack = [];\n  var expectHTML = options.expectHTML;\n  var isUnaryTag$$1 = options.isUnaryTag || no;\n  var canBeLeftOpenTag$$1 = options.canBeLeftOpenTag || no;\n  var index = 0;\n  var last, lastTag;\n  while (html) {\n    last = html;\n    // Make sure we're not in a plaintext content element like script/style\n    if (!lastTag || !isPlainTextElement(lastTag)) {\n      var textEnd = html.indexOf('<');\n      if (textEnd === 0) {\n        // Comment:\n        if (comment.test(html)) {\n          var commentEnd = html.indexOf('-->');\n\n          if (commentEnd >= 0) {\n            if (options.shouldKeepComment) {\n              options.comment(html.substring(4, commentEnd));\n            }\n            advance(commentEnd + 3);\n            continue;\n          }\n        }\n\n        // http://en.wikipedia.org/wiki/Conditional_comment#Downlevel-revealed_conditional_comment\n        if (conditionalComment.test(html)) {\n          var conditionalEnd = html.indexOf(']>');\n\n          if (conditionalEnd >= 0) {\n            advance(conditionalEnd + 2);\n            continue;\n          }\n        }\n\n        // Doctype:\n        var doctypeMatch = html.match(doctype);\n        if (doctypeMatch) {\n          advance(doctypeMatch[0].length);\n          continue;\n        }\n\n        // End tag:\n        var endTagMatch = html.match(endTag);\n        if (endTagMatch) {\n          var curIndex = index;\n          advance(endTagMatch[0].length);\n          parseEndTag(endTagMatch[1], curIndex, index);\n          continue;\n        }\n\n        // Start tag:\n        var startTagMatch = parseStartTag();\n        if (startTagMatch) {\n          handleStartTag(startTagMatch);\n          if (shouldIgnoreFirstNewline(lastTag, html)) {\n            advance(1);\n          }\n          continue;\n        }\n      }\n\n      var text = void 0,\n          rest = void 0,\n          next = void 0;\n      if (textEnd >= 0) {\n        rest = html.slice(textEnd);\n        while (!endTag.test(rest) && !startTagOpen.test(rest) && !comment.test(rest) && !conditionalComment.test(rest)) {\n          // < in plain text, be forgiving and treat it as text\n          next = rest.indexOf('<', 1);\n          if (next < 0) {\n            break;\n          }\n          textEnd += next;\n          rest = html.slice(textEnd);\n        }\n        text = html.substring(0, textEnd);\n        advance(textEnd);\n      }\n\n      if (textEnd < 0) {\n        text = html;\n        html = '';\n      }\n\n      if (options.chars && text) {\n        options.chars(text);\n      }\n    } else {\n      var endTagLength = 0;\n      var stackedTag = lastTag.toLowerCase();\n      var reStackedTag = reCache[stackedTag] || (reCache[stackedTag] = new RegExp('([\\\\s\\\\S]*?)(</' + stackedTag + '[^>]*>)', 'i'));\n      var rest$1 = html.replace(reStackedTag, function (all, text, endTag) {\n        endTagLength = endTag.length;\n        if (!isPlainTextElement(stackedTag) && stackedTag !== 'noscript') {\n          text = text.replace(/<!--([\\s\\S]*?)-->/g, '$1').replace(/<!\\[CDATA\\[([\\s\\S]*?)]]>/g, '$1');\n        }\n        if (shouldIgnoreFirstNewline(stackedTag, text)) {\n          text = text.slice(1);\n        }\n        if (options.chars) {\n          options.chars(text);\n        }\n        return '';\n      });\n      index += html.length - rest$1.length;\n      html = rest$1;\n      parseEndTag(stackedTag, index - endTagLength, index);\n    }\n\n    if (html === last) {\n      options.chars && options.chars(html);\n      if (process.env.NODE_ENV !== 'production' && !stack.length && options.warn) {\n        options.warn(\"Mal-formatted tag at end of template: \\\"\" + html + \"\\\"\");\n      }\n      break;\n    }\n  }\n\n  // Clean up any remaining tags\n  parseEndTag();\n\n  function advance(n) {\n    index += n;\n    html = html.substring(n);\n  }\n\n  function parseStartTag() {\n    var start = html.match(startTagOpen);\n    if (start) {\n      var match = {\n        tagName: start[1],\n        attrs: [],\n        start: index\n      };\n      advance(start[0].length);\n      var end, attr;\n      while (!(end = html.match(startTagClose)) && (attr = html.match(attribute))) {\n        advance(attr[0].length);\n        match.attrs.push(attr);\n      }\n      if (end) {\n        match.unarySlash = end[1];\n        advance(end[0].length);\n        match.end = index;\n        return match;\n      }\n    }\n  }\n\n  function handleStartTag(match) {\n    var tagName = match.tagName;\n    var unarySlash = match.unarySlash;\n\n    if (expectHTML) {\n      if (lastTag === 'p' && isNonPhrasingTag(tagName)) {\n        parseEndTag(lastTag);\n      }\n      if (canBeLeftOpenTag$$1(tagName) && lastTag === tagName) {\n        parseEndTag(tagName);\n      }\n    }\n\n    var unary = isUnaryTag$$1(tagName) || !!unarySlash;\n\n    var l = match.attrs.length;\n    var attrs = new Array(l);\n    for (var i = 0; i < l; i++) {\n      var args = match.attrs[i];\n      // hackish work around FF bug https://bugzilla.mozilla.org/show_bug.cgi?id=369778\n      if (IS_REGEX_CAPTURING_BROKEN && args[0].indexOf('\"\"') === -1) {\n        if (args[3] === '') {\n          delete args[3];\n        }\n        if (args[4] === '') {\n          delete args[4];\n        }\n        if (args[5] === '') {\n          delete args[5];\n        }\n      }\n      var value = args[3] || args[4] || args[5] || '';\n      var shouldDecodeNewlines = tagName === 'a' && args[1] === 'href' ? options.shouldDecodeNewlinesForHref : options.shouldDecodeNewlines;\n      attrs[i] = {\n        name: args[1],\n        value: decodeAttr(value, shouldDecodeNewlines)\n      };\n    }\n\n    if (!unary) {\n      stack.push({ tag: tagName, lowerCasedTag: tagName.toLowerCase(), attrs: attrs });\n      lastTag = tagName;\n    }\n\n    if (options.start) {\n      options.start(tagName, attrs, unary, match.start, match.end);\n    }\n  }\n\n  function parseEndTag(tagName, start, end) {\n    var pos, lowerCasedTagName;\n    if (start == null) {\n      start = index;\n    }\n    if (end == null) {\n      end = index;\n    }\n\n    if (tagName) {\n      lowerCasedTagName = tagName.toLowerCase();\n    }\n\n    // Find the closest opened tag of the same type\n    if (tagName) {\n      for (pos = stack.length - 1; pos >= 0; pos--) {\n        if (stack[pos].lowerCasedTag === lowerCasedTagName) {\n          break;\n        }\n      }\n    } else {\n      // If no tag name is provided, clean shop\n      pos = 0;\n    }\n\n    if (pos >= 0) {\n      // Close all the open elements, up the stack\n      for (var i = stack.length - 1; i >= pos; i--) {\n        if (process.env.NODE_ENV !== 'production' && (i > pos || !tagName) && options.warn) {\n          options.warn(\"tag <\" + stack[i].tag + \"> has no matching end tag.\");\n        }\n        if (options.end) {\n          options.end(stack[i].tag, start, end);\n        }\n      }\n\n      // Remove the open elements from the stack\n      stack.length = pos;\n      lastTag = pos && stack[pos - 1].tag;\n    } else if (lowerCasedTagName === 'br') {\n      if (options.start) {\n        options.start(tagName, [], true, start, end);\n      }\n    } else if (lowerCasedTagName === 'p') {\n      if (options.start) {\n        options.start(tagName, [], false, start, end);\n      }\n      if (options.end) {\n        options.end(tagName, start, end);\n      }\n    }\n  }\n}\n\n/*  */\n\nvar onRE = /^@|^v-on:/;\nvar dirRE = /^v-|^@|^:/;\nvar forAliasRE = /(.*?)\\s+(?:in|of)\\s+(.*)/;\nvar forIteratorRE = /,([^,\\}\\]]*)(?:,([^,\\}\\]]*))?$/;\nvar stripParensRE = /^\\(|\\)$/g;\n\nvar argRE = /:(.*)$/;\nvar bindRE = /^:|^v-bind:/;\nvar modifierRE = /\\.[^.]+/g;\n\nvar decodeHTMLCached = cached(he.decode);\n\n// configurable state\nvar warn$2;\nvar delimiters;\nvar transforms;\nvar preTransforms;\nvar postTransforms;\nvar platformIsPreTag;\nvar platformMustUseProp;\nvar platformGetTagNamespace;\n\nfunction createASTElement(tag, attrs, parent) {\n  return {\n    type: 1,\n    tag: tag,\n    attrsList: attrs,\n    attrsMap: makeAttrsMap(attrs),\n    parent: parent,\n    children: []\n  };\n}\n\n/**\n * Convert HTML string to AST.\n */\nfunction parse(template, options) {\n  warn$2 = options.warn || baseWarn;\n\n  platformIsPreTag = options.isPreTag || no;\n  platformMustUseProp = options.mustUseProp || no;\n  platformGetTagNamespace = options.getTagNamespace || no;\n\n  transforms = pluckModuleFunction(options.modules, 'transformNode');\n  preTransforms = pluckModuleFunction(options.modules, 'preTransformNode');\n  postTransforms = pluckModuleFunction(options.modules, 'postTransformNode');\n\n  delimiters = options.delimiters;\n\n  var stack = [];\n  var preserveWhitespace = options.preserveWhitespace !== false;\n  var root;\n  var currentParent;\n  var inVPre = false;\n  var inPre = false;\n  var warned = false;\n\n  function warnOnce(msg) {\n    if (!warned) {\n      warned = true;\n      warn$2(msg);\n    }\n  }\n\n  function endPre(element) {\n    // check pre state\n    if (element.pre) {\n      inVPre = false;\n    }\n    if (platformIsPreTag(element.tag)) {\n      inPre = false;\n    }\n  }\n\n  parseHTML(template, {\n    warn: warn$2,\n    expectHTML: options.expectHTML,\n    isUnaryTag: options.isUnaryTag,\n    canBeLeftOpenTag: options.canBeLeftOpenTag,\n    shouldDecodeNewlines: options.shouldDecodeNewlines,\n    shouldDecodeNewlinesForHref: options.shouldDecodeNewlinesForHref,\n    shouldKeepComment: options.comments,\n    start: function start(tag, attrs, unary) {\n      // check namespace.\n      // inherit parent ns if there is one\n      var ns = currentParent && currentParent.ns || platformGetTagNamespace(tag);\n\n      // handle IE svg bug\n      /* istanbul ignore if */\n      if (isIE && ns === 'svg') {\n        attrs = guardIESVGBug(attrs);\n      }\n\n      var element = createASTElement(tag, attrs, currentParent);\n      if (ns) {\n        element.ns = ns;\n      }\n\n      if (isForbiddenTag(element) && !isServerRendering()) {\n        element.forbidden = true;\n        process.env.NODE_ENV !== 'production' && warn$2('Templates should only be responsible for mapping the state to the ' + 'UI. Avoid placing tags with side-effects in your templates, such as ' + \"<\" + tag + \">\" + ', as they will not be parsed.');\n      }\n\n      // apply pre-transforms\n      for (var i = 0; i < preTransforms.length; i++) {\n        element = preTransforms[i](element, options) || element;\n      }\n\n      if (!inVPre) {\n        processPre(element);\n        if (element.pre) {\n          inVPre = true;\n        }\n      }\n      if (platformIsPreTag(element.tag)) {\n        inPre = true;\n      }\n      if (inVPre) {\n        processRawAttrs(element);\n      } else if (!element.processed) {\n        // structural directives\n        processFor(element);\n        processIf(element);\n        processOnce(element);\n        // element-scope stuff\n        processElement(element, options);\n      }\n\n      function checkRootConstraints(el) {\n        if (process.env.NODE_ENV !== 'production') {\n          if (el.tag === 'slot' || el.tag === 'template') {\n            warnOnce(\"Cannot use <\" + el.tag + \"> as component root element because it may \" + 'contain multiple nodes.');\n          }\n          if (el.attrsMap.hasOwnProperty('v-for')) {\n            warnOnce('Cannot use v-for on stateful component root element because ' + 'it renders multiple elements.');\n          }\n        }\n      }\n\n      // tree management\n      if (!root) {\n        root = element;\n        checkRootConstraints(root);\n      } else if (!stack.length) {\n        // allow root elements with v-if, v-else-if and v-else\n        if (root.if && (element.elseif || element.else)) {\n          checkRootConstraints(element);\n          addIfCondition(root, {\n            exp: element.elseif,\n            block: element\n          });\n        } else if (process.env.NODE_ENV !== 'production') {\n          warnOnce(\"Component template should contain exactly one root element. \" + \"If you are using v-if on multiple elements, \" + \"use v-else-if to chain them instead.\");\n        }\n      }\n      if (currentParent && !element.forbidden) {\n        if (element.elseif || element.else) {\n          processIfConditions(element, currentParent);\n        } else if (element.slotScope) {\n          // scoped slot\n          currentParent.plain = false;\n          var name = element.slotTarget || '\"default\"';(currentParent.scopedSlots || (currentParent.scopedSlots = {}))[name] = element;\n        } else {\n          currentParent.children.push(element);\n          element.parent = currentParent;\n        }\n      }\n      if (!unary) {\n        currentParent = element;\n        stack.push(element);\n      } else {\n        endPre(element);\n      }\n      // apply post-transforms\n      for (var i$1 = 0; i$1 < postTransforms.length; i$1++) {\n        postTransforms[i$1](element, options);\n      }\n    },\n\n    end: function end() {\n      // remove trailing whitespace\n      var element = stack[stack.length - 1];\n      var lastNode = element.children[element.children.length - 1];\n      if (lastNode && lastNode.type === 3 && lastNode.text === ' ' && !inPre) {\n        element.children.pop();\n      }\n      // pop stack\n      stack.length -= 1;\n      currentParent = stack[stack.length - 1];\n      endPre(element);\n    },\n\n    chars: function chars(text) {\n      if (!currentParent) {\n        if (process.env.NODE_ENV !== 'production') {\n          if (text === template) {\n            warnOnce('Component template requires a root element, rather than just text.');\n          } else if (text = text.trim()) {\n            warnOnce(\"text \\\"\" + text + \"\\\" outside root element will be ignored.\");\n          }\n        }\n        return;\n      }\n      // IE textarea placeholder bug\n      /* istanbul ignore if */\n      if (isIE && currentParent.tag === 'textarea' && currentParent.attrsMap.placeholder === text) {\n        return;\n      }\n      var children = currentParent.children;\n      text = inPre || text.trim() ? isTextTag(currentParent) ? text : decodeHTMLCached(text)\n      // only preserve whitespace if its not right after a starting tag\n      : preserveWhitespace && children.length ? ' ' : '';\n      if (text) {\n        var expression;\n        if (!inVPre && text !== ' ' && (expression = parseText(text, delimiters))) {\n          children.push({\n            type: 2,\n            expression: expression,\n            text: text\n          });\n        } else if (text !== ' ' || !children.length || children[children.length - 1].text !== ' ') {\n          children.push({\n            type: 3,\n            text: text\n          });\n        }\n      }\n    },\n    comment: function comment(text) {\n      currentParent.children.push({\n        type: 3,\n        text: text,\n        isComment: true\n      });\n    }\n  });\n  return root;\n}\n\nfunction processPre(el) {\n  if (getAndRemoveAttr(el, 'v-pre') != null) {\n    el.pre = true;\n  }\n}\n\nfunction processRawAttrs(el) {\n  var l = el.attrsList.length;\n  if (l) {\n    var attrs = el.attrs = new Array(l);\n    for (var i = 0; i < l; i++) {\n      attrs[i] = {\n        name: el.attrsList[i].name,\n        value: JSON.stringify(el.attrsList[i].value)\n      };\n    }\n  } else if (!el.pre) {\n    // non root node in pre blocks with no attributes\n    el.plain = true;\n  }\n}\n\nfunction processElement(element, options) {\n  processKey(element);\n\n  // determine whether this is a plain element after\n  // removing structural attributes\n  element.plain = !element.key && !element.attrsList.length;\n\n  processRef(element);\n  processSlot(element);\n  processComponent(element);\n  for (var i = 0; i < transforms.length; i++) {\n    element = transforms[i](element, options) || element;\n  }\n  processAttrs(element);\n}\n\nfunction processKey(el) {\n  var exp = getBindingAttr(el, 'key');\n  if (exp) {\n    if (process.env.NODE_ENV !== 'production' && el.tag === 'template') {\n      warn$2(\"<template> cannot be keyed. Place the key on real elements instead.\");\n    }\n    el.key = exp;\n  }\n}\n\nfunction processRef(el) {\n  var ref = getBindingAttr(el, 'ref');\n  if (ref) {\n    el.ref = ref;\n    el.refInFor = checkInFor(el);\n  }\n}\n\nfunction processFor(el) {\n  var exp;\n  if (exp = getAndRemoveAttr(el, 'v-for')) {\n    var inMatch = exp.match(forAliasRE);\n    if (!inMatch) {\n      process.env.NODE_ENV !== 'production' && warn$2(\"Invalid v-for expression: \" + exp);\n      return;\n    }\n    el.for = inMatch[2].trim();\n    var alias = inMatch[1].trim().replace(stripParensRE, '');\n    var iteratorMatch = alias.match(forIteratorRE);\n    if (iteratorMatch) {\n      el.alias = alias.replace(forIteratorRE, '');\n      el.iterator1 = iteratorMatch[1].trim();\n      if (iteratorMatch[2]) {\n        el.iterator2 = iteratorMatch[2].trim();\n      }\n    } else {\n      el.alias = alias;\n    }\n  }\n}\n\nfunction processIf(el) {\n  var exp = getAndRemoveAttr(el, 'v-if');\n  if (exp) {\n    el.if = exp;\n    addIfCondition(el, {\n      exp: exp,\n      block: el\n    });\n  } else {\n    if (getAndRemoveAttr(el, 'v-else') != null) {\n      el.else = true;\n    }\n    var elseif = getAndRemoveAttr(el, 'v-else-if');\n    if (elseif) {\n      el.elseif = elseif;\n    }\n  }\n}\n\nfunction processIfConditions(el, parent) {\n  var prev = findPrevElement(parent.children);\n  if (prev && prev.if) {\n    addIfCondition(prev, {\n      exp: el.elseif,\n      block: el\n    });\n  } else if (process.env.NODE_ENV !== 'production') {\n    warn$2(\"v-\" + (el.elseif ? 'else-if=\"' + el.elseif + '\"' : 'else') + \" \" + \"used on element <\" + el.tag + \"> without corresponding v-if.\");\n  }\n}\n\nfunction findPrevElement(children) {\n  var i = children.length;\n  while (i--) {\n    if (children[i].type === 1) {\n      return children[i];\n    } else {\n      if (process.env.NODE_ENV !== 'production' && children[i].text !== ' ') {\n        warn$2(\"text \\\"\" + children[i].text.trim() + \"\\\" between v-if and v-else(-if) \" + \"will be ignored.\");\n      }\n      children.pop();\n    }\n  }\n}\n\nfunction addIfCondition(el, condition) {\n  if (!el.ifConditions) {\n    el.ifConditions = [];\n  }\n  el.ifConditions.push(condition);\n}\n\nfunction processOnce(el) {\n  var once$$1 = getAndRemoveAttr(el, 'v-once');\n  if (once$$1 != null) {\n    el.once = true;\n  }\n}\n\nfunction processSlot(el) {\n  if (el.tag === 'slot') {\n    el.slotName = getBindingAttr(el, 'name');\n    if (process.env.NODE_ENV !== 'production' && el.key) {\n      warn$2(\"`key` does not work on <slot> because slots are abstract outlets \" + \"and can possibly expand into multiple elements. \" + \"Use the key on a wrapping element instead.\");\n    }\n  } else {\n    var slotScope;\n    if (el.tag === 'template') {\n      slotScope = getAndRemoveAttr(el, 'scope');\n      /* istanbul ignore if */\n      if (process.env.NODE_ENV !== 'production' && slotScope) {\n        warn$2(\"the \\\"scope\\\" attribute for scoped slots have been deprecated and \" + \"replaced by \\\"slot-scope\\\" since 2.5. The new \\\"slot-scope\\\" attribute \" + \"can also be used on plain elements in addition to <template> to \" + \"denote scoped slots.\", true);\n      }\n      el.slotScope = slotScope || getAndRemoveAttr(el, 'slot-scope');\n    } else if (slotScope = getAndRemoveAttr(el, 'slot-scope')) {\n      /* istanbul ignore if */\n      if (process.env.NODE_ENV !== 'production' && el.attrsMap['v-for']) {\n        warn$2(\"Ambiguous combined usage of slot-scope and v-for on <\" + el.tag + \"> \" + \"(v-for takes higher priority). Use a wrapper <template> for the \" + \"scoped slot to make it clearer.\", true);\n      }\n      el.slotScope = slotScope;\n    }\n    var slotTarget = getBindingAttr(el, 'slot');\n    if (slotTarget) {\n      el.slotTarget = slotTarget === '\"\"' ? '\"default\"' : slotTarget;\n      // preserve slot as an attribute for native shadow DOM compat\n      // only for non-scoped slots.\n      if (el.tag !== 'template' && !el.slotScope) {\n        addAttr(el, 'slot', slotTarget);\n      }\n    }\n  }\n}\n\nfunction processComponent(el) {\n  var binding;\n  if (binding = getBindingAttr(el, 'is')) {\n    el.component = binding;\n  }\n  if (getAndRemoveAttr(el, 'inline-template') != null) {\n    el.inlineTemplate = true;\n  }\n}\n\nfunction processAttrs(el) {\n  var list = el.attrsList;\n  var i, l, name, rawName, value, modifiers, isProp;\n  for (i = 0, l = list.length; i < l; i++) {\n    name = rawName = list[i].name;\n    value = list[i].value;\n    if (dirRE.test(name)) {\n      // mark element as dynamic\n      el.hasBindings = true;\n      // modifiers\n      modifiers = parseModifiers(name);\n      if (modifiers) {\n        name = name.replace(modifierRE, '');\n      }\n      if (bindRE.test(name)) {\n        // v-bind\n        name = name.replace(bindRE, '');\n        value = parseFilters(value);\n        isProp = false;\n        if (modifiers) {\n          if (modifiers.prop) {\n            isProp = true;\n            name = camelize(name);\n            if (name === 'innerHtml') {\n              name = 'innerHTML';\n            }\n          }\n          if (modifiers.camel) {\n            name = camelize(name);\n          }\n          if (modifiers.sync) {\n            addHandler(el, \"update:\" + camelize(name), genAssignmentCode(value, \"$event\"));\n          }\n        }\n        if (isProp || !el.component && platformMustUseProp(el.tag, el.attrsMap.type, name)) {\n          addProp(el, name, value);\n        } else {\n          addAttr(el, name, value);\n        }\n      } else if (onRE.test(name)) {\n        // v-on\n        name = name.replace(onRE, '');\n        addHandler(el, name, value, modifiers, false, warn$2);\n      } else {\n        // normal directives\n        name = name.replace(dirRE, '');\n        // parse arg\n        var argMatch = name.match(argRE);\n        var arg = argMatch && argMatch[1];\n        if (arg) {\n          name = name.slice(0, -(arg.length + 1));\n        }\n        addDirective(el, name, rawName, value, arg, modifiers);\n        if (process.env.NODE_ENV !== 'production' && name === 'model') {\n          checkForAliasModel(el, value);\n        }\n      }\n    } else {\n      // literal attribute\n      if (process.env.NODE_ENV !== 'production') {\n        var expression = parseText(value, delimiters);\n        if (expression) {\n          warn$2(name + \"=\\\"\" + value + \"\\\": \" + 'Interpolation inside attributes has been removed. ' + 'Use v-bind or the colon shorthand instead. For example, ' + 'instead of <div id=\"{{ val }}\">, use <div :id=\"val\">.');\n        }\n      }\n      addAttr(el, name, JSON.stringify(value));\n      // #6887 firefox doesn't update muted state if set via attribute\n      // even immediately after element creation\n      if (!el.component && name === 'muted' && platformMustUseProp(el.tag, el.attrsMap.type, name)) {\n        addProp(el, name, 'true');\n      }\n    }\n  }\n}\n\nfunction checkInFor(el) {\n  var parent = el;\n  while (parent) {\n    if (parent.for !== undefined) {\n      return true;\n    }\n    parent = parent.parent;\n  }\n  return false;\n}\n\nfunction parseModifiers(name) {\n  var match = name.match(modifierRE);\n  if (match) {\n    var ret = {};\n    match.forEach(function (m) {\n      ret[m.slice(1)] = true;\n    });\n    return ret;\n  }\n}\n\nfunction makeAttrsMap(attrs) {\n  var map = {};\n  for (var i = 0, l = attrs.length; i < l; i++) {\n    if (process.env.NODE_ENV !== 'production' && map[attrs[i].name] && !isIE && !isEdge) {\n      warn$2('duplicate attribute: ' + attrs[i].name);\n    }\n    map[attrs[i].name] = attrs[i].value;\n  }\n  return map;\n}\n\n// for script (e.g. type=\"x/template\") or style, do not decode content\nfunction isTextTag(el) {\n  return el.tag === 'script' || el.tag === 'style';\n}\n\nfunction isForbiddenTag(el) {\n  return el.tag === 'style' || el.tag === 'script' && (!el.attrsMap.type || el.attrsMap.type === 'text/javascript');\n}\n\nvar ieNSBug = /^xmlns:NS\\d+/;\nvar ieNSPrefix = /^NS\\d+:/;\n\n/* istanbul ignore next */\nfunction guardIESVGBug(attrs) {\n  var res = [];\n  for (var i = 0; i < attrs.length; i++) {\n    var attr = attrs[i];\n    if (!ieNSBug.test(attr.name)) {\n      attr.name = attr.name.replace(ieNSPrefix, '');\n      res.push(attr);\n    }\n  }\n  return res;\n}\n\nfunction checkForAliasModel(el, value) {\n  var _el = el;\n  while (_el) {\n    if (_el.for && _el.alias === value) {\n      warn$2(\"<\" + el.tag + \" v-model=\\\"\" + value + \"\\\">: \" + \"You are binding v-model directly to a v-for iteration alias. \" + \"This will not be able to modify the v-for source array because \" + \"writing to the alias is like modifying a function local variable. \" + \"Consider using an array of objects and use v-model on an object property instead.\");\n    }\n    _el = _el.parent;\n  }\n}\n\n/*  */\n\n/**\n * Expand input[v-model] with dyanmic type bindings into v-if-else chains\n * Turn this:\n *   <input v-model=\"data[type]\" :type=\"type\">\n * into this:\n *   <input v-if=\"type === 'checkbox'\" type=\"checkbox\" v-model=\"data[type]\">\n *   <input v-else-if=\"type === 'radio'\" type=\"radio\" v-model=\"data[type]\">\n *   <input v-else :type=\"type\" v-model=\"data[type]\">\n */\n\nfunction preTransformNode(el, options) {\n  if (el.tag === 'input') {\n    var map = el.attrsMap;\n    if (map['v-model'] && (map['v-bind:type'] || map[':type'])) {\n      var typeBinding = getBindingAttr(el, 'type');\n      var ifCondition = getAndRemoveAttr(el, 'v-if', true);\n      var ifConditionExtra = ifCondition ? \"&&(\" + ifCondition + \")\" : \"\";\n      var hasElse = getAndRemoveAttr(el, 'v-else', true) != null;\n      var elseIfCondition = getAndRemoveAttr(el, 'v-else-if', true);\n      // 1. checkbox\n      var branch0 = cloneASTElement(el);\n      // process for on the main node\n      processFor(branch0);\n      addRawAttr(branch0, 'type', 'checkbox');\n      processElement(branch0, options);\n      branch0.processed = true; // prevent it from double-processed\n      branch0.if = \"(\" + typeBinding + \")==='checkbox'\" + ifConditionExtra;\n      addIfCondition(branch0, {\n        exp: branch0.if,\n        block: branch0\n      });\n      // 2. add radio else-if condition\n      var branch1 = cloneASTElement(el);\n      getAndRemoveAttr(branch1, 'v-for', true);\n      addRawAttr(branch1, 'type', 'radio');\n      processElement(branch1, options);\n      addIfCondition(branch0, {\n        exp: \"(\" + typeBinding + \")==='radio'\" + ifConditionExtra,\n        block: branch1\n      });\n      // 3. other\n      var branch2 = cloneASTElement(el);\n      getAndRemoveAttr(branch2, 'v-for', true);\n      addRawAttr(branch2, ':type', typeBinding);\n      processElement(branch2, options);\n      addIfCondition(branch0, {\n        exp: ifCondition,\n        block: branch2\n      });\n\n      if (hasElse) {\n        branch0.else = true;\n      } else if (elseIfCondition) {\n        branch0.elseif = elseIfCondition;\n      }\n\n      return branch0;\n    }\n  }\n}\n\nfunction cloneASTElement(el) {\n  return createASTElement(el.tag, el.attrsList.slice(), el.parent);\n}\n\nfunction addRawAttr(el, name, value) {\n  el.attrsMap[name] = value;\n  el.attrsList.push({ name: name, value: value });\n}\n\nvar model$2 = {\n  preTransformNode: preTransformNode\n};\n\nvar modules$1 = [klass$1, style$1, model$2];\n\n/*  */\n\nfunction text(el, dir) {\n  if (dir.value) {\n    addProp(el, 'textContent', \"_s(\" + dir.value + \")\");\n  }\n}\n\n/*  */\n\nfunction html(el, dir) {\n  if (dir.value) {\n    addProp(el, 'innerHTML', \"_s(\" + dir.value + \")\");\n  }\n}\n\nvar directives$1 = {\n  model: model,\n  text: text,\n  html: html\n};\n\n/*  */\n\nvar baseOptions = {\n  expectHTML: true,\n  modules: modules$1,\n  directives: directives$1,\n  isPreTag: isPreTag,\n  isUnaryTag: isUnaryTag,\n  mustUseProp: mustUseProp,\n  canBeLeftOpenTag: canBeLeftOpenTag,\n  isReservedTag: isReservedTag,\n  getTagNamespace: getTagNamespace,\n  staticKeys: genStaticKeys(modules$1)\n};\n\n/*  */\n\nvar isStaticKey;\nvar isPlatformReservedTag;\n\nvar genStaticKeysCached = cached(genStaticKeys$1);\n\n/**\n * Goal of the optimizer: walk the generated template AST tree\n * and detect sub-trees that are purely static, i.e. parts of\n * the DOM that never needs to change.\n *\n * Once we detect these sub-trees, we can:\n *\n * 1. Hoist them into constants, so that we no longer need to\n *    create fresh nodes for them on each re-render;\n * 2. Completely skip them in the patching process.\n */\nfunction optimize(root, options) {\n  if (!root) {\n    return;\n  }\n  isStaticKey = genStaticKeysCached(options.staticKeys || '');\n  isPlatformReservedTag = options.isReservedTag || no;\n  // first pass: mark all non-static nodes.\n  markStatic$1(root);\n  // second pass: mark static roots.\n  markStaticRoots(root, false);\n}\n\nfunction genStaticKeys$1(keys) {\n  return makeMap('type,tag,attrsList,attrsMap,plain,parent,children,attrs' + (keys ? ',' + keys : ''));\n}\n\nfunction markStatic$1(node) {\n  node.static = isStatic(node);\n  if (node.type === 1) {\n    // do not make component slot content static. this avoids\n    // 1. components not able to mutate slot nodes\n    // 2. static slot content fails for hot-reloading\n    if (!isPlatformReservedTag(node.tag) && node.tag !== 'slot' && node.attrsMap['inline-template'] == null) {\n      return;\n    }\n    for (var i = 0, l = node.children.length; i < l; i++) {\n      var child = node.children[i];\n      markStatic$1(child);\n      if (!child.static) {\n        node.static = false;\n      }\n    }\n    if (node.ifConditions) {\n      for (var i$1 = 1, l$1 = node.ifConditions.length; i$1 < l$1; i$1++) {\n        var block = node.ifConditions[i$1].block;\n        markStatic$1(block);\n        if (!block.static) {\n          node.static = false;\n        }\n      }\n    }\n  }\n}\n\nfunction markStaticRoots(node, isInFor) {\n  if (node.type === 1) {\n    if (node.static || node.once) {\n      node.staticInFor = isInFor;\n    }\n    // For a node to qualify as a static root, it should have children that\n    // are not just static text. Otherwise the cost of hoisting out will\n    // outweigh the benefits and it's better off to just always render it fresh.\n    if (node.static && node.children.length && !(node.children.length === 1 && node.children[0].type === 3)) {\n      node.staticRoot = true;\n      return;\n    } else {\n      node.staticRoot = false;\n    }\n    if (node.children) {\n      for (var i = 0, l = node.children.length; i < l; i++) {\n        markStaticRoots(node.children[i], isInFor || !!node.for);\n      }\n    }\n    if (node.ifConditions) {\n      for (var i$1 = 1, l$1 = node.ifConditions.length; i$1 < l$1; i$1++) {\n        markStaticRoots(node.ifConditions[i$1].block, isInFor);\n      }\n    }\n  }\n}\n\nfunction isStatic(node) {\n  if (node.type === 2) {\n    // expression\n    return false;\n  }\n  if (node.type === 3) {\n    // text\n    return true;\n  }\n  return !!(node.pre || !node.hasBindings && // no dynamic bindings\n  !node.if && !node.for && // not v-if or v-for or v-else\n  !isBuiltInTag(node.tag) && // not a built-in\n  isPlatformReservedTag(node.tag) && // not a component\n  !isDirectChildOfTemplateFor(node) && Object.keys(node).every(isStaticKey));\n}\n\nfunction isDirectChildOfTemplateFor(node) {\n  while (node.parent) {\n    node = node.parent;\n    if (node.tag !== 'template') {\n      return false;\n    }\n    if (node.for) {\n      return true;\n    }\n  }\n  return false;\n}\n\n/*  */\n\nvar fnExpRE = /^\\s*([\\w$_]+|\\([^)]*?\\))\\s*=>|^function\\s*\\(/;\nvar simplePathRE = /^\\s*[A-Za-z_$][\\w$]*(?:\\.[A-Za-z_$][\\w$]*|\\['.*?']|\\[\".*?\"]|\\[\\d+]|\\[[A-Za-z_$][\\w$]*])*\\s*$/;\n\n// keyCode aliases\nvar keyCodes = {\n  esc: 27,\n  tab: 9,\n  enter: 13,\n  space: 32,\n  up: 38,\n  left: 37,\n  right: 39,\n  down: 40,\n  'delete': [8, 46]\n};\n\n// #4868: modifiers that prevent the execution of the listener\n// need to explicitly return null so that we can determine whether to remove\n// the listener for .once\nvar genGuard = function genGuard(condition) {\n  return \"if(\" + condition + \")return null;\";\n};\n\nvar modifierCode = {\n  stop: '$event.stopPropagation();',\n  prevent: '$event.preventDefault();',\n  self: genGuard(\"$event.target !== $event.currentTarget\"),\n  ctrl: genGuard(\"!$event.ctrlKey\"),\n  shift: genGuard(\"!$event.shiftKey\"),\n  alt: genGuard(\"!$event.altKey\"),\n  meta: genGuard(\"!$event.metaKey\"),\n  left: genGuard(\"'button' in $event && $event.button !== 0\"),\n  middle: genGuard(\"'button' in $event && $event.button !== 1\"),\n  right: genGuard(\"'button' in $event && $event.button !== 2\")\n};\n\nfunction genHandlers(events, isNative, warn) {\n  var res = isNative ? 'nativeOn:{' : 'on:{';\n  for (var name in events) {\n    res += \"\\\"\" + name + \"\\\":\" + genHandler(name, events[name]) + \",\";\n  }\n  return res.slice(0, -1) + '}';\n}\n\nfunction genHandler(name, handler) {\n  if (!handler) {\n    return 'function(){}';\n  }\n\n  if (Array.isArray(handler)) {\n    return \"[\" + handler.map(function (handler) {\n      return genHandler(name, handler);\n    }).join(',') + \"]\";\n  }\n\n  var isMethodPath = simplePathRE.test(handler.value);\n  var isFunctionExpression = fnExpRE.test(handler.value);\n\n  if (!handler.modifiers) {\n    return isMethodPath || isFunctionExpression ? handler.value : \"function($event){\" + handler.value + \"}\"; // inline statement\n  } else {\n    var code = '';\n    var genModifierCode = '';\n    var keys = [];\n    for (var key in handler.modifiers) {\n      if (modifierCode[key]) {\n        genModifierCode += modifierCode[key];\n        // left/right\n        if (keyCodes[key]) {\n          keys.push(key);\n        }\n      } else if (key === 'exact') {\n        var modifiers = handler.modifiers;\n        genModifierCode += genGuard(['ctrl', 'shift', 'alt', 'meta'].filter(function (keyModifier) {\n          return !modifiers[keyModifier];\n        }).map(function (keyModifier) {\n          return \"$event.\" + keyModifier + \"Key\";\n        }).join('||'));\n      } else {\n        keys.push(key);\n      }\n    }\n    if (keys.length) {\n      code += genKeyFilter(keys);\n    }\n    // Make sure modifiers like prevent and stop get executed after key filtering\n    if (genModifierCode) {\n      code += genModifierCode;\n    }\n    var handlerCode = isMethodPath ? handler.value + '($event)' : isFunctionExpression ? \"(\" + handler.value + \")($event)\" : handler.value;\n    return \"function($event){\" + code + handlerCode + \"}\";\n  }\n}\n\nfunction genKeyFilter(keys) {\n  return \"if(!('button' in $event)&&\" + keys.map(genFilterCode).join('&&') + \")return null;\";\n}\n\nfunction genFilterCode(key) {\n  var keyVal = parseInt(key, 10);\n  if (keyVal) {\n    return \"$event.keyCode!==\" + keyVal;\n  }\n  var code = keyCodes[key];\n  return \"_k($event.keyCode,\" + JSON.stringify(key) + \",\" + JSON.stringify(code) + \",\" + \"$event.key)\";\n}\n\n/*  */\n\nfunction on(el, dir) {\n  if (process.env.NODE_ENV !== 'production' && dir.modifiers) {\n    warn(\"v-on without argument does not support modifiers.\");\n  }\n  el.wrapListeners = function (code) {\n    return \"_g(\" + code + \",\" + dir.value + \")\";\n  };\n}\n\n/*  */\n\nfunction bind$1(el, dir) {\n  el.wrapData = function (code) {\n    return \"_b(\" + code + \",'\" + el.tag + \"',\" + dir.value + \",\" + (dir.modifiers && dir.modifiers.prop ? 'true' : 'false') + (dir.modifiers && dir.modifiers.sync ? ',true' : '') + \")\";\n  };\n}\n\n/*  */\n\nvar baseDirectives = {\n  on: on,\n  bind: bind$1,\n  cloak: noop\n};\n\n/*  */\n\nvar CodegenState = function CodegenState(options) {\n  this.options = options;\n  this.warn = options.warn || baseWarn;\n  this.transforms = pluckModuleFunction(options.modules, 'transformCode');\n  this.dataGenFns = pluckModuleFunction(options.modules, 'genData');\n  this.directives = extend(extend({}, baseDirectives), options.directives);\n  var isReservedTag = options.isReservedTag || no;\n  this.maybeComponent = function (el) {\n    return !isReservedTag(el.tag);\n  };\n  this.onceId = 0;\n  this.staticRenderFns = [];\n};\n\nfunction generate(ast, options) {\n  var state = new CodegenState(options);\n  var code = ast ? genElement(ast, state) : '_c(\"div\")';\n  return {\n    render: \"with(this){return \" + code + \"}\",\n    staticRenderFns: state.staticRenderFns\n  };\n}\n\nfunction genElement(el, state) {\n  if (el.staticRoot && !el.staticProcessed) {\n    return genStatic(el, state);\n  } else if (el.once && !el.onceProcessed) {\n    return genOnce(el, state);\n  } else if (el.for && !el.forProcessed) {\n    return genFor(el, state);\n  } else if (el.if && !el.ifProcessed) {\n    return genIf(el, state);\n  } else if (el.tag === 'template' && !el.slotTarget) {\n    return genChildren(el, state) || 'void 0';\n  } else if (el.tag === 'slot') {\n    return genSlot(el, state);\n  } else {\n    // component or element\n    var code;\n    if (el.component) {\n      code = genComponent(el.component, el, state);\n    } else {\n      var data = el.plain ? undefined : genData$2(el, state);\n\n      var children = el.inlineTemplate ? null : genChildren(el, state, true);\n      code = \"_c('\" + el.tag + \"'\" + (data ? \",\" + data : '') + (children ? \",\" + children : '') + \")\";\n    }\n    // module transforms\n    for (var i = 0; i < state.transforms.length; i++) {\n      code = state.transforms[i](el, code);\n    }\n    return code;\n  }\n}\n\n// hoist static sub-trees out\nfunction genStatic(el, state) {\n  el.staticProcessed = true;\n  state.staticRenderFns.push(\"with(this){return \" + genElement(el, state) + \"}\");\n  return \"_m(\" + (state.staticRenderFns.length - 1) + (el.staticInFor ? ',true' : '') + \")\";\n}\n\n// v-once\nfunction genOnce(el, state) {\n  el.onceProcessed = true;\n  if (el.if && !el.ifProcessed) {\n    return genIf(el, state);\n  } else if (el.staticInFor) {\n    var key = '';\n    var parent = el.parent;\n    while (parent) {\n      if (parent.for) {\n        key = parent.key;\n        break;\n      }\n      parent = parent.parent;\n    }\n    if (!key) {\n      process.env.NODE_ENV !== 'production' && state.warn(\"v-once can only be used inside v-for that is keyed. \");\n      return genElement(el, state);\n    }\n    return \"_o(\" + genElement(el, state) + \",\" + state.onceId++ + \",\" + key + \")\";\n  } else {\n    return genStatic(el, state);\n  }\n}\n\nfunction genIf(el, state, altGen, altEmpty) {\n  el.ifProcessed = true; // avoid recursion\n  return genIfConditions(el.ifConditions.slice(), state, altGen, altEmpty);\n}\n\nfunction genIfConditions(conditions, state, altGen, altEmpty) {\n  if (!conditions.length) {\n    return altEmpty || '_e()';\n  }\n\n  var condition = conditions.shift();\n  if (condition.exp) {\n    return \"(\" + condition.exp + \")?\" + genTernaryExp(condition.block) + \":\" + genIfConditions(conditions, state, altGen, altEmpty);\n  } else {\n    return \"\" + genTernaryExp(condition.block);\n  }\n\n  // v-if with v-once should generate code like (a)?_m(0):_m(1)\n  function genTernaryExp(el) {\n    return altGen ? altGen(el, state) : el.once ? genOnce(el, state) : genElement(el, state);\n  }\n}\n\nfunction genFor(el, state, altGen, altHelper) {\n  var exp = el.for;\n  var alias = el.alias;\n  var iterator1 = el.iterator1 ? \",\" + el.iterator1 : '';\n  var iterator2 = el.iterator2 ? \",\" + el.iterator2 : '';\n\n  if (process.env.NODE_ENV !== 'production' && state.maybeComponent(el) && el.tag !== 'slot' && el.tag !== 'template' && !el.key) {\n    state.warn(\"<\" + el.tag + \" v-for=\\\"\" + alias + \" in \" + exp + \"\\\">: component lists rendered with \" + \"v-for should have explicit keys. \" + \"See https://vuejs.org/guide/list.html#key for more info.\", true /* tip */\n    );\n  }\n\n  el.forProcessed = true; // avoid recursion\n  return (altHelper || '_l') + \"((\" + exp + \"),\" + \"function(\" + alias + iterator1 + iterator2 + \"){\" + \"return \" + (altGen || genElement)(el, state) + '})';\n}\n\nfunction genData$2(el, state) {\n  var data = '{';\n\n  // directives first.\n  // directives may mutate the el's other properties before they are generated.\n  var dirs = genDirectives(el, state);\n  if (dirs) {\n    data += dirs + ',';\n  }\n\n  // key\n  if (el.key) {\n    data += \"key:\" + el.key + \",\";\n  }\n  // ref\n  if (el.ref) {\n    data += \"ref:\" + el.ref + \",\";\n  }\n  if (el.refInFor) {\n    data += \"refInFor:true,\";\n  }\n  // pre\n  if (el.pre) {\n    data += \"pre:true,\";\n  }\n  // record original tag name for components using \"is\" attribute\n  if (el.component) {\n    data += \"tag:\\\"\" + el.tag + \"\\\",\";\n  }\n  // module data generation functions\n  for (var i = 0; i < state.dataGenFns.length; i++) {\n    data += state.dataGenFns[i](el);\n  }\n  // attributes\n  if (el.attrs) {\n    data += \"attrs:{\" + genProps(el.attrs) + \"},\";\n  }\n  // DOM props\n  if (el.props) {\n    data += \"domProps:{\" + genProps(el.props) + \"},\";\n  }\n  // event handlers\n  if (el.events) {\n    data += genHandlers(el.events, false, state.warn) + \",\";\n  }\n  if (el.nativeEvents) {\n    data += genHandlers(el.nativeEvents, true, state.warn) + \",\";\n  }\n  // slot target\n  // only for non-scoped slots\n  if (el.slotTarget && !el.slotScope) {\n    data += \"slot:\" + el.slotTarget + \",\";\n  }\n  // scoped slots\n  if (el.scopedSlots) {\n    data += genScopedSlots(el.scopedSlots, state) + \",\";\n  }\n  // component v-model\n  if (el.model) {\n    data += \"model:{value:\" + el.model.value + \",callback:\" + el.model.callback + \",expression:\" + el.model.expression + \"},\";\n  }\n  // inline-template\n  if (el.inlineTemplate) {\n    var inlineTemplate = genInlineTemplate(el, state);\n    if (inlineTemplate) {\n      data += inlineTemplate + \",\";\n    }\n  }\n  data = data.replace(/,$/, '') + '}';\n  // v-bind data wrap\n  if (el.wrapData) {\n    data = el.wrapData(data);\n  }\n  // v-on data wrap\n  if (el.wrapListeners) {\n    data = el.wrapListeners(data);\n  }\n  return data;\n}\n\nfunction genDirectives(el, state) {\n  var dirs = el.directives;\n  if (!dirs) {\n    return;\n  }\n  var res = 'directives:[';\n  var hasRuntime = false;\n  var i, l, dir, needRuntime;\n  for (i = 0, l = dirs.length; i < l; i++) {\n    dir = dirs[i];\n    needRuntime = true;\n    var gen = state.directives[dir.name];\n    if (gen) {\n      // compile-time directive that manipulates AST.\n      // returns true if it also needs a runtime counterpart.\n      needRuntime = !!gen(el, dir, state.warn);\n    }\n    if (needRuntime) {\n      hasRuntime = true;\n      res += \"{name:\\\"\" + dir.name + \"\\\",rawName:\\\"\" + dir.rawName + \"\\\"\" + (dir.value ? \",value:(\" + dir.value + \"),expression:\" + JSON.stringify(dir.value) : '') + (dir.arg ? \",arg:\\\"\" + dir.arg + \"\\\"\" : '') + (dir.modifiers ? \",modifiers:\" + JSON.stringify(dir.modifiers) : '') + \"},\";\n    }\n  }\n  if (hasRuntime) {\n    return res.slice(0, -1) + ']';\n  }\n}\n\nfunction genInlineTemplate(el, state) {\n  var ast = el.children[0];\n  if (process.env.NODE_ENV !== 'production' && (el.children.length !== 1 || ast.type !== 1)) {\n    state.warn('Inline-template components must have exactly one child element.');\n  }\n  if (ast.type === 1) {\n    var inlineRenderFns = generate(ast, state.options);\n    return \"inlineTemplate:{render:function(){\" + inlineRenderFns.render + \"},staticRenderFns:[\" + inlineRenderFns.staticRenderFns.map(function (code) {\n      return \"function(){\" + code + \"}\";\n    }).join(',') + \"]}\";\n  }\n}\n\nfunction genScopedSlots(slots, state) {\n  return \"scopedSlots:_u([\" + Object.keys(slots).map(function (key) {\n    return genScopedSlot(key, slots[key], state);\n  }).join(',') + \"])\";\n}\n\nfunction genScopedSlot(key, el, state) {\n  if (el.for && !el.forProcessed) {\n    return genForScopedSlot(key, el, state);\n  }\n  var fn = \"function(\" + String(el.slotScope) + \"){\" + \"return \" + (el.tag === 'template' ? el.if ? el.if + \"?\" + (genChildren(el, state) || 'undefined') + \":undefined\" : genChildren(el, state) || 'undefined' : genElement(el, state)) + \"}\";\n  return \"{key:\" + key + \",fn:\" + fn + \"}\";\n}\n\nfunction genForScopedSlot(key, el, state) {\n  var exp = el.for;\n  var alias = el.alias;\n  var iterator1 = el.iterator1 ? \",\" + el.iterator1 : '';\n  var iterator2 = el.iterator2 ? \",\" + el.iterator2 : '';\n  el.forProcessed = true; // avoid recursion\n  return \"_l((\" + exp + \"),\" + \"function(\" + alias + iterator1 + iterator2 + \"){\" + \"return \" + genScopedSlot(key, el, state) + '})';\n}\n\nfunction genChildren(el, state, checkSkip, altGenElement, altGenNode) {\n  var children = el.children;\n  if (children.length) {\n    var el$1 = children[0];\n    // optimize single v-for\n    if (children.length === 1 && el$1.for && el$1.tag !== 'template' && el$1.tag !== 'slot') {\n      return (altGenElement || genElement)(el$1, state);\n    }\n    var normalizationType = checkSkip ? getNormalizationType(children, state.maybeComponent) : 0;\n    var gen = altGenNode || genNode;\n    return \"[\" + children.map(function (c) {\n      return gen(c, state);\n    }).join(',') + \"]\" + (normalizationType ? \",\" + normalizationType : '');\n  }\n}\n\n// determine the normalization needed for the children array.\n// 0: no normalization needed\n// 1: simple normalization needed (possible 1-level deep nested array)\n// 2: full normalization needed\nfunction getNormalizationType(children, maybeComponent) {\n  var res = 0;\n  for (var i = 0; i < children.length; i++) {\n    var el = children[i];\n    if (el.type !== 1) {\n      continue;\n    }\n    if (needsNormalization(el) || el.ifConditions && el.ifConditions.some(function (c) {\n      return needsNormalization(c.block);\n    })) {\n      res = 2;\n      break;\n    }\n    if (maybeComponent(el) || el.ifConditions && el.ifConditions.some(function (c) {\n      return maybeComponent(c.block);\n    })) {\n      res = 1;\n    }\n  }\n  return res;\n}\n\nfunction needsNormalization(el) {\n  return el.for !== undefined || el.tag === 'template' || el.tag === 'slot';\n}\n\nfunction genNode(node, state) {\n  if (node.type === 1) {\n    return genElement(node, state);\n  }if (node.type === 3 && node.isComment) {\n    return genComment(node);\n  } else {\n    return genText(node);\n  }\n}\n\nfunction genText(text) {\n  return \"_v(\" + (text.type === 2 ? text.expression // no need for () because already wrapped in _s()\n  : transformSpecialNewlines(JSON.stringify(text.text))) + \")\";\n}\n\nfunction genComment(comment) {\n  return \"_e(\" + JSON.stringify(comment.text) + \")\";\n}\n\nfunction genSlot(el, state) {\n  var slotName = el.slotName || '\"default\"';\n  var children = genChildren(el, state);\n  var res = \"_t(\" + slotName + (children ? \",\" + children : '');\n  var attrs = el.attrs && \"{\" + el.attrs.map(function (a) {\n    return camelize(a.name) + \":\" + a.value;\n  }).join(',') + \"}\";\n  var bind$$1 = el.attrsMap['v-bind'];\n  if ((attrs || bind$$1) && !children) {\n    res += \",null\";\n  }\n  if (attrs) {\n    res += \",\" + attrs;\n  }\n  if (bind$$1) {\n    res += (attrs ? '' : ',null') + \",\" + bind$$1;\n  }\n  return res + ')';\n}\n\n// componentName is el.component, take it as argument to shun flow's pessimistic refinement\nfunction genComponent(componentName, el, state) {\n  var children = el.inlineTemplate ? null : genChildren(el, state, true);\n  return \"_c(\" + componentName + \",\" + genData$2(el, state) + (children ? \",\" + children : '') + \")\";\n}\n\nfunction genProps(props) {\n  var res = '';\n  for (var i = 0; i < props.length; i++) {\n    var prop = props[i];\n    res += \"\\\"\" + prop.name + \"\\\":\" + transformSpecialNewlines(prop.value) + \",\";\n  }\n  return res.slice(0, -1);\n}\n\n// #3895, #4268\nfunction transformSpecialNewlines(text) {\n  return text.replace(/\\u2028/g, '\\\\u2028').replace(/\\u2029/g, '\\\\u2029');\n}\n\n/*  */\n\n// these keywords should not appear inside expressions, but operators like\n// typeof, instanceof and in are allowed\nvar prohibitedKeywordRE = new RegExp('\\\\b' + ('do,if,for,let,new,try,var,case,else,with,await,break,catch,class,const,' + 'super,throw,while,yield,delete,export,import,return,switch,default,' + 'extends,finally,continue,debugger,function,arguments').split(',').join('\\\\b|\\\\b') + '\\\\b');\n\n// these unary operators should not be used as property/method names\nvar unaryOperatorsRE = new RegExp('\\\\b' + 'delete,typeof,void'.split(',').join('\\\\s*\\\\([^\\\\)]*\\\\)|\\\\b') + '\\\\s*\\\\([^\\\\)]*\\\\)');\n\n// strip strings in expressions\nvar stripStringRE = /'(?:[^'\\\\]|\\\\.)*'|\"(?:[^\"\\\\]|\\\\.)*\"|`(?:[^`\\\\]|\\\\.)*\\$\\{|\\}(?:[^`\\\\]|\\\\.)*`|`(?:[^`\\\\]|\\\\.)*`/g;\n\n// detect problematic expressions in a template\nfunction detectErrors(ast) {\n  var errors = [];\n  if (ast) {\n    checkNode(ast, errors);\n  }\n  return errors;\n}\n\nfunction checkNode(node, errors) {\n  if (node.type === 1) {\n    for (var name in node.attrsMap) {\n      if (dirRE.test(name)) {\n        var value = node.attrsMap[name];\n        if (value) {\n          if (name === 'v-for') {\n            checkFor(node, \"v-for=\\\"\" + value + \"\\\"\", errors);\n          } else if (onRE.test(name)) {\n            checkEvent(value, name + \"=\\\"\" + value + \"\\\"\", errors);\n          } else {\n            checkExpression(value, name + \"=\\\"\" + value + \"\\\"\", errors);\n          }\n        }\n      }\n    }\n    if (node.children) {\n      for (var i = 0; i < node.children.length; i++) {\n        checkNode(node.children[i], errors);\n      }\n    }\n  } else if (node.type === 2) {\n    checkExpression(node.expression, node.text, errors);\n  }\n}\n\nfunction checkEvent(exp, text, errors) {\n  var stipped = exp.replace(stripStringRE, '');\n  var keywordMatch = stipped.match(unaryOperatorsRE);\n  if (keywordMatch && stipped.charAt(keywordMatch.index - 1) !== '$') {\n    errors.push(\"avoid using JavaScript unary operator as property name: \" + \"\\\"\" + keywordMatch[0] + \"\\\" in expression \" + text.trim());\n  }\n  checkExpression(exp, text, errors);\n}\n\nfunction checkFor(node, text, errors) {\n  checkExpression(node.for || '', text, errors);\n  checkIdentifier(node.alias, 'v-for alias', text, errors);\n  checkIdentifier(node.iterator1, 'v-for iterator', text, errors);\n  checkIdentifier(node.iterator2, 'v-for iterator', text, errors);\n}\n\nfunction checkIdentifier(ident, type, text, errors) {\n  if (typeof ident === 'string') {\n    try {\n      new Function(\"var \" + ident + \"=_\");\n    } catch (e) {\n      errors.push(\"invalid \" + type + \" \\\"\" + ident + \"\\\" in expression: \" + text.trim());\n    }\n  }\n}\n\nfunction checkExpression(exp, text, errors) {\n  try {\n    new Function(\"return \" + exp);\n  } catch (e) {\n    var keywordMatch = exp.replace(stripStringRE, '').match(prohibitedKeywordRE);\n    if (keywordMatch) {\n      errors.push(\"avoid using JavaScript keyword as property name: \" + \"\\\"\" + keywordMatch[0] + \"\\\"\\n  Raw expression: \" + text.trim());\n    } else {\n      errors.push(\"invalid expression: \" + e.message + \" in\\n\\n\" + \"    \" + exp + \"\\n\\n\" + \"  Raw expression: \" + text.trim() + \"\\n\");\n    }\n  }\n}\n\n/*  */\n\nfunction createFunction(code, errors) {\n  try {\n    return new Function(code);\n  } catch (err) {\n    errors.push({ err: err, code: code });\n    return noop;\n  }\n}\n\nfunction createCompileToFunctionFn(compile) {\n  var cache = Object.create(null);\n\n  return function compileToFunctions(template, options, vm) {\n    options = extend({}, options);\n    var warn$$1 = options.warn || warn;\n    delete options.warn;\n\n    /* istanbul ignore if */\n    if (process.env.NODE_ENV !== 'production') {\n      // detect possible CSP restriction\n      try {\n        new Function('return 1');\n      } catch (e) {\n        if (e.toString().match(/unsafe-eval|CSP/)) {\n          warn$$1('It seems you are using the standalone build of Vue.js in an ' + 'environment with Content Security Policy that prohibits unsafe-eval. ' + 'The template compiler cannot work in this environment. Consider ' + 'relaxing the policy to allow unsafe-eval or pre-compiling your ' + 'templates into render functions.');\n        }\n      }\n    }\n\n    // check cache\n    var key = options.delimiters ? String(options.delimiters) + template : template;\n    if (cache[key]) {\n      return cache[key];\n    }\n\n    // compile\n    var compiled = compile(template, options);\n\n    // check compilation errors/tips\n    if (process.env.NODE_ENV !== 'production') {\n      if (compiled.errors && compiled.errors.length) {\n        warn$$1(\"Error compiling template:\\n\\n\" + template + \"\\n\\n\" + compiled.errors.map(function (e) {\n          return \"- \" + e;\n        }).join('\\n') + '\\n', vm);\n      }\n      if (compiled.tips && compiled.tips.length) {\n        compiled.tips.forEach(function (msg) {\n          return tip(msg, vm);\n        });\n      }\n    }\n\n    // turn code into functions\n    var res = {};\n    var fnGenErrors = [];\n    res.render = createFunction(compiled.render, fnGenErrors);\n    res.staticRenderFns = compiled.staticRenderFns.map(function (code) {\n      return createFunction(code, fnGenErrors);\n    });\n\n    // check function generation errors.\n    // this should only happen if there is a bug in the compiler itself.\n    // mostly for codegen development use\n    /* istanbul ignore if */\n    if (process.env.NODE_ENV !== 'production') {\n      if ((!compiled.errors || !compiled.errors.length) && fnGenErrors.length) {\n        warn$$1(\"Failed to generate render function:\\n\\n\" + fnGenErrors.map(function (ref) {\n          var err = ref.err;\n          var code = ref.code;\n\n          return err.toString() + \" in\\n\\n\" + code + \"\\n\";\n        }).join('\\n'), vm);\n      }\n    }\n\n    return cache[key] = res;\n  };\n}\n\n/*  */\n\nfunction createCompilerCreator(baseCompile) {\n  return function createCompiler(baseOptions) {\n    function compile(template, options) {\n      var finalOptions = Object.create(baseOptions);\n      var errors = [];\n      var tips = [];\n      finalOptions.warn = function (msg, tip) {\n        (tip ? tips : errors).push(msg);\n      };\n\n      if (options) {\n        // merge custom modules\n        if (options.modules) {\n          finalOptions.modules = (baseOptions.modules || []).concat(options.modules);\n        }\n        // merge custom directives\n        if (options.directives) {\n          finalOptions.directives = extend(Object.create(baseOptions.directives || null), options.directives);\n        }\n        // copy other options\n        for (var key in options) {\n          if (key !== 'modules' && key !== 'directives') {\n            finalOptions[key] = options[key];\n          }\n        }\n      }\n\n      var compiled = baseCompile(template, finalOptions);\n      if (process.env.NODE_ENV !== 'production') {\n        errors.push.apply(errors, detectErrors(compiled.ast));\n      }\n      compiled.errors = errors;\n      compiled.tips = tips;\n      return compiled;\n    }\n\n    return {\n      compile: compile,\n      compileToFunctions: createCompileToFunctionFn(compile)\n    };\n  };\n}\n\n/*  */\n\n// `createCompilerCreator` allows creating compilers that use alternative\n// parser/optimizer/codegen, e.g the SSR optimizing compiler.\n// Here we just export a default compiler using the default parts.\nvar createCompiler = createCompilerCreator(function baseCompile(template, options) {\n  var ast = parse(template.trim(), options);\n  optimize(ast, options);\n  var code = generate(ast, options);\n  return {\n    ast: ast,\n    render: code.render,\n    staticRenderFns: code.staticRenderFns\n  };\n});\n\n/*  */\n\nvar ref$1 = createCompiler(baseOptions);\nvar compileToFunctions = ref$1.compileToFunctions;\n\n/*  */\n\n// check whether current browser encodes a char inside attribute values\nvar div;\nfunction getShouldDecode(href) {\n  div = div || document.createElement('div');\n  div.innerHTML = href ? \"<a href=\\\"\\n\\\"/>\" : \"<div a=\\\"\\n\\\"/>\";\n  return div.innerHTML.indexOf('&#10;') > 0;\n}\n\n// #3663: IE encodes newlines inside attribute values while other browsers don't\nvar shouldDecodeNewlines = inBrowser ? getShouldDecode(false) : false;\n// #6828: chrome encodes content in a[href]\nvar shouldDecodeNewlinesForHref = inBrowser ? getShouldDecode(true) : false;\n\n/*  */\n\nvar idToTemplate = cached(function (id) {\n  var el = query(id);\n  return el && el.innerHTML;\n});\n\nvar mount = Vue$3.prototype.$mount;\nVue$3.prototype.$mount = function (el, hydrating) {\n  el = el && query(el);\n\n  /* istanbul ignore if */\n  if (el === document.body || el === document.documentElement) {\n    process.env.NODE_ENV !== 'production' && warn(\"Do not mount Vue to <html> or <body> - mount to normal elements instead.\");\n    return this;\n  }\n\n  var options = this.$options;\n  // resolve template/el and convert to render function\n  if (!options.render) {\n    var template = options.template;\n    if (template) {\n      if (typeof template === 'string') {\n        if (template.charAt(0) === '#') {\n          template = idToTemplate(template);\n          /* istanbul ignore if */\n          if (process.env.NODE_ENV !== 'production' && !template) {\n            warn(\"Template element not found or is empty: \" + options.template, this);\n          }\n        }\n      } else if (template.nodeType) {\n        template = template.innerHTML;\n      } else {\n        if (process.env.NODE_ENV !== 'production') {\n          warn('invalid template option:' + template, this);\n        }\n        return this;\n      }\n    } else if (el) {\n      template = getOuterHTML(el);\n    }\n    if (template) {\n      /* istanbul ignore if */\n      if (process.env.NODE_ENV !== 'production' && config.performance && mark) {\n        mark('compile');\n      }\n\n      var ref = compileToFunctions(template, {\n        shouldDecodeNewlines: shouldDecodeNewlines,\n        shouldDecodeNewlinesForHref: shouldDecodeNewlinesForHref,\n        delimiters: options.delimiters,\n        comments: options.comments\n      }, this);\n      var render = ref.render;\n      var staticRenderFns = ref.staticRenderFns;\n      options.render = render;\n      options.staticRenderFns = staticRenderFns;\n\n      /* istanbul ignore if */\n      if (process.env.NODE_ENV !== 'production' && config.performance && mark) {\n        mark('compile end');\n        measure(\"vue \" + this._name + \" compile\", 'compile', 'compile end');\n      }\n    }\n  }\n  return mount.call(this, el, hydrating);\n};\n\n/**\n * Get outerHTML of elements, taking care\n * of SVG elements in IE as well.\n */\nfunction getOuterHTML(el) {\n  if (el.outerHTML) {\n    return el.outerHTML;\n  } else {\n    var container = document.createElement('div');\n    container.appendChild(el.cloneNode(true));\n    return container.innerHTML;\n  }\n}\n\nVue$3.compile = compileToFunctions;\n\nmodule.exports = Vue$3;\n/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(43), __webpack_require__(66), __webpack_require__(392).setImmediate))\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L192dWVAMi41LjExQHZ1ZS9kaXN0L3Z1ZS5jb21tb24uanM/NGVhOSJdLCJuYW1lcyI6WyJlbXB0eU9iamVjdCIsIk9iamVjdCIsImZyZWV6ZSIsImlzVW5kZWYiLCJ2IiwidW5kZWZpbmVkIiwiaXNEZWYiLCJpc1RydWUiLCJpc0ZhbHNlIiwiaXNQcmltaXRpdmUiLCJ2YWx1ZSIsImlzT2JqZWN0Iiwib2JqIiwiX3RvU3RyaW5nIiwicHJvdG90eXBlIiwidG9TdHJpbmciLCJ0b1Jhd1R5cGUiLCJjYWxsIiwic2xpY2UiLCJpc1BsYWluT2JqZWN0IiwiaXNSZWdFeHAiLCJpc1ZhbGlkQXJyYXlJbmRleCIsInZhbCIsIm4iLCJwYXJzZUZsb2F0IiwiU3RyaW5nIiwiTWF0aCIsImZsb29yIiwiaXNGaW5pdGUiLCJKU09OIiwic3RyaW5naWZ5IiwidG9OdW1iZXIiLCJpc05hTiIsIm1ha2VNYXAiLCJzdHIiLCJleHBlY3RzTG93ZXJDYXNlIiwibWFwIiwiY3JlYXRlIiwibGlzdCIsInNwbGl0IiwiaSIsImxlbmd0aCIsInRvTG93ZXJDYXNlIiwiaXNCdWlsdEluVGFnIiwiaXNSZXNlcnZlZEF0dHJpYnV0ZSIsInJlbW92ZSIsImFyciIsIml0ZW0iLCJpbmRleCIsImluZGV4T2YiLCJzcGxpY2UiLCJoYXNPd25Qcm9wZXJ0eSIsImhhc093biIsImtleSIsImNhY2hlZCIsImZuIiwiY2FjaGUiLCJjYWNoZWRGbiIsImhpdCIsImNhbWVsaXplUkUiLCJjYW1lbGl6ZSIsInJlcGxhY2UiLCJfIiwiYyIsInRvVXBwZXJDYXNlIiwiY2FwaXRhbGl6ZSIsImNoYXJBdCIsImh5cGhlbmF0ZVJFIiwiaHlwaGVuYXRlIiwiYmluZCIsImN0eCIsImJvdW5kRm4iLCJhIiwibCIsImFyZ3VtZW50cyIsImFwcGx5IiwiX2xlbmd0aCIsInRvQXJyYXkiLCJzdGFydCIsInJldCIsIkFycmF5IiwiZXh0ZW5kIiwidG8iLCJfZnJvbSIsInRvT2JqZWN0IiwicmVzIiwibm9vcCIsImIiLCJubyIsImlkZW50aXR5IiwiZ2VuU3RhdGljS2V5cyIsIm1vZHVsZXMiLCJyZWR1Y2UiLCJrZXlzIiwibSIsImNvbmNhdCIsInN0YXRpY0tleXMiLCJqb2luIiwibG9vc2VFcXVhbCIsImlzT2JqZWN0QSIsImlzT2JqZWN0QiIsImlzQXJyYXlBIiwiaXNBcnJheSIsImlzQXJyYXlCIiwiZXZlcnkiLCJlIiwia2V5c0EiLCJrZXlzQiIsImxvb3NlSW5kZXhPZiIsIm9uY2UiLCJjYWxsZWQiLCJTU1JfQVRUUiIsIkFTU0VUX1RZUEVTIiwiTElGRUNZQ0xFX0hPT0tTIiwiY29uZmlnIiwib3B0aW9uTWVyZ2VTdHJhdGVnaWVzIiwic2lsZW50IiwicHJvZHVjdGlvblRpcCIsInByb2Nlc3MiLCJlbnYiLCJOT0RFX0VOViIsImRldnRvb2xzIiwicGVyZm9ybWFuY2UiLCJlcnJvckhhbmRsZXIiLCJ3YXJuSGFuZGxlciIsImlnbm9yZWRFbGVtZW50cyIsImtleUNvZGVzIiwiaXNSZXNlcnZlZFRhZyIsImlzUmVzZXJ2ZWRBdHRyIiwiaXNVbmtub3duRWxlbWVudCIsImdldFRhZ05hbWVzcGFjZSIsInBhcnNlUGxhdGZvcm1UYWdOYW1lIiwibXVzdFVzZVByb3AiLCJfbGlmZWN5Y2xlSG9va3MiLCJpc1Jlc2VydmVkIiwiY2hhckNvZGVBdCIsImRlZiIsImVudW1lcmFibGUiLCJkZWZpbmVQcm9wZXJ0eSIsIndyaXRhYmxlIiwiY29uZmlndXJhYmxlIiwiYmFpbFJFIiwicGFyc2VQYXRoIiwicGF0aCIsInRlc3QiLCJzZWdtZW50cyIsImhhc1Byb3RvIiwiaW5Ccm93c2VyIiwid2luZG93IiwiaW5XZWV4IiwiV1hFbnZpcm9ubWVudCIsInBsYXRmb3JtIiwid2VleFBsYXRmb3JtIiwiVUEiLCJuYXZpZ2F0b3IiLCJ1c2VyQWdlbnQiLCJpc0lFIiwiaXNJRTkiLCJpc0VkZ2UiLCJpc0FuZHJvaWQiLCJpc0lPUyIsImlzQ2hyb21lIiwibmF0aXZlV2F0Y2giLCJ3YXRjaCIsInN1cHBvcnRzUGFzc2l2ZSIsIm9wdHMiLCJnZXQiLCJhZGRFdmVudExpc3RlbmVyIiwiX2lzU2VydmVyIiwiaXNTZXJ2ZXJSZW5kZXJpbmciLCJnbG9iYWwiLCJWVUVfRU5WIiwiX19WVUVfREVWVE9PTFNfR0xPQkFMX0hPT0tfXyIsImlzTmF0aXZlIiwiQ3RvciIsImhhc1N5bWJvbCIsIlN5bWJvbCIsIlJlZmxlY3QiLCJvd25LZXlzIiwiX1NldCIsIlNldCIsInNldCIsImhhcyIsImFkZCIsImNsZWFyIiwid2FybiIsInRpcCIsImdlbmVyYXRlQ29tcG9uZW50VHJhY2UiLCJmb3JtYXRDb21wb25lbnROYW1lIiwiaGFzQ29uc29sZSIsImNvbnNvbGUiLCJjbGFzc2lmeVJFIiwiY2xhc3NpZnkiLCJtc2ciLCJ2bSIsInRyYWNlIiwiZXJyb3IiLCJpbmNsdWRlRmlsZSIsIiRyb290Iiwib3B0aW9ucyIsImNpZCIsIl9pc1Z1ZSIsIiRvcHRpb25zIiwiY29uc3RydWN0b3IiLCJuYW1lIiwiX2NvbXBvbmVudFRhZyIsImZpbGUiLCJfX2ZpbGUiLCJtYXRjaCIsInJlcGVhdCIsIiRwYXJlbnQiLCJ0cmVlIiwiY3VycmVudFJlY3Vyc2l2ZVNlcXVlbmNlIiwibGFzdCIsInB1c2giLCJ1aWQiLCJEZXAiLCJpZCIsInN1YnMiLCJhZGRTdWIiLCJzdWIiLCJyZW1vdmVTdWIiLCJkZXBlbmQiLCJ0YXJnZXQiLCJhZGREZXAiLCJub3RpZnkiLCJ1cGRhdGUiLCJ0YXJnZXRTdGFjayIsInB1c2hUYXJnZXQiLCJfdGFyZ2V0IiwicG9wVGFyZ2V0IiwicG9wIiwiVk5vZGUiLCJ0YWciLCJkYXRhIiwiY2hpbGRyZW4iLCJ0ZXh0IiwiZWxtIiwiY29udGV4dCIsImNvbXBvbmVudE9wdGlvbnMiLCJhc3luY0ZhY3RvcnkiLCJucyIsImZuQ29udGV4dCIsImZuT3B0aW9ucyIsImZuU2NvcGVJZCIsImNvbXBvbmVudEluc3RhbmNlIiwicGFyZW50IiwicmF3IiwiaXNTdGF0aWMiLCJpc1Jvb3RJbnNlcnQiLCJpc0NvbW1lbnQiLCJpc0Nsb25lZCIsImlzT25jZSIsImFzeW5jTWV0YSIsImlzQXN5bmNQbGFjZWhvbGRlciIsInByb3RvdHlwZUFjY2Vzc29ycyIsImNoaWxkIiwiZGVmaW5lUHJvcGVydGllcyIsImNyZWF0ZUVtcHR5Vk5vZGUiLCJub2RlIiwiY3JlYXRlVGV4dFZOb2RlIiwiY2xvbmVWTm9kZSIsInZub2RlIiwiZGVlcCIsImNsb25lZCIsImNsb25lVk5vZGVzIiwidm5vZGVzIiwibGVuIiwiYXJyYXlQcm90byIsImFycmF5TWV0aG9kcyIsImZvckVhY2giLCJtZXRob2QiLCJvcmlnaW5hbCIsIm11dGF0b3IiLCJhcmdzIiwicmVzdWx0Iiwib2IiLCJfX29iX18iLCJpbnNlcnRlZCIsIm9ic2VydmVBcnJheSIsImRlcCIsImFycmF5S2V5cyIsImdldE93blByb3BlcnR5TmFtZXMiLCJvYnNlcnZlclN0YXRlIiwic2hvdWxkQ29udmVydCIsIk9ic2VydmVyIiwidm1Db3VudCIsImF1Z21lbnQiLCJwcm90b0F1Z21lbnQiLCJjb3B5QXVnbWVudCIsIndhbGsiLCJkZWZpbmVSZWFjdGl2ZSIsIml0ZW1zIiwib2JzZXJ2ZSIsInNyYyIsIl9fcHJvdG9fXyIsImFzUm9vdERhdGEiLCJpc0V4dGVuc2libGUiLCJjdXN0b21TZXR0ZXIiLCJzaGFsbG93IiwicHJvcGVydHkiLCJnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IiLCJnZXR0ZXIiLCJzZXR0ZXIiLCJjaGlsZE9iIiwicmVhY3RpdmVHZXR0ZXIiLCJkZXBlbmRBcnJheSIsInJlYWN0aXZlU2V0dGVyIiwibmV3VmFsIiwibWF4IiwiZGVsIiwic3RyYXRzIiwiZWwiLCJwcm9wc0RhdGEiLCJkZWZhdWx0U3RyYXQiLCJtZXJnZURhdGEiLCJmcm9tIiwidG9WYWwiLCJmcm9tVmFsIiwibWVyZ2VEYXRhT3JGbiIsInBhcmVudFZhbCIsImNoaWxkVmFsIiwibWVyZ2VkRGF0YUZuIiwibWVyZ2VkSW5zdGFuY2VEYXRhRm4iLCJpbnN0YW5jZURhdGEiLCJkZWZhdWx0RGF0YSIsIm1lcmdlSG9vayIsImhvb2siLCJtZXJnZUFzc2V0cyIsImFzc2VydE9iamVjdFR5cGUiLCJ0eXBlIiwia2V5JDEiLCJwcm9wcyIsIm1ldGhvZHMiLCJpbmplY3QiLCJjb21wdXRlZCIsInByb3ZpZGUiLCJjaGVja0NvbXBvbmVudHMiLCJjb21wb25lbnRzIiwidmFsaWRhdGVDb21wb25lbnROYW1lIiwibm9ybWFsaXplUHJvcHMiLCJ2YWxpZGF0ZVByb3BPYmplY3QiLCJwcm9wT3B0aW9uc1JFIiwicHJvcE5hbWUiLCJwcm9wIiwibm9ybWFsaXplSW5qZWN0Iiwibm9ybWFsaXplZCIsIm5vcm1hbGl6ZURpcmVjdGl2ZXMiLCJkaXJzIiwiZGlyZWN0aXZlcyIsIm1lcmdlT3B0aW9ucyIsImV4dGVuZHNGcm9tIiwiZXh0ZW5kcyIsIm1peGlucyIsIm1lcmdlRmllbGQiLCJzdHJhdCIsInJlc29sdmVBc3NldCIsIndhcm5NaXNzaW5nIiwiYXNzZXRzIiwiY2FtZWxpemVkSWQiLCJQYXNjYWxDYXNlSWQiLCJ2YWxpZGF0ZVByb3AiLCJwcm9wT3B0aW9ucyIsImFic2VudCIsImlzVHlwZSIsIkJvb2xlYW4iLCJnZXRQcm9wRGVmYXVsdFZhbHVlIiwicHJldlNob3VsZENvbnZlcnQiLCJhc3NlcnRQcm9wIiwiZGVmYXVsdCIsIl9wcm9wcyIsImdldFR5cGUiLCJyZXF1aXJlZCIsInZhbGlkIiwiZXhwZWN0ZWRUeXBlcyIsImFzc2VydGVkVHlwZSIsImFzc2VydFR5cGUiLCJleHBlY3RlZFR5cGUiLCJ2YWxpZGF0b3IiLCJzaW1wbGVDaGVja1JFIiwidCIsImhhbmRsZUVycm9yIiwiZXJyIiwiaW5mbyIsImN1ciIsImhvb2tzIiwiZXJyb3JDYXB0dXJlZCIsImNhcHR1cmUiLCJnbG9iYWxIYW5kbGVFcnJvciIsImxvZ0Vycm9yIiwiY2FsbGJhY2tzIiwicGVuZGluZyIsImZsdXNoQ2FsbGJhY2tzIiwiY29waWVzIiwibWljcm9UaW1lckZ1bmMiLCJtYWNyb1RpbWVyRnVuYyIsInVzZU1hY3JvVGFzayIsInNldEltbWVkaWF0ZSIsIk1lc3NhZ2VDaGFubmVsIiwiY2hhbm5lbCIsInBvcnQiLCJwb3J0MiIsInBvcnQxIiwib25tZXNzYWdlIiwicG9zdE1lc3NhZ2UiLCJzZXRUaW1lb3V0IiwiUHJvbWlzZSIsInAiLCJyZXNvbHZlIiwidGhlbiIsIndpdGhNYWNyb1Rhc2siLCJfd2l0aFRhc2siLCJuZXh0VGljayIsImNiIiwiX3Jlc29sdmUiLCJtYXJrIiwibWVhc3VyZSIsInBlcmYiLCJjbGVhck1hcmtzIiwiY2xlYXJNZWFzdXJlcyIsInN0YXJ0VGFnIiwiZW5kVGFnIiwiaW5pdFByb3h5IiwiYWxsb3dlZEdsb2JhbHMiLCJ3YXJuTm9uUHJlc2VudCIsImhhc1Byb3h5IiwiUHJveHkiLCJpc0J1aWx0SW5Nb2RpZmllciIsImhhc0hhbmRsZXIiLCJpc0FsbG93ZWQiLCJnZXRIYW5kbGVyIiwiaGFuZGxlcnMiLCJyZW5kZXIiLCJfd2l0aFN0cmlwcGVkIiwiX3JlbmRlclByb3h5Iiwic2Vlbk9iamVjdHMiLCJ0cmF2ZXJzZSIsIl90cmF2ZXJzZSIsInNlZW4iLCJpc0EiLCJpc0Zyb3plbiIsImRlcElkIiwibm9ybWFsaXplRXZlbnQiLCJwYXNzaXZlIiwib25jZSQkMSIsImNyZWF0ZUZuSW52b2tlciIsImZucyIsImludm9rZXIiLCJhcmd1bWVudHMkMSIsInVwZGF0ZUxpc3RlbmVycyIsIm9uIiwib2xkT24iLCJyZW1vdmUkJDEiLCJvbGQiLCJldmVudCIsIm1lcmdlVk5vZGVIb29rIiwiaG9va0tleSIsIm9sZEhvb2siLCJ3cmFwcGVkSG9vayIsIm1lcmdlZCIsImV4dHJhY3RQcm9wc0Zyb21WTm9kZURhdGEiLCJhdHRycyIsImFsdEtleSIsImtleUluTG93ZXJDYXNlIiwiY2hlY2tQcm9wIiwiaGFzaCIsInByZXNlcnZlIiwic2ltcGxlTm9ybWFsaXplQ2hpbGRyZW4iLCJub3JtYWxpemVDaGlsZHJlbiIsIm5vcm1hbGl6ZUFycmF5Q2hpbGRyZW4iLCJpc1RleHROb2RlIiwibmVzdGVkSW5kZXgiLCJsYXN0SW5kZXgiLCJzaGlmdCIsIl9pc1ZMaXN0IiwiZW5zdXJlQ3RvciIsImNvbXAiLCJiYXNlIiwiX19lc01vZHVsZSIsInRvU3RyaW5nVGFnIiwiY3JlYXRlQXN5bmNQbGFjZWhvbGRlciIsImZhY3RvcnkiLCJyZXNvbHZlQXN5bmNDb21wb25lbnQiLCJiYXNlQ3RvciIsImVycm9yQ29tcCIsInJlc29sdmVkIiwibG9hZGluZyIsImxvYWRpbmdDb21wIiwiY29udGV4dHMiLCJzeW5jIiwiZm9yY2VSZW5kZXIiLCIkZm9yY2VVcGRhdGUiLCJyZWplY3QiLCJyZWFzb24iLCJjb21wb25lbnQiLCJkZWxheSIsInRpbWVvdXQiLCJnZXRGaXJzdENvbXBvbmVudENoaWxkIiwiaW5pdEV2ZW50cyIsIl9ldmVudHMiLCJfaGFzSG9va0V2ZW50IiwibGlzdGVuZXJzIiwiX3BhcmVudExpc3RlbmVycyIsInVwZGF0ZUNvbXBvbmVudExpc3RlbmVycyIsIiRvbmNlIiwiJG9uIiwicmVtb3ZlJDEiLCIkb2ZmIiwib2xkTGlzdGVuZXJzIiwiZXZlbnRzTWl4aW4iLCJWdWUiLCJob29rUkUiLCJ0aGlzJDEiLCJjYnMiLCJpJDEiLCIkZW1pdCIsImxvd2VyQ2FzZUV2ZW50IiwicmVzb2x2ZVNsb3RzIiwic2xvdHMiLCJzbG90IiwibmFtZSQxIiwiaXNXaGl0ZXNwYWNlIiwicmVzb2x2ZVNjb3BlZFNsb3RzIiwiYWN0aXZlSW5zdGFuY2UiLCJpc1VwZGF0aW5nQ2hpbGRDb21wb25lbnQiLCJpbml0TGlmZWN5Y2xlIiwiYWJzdHJhY3QiLCIkY2hpbGRyZW4iLCIkcmVmcyIsIl93YXRjaGVyIiwiX2luYWN0aXZlIiwiX2RpcmVjdEluYWN0aXZlIiwiX2lzTW91bnRlZCIsIl9pc0Rlc3Ryb3llZCIsIl9pc0JlaW5nRGVzdHJveWVkIiwibGlmZWN5Y2xlTWl4aW4iLCJfdXBkYXRlIiwiaHlkcmF0aW5nIiwiY2FsbEhvb2siLCJwcmV2RWwiLCIkZWwiLCJwcmV2Vm5vZGUiLCJfdm5vZGUiLCJwcmV2QWN0aXZlSW5zdGFuY2UiLCJfX3BhdGNoX18iLCJfcGFyZW50RWxtIiwiX3JlZkVsbSIsIl9fdnVlX18iLCIkdm5vZGUiLCIkZGVzdHJveSIsInRlYXJkb3duIiwiX3dhdGNoZXJzIiwiX2RhdGEiLCJtb3VudENvbXBvbmVudCIsInRlbXBsYXRlIiwidXBkYXRlQ29tcG9uZW50IiwiX25hbWUiLCJfdWlkIiwiX3JlbmRlciIsIldhdGNoZXIiLCJ1cGRhdGVDaGlsZENvbXBvbmVudCIsInBhcmVudFZub2RlIiwicmVuZGVyQ2hpbGRyZW4iLCJoYXNDaGlsZHJlbiIsIl9yZW5kZXJDaGlsZHJlbiIsInNjb3BlZFNsb3RzIiwiJHNjb3BlZFNsb3RzIiwiX3BhcmVudFZub2RlIiwiJGF0dHJzIiwiJGxpc3RlbmVycyIsInByb3BLZXlzIiwiX3Byb3BLZXlzIiwiJHNsb3RzIiwiaXNJbkluYWN0aXZlVHJlZSIsImFjdGl2YXRlQ2hpbGRDb21wb25lbnQiLCJkaXJlY3QiLCJkZWFjdGl2YXRlQ2hpbGRDb21wb25lbnQiLCJqIiwiTUFYX1VQREFURV9DT1VOVCIsInF1ZXVlIiwiYWN0aXZhdGVkQ2hpbGRyZW4iLCJjaXJjdWxhciIsIndhaXRpbmciLCJmbHVzaGluZyIsInJlc2V0U2NoZWR1bGVyU3RhdGUiLCJmbHVzaFNjaGVkdWxlclF1ZXVlIiwid2F0Y2hlciIsInNvcnQiLCJydW4iLCJ1c2VyIiwiZXhwcmVzc2lvbiIsImFjdGl2YXRlZFF1ZXVlIiwidXBkYXRlZFF1ZXVlIiwiY2FsbEFjdGl2YXRlZEhvb2tzIiwiY2FsbFVwZGF0ZWRIb29rcyIsImVtaXQiLCJxdWV1ZUFjdGl2YXRlZENvbXBvbmVudCIsInF1ZXVlV2F0Y2hlciIsInVpZCQyIiwiZXhwT3JGbiIsImlzUmVuZGVyV2F0Y2hlciIsImxhenkiLCJhY3RpdmUiLCJkaXJ0eSIsImRlcHMiLCJuZXdEZXBzIiwiZGVwSWRzIiwibmV3RGVwSWRzIiwiY2xlYW51cERlcHMiLCJ0bXAiLCJvbGRWYWx1ZSIsImV2YWx1YXRlIiwic2hhcmVkUHJvcGVydHlEZWZpbml0aW9uIiwicHJveHkiLCJzb3VyY2VLZXkiLCJwcm94eUdldHRlciIsInByb3h5U2V0dGVyIiwiaW5pdFN0YXRlIiwiaW5pdFByb3BzIiwiaW5pdE1ldGhvZHMiLCJpbml0RGF0YSIsImluaXRDb21wdXRlZCIsImluaXRXYXRjaCIsInByb3BzT3B0aW9ucyIsImlzUm9vdCIsImxvb3AiLCJoeXBoZW5hdGVkS2V5IiwiZ2V0RGF0YSIsImNvbXB1dGVkV2F0Y2hlck9wdGlvbnMiLCJ3YXRjaGVycyIsIl9jb21wdXRlZFdhdGNoZXJzIiwiaXNTU1IiLCJ1c2VyRGVmIiwiZGVmaW5lQ29tcHV0ZWQiLCIkZGF0YSIsInNob3VsZENhY2hlIiwiY3JlYXRlQ29tcHV0ZWRHZXR0ZXIiLCJjb21wdXRlZEdldHRlciIsImhhbmRsZXIiLCJjcmVhdGVXYXRjaGVyIiwia2V5T3JGbiIsIiR3YXRjaCIsInN0YXRlTWl4aW4iLCJkYXRhRGVmIiwicHJvcHNEZWYiLCJuZXdEYXRhIiwiJHNldCIsIiRkZWxldGUiLCJpbW1lZGlhdGUiLCJ1bndhdGNoRm4iLCJpbml0UHJvdmlkZSIsIl9wcm92aWRlZCIsImluaXRJbmplY3Rpb25zIiwicmVzb2x2ZUluamVjdCIsImZpbHRlciIsInByb3ZpZGVLZXkiLCJzb3VyY2UiLCJwcm92aWRlRGVmYXVsdCIsInJlbmRlckxpc3QiLCJyZW5kZXJTbG90IiwiZmFsbGJhY2siLCJiaW5kT2JqZWN0Iiwic2NvcGVkU2xvdEZuIiwibm9kZXMiLCJzbG90Tm9kZXMiLCJfcmVuZGVyZWQiLCIkY3JlYXRlRWxlbWVudCIsInJlc29sdmVGaWx0ZXIiLCJjaGVja0tleUNvZGVzIiwiZXZlbnRLZXlDb2RlIiwiYnVpbHRJbkFsaWFzIiwiZXZlbnRLZXlOYW1lIiwiYmluZE9iamVjdFByb3BzIiwiYXNQcm9wIiwiaXNTeW5jIiwiZG9tUHJvcHMiLCIkZXZlbnQiLCJyZW5kZXJTdGF0aWMiLCJpc0luRm9yIiwiX3N0YXRpY1RyZWVzIiwic3RhdGljUmVuZGVyRm5zIiwibWFya1N0YXRpYyIsIm1hcmtPbmNlIiwibWFya1N0YXRpY05vZGUiLCJiaW5kT2JqZWN0TGlzdGVuZXJzIiwiZXhpc3RpbmciLCJvdXJzIiwiaW5zdGFsbFJlbmRlckhlbHBlcnMiLCJfbyIsIl9uIiwiX3MiLCJfbCIsIl90IiwiX3EiLCJfaSIsIl9tIiwiX2YiLCJfayIsIl9iIiwiX3YiLCJfZSIsIl91IiwiX2ciLCJGdW5jdGlvbmFsUmVuZGVyQ29udGV4dCIsImluamVjdGlvbnMiLCJjb250ZXh0Vm0iLCJpc0NvbXBpbGVkIiwiX2NvbXBpbGVkIiwibmVlZE5vcm1hbGl6YXRpb24iLCJfc2NvcGVJZCIsIl9jIiwiZCIsImNyZWF0ZUVsZW1lbnQiLCJjcmVhdGVGdW5jdGlvbmFsQ29tcG9uZW50IiwibWVyZ2VQcm9wcyIsInJlbmRlckNvbnRleHQiLCJjb21wb25lbnRWTm9kZUhvb2tzIiwiaW5pdCIsInBhcmVudEVsbSIsInJlZkVsbSIsImNyZWF0ZUNvbXBvbmVudEluc3RhbmNlRm9yVm5vZGUiLCIkbW91bnQiLCJrZWVwQWxpdmUiLCJtb3VudGVkTm9kZSIsInByZXBhdGNoIiwib2xkVm5vZGUiLCJpbnNlcnQiLCJkZXN0cm95IiwiaG9va3NUb01lcmdlIiwiY3JlYXRlQ29tcG9uZW50IiwiX2Jhc2UiLCJyZXNvbHZlQ29uc3RydWN0b3JPcHRpb25zIiwibW9kZWwiLCJ0cmFuc2Zvcm1Nb2RlbCIsImZ1bmN0aW9uYWwiLCJuYXRpdmVPbiIsIm1lcmdlSG9va3MiLCJfaXNDb21wb25lbnQiLCJpbmxpbmVUZW1wbGF0ZSIsImZyb21QYXJlbnQiLCJtZXJnZUhvb2skMSIsIm9uZSIsInR3byIsImNhbGxiYWNrIiwiU0lNUExFX05PUk1BTElaRSIsIkFMV0FZU19OT1JNQUxJWkUiLCJub3JtYWxpemF0aW9uVHlwZSIsImFsd2F5c05vcm1hbGl6ZSIsIl9jcmVhdGVFbGVtZW50IiwiaXMiLCJhcHBseU5TIiwiZm9yY2UiLCJpbml0UmVuZGVyIiwicGFyZW50RGF0YSIsInJlbmRlck1peGluIiwiJG5leHRUaWNrIiwicmVmIiwicmVuZGVyRXJyb3IiLCJ1aWQkMSIsImluaXRNaXhpbiIsIl9pbml0IiwiaW5pdEludGVybmFsQ29tcG9uZW50IiwiX3NlbGYiLCJ2bm9kZUNvbXBvbmVudE9wdGlvbnMiLCJzdXBlciIsInN1cGVyT3B0aW9ucyIsImNhY2hlZFN1cGVyT3B0aW9ucyIsIm1vZGlmaWVkT3B0aW9ucyIsInJlc29sdmVNb2RpZmllZE9wdGlvbnMiLCJleHRlbmRPcHRpb25zIiwibW9kaWZpZWQiLCJsYXRlc3QiLCJleHRlbmRlZCIsInNlYWxlZCIsInNlYWxlZE9wdGlvbnMiLCJkZWR1cGUiLCJWdWUkMyIsImluaXRVc2UiLCJ1c2UiLCJwbHVnaW4iLCJpbnN0YWxsZWRQbHVnaW5zIiwiX2luc3RhbGxlZFBsdWdpbnMiLCJ1bnNoaWZ0IiwiaW5zdGFsbCIsImluaXRNaXhpbiQxIiwibWl4aW4iLCJpbml0RXh0ZW5kIiwiU3VwZXIiLCJTdXBlcklkIiwiY2FjaGVkQ3RvcnMiLCJfQ3RvciIsIlN1YiIsIlZ1ZUNvbXBvbmVudCIsImluaXRQcm9wcyQxIiwiaW5pdENvbXB1dGVkJDEiLCJDb21wIiwiaW5pdEFzc2V0UmVnaXN0ZXJzIiwiZGVmaW5pdGlvbiIsImdldENvbXBvbmVudE5hbWUiLCJtYXRjaGVzIiwicGF0dGVybiIsInBydW5lQ2FjaGUiLCJrZWVwQWxpdmVJbnN0YW5jZSIsImNhY2hlZE5vZGUiLCJwcnVuZUNhY2hlRW50cnkiLCJjdXJyZW50IiwiY2FjaGVkJCQxIiwicGF0dGVyblR5cGVzIiwiUmVnRXhwIiwiS2VlcEFsaXZlIiwiaW5jbHVkZSIsImV4Y2x1ZGUiLCJOdW1iZXIiLCJjcmVhdGVkIiwiZGVzdHJveWVkIiwicmVmJDEiLCJwYXJzZUludCIsImJ1aWx0SW5Db21wb25lbnRzIiwiaW5pdEdsb2JhbEFQSSIsImNvbmZpZ0RlZiIsInV0aWwiLCJkZWxldGUiLCJzc3JDb250ZXh0IiwidmVyc2lvbiIsImFjY2VwdFZhbHVlIiwiYXR0ciIsImlzRW51bWVyYXRlZEF0dHIiLCJpc0Jvb2xlYW5BdHRyIiwieGxpbmtOUyIsImlzWGxpbmsiLCJnZXRYbGlua1Byb3AiLCJpc0ZhbHN5QXR0clZhbHVlIiwiZ2VuQ2xhc3NGb3JWbm9kZSIsInBhcmVudE5vZGUiLCJjaGlsZE5vZGUiLCJtZXJnZUNsYXNzRGF0YSIsInJlbmRlckNsYXNzIiwic3RhdGljQ2xhc3MiLCJjbGFzcyIsImR5bmFtaWNDbGFzcyIsInN0cmluZ2lmeUNsYXNzIiwic3RyaW5naWZ5QXJyYXkiLCJzdHJpbmdpZnlPYmplY3QiLCJzdHJpbmdpZmllZCIsIm5hbWVzcGFjZU1hcCIsInN2ZyIsIm1hdGgiLCJpc0hUTUxUYWciLCJpc1NWRyIsImlzUHJlVGFnIiwidW5rbm93bkVsZW1lbnRDYWNoZSIsImRvY3VtZW50IiwiSFRNTFVua25vd25FbGVtZW50IiwiSFRNTEVsZW1lbnQiLCJpc1RleHRJbnB1dFR5cGUiLCJxdWVyeSIsInNlbGVjdGVkIiwicXVlcnlTZWxlY3RvciIsImNyZWF0ZUVsZW1lbnQkMSIsInRhZ05hbWUiLCJtdWx0aXBsZSIsInNldEF0dHJpYnV0ZSIsImNyZWF0ZUVsZW1lbnROUyIsIm5hbWVzcGFjZSIsImNyZWF0ZVRleHROb2RlIiwiY3JlYXRlQ29tbWVudCIsImluc2VydEJlZm9yZSIsIm5ld05vZGUiLCJyZWZlcmVuY2VOb2RlIiwicmVtb3ZlQ2hpbGQiLCJhcHBlbmRDaGlsZCIsIm5leHRTaWJsaW5nIiwic2V0VGV4dENvbnRlbnQiLCJ0ZXh0Q29udGVudCIsIm5vZGVPcHMiLCJyZWdpc3RlclJlZiIsImlzUmVtb3ZhbCIsInJlZnMiLCJyZWZJbkZvciIsImVtcHR5Tm9kZSIsInNhbWVWbm9kZSIsInNhbWVJbnB1dFR5cGUiLCJ0eXBlQSIsInR5cGVCIiwiY3JlYXRlS2V5VG9PbGRJZHgiLCJiZWdpbklkeCIsImVuZElkeCIsImNyZWF0ZVBhdGNoRnVuY3Rpb24iLCJiYWNrZW5kIiwiZW1wdHlOb2RlQXQiLCJjcmVhdGVSbUNiIiwiY2hpbGRFbG0iLCJyZW1vdmVOb2RlIiwiaXNVbmtub3duRWxlbWVudCQkMSIsImluVlByZSIsInNvbWUiLCJpZ25vcmUiLCJjcmVhdGluZ0VsbUluVlByZSIsImNyZWF0ZUVsbSIsImluc2VydGVkVm5vZGVRdWV1ZSIsIm5lc3RlZCIsInByZSIsInNldFNjb3BlIiwiY3JlYXRlQ2hpbGRyZW4iLCJpbnZva2VDcmVhdGVIb29rcyIsImlzUmVhY3RpdmF0ZWQiLCJpbml0Q29tcG9uZW50IiwicmVhY3RpdmF0ZUNvbXBvbmVudCIsInBlbmRpbmdJbnNlcnQiLCJpc1BhdGNoYWJsZSIsImlubmVyTm9kZSIsInRyYW5zaXRpb24iLCJhY3RpdmF0ZSIsInJlZiQkMSIsImNoZWNrRHVwbGljYXRlS2V5cyIsImFuY2VzdG9yIiwiYWRkVm5vZGVzIiwic3RhcnRJZHgiLCJpbnZva2VEZXN0cm95SG9vayIsInJlbW92ZVZub2RlcyIsImNoIiwicmVtb3ZlQW5kSW52b2tlUmVtb3ZlSG9vayIsInJtIiwidXBkYXRlQ2hpbGRyZW4iLCJvbGRDaCIsIm5ld0NoIiwicmVtb3ZlT25seSIsIm9sZFN0YXJ0SWR4IiwibmV3U3RhcnRJZHgiLCJvbGRFbmRJZHgiLCJvbGRTdGFydFZub2RlIiwib2xkRW5kVm5vZGUiLCJuZXdFbmRJZHgiLCJuZXdTdGFydFZub2RlIiwibmV3RW5kVm5vZGUiLCJvbGRLZXlUb0lkeCIsImlkeEluT2xkIiwidm5vZGVUb01vdmUiLCJjYW5Nb3ZlIiwicGF0Y2hWbm9kZSIsImZpbmRJZHhJbk9sZCIsInNlZW5LZXlzIiwiZW5kIiwiaHlkcmF0ZSIsInBvc3RwYXRjaCIsImludm9rZUluc2VydEhvb2siLCJpbml0aWFsIiwiaHlkcmF0aW9uQmFpbGVkIiwiaXNSZW5kZXJlZE1vZHVsZSIsImFzc2VydE5vZGVNYXRjaCIsImhhc0NoaWxkTm9kZXMiLCJpbm5lckhUTUwiLCJjaGlsZHJlbk1hdGNoIiwiZmlyc3RDaGlsZCIsImNoaWxkTm9kZXMiLCJmdWxsSW52b2tlIiwibm9kZVR5cGUiLCJwYXRjaCIsImlzSW5pdGlhbFBhdGNoIiwiaXNSZWFsRWxlbWVudCIsImhhc0F0dHJpYnV0ZSIsInJlbW92ZUF0dHJpYnV0ZSIsIm9sZEVsbSIsInBhcmVudEVsbSQxIiwiX2xlYXZlQ2IiLCJwYXRjaGFibGUiLCJpJDIiLCJ1cGRhdGVEaXJlY3RpdmVzIiwidW5iaW5kRGlyZWN0aXZlcyIsImlzQ3JlYXRlIiwiaXNEZXN0cm95Iiwib2xkRGlycyIsIm5vcm1hbGl6ZURpcmVjdGl2ZXMkMSIsIm5ld0RpcnMiLCJkaXJzV2l0aEluc2VydCIsImRpcnNXaXRoUG9zdHBhdGNoIiwib2xkRGlyIiwiZGlyIiwiY2FsbEhvb2skMSIsImNvbXBvbmVudFVwZGF0ZWQiLCJjYWxsSW5zZXJ0IiwiZW1wdHlNb2RpZmllcnMiLCJtb2RpZmllcnMiLCJnZXRSYXdEaXJOYW1lIiwicmF3TmFtZSIsImJhc2VNb2R1bGVzIiwidXBkYXRlQXR0cnMiLCJpbmhlcml0QXR0cnMiLCJvbGRBdHRycyIsInNldEF0dHIiLCJyZW1vdmVBdHRyaWJ1dGVOUyIsInNldEF0dHJpYnV0ZU5TIiwiX19pZXBoIiwiYmxvY2tlciIsInN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbiIsInJlbW92ZUV2ZW50TGlzdGVuZXIiLCJ1cGRhdGVDbGFzcyIsIm9sZERhdGEiLCJjbHMiLCJ0cmFuc2l0aW9uQ2xhc3MiLCJfdHJhbnNpdGlvbkNsYXNzZXMiLCJfcHJldkNsYXNzIiwia2xhc3MiLCJ2YWxpZERpdmlzaW9uQ2hhclJFIiwicGFyc2VGaWx0ZXJzIiwiZXhwIiwiaW5TaW5nbGUiLCJpbkRvdWJsZSIsImluVGVtcGxhdGVTdHJpbmciLCJpblJlZ2V4IiwiY3VybHkiLCJzcXVhcmUiLCJwYXJlbiIsImxhc3RGaWx0ZXJJbmRleCIsInByZXYiLCJmaWx0ZXJzIiwidHJpbSIsInB1c2hGaWx0ZXIiLCJ3cmFwRmlsdGVyIiwiYmFzZVdhcm4iLCJwbHVja01vZHVsZUZ1bmN0aW9uIiwiYWRkUHJvcCIsImFkZEF0dHIiLCJhZGREaXJlY3RpdmUiLCJhcmciLCJhZGRIYW5kbGVyIiwiaW1wb3J0YW50IiwicHJldmVudCIsInJpZ2h0IiwibWlkZGxlIiwiZXZlbnRzIiwibmF0aXZlIiwibmF0aXZlRXZlbnRzIiwibmV3SGFuZGxlciIsImdldEJpbmRpbmdBdHRyIiwiZ2V0U3RhdGljIiwiZHluYW1pY1ZhbHVlIiwiZ2V0QW5kUmVtb3ZlQXR0ciIsInN0YXRpY1ZhbHVlIiwicmVtb3ZlRnJvbU1hcCIsImF0dHJzTWFwIiwiYXR0cnNMaXN0IiwiZ2VuQ29tcG9uZW50TW9kZWwiLCJudW1iZXIiLCJiYXNlVmFsdWVFeHByZXNzaW9uIiwidmFsdWVFeHByZXNzaW9uIiwiYXNzaWdubWVudCIsImdlbkFzc2lnbm1lbnRDb2RlIiwicGFyc2VNb2RlbCIsImNociIsImluZGV4JDEiLCJleHByZXNzaW9uUG9zIiwiZXhwcmVzc2lvbkVuZFBvcyIsImxhc3RJbmRleE9mIiwiZW9mIiwibmV4dCIsImlzU3RyaW5nU3RhcnQiLCJwYXJzZVN0cmluZyIsInBhcnNlQnJhY2tldCIsImluQnJhY2tldCIsInN0cmluZ1F1b3RlIiwid2FybiQxIiwiUkFOR0VfVE9LRU4iLCJDSEVDS0JPWF9SQURJT19UT0tFTiIsIl93YXJuIiwiZ2VuU2VsZWN0IiwiZ2VuQ2hlY2tib3hNb2RlbCIsImdlblJhZGlvTW9kZWwiLCJnZW5EZWZhdWx0TW9kZWwiLCJ2YWx1ZUJpbmRpbmciLCJ0cnVlVmFsdWVCaW5kaW5nIiwiZmFsc2VWYWx1ZUJpbmRpbmciLCJzZWxlY3RlZFZhbCIsImNvZGUiLCJ2YWx1ZSQxIiwiYmluZGluZyIsIm5lZWRDb21wb3NpdGlvbkd1YXJkIiwibm9ybWFsaXplRXZlbnRzIiwiY2hhbmdlIiwidGFyZ2V0JDEiLCJjcmVhdGVPbmNlSGFuZGxlciIsIm9uY2VIYW5kbGVyIiwicmVtb3ZlJDIiLCJhZGQkMSIsInVwZGF0ZURPTUxpc3RlbmVycyIsInVwZGF0ZURPTVByb3BzIiwib2xkUHJvcHMiLCJfdmFsdWUiLCJzdHJDdXIiLCJzaG91bGRVcGRhdGVWYWx1ZSIsImNoZWNrVmFsIiwiY29tcG9zaW5nIiwiaXNOb3RJbkZvY3VzQW5kRGlydHkiLCJpc0RpcnR5V2l0aE1vZGlmaWVycyIsIm5vdEluRm9jdXMiLCJhY3RpdmVFbGVtZW50IiwiX3ZNb2RpZmllcnMiLCJwYXJzZVN0eWxlVGV4dCIsImNzc1RleHQiLCJsaXN0RGVsaW1pdGVyIiwicHJvcGVydHlEZWxpbWl0ZXIiLCJub3JtYWxpemVTdHlsZURhdGEiLCJzdHlsZSIsIm5vcm1hbGl6ZVN0eWxlQmluZGluZyIsInN0YXRpY1N0eWxlIiwiYmluZGluZ1N0eWxlIiwiZ2V0U3R5bGUiLCJjaGVja0NoaWxkIiwic3R5bGVEYXRhIiwiY3NzVmFyUkUiLCJpbXBvcnRhbnRSRSIsInNldFByb3AiLCJzZXRQcm9wZXJ0eSIsIm5vcm1hbGl6ZWROYW1lIiwibm9ybWFsaXplIiwidmVuZG9yTmFtZXMiLCJlbXB0eVN0eWxlIiwiY2FwTmFtZSIsInVwZGF0ZVN0eWxlIiwib2xkU3RhdGljU3R5bGUiLCJvbGRTdHlsZUJpbmRpbmciLCJub3JtYWxpemVkU3R5bGUiLCJvbGRTdHlsZSIsIm5ld1N0eWxlIiwiYWRkQ2xhc3MiLCJjbGFzc0xpc3QiLCJnZXRBdHRyaWJ1dGUiLCJyZW1vdmVDbGFzcyIsInRhciIsInJlc29sdmVUcmFuc2l0aW9uIiwiY3NzIiwiYXV0b0Nzc1RyYW5zaXRpb24iLCJlbnRlckNsYXNzIiwiZW50ZXJUb0NsYXNzIiwiZW50ZXJBY3RpdmVDbGFzcyIsImxlYXZlQ2xhc3MiLCJsZWF2ZVRvQ2xhc3MiLCJsZWF2ZUFjdGl2ZUNsYXNzIiwiaGFzVHJhbnNpdGlvbiIsIlRSQU5TSVRJT04iLCJBTklNQVRJT04iLCJ0cmFuc2l0aW9uUHJvcCIsInRyYW5zaXRpb25FbmRFdmVudCIsImFuaW1hdGlvblByb3AiLCJhbmltYXRpb25FbmRFdmVudCIsIm9udHJhbnNpdGlvbmVuZCIsIm9ud2Via2l0dHJhbnNpdGlvbmVuZCIsIm9uYW5pbWF0aW9uZW5kIiwib253ZWJraXRhbmltYXRpb25lbmQiLCJyYWYiLCJyZXF1ZXN0QW5pbWF0aW9uRnJhbWUiLCJuZXh0RnJhbWUiLCJhZGRUcmFuc2l0aW9uQ2xhc3MiLCJ0cmFuc2l0aW9uQ2xhc3NlcyIsInJlbW92ZVRyYW5zaXRpb25DbGFzcyIsIndoZW5UcmFuc2l0aW9uRW5kcyIsImdldFRyYW5zaXRpb25JbmZvIiwicHJvcENvdW50IiwiZW5kZWQiLCJvbkVuZCIsInRyYW5zZm9ybVJFIiwic3R5bGVzIiwiZ2V0Q29tcHV0ZWRTdHlsZSIsInRyYW5zaXRpb25EZWxheXMiLCJ0cmFuc2l0aW9uRHVyYXRpb25zIiwidHJhbnNpdGlvblRpbWVvdXQiLCJnZXRUaW1lb3V0IiwiYW5pbWF0aW9uRGVsYXlzIiwiYW5pbWF0aW9uRHVyYXRpb25zIiwiYW5pbWF0aW9uVGltZW91dCIsImhhc1RyYW5zZm9ybSIsImRlbGF5cyIsImR1cmF0aW9ucyIsInRvTXMiLCJzIiwiZW50ZXIiLCJ0b2dnbGVEaXNwbGF5IiwiY2FuY2VsbGVkIiwiX2VudGVyQ2IiLCJhcHBlYXJDbGFzcyIsImFwcGVhclRvQ2xhc3MiLCJhcHBlYXJBY3RpdmVDbGFzcyIsImJlZm9yZUVudGVyIiwiYWZ0ZXJFbnRlciIsImVudGVyQ2FuY2VsbGVkIiwiYmVmb3JlQXBwZWFyIiwiYXBwZWFyIiwiYWZ0ZXJBcHBlYXIiLCJhcHBlYXJDYW5jZWxsZWQiLCJkdXJhdGlvbiIsInRyYW5zaXRpb25Ob2RlIiwiaXNBcHBlYXIiLCJzdGFydENsYXNzIiwiYWN0aXZlQ2xhc3MiLCJ0b0NsYXNzIiwiYmVmb3JlRW50ZXJIb29rIiwiZW50ZXJIb29rIiwiYWZ0ZXJFbnRlckhvb2siLCJlbnRlckNhbmNlbGxlZEhvb2siLCJleHBsaWNpdEVudGVyRHVyYXRpb24iLCJjaGVja0R1cmF0aW9uIiwiZXhwZWN0c0NTUyIsInVzZXJXYW50c0NvbnRyb2wiLCJnZXRIb29rQXJndW1lbnRzTGVuZ3RoIiwic2hvdyIsInBlbmRpbmdOb2RlIiwiX3BlbmRpbmciLCJpc1ZhbGlkRHVyYXRpb24iLCJsZWF2ZSIsImJlZm9yZUxlYXZlIiwiYWZ0ZXJMZWF2ZSIsImxlYXZlQ2FuY2VsbGVkIiwiZGVsYXlMZWF2ZSIsImV4cGxpY2l0TGVhdmVEdXJhdGlvbiIsInBlcmZvcm1MZWF2ZSIsImludm9rZXJGbnMiLCJfZW50ZXIiLCJwbGF0Zm9ybU1vZHVsZXMiLCJ2bW9kZWwiLCJ0cmlnZ2VyIiwiZGlyZWN0aXZlIiwiX3ZPcHRpb25zIiwic2V0U2VsZWN0ZWQiLCJnZXRWYWx1ZSIsIm9uQ29tcG9zaXRpb25FbmQiLCJvbkNvbXBvc2l0aW9uU3RhcnQiLCJwcmV2T3B0aW9ucyIsImN1ck9wdGlvbnMiLCJvIiwibmVlZFJlc2V0IiwiaGFzTm9NYXRjaGluZ09wdGlvbiIsImFjdHVhbGx5U2V0U2VsZWN0ZWQiLCJpc011bHRpcGxlIiwib3B0aW9uIiwic2VsZWN0ZWRJbmRleCIsImNyZWF0ZUV2ZW50IiwiaW5pdEV2ZW50IiwiZGlzcGF0Y2hFdmVudCIsImxvY2F0ZU5vZGUiLCJ0cmFuc2l0aW9uJCQxIiwib3JpZ2luYWxEaXNwbGF5IiwiX192T3JpZ2luYWxEaXNwbGF5IiwiZGlzcGxheSIsInVuYmluZCIsInBsYXRmb3JtRGlyZWN0aXZlcyIsInRyYW5zaXRpb25Qcm9wcyIsIm1vZGUiLCJnZXRSZWFsQ2hpbGQiLCJjb21wT3B0aW9ucyIsImV4dHJhY3RUcmFuc2l0aW9uRGF0YSIsInBsYWNlaG9sZGVyIiwiaCIsInJhd0NoaWxkIiwiaGFzUGFyZW50VHJhbnNpdGlvbiIsImlzU2FtZUNoaWxkIiwib2xkQ2hpbGQiLCJUcmFuc2l0aW9uIiwiX2xlYXZpbmciLCJvbGRSYXdDaGlsZCIsImRlbGF5ZWRMZWF2ZSIsIm1vdmVDbGFzcyIsIlRyYW5zaXRpb25Hcm91cCIsInByZXZDaGlsZHJlbiIsInJhd0NoaWxkcmVuIiwidHJhbnNpdGlvbkRhdGEiLCJrZXB0IiwicmVtb3ZlZCIsImMkMSIsInBvcyIsImdldEJvdW5kaW5nQ2xpZW50UmVjdCIsImJlZm9yZVVwZGF0ZSIsInVwZGF0ZWQiLCJoYXNNb3ZlIiwiY2FsbFBlbmRpbmdDYnMiLCJyZWNvcmRQb3NpdGlvbiIsImFwcGx5VHJhbnNsYXRpb24iLCJfcmVmbG93IiwiYm9keSIsIm9mZnNldEhlaWdodCIsIm1vdmVkIiwidHJhbnNmb3JtIiwiV2Via2l0VHJhbnNmb3JtIiwidHJhbnNpdGlvbkR1cmF0aW9uIiwiX21vdmVDYiIsInByb3BlcnR5TmFtZSIsIl9oYXNNb3ZlIiwiY2xvbmUiLCJjbG9uZU5vZGUiLCJuZXdQb3MiLCJvbGRQb3MiLCJkeCIsImxlZnQiLCJkeSIsInRvcCIsInBsYXRmb3JtQ29tcG9uZW50cyIsImRlZmF1bHRUYWdSRSIsInJlZ2V4RXNjYXBlUkUiLCJidWlsZFJlZ2V4IiwiZGVsaW1pdGVycyIsIm9wZW4iLCJjbG9zZSIsInBhcnNlVGV4dCIsInRhZ1JFIiwidG9rZW5zIiwiZXhlYyIsInRyYW5zZm9ybU5vZGUiLCJjbGFzc0JpbmRpbmciLCJnZW5EYXRhIiwia2xhc3MkMSIsInRyYW5zZm9ybU5vZGUkMSIsInN0eWxlQmluZGluZyIsImdlbkRhdGEkMSIsInN0eWxlJDEiLCJkZWNvZGVyIiwiaGUiLCJkZWNvZGUiLCJodG1sIiwiaXNVbmFyeVRhZyIsImNhbkJlTGVmdE9wZW5UYWciLCJpc05vblBocmFzaW5nVGFnIiwiYXR0cmlidXRlIiwibmNuYW1lIiwicW5hbWVDYXB0dXJlIiwic3RhcnRUYWdPcGVuIiwic3RhcnRUYWdDbG9zZSIsImRvY3R5cGUiLCJjb21tZW50IiwiY29uZGl0aW9uYWxDb21tZW50IiwiSVNfUkVHRVhfQ0FQVFVSSU5HX0JST0tFTiIsImciLCJpc1BsYWluVGV4dEVsZW1lbnQiLCJyZUNhY2hlIiwiZGVjb2RpbmdNYXAiLCJlbmNvZGVkQXR0ciIsImVuY29kZWRBdHRyV2l0aE5ld0xpbmVzIiwiaXNJZ25vcmVOZXdsaW5lVGFnIiwic2hvdWxkSWdub3JlRmlyc3ROZXdsaW5lIiwiZGVjb2RlQXR0ciIsInNob3VsZERlY29kZU5ld2xpbmVzIiwicmUiLCJwYXJzZUhUTUwiLCJzdGFjayIsImV4cGVjdEhUTUwiLCJpc1VuYXJ5VGFnJCQxIiwiY2FuQmVMZWZ0T3BlblRhZyQkMSIsImxhc3RUYWciLCJ0ZXh0RW5kIiwiY29tbWVudEVuZCIsInNob3VsZEtlZXBDb21tZW50Iiwic3Vic3RyaW5nIiwiYWR2YW5jZSIsImNvbmRpdGlvbmFsRW5kIiwiZG9jdHlwZU1hdGNoIiwiZW5kVGFnTWF0Y2giLCJjdXJJbmRleCIsInBhcnNlRW5kVGFnIiwic3RhcnRUYWdNYXRjaCIsInBhcnNlU3RhcnRUYWciLCJoYW5kbGVTdGFydFRhZyIsInJlc3QiLCJjaGFycyIsImVuZFRhZ0xlbmd0aCIsInN0YWNrZWRUYWciLCJyZVN0YWNrZWRUYWciLCJyZXN0JDEiLCJhbGwiLCJ1bmFyeVNsYXNoIiwidW5hcnkiLCJzaG91bGREZWNvZGVOZXdsaW5lc0ZvckhyZWYiLCJsb3dlckNhc2VkVGFnIiwibG93ZXJDYXNlZFRhZ05hbWUiLCJvblJFIiwiZGlyUkUiLCJmb3JBbGlhc1JFIiwiZm9ySXRlcmF0b3JSRSIsInN0cmlwUGFyZW5zUkUiLCJhcmdSRSIsImJpbmRSRSIsIm1vZGlmaWVyUkUiLCJkZWNvZGVIVE1MQ2FjaGVkIiwid2FybiQyIiwidHJhbnNmb3JtcyIsInByZVRyYW5zZm9ybXMiLCJwb3N0VHJhbnNmb3JtcyIsInBsYXRmb3JtSXNQcmVUYWciLCJwbGF0Zm9ybU11c3RVc2VQcm9wIiwicGxhdGZvcm1HZXRUYWdOYW1lc3BhY2UiLCJjcmVhdGVBU1RFbGVtZW50IiwibWFrZUF0dHJzTWFwIiwicGFyc2UiLCJwcmVzZXJ2ZVdoaXRlc3BhY2UiLCJyb290IiwiY3VycmVudFBhcmVudCIsImluUHJlIiwid2FybmVkIiwid2Fybk9uY2UiLCJlbmRQcmUiLCJlbGVtZW50IiwiY29tbWVudHMiLCJndWFyZElFU1ZHQnVnIiwiaXNGb3JiaWRkZW5UYWciLCJmb3JiaWRkZW4iLCJwcm9jZXNzUHJlIiwicHJvY2Vzc1Jhd0F0dHJzIiwicHJvY2Vzc2VkIiwicHJvY2Vzc0ZvciIsInByb2Nlc3NJZiIsInByb2Nlc3NPbmNlIiwicHJvY2Vzc0VsZW1lbnQiLCJjaGVja1Jvb3RDb25zdHJhaW50cyIsImlmIiwiZWxzZWlmIiwiZWxzZSIsImFkZElmQ29uZGl0aW9uIiwiYmxvY2siLCJwcm9jZXNzSWZDb25kaXRpb25zIiwic2xvdFNjb3BlIiwicGxhaW4iLCJzbG90VGFyZ2V0IiwibGFzdE5vZGUiLCJpc1RleHRUYWciLCJwcm9jZXNzS2V5IiwicHJvY2Vzc1JlZiIsInByb2Nlc3NTbG90IiwicHJvY2Vzc0NvbXBvbmVudCIsInByb2Nlc3NBdHRycyIsImNoZWNrSW5Gb3IiLCJpbk1hdGNoIiwiZm9yIiwiYWxpYXMiLCJpdGVyYXRvck1hdGNoIiwiaXRlcmF0b3IxIiwiaXRlcmF0b3IyIiwiZmluZFByZXZFbGVtZW50IiwiY29uZGl0aW9uIiwiaWZDb25kaXRpb25zIiwic2xvdE5hbWUiLCJpc1Byb3AiLCJoYXNCaW5kaW5ncyIsInBhcnNlTW9kaWZpZXJzIiwiY2FtZWwiLCJhcmdNYXRjaCIsImNoZWNrRm9yQWxpYXNNb2RlbCIsImllTlNCdWciLCJpZU5TUHJlZml4IiwiX2VsIiwicHJlVHJhbnNmb3JtTm9kZSIsInR5cGVCaW5kaW5nIiwiaWZDb25kaXRpb24iLCJpZkNvbmRpdGlvbkV4dHJhIiwiaGFzRWxzZSIsImVsc2VJZkNvbmRpdGlvbiIsImJyYW5jaDAiLCJjbG9uZUFTVEVsZW1lbnQiLCJhZGRSYXdBdHRyIiwiYnJhbmNoMSIsImJyYW5jaDIiLCJtb2RlbCQyIiwibW9kdWxlcyQxIiwiZGlyZWN0aXZlcyQxIiwiYmFzZU9wdGlvbnMiLCJpc1N0YXRpY0tleSIsImlzUGxhdGZvcm1SZXNlcnZlZFRhZyIsImdlblN0YXRpY0tleXNDYWNoZWQiLCJnZW5TdGF0aWNLZXlzJDEiLCJvcHRpbWl6ZSIsIm1hcmtTdGF0aWMkMSIsIm1hcmtTdGF0aWNSb290cyIsInN0YXRpYyIsImwkMSIsInN0YXRpY0luRm9yIiwic3RhdGljUm9vdCIsImlzRGlyZWN0Q2hpbGRPZlRlbXBsYXRlRm9yIiwiZm5FeHBSRSIsInNpbXBsZVBhdGhSRSIsImVzYyIsInRhYiIsInNwYWNlIiwidXAiLCJkb3duIiwiZ2VuR3VhcmQiLCJtb2RpZmllckNvZGUiLCJzdG9wIiwic2VsZiIsImN0cmwiLCJhbHQiLCJtZXRhIiwiZ2VuSGFuZGxlcnMiLCJnZW5IYW5kbGVyIiwiaXNNZXRob2RQYXRoIiwiaXNGdW5jdGlvbkV4cHJlc3Npb24iLCJnZW5Nb2RpZmllckNvZGUiLCJrZXlNb2RpZmllciIsImdlbktleUZpbHRlciIsImhhbmRsZXJDb2RlIiwiZ2VuRmlsdGVyQ29kZSIsImtleVZhbCIsIndyYXBMaXN0ZW5lcnMiLCJiaW5kJDEiLCJ3cmFwRGF0YSIsImJhc2VEaXJlY3RpdmVzIiwiY2xvYWsiLCJDb2RlZ2VuU3RhdGUiLCJkYXRhR2VuRm5zIiwibWF5YmVDb21wb25lbnQiLCJvbmNlSWQiLCJnZW5lcmF0ZSIsImFzdCIsInN0YXRlIiwiZ2VuRWxlbWVudCIsInN0YXRpY1Byb2Nlc3NlZCIsImdlblN0YXRpYyIsIm9uY2VQcm9jZXNzZWQiLCJnZW5PbmNlIiwiZm9yUHJvY2Vzc2VkIiwiZ2VuRm9yIiwiaWZQcm9jZXNzZWQiLCJnZW5JZiIsImdlbkNoaWxkcmVuIiwiZ2VuU2xvdCIsImdlbkNvbXBvbmVudCIsImdlbkRhdGEkMiIsImFsdEdlbiIsImFsdEVtcHR5IiwiZ2VuSWZDb25kaXRpb25zIiwiY29uZGl0aW9ucyIsImdlblRlcm5hcnlFeHAiLCJhbHRIZWxwZXIiLCJnZW5EaXJlY3RpdmVzIiwiZ2VuUHJvcHMiLCJnZW5TY29wZWRTbG90cyIsImdlbklubGluZVRlbXBsYXRlIiwiaGFzUnVudGltZSIsIm5lZWRSdW50aW1lIiwiZ2VuIiwiaW5saW5lUmVuZGVyRm5zIiwiZ2VuU2NvcGVkU2xvdCIsImdlbkZvclNjb3BlZFNsb3QiLCJjaGVja1NraXAiLCJhbHRHZW5FbGVtZW50IiwiYWx0R2VuTm9kZSIsImVsJDEiLCJnZXROb3JtYWxpemF0aW9uVHlwZSIsImdlbk5vZGUiLCJuZWVkc05vcm1hbGl6YXRpb24iLCJnZW5Db21tZW50IiwiZ2VuVGV4dCIsInRyYW5zZm9ybVNwZWNpYWxOZXdsaW5lcyIsImJpbmQkJDEiLCJjb21wb25lbnROYW1lIiwicHJvaGliaXRlZEtleXdvcmRSRSIsInVuYXJ5T3BlcmF0b3JzUkUiLCJzdHJpcFN0cmluZ1JFIiwiZGV0ZWN0RXJyb3JzIiwiZXJyb3JzIiwiY2hlY2tOb2RlIiwiY2hlY2tGb3IiLCJjaGVja0V2ZW50IiwiY2hlY2tFeHByZXNzaW9uIiwic3RpcHBlZCIsImtleXdvcmRNYXRjaCIsImNoZWNrSWRlbnRpZmllciIsImlkZW50IiwiRnVuY3Rpb24iLCJtZXNzYWdlIiwiY3JlYXRlRnVuY3Rpb24iLCJjcmVhdGVDb21waWxlVG9GdW5jdGlvbkZuIiwiY29tcGlsZSIsImNvbXBpbGVUb0Z1bmN0aW9ucyIsIndhcm4kJDEiLCJjb21waWxlZCIsInRpcHMiLCJmbkdlbkVycm9ycyIsImNyZWF0ZUNvbXBpbGVyQ3JlYXRvciIsImJhc2VDb21waWxlIiwiY3JlYXRlQ29tcGlsZXIiLCJmaW5hbE9wdGlvbnMiLCJkaXYiLCJnZXRTaG91bGREZWNvZGUiLCJocmVmIiwiaWRUb1RlbXBsYXRlIiwibW91bnQiLCJkb2N1bWVudEVsZW1lbnQiLCJnZXRPdXRlckhUTUwiLCJvdXRlckhUTUwiLCJjb250YWluZXIiLCJtb2R1bGUiLCJleHBvcnRzIl0sIm1hcHBpbmdzIjoiQUFBQTs7Ozs7QUFLQTs7QUFFQTs7OztBQUVBLElBQUlBLGNBQWNDLE9BQU9DLE1BQVAsQ0FBYyxFQUFkLENBQWxCOztBQUVBO0FBQ0E7QUFDQSxTQUFTQyxPQUFULENBQWtCQyxDQUFsQixFQUFxQjtBQUNuQixTQUFPQSxNQUFNQyxTQUFOLElBQW1CRCxNQUFNLElBQWhDO0FBQ0Q7O0FBRUQsU0FBU0UsS0FBVCxDQUFnQkYsQ0FBaEIsRUFBbUI7QUFDakIsU0FBT0EsTUFBTUMsU0FBTixJQUFtQkQsTUFBTSxJQUFoQztBQUNEOztBQUVELFNBQVNHLE1BQVQsQ0FBaUJILENBQWpCLEVBQW9CO0FBQ2xCLFNBQU9BLE1BQU0sSUFBYjtBQUNEOztBQUVELFNBQVNJLE9BQVQsQ0FBa0JKLENBQWxCLEVBQXFCO0FBQ25CLFNBQU9BLE1BQU0sS0FBYjtBQUNEOztBQUVEOzs7QUFHQSxTQUFTSyxXQUFULENBQXNCQyxL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QTtBQUNBLFVBQUlsakIsUUFBUUMsR0FBUixDQUFZQyxRQUFaLEtBQXlCLFlBQXpCLElBQXlDTixPQUFPUSxXQUFoRCxJQUErRHFTLElBQW5FLEVBQXlFO0FBQ3ZFQSxhQUFLLGFBQUw7QUFDQUMsZ0JBQVMsU0FBVSxLQUFLNEksS0FBZixHQUF3QixVQUFqQyxFQUE4QyxTQUE5QyxFQUF5RCxhQUF6RDtBQUNEO0FBQ0Y7QUFDRjtBQUNELFNBQU9pZ0MsTUFBTTVoRCxJQUFOLENBQVcsSUFBWCxFQUFpQnVTLEVBQWpCLEVBQXFCaU8sU0FBckIsQ0FBUDtBQUNELENBbEVEOztBQW9FQTs7OztBQUlBLFNBQVNzaEMsWUFBVCxDQUF1QnZ2QyxFQUF2QixFQUEyQjtBQUN6QixNQUFJQSxHQUFHd3ZDLFNBQVAsRUFBa0I7QUFDaEIsV0FBT3h2QyxHQUFHd3ZDLFNBQVY7QUFDRCxHQUZELE1BRU87QUFDTCxRQUFJQyxZQUFZOXRCLFNBQVMzSSxhQUFULENBQXVCLEtBQXZCLENBQWhCO0FBQ0F5MkIsY0FBVTNzQixXQUFWLENBQXNCOWlCLEdBQUcrOEIsU0FBSCxDQUFhLElBQWIsQ0FBdEI7QUFDQSxXQUFPMFMsVUFBVTFuQixTQUFqQjtBQUNEO0FBQ0Y7O0FBRUQvSyxNQUFNdXhCLE9BQU4sR0FBZ0JDLGtCQUFoQjs7QUFFQWtCLE9BQU9DLE9BQVAsR0FBaUIzeUIsS0FBakIsQyIsImZpbGUiOiI0NC5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8qIVxuICogVnVlLmpzIHYyLjUuMTFcbiAqIChjKSAyMDE0LTIwMTcgRXZhbiBZb3VcbiAqIFJlbGVhc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cbiAqL1xuJ3VzZSBzdHJpY3QnO1xuXG4vKiAgKi9cblxudmFyIGVtcHR5T2JqZWN0ID0gT2JqZWN0LmZyZWV6ZSh7fSk7XG5cbi8vIHRoZXNlIGhlbHBlcnMgcHJvZHVjZXMgYmV0dGVyIHZtIGNvZGUgaW4gSlMgZW5naW5lcyBkdWUgdG8gdGhlaXJcbi8vIGV4cGxpY2l0bmVzcyBhbmQgZnVuY3Rpb24gaW5saW5pbmdcbmZ1bmN0aW9uIGlzVW5kZWYgKHYpIHtcbiAgcmV0dXJuIHYgPT09IHVuZGVmaW5lZCB8fCB2ID09PSBudWxsXG59XG5cbmZ1bmN0aW9uIGlzRGVmICh2KSB7XG4gIHJldHVybiB2ICE9PSB1bmRlZmluZWQgJiYgdiAhPT0gbnVsbFxufVxuXG5mdW5jdGlvbiBpc1RydWUgKHYpIHtcbiAgcmV0dXJuIHYgPT09IHRydWVcbn1cblxuZnVuY3Rpb24gaXNGYWxzZSAodikge1xuICByZXR1cm4gdiA9PT0gZmFsc2Vcbn1cblxuLyoqXG4gKiBDaGVjayBpZiB2YWx1ZSBpcyBwcmltaXRpdmVcbiAqL1xuZnVuY3Rpb24gaXNQcmltaXRpdmUgKHZhbHVlKSB7XG4gIHJldHVybiAoXG4gICAgdHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJyB8fFxuICAgIHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicgfHxcbiAgICB0eXBlb2YgdmFsdWUgPT09ICdib29sZWFuJ1xuICApXG59XG5cbi8qKlxuICogUXVpY2sgb2JqZWN0IGNoZWNrIC0gdGhpcyBpcyBwcmltYXJpbHkgdXNlZCB0byB0ZWxsXG4gKiBPYmplY3RzIGZyb20gcHJpbWl0aXZlIHZhbHVlcyB3aGVuIHdlIGtub3cgdGhlIHZhbHVlXG4gKiBpcyBhIEpTT04tY29tcGxpYW50IHR5cGUuXG4gKi9cbmZ1bmN0aW9uIGlzT2JqZWN0IChvYmopIHtcbiAgcmV0dXJuIG9iaiAhPT0gbnVsbCAmJiB0eXBlb2Ygb2JqID09PSAnb2JqZWN0J1xufVxuXG4vKipcbiAqIEdldCB0aGUgcmF3IHR5cGUgc3RyaW5nIG9mIGEgdmFsdWUgZS5nLiBbb2JqZWN0IE9iamVjdF1cbiAqL1xudmFyIF90b1N0cmluZyA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmc7XG5cbmZ1bmN0aW9uIHRvUmF3VHlwZSAodmFsdWUpIHtcbiAgcmV0dXJuIF90b1N0cmluZy5jYWxsKHZhbHVlKS5zbGljZSg4LCAtMSlcbn1cblxuLyoqXG4gKiBTdHJpY3Qgb2JqZWN0IHR5cGUgY2hlY2suIE9ubHkgcmV0dXJucyB0cnVlXG4gKiBmb3IgcGxhaW4gSmF2YVNjcmlwdCBvYmplY3RzLlxuICovXG5mdW5jdGlvbiBpc1BsYWluT2JqZWN0IChvYmopIHtcbiAgcmV0dXJuIF90b1N0cmluZy5jYWxsKG9iaikgPT09ICdbb2JqZWN0IE9iamVjdF0nXG59XG5cbmZ1bmN0aW9uIGlzUmVnRXhwICh2KSB7XG4gIHJldHVybiBfdG9TdHJpbmcuY2FsbCh2KSA9PT0gJ1tvYmplY3QgUmVnRXhwXSdcbn1cblxuLyoqXG4gKiBDaGVjayBpZiB2YWwgaXMgYSB2YWxpZCBhcnJheSBpbmRleC5cbiAqL1xuZnVuY3Rpb24gaXNWYWxpZEFycmF5SW5kZXggKHZhbCkge1xuICB2YXIgbiA9IHBhcnNlRmxvYXQoU3RyaW5nKHZhbCkpO1xuICByZXR1cm4gbiA+PSAwICYmIE1hdGguZmxvb3IobikgPT09IG4gJiYgaXNGaW5pdGUodmFsKVxufVxuXG4vKipcbiAqIENvbnZlcnQgYSB2YWx1ZSB0byBhIHN0cmluZyB0aGF0IGlzIGFjdHVhbGx5IHJlbmRlcmVkLlxuICovXG5mdW5jdGlvbiB0b1N0cmluZyAodmFsKSB7XG4gIHJldHVybiB2YWwgPT0gbnVsbFxuICAgID8gJydcbiAgICA6IHR5cGVvZiB2YWwgPT09ICdvYmplY3QnXG4gICAgICA/IEpTT04uc3RyaW5naWZ5KHZhbCwgbnVsbCwgMilcbiAgICAgIDogU3RyaW5nKHZhbClcbn1cblxuLyoqXG4gKiBDb252ZXJ0IGEgaW5wdXQgdmFsdWUgdG8gYSBudW1iZXIgZm9yIHBlcnNpc3RlbmNlLlxuICogSWYgdGhlIGNvbnZlcnNpb24gZmFpbHMsIHJldHVybiBvcmlnaW5hbCBzdHJpbmcuXG4gKi9cbmZ1bmN0aW9uIHRvTnVtYmVyICh2YWwpIHtcbiAgdmFyIG4gPSBwYXJzZUZsb2F0KHZhbCk7XG4gIHJldHVybiBpc05hTihuKSA/IHZhbCA6IG5cbn1cblxuLyoqXG4gKiBNYWtlIGEgbWFwIGFuZCByZXR1cm4gYSBmdW5jdGlvbiBmb3IgY2hlY2tpbmcgaWYgYSBrZXlcbiAqIGlzIGluIHRoYXQgbWFwLlxuICovXG5mdW5jdGlvbiBtYWtlTWFwIChcbiAgc3RyLFxuICBleHBlY3RzTG93ZXJDYXNlXG4pIHtcbiAgdmFyIG1hcCA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gIHZhciBsaXN0ID0gc3RyLnNwbGl0KCcsJyk7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGlzdC5sZW5ndGg7IGkrKykge1xuICAgIG1hcFtsaXN0W2ldXSA9IHRydWU7XG4gIH1cbiAgcmV0dXJuIGV4cGVjdHNMb3dlckNhc2VcbiAgICA/IGZ1bmN0aW9uICh2YWwpIHsgcmV0dXJuIG1hcFt2YWwudG9Mb3dlckNhc2UoKV07IH1cbiAgICA6IGZ1bmN0aW9uICh2YWwpIHsgcmV0dXJuIG1hcFt2YWxdOyB9XG59XG5cbi8qKlxuICogQ2hlY2sgaWYgYSB0YWcgaXMgYSBidWlsdC1pbiB0YWcuXG4gKi9cbnZhciBpc0J1aWx0SW5UYWcgPSBtYWtlTWFwKCdzbG90LGNvbXBvbmVudCcsIHRydWUpO1xuXG4vKipcbiAqIENoZWNrIGlmIGEgYXR0cmlidXRlIGlzIGEgcmVzZXJ2ZWQgYXR0cmlidXRlLlxuICovXG52YXIgaXNSZXNlcnZlZEF0dHJpYnV0ZSA9IG1ha2VNYXAoJ2tleSxyZWYsc2xvdCxzbG90LXNjb3BlLGlzJyk7XG5cbi8qKlxuICogUmVtb3ZlIGFuIGl0ZW0gZnJvbSBhbiBhcnJheVxuICovXG5mdW5jdGlvbiByZW1vdmUgKGFyciwgaXRlbSkge1xuICBpZiAoYXJyLmxlbmd0aCkge1xuICAgIHZhciBpbmRleCA9IGFyci5pbmRleE9mKGl0ZW0pO1xuICAgIGlmIChpbmRleCA+IC0xKSB7XG4gICAgICByZXR1cm4gYXJyLnNwbGljZShpbmRleCwgMSlcbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBDaGVjayB3aGV0aGVyIHRoZSBvYmplY3QgaGFzIHRoZSBwcm9wZXJ0eS5cbiAqL1xudmFyIGhhc093blByb3BlcnR5ID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eTtcbmZ1bmN0aW9uIGhhc093biAob2JqLCBrZXkpIHtcbiAgcmV0dXJuIGhhc093blByb3BlcnR5LmNhbGwob2JqLCBrZXkpXG59XG5cbi8qKlxuICogQ3JlYXRlIGEgY2FjaGVkIHZlcnNpb24gb2YgYSBwdXJlIGZ1bmN0aW9uLlxuICovXG5mdW5jdGlvbiBjYWNoZWQgKGZuKSB7XG4gIHZhciBjYWNoZSA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gIHJldHVybiAoZnVuY3Rpb24gY2FjaGVkRm4gKHN0cikge1xuICAgIHZhciBoaXQgPSBjYWNoZVtzdHJdO1xuICAgIHJldHVybiBoaXQgfHwgKGNhY2hlW3N0cl0gPSBmbihzdHIpKVxuICB9KVxufVxuXG4vKipcbiAqIENhbWVsaXplIGEgaHlwaGVuLWRlbGltaXRlZCBzdHJpbmcuXG4gKi9cbnZhciBjYW1lbGl6ZVJFID0gLy0oXFx3KS9nO1xudmFyIGNhbWVsaXplID0gY2FjaGVkKGZ1bmN0aW9uIChzdHIpIHtcbiAgcmV0dXJuIHN0ci5yZXBsYWNlKGNhbWVsaXplUkUsIGZ1bmN0aW9uIChfLCBjKSB7IHJldHVybiBjID8gYy50b1VwcGVyQ2FzZSgpIDogJyc7IH0pXG59KTtcblxuLyoqXG4gKiBDYXBpdGFsaXplIGEgc3RyaW5nLlxuICovXG52YXIgY2FwaXRhbGl6ZSA9IGNhY2hlZChmdW5jdGlvbiAoc3RyKSB7XG4gIHJldHVybiBzdHIuY2hhckF0KDApLnRvVXBwZXJDYXNlKCkgKyBzdHIuc2xpY2UoMSlcbn0pO1xuXG4vKipcbiAqIEh5cGhlbmF0ZSBhIGNhbWVsQ2FzZSBzdHJpbmcuXG4gKi9cbnZhciBoeXBoZW5hdGVSRSA9IC9cXEIoW0EtWl0pL2c7XG52YXIgaHlwaGVuYXRlID0gY2FjaGVkKGZ1bmN0aW9uIChzdHIpIHtcbiAgcmV0dXJuIHN0ci5yZXBsYWNlKGh5cGhlbmF0ZVJFLCAnLSQxJykudG9Mb3dlckNhc2UoKVxufSk7XG5cbi8qKlxuICogU2ltcGxlIGJpbmQsIGZhc3RlciB0aGFuIG5hdGl2ZVxuICovXG5mdW5jdGlvbiBiaW5kIChmbiwgY3R4KSB7XG4gIGZ1bmN0aW9uIGJvdW5kRm4gKGEpIHtcbiAgICB2YXIgbCA9IGFyZ3VtZW50cy5sZW5ndGg7XG4gICAgcmV0dXJuIGxcbiAgICAgID8gbCA+IDFcbiAgICAgICAgPyBmbi5hcHBseShjdHgsIGFyZ3VtZW50cylcbiAgICAgICAgOiBmbi5jYWxsKGN0eCwgYSlcbiAgICAgIDogZm4uY2FsbChjdHgpXG4gIH1cbiAgLy8gcmVjb3JkIG9yaWdpbmFsIGZuIGxlbmd0aFxuICBib3VuZEZuLl9sZW5ndGggPSBmbi5sZW5ndGg7XG4gIHJldHVybiBib3VuZEZuXG59XG5cbi8qKlxuICogQ29udmVydCBhbiBBcnJheS1saWtlIG9iamVjdCB0byBhIHJlYWwgQXJyYXkuXG4gKi9cbmZ1bmN0aW9uIHRvQXJyYXkgKGxpc3QsIHN0YXJ0KSB7XG4gIHN0YXJ0ID0gc3RhcnQgfHwgMDtcbiAgdmFyIGkgPSBsaXN0Lmxlbmd0aCAtIHN0YXJ0O1xuICB2YXIgcmV0ID0gbmV3IEFycmF5KGkpO1xuICB3aGlsZSAoaS0tKSB7XG4gICAgcmV0W2ldID0gbGlzdFtpICsgc3RhcnRdO1xuICB9XG4gIHJldHVybiByZXRcbn1cblxuLyoqXG4gKiBNaXggcHJvcGVydGllcyBpbnRvIHRhcmdldCBvYmplY3QuXG4gKi9cbmZ1bmN0aW9uIGV4dGVuZCAodG8sIF9mcm9tKSB7XG4gIGZvciAodmFyIGtleSBpbiBfZnJvbSkge1xuICAgIHRvW2tleV0gPSBfZnJvbVtrZXldO1xuICB9XG4gIHJldHVybiB0b1xufVxuXG4vKipcbiAqIE1lcmdlIGFuIEFycmF5IG9mIE9iamVjdHMgaW50byBhIHNpbmdsZSBPYmplY3QuXG4gKi9cbmZ1bmN0aW9uIHRvT2JqZWN0IChhcnIpIHtcbiAgdmFyIHJlcyA9IHt9O1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGFyci5sZW5ndGg7IGkrKykge1xuICAgIGlmIChhcnJbaV0pIHtcbiAgICAgIGV4dGVuZChyZXMsIGFycltpXSk7XG4gICAgfVxuICB9XG4gIHJldHVybiByZXNcbn1cblxuLyoqXG4gKiBQZXJmb3JtIG5vIG9wZXJhdGlvbi5cbiAqIFN0dWJiaW5nIGFyZ3MgdG8gbWFrZSBGbG93IGhhcHB5IHdpdGhvdXQgbGVhdmluZyB1c2VsZXNzIHRyYW5zcGlsZWQgY29kZVxuICogd2l0aCAuLi5yZXN0IChodHRwczovL2Zsb3cub3JnL2Jsb2cvMjAxNy8wNS8wNy9TdHJpY3QtRnVuY3Rpb24tQ2FsbC1Bcml0eS8pXG4gKi9cbmZ1bmN0aW9uIG5vb3AgKGEsIGIsIGMpIHt9XG5cbi8qKlxuICogQWx3YXlzIHJldHVybiBmYWxzZS5cbiAqL1xudmFyIG5vID0gZnVuY3Rpb24gKGEsIGIsIGMpIHsgcmV0dXJuIGZhbHNlOyB9O1xuXG4vKipcbiAqIFJldHVybiBzYW1lIHZhbHVlXG4gKi9cbnZhciBpZGVudGl0eSA9IGZ1bmN0aW9uIChfKSB7IHJldHVybiBfOyB9O1xuXG4vKipcbiAqIEdlbmVyYXRlIGEgc3RhdGljIGtleXMgc3RyaW5nIGZyb20gY29tcGlsZXIgbW9kdWxlcy5cbiAqL1xuZnVuY3Rpb24gZ2VuU3RhdGljS2V5cyAobW9kdWxlcykge1xuICByZXR1cm4gbW9kdWxlcy5yZWR1Y2UoZnVuY3Rpb24gKGtleXMsIG0pIHtcbiAgICByZXR1cm4ga2V5cy5jb25jYXQobS5zdGF0aWNLZXlzIHx8IFtdKVxuICB9LCBbXSkuam9pbignLCcpXG59XG5cbi8qKlxuICogQ2hlY2sgaWYgdHdvIHZhbHVlcyBhcmUgbG9vc2VseSBlcXVhbCAtIHRoYXQgaXMsXG4gKiBpZiB0aGV5IGFyZSBwbGFpbiBvYmplY3RzLCBkbyB0aGV5IGhhdmUgdGhlIHNhbWUgc2hhcGU/XG4gKi9cbmZ1bmN0aW9uIGxvb3NlRXF1YWwgKGEsIGIpIHtcbiAgaWYgKGEgPT09IGIpIHsgcmV0dXJuIHRydWUgfVxuICB2YXIgaXNPYmplY3RBID0gaXNPYmplY3QoYSk7XG4gIHZhciBpc09iamVjdEIgPSBpc09iamVjdChiKTtcbiAgaWYgKGlzT2JqZWN0QSAmJiBpc09iamVjdEIpIHtcbiAgICB0cnkge1xuICAgICAgdmFyIGlzQXJyYXlBID0gQXJyYXkuaXNBcnJheShhKTtcbiAgICAgIHZhciBpc0FycmF5QiA9IEFycmF5LmlzQXJyYXkoYik7XG4gICAgICBpZiAoaXNBcnJheUEgJiYgaXNBcnJheUIpIHtcbiAgICAgICAgcmV0dXJuIGEubGVuZ3RoID09PSBiLmxlbmd0aCAmJiBhLmV2ZXJ5KGZ1bmN0aW9uIChlLCBpKSB7XG4gICAgICAgICAgcmV0dXJuIGxvb3NlRXF1YWwoZSwgYltpXSlcbiAgICAgICAgfSlcbiAgICAgIH0gZWxzZSBpZiAoIWlzQXJyYXlBICYmICFpc0FycmF5Qikge1xuICAgICAgICB2YXIga2V5c0EgPSBPYmplY3Qua2V5cyhhKTtcbiAgICAgICAgdmFyIGtleXNCID0gT2JqZWN0LmtleXMoYik7XG4gICAgICAgIHJldHVybiBrZXlzQS5sZW5ndGggPT09IGtleXNCLmxlbmd0aCAmJiBrZXlzQS5ldmVyeShmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgICAgcmV0dXJuIGxvb3NlRXF1YWwoYVtrZXldLCBiW2tleV0pXG4gICAgICAgIH0pXG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgIH1cbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgICAgcmV0dXJuIGZhbHNlXG4gICAgfVxuICB9IGVsc2UgaWYgKCFpc09iamVjdEEgJiYgIWlzT2JqZWN0Qikge1xuICAgIHJldHVybiBTdHJpbmcoYSkgPT09IFN0cmluZyhiKVxuICB9IGVsc2Uge1xuICAgIHJldHVybiBmYWxzZVxuICB9XG59XG5cbmZ1bmN0aW9uIGxvb3NlSW5kZXhPZiAoYXJyLCB2YWwpIHtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcnIubGVuZ3RoOyBpKyspIHtcbiAgICBpZiAobG9vc2VFcXVhbChhcnJbaV0sIHZhbCkpIHsgcmV0dXJuIGkgfVxuICB9XG4gIHJldHVybiAtMVxufVxuXG4vKipcbiAqIEVuc3VyZSBhIGZ1bmN0aW9uIGlzIGNhbGxlZCBvbmx5IG9uY2UuXG4gKi9cbmZ1bmN0aW9uIG9uY2UgKGZuKSB7XG4gIHZhciBjYWxsZWQgPSBmYWxzZTtcbiAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoIWNhbGxlZCkge1xuICAgICAgY2FsbGVkID0gdHJ1ZTtcbiAgICAgIGZuLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfVxuICB9XG59XG5cbnZhciBTU1JfQVRUUiA9ICdkYXRhLXNlcnZlci1yZW5kZXJlZCc7XG5cbnZhciBBU1NFVF9UWVBFUyA9IFtcbiAgJ2NvbXBvbmVudCcsXG4gICdkaXJlY3RpdmUnLFxuICAnZmlsdGVyJ1xuXTtcblxudmFyIExJRkVDWUNMRV9IT09LUyA9IFtcbiAgJ2JlZm9yZUNyZWF0ZScsXG4gICdjcmVhdGVkJyxcbiAgJ2JlZm9yZU1vdW50JyxcbiAgJ21vdW50ZWQnLFxuICAnYmVmb3JlVXBkYXRlJyxcbiAgJ3VwZGF0ZWQnLFxuICAnYmVmb3JlRGVzdHJveScsXG4gICdkZXN0cm95ZWQnLFxuICAnYWN0aXZhdGVkJyxcbiAgJ2RlYWN0aXZhdGVkJyxcbiAgJ2Vycm9yQ2FwdHVyZWQnXG5dO1xuXG4vKiAgKi9cblxudmFyIGNvbmZpZyA9ICh7XG4gIC8qKlxuICAgKiBPcHRpb24gbWVyZ2Ugc3RyYXRlZ2llcyAodXNlZCBpbiBjb3JlL3V0aWwvb3B0aW9ucylcbiAgICovXG4gIC8vICRmbG93LWRpc2FibGUtbGluZVxuICBvcHRpb25NZXJnZVN0cmF0ZWdpZXM6IE9iamVjdC5jcmVhdGUobnVsbCksXG5cbiAgLyoqXG4gICAqIFdoZXRoZXIgdG8gc3VwcHJlc3Mgd2FybmluZ3MuXG4gICAqL1xuICBzaWxlbnQ6IGZhbHNlLFxuXG4gIC8qKlxuICAgKiBTaG93IHByb2R1Y3Rpb24gbW9kZSB0aXAgbWVzc2FnZSBvbiBib290P1xuICAgKi9cbiAgcHJvZHVjdGlvblRpcDogcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyxcblxuICAvKipcbiAgICogV2hldGhlciB0byBlbmFibGUgZGV2dG9vbHNcbiAgICovXG4gIGRldnRvb2xzOiBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nLFxuXG4gIC8qKlxuICAgKiBXaGV0aGVyIHRvIHJlY29yZCBwZXJmXG4gICAqL1xuICBwZXJmb3JtYW5jZTogZmFsc2UsXG5cbiAgLyoqXG4gICAqIEVycm9yIGhhbmRsZXIgZm9yIHdhdGNoZXIgZXJyb3JzXG4gICAqL1xuICBlcnJvckhhbmRsZXI6IG51bGwsXG5cbiAgLyoqXG4gICAqIFdhcm4gaGFuZGxlciBmb3Igd2F0Y2hlciB3YXJuc1xuICAgKi9cbiAgd2FybkhhbmRsZXI6IG51bGwsXG5cbiAgLyoqXG4gICAqIElnbm9yZSBjZXJ0YWluIGN1c3RvbSBlbGVtZW50c1xuICAgKi9cbiAgaWdub3JlZEVsZW1lbnRzOiBbXSxcblxuICAvKipcbiAgICogQ3VzdG9tIHVzZXIga2V5IGFsaWFzZXMgZm9yIHYtb25cbiAgICovXG4gIC8vICRmbG93LWRpc2FibGUtbGluZVxuICBrZXlDb2RlczogT2JqZWN0LmNyZWF0ZShudWxsKSxcblxuICAvKipcbiAgICogQ2hlY2sgaWYgYSB0YWcgaXMgcmVzZXJ2ZWQgc28gdGhhdCBpdCBjYW5ub3QgYmUgcmVnaXN0ZXJlZCBhcyBhXG4gICAqIGNvbXBvbmVudC4gVGhpcyBpcyBwbGF0Zm9ybS1kZXBlbmRlbnQgYW5kIG1heSBiZSBvdmVyd3JpdHRlbi5cbiAgICovXG4gIGlzUmVzZXJ2ZWRUYWc6IG5vLFxuXG4gIC8qKlxuICAgKiBDaGVjayBpZiBhbiBhdHRyaWJ1dGUgaXMgcmVzZXJ2ZWQgc28gdGhhdCBpdCBjYW5ub3QgYmUgdXNlZCBhcyBhIGNvbXBvbmVudFxuICAgKiBwcm9wLiBUaGlzIGlzIHBsYXRmb3JtLWRlcGVuZGVudCBhbmQgbWF5IGJlIG92ZXJ3cml0dGVuLlxuICAgKi9cbiAgaXNSZXNlcnZlZEF0dHI6IG5vLFxuXG4gIC8qKlxuICAgKiBDaGVjayBpZiBhIHRhZyBpcyBhbiB1bmtub3duIGVsZW1lbnQuXG4gICAqIFBsYXRmb3JtLWRlcGVuZGVudC5cbiAgICovXG4gIGlzVW5rbm93bkVsZW1lbnQ6IG5vLFxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIG5hbWVzcGFjZSBvZiBhbiBlbGVtZW50XG4gICAqL1xuICBnZXRUYWdOYW1lc3BhY2U6IG5vb3AsXG5cbiAgLyoqXG4gICAqIFBhcnNlIHRoZSByZWFsIHRhZyBuYW1lIGZvciB0aGUgc3BlY2lmaWMgcGxhdGZvcm0uXG4gICAqL1xuICBwYXJzZVBsYXRmb3JtVGFnTmFtZTogaWRlbnRpdHksXG5cbiAgLyoqXG4gICAqIENoZWNrIGlmIGFuIGF0dHJpYnV0ZSBtdXN0IGJlIGJvdW5kIHVzaW5nIHByb3BlcnR5LCBlLmcuIHZhbHVlXG4gICAqIFBsYXRmb3JtLWRlcGVuZGVudC5cbiAgICovXG4gIG11c3RVc2VQcm9wOiBubyxcblxuICAvKipcbiAgICogRXhwb3NlZCBmb3IgbGVnYWN5IHJlYXNvbnNcbiAgICovXG4gIF9saWZlY3ljbGVIb29rczogTElGRUNZQ0xFX0hPT0tTXG59KTtcblxuLyogICovXG5cbi8qKlxuICogQ2hlY2sgaWYgYSBzdHJpbmcgc3RhcnRzIHdpdGggJCBvciBfXG4gKi9cbmZ1bmN0aW9uIGlzUmVzZXJ2ZWQgKHN0cikge1xuICB2YXIgYyA9IChzdHIgKyAnJykuY2hhckNvZGVBdCgwKTtcbiAgcmV0dXJuIGMgPT09IDB4MjQgfHwgYyA9PT0gMHg1RlxufVxuXG4vKipcbiAqIERlZmluZSBhIHByb3BlcnR5LlxuICovXG5mdW5jdGlvbiBkZWYgKG9iaiwga2V5LCB2YWwsIGVudW1lcmFibGUpIHtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iaiwga2V5LCB7XG4gICAgdmFsdWU6IHZhbCxcbiAgICBlbnVtZXJhYmxlOiAhIWVudW1lcmFibGUsXG4gICAgd3JpdGFibGU6IHRydWUsXG4gICAgY29uZmlndXJhYmxlOiB0cnVlXG4gIH0pO1xufVxuXG4vKipcbiAqIFBhcnNlIHNpbXBsZSBwYXRoLlxuICovXG52YXIgYmFpbFJFID0gL1teXFx3LiRdLztcbmZ1bmN0aW9uIHBhcnNlUGF0aCAocGF0aCkge1xuICBpZiAoYmFpbFJFLnRlc3QocGF0aCkpIHtcbiAgICByZXR1cm5cbiAgfVxuICB2YXIgc2VnbWVudHMgPSBwYXRoLnNwbGl0KCcuJyk7XG4gIHJldHVybiBmdW5jdGlvbiAob2JqKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzZWdtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgaWYgKCFvYmopIHsgcmV0dXJuIH1cbiAgICAgIG9iaiA9IG9ialtzZWdtZW50c1tpXV07XG4gICAgfVxuICAgIHJldHVybiBvYmpcbiAgfVxufVxuXG4vKiAgKi9cblxuXG4vLyBjYW4gd2UgdXNlIF9fcHJvdG9fXz9cbnZhciBoYXNQcm90byA9ICdfX3Byb3RvX18nIGluIHt9O1xuXG4vLyBCcm93c2VyIGVudmlyb25tZW50IHNuaWZmaW5nXG52YXIgaW5Ccm93c2VyID0gdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCc7XG52YXIgaW5XZWV4ID0gdHlwZW9mIFdYRW52aXJvbm1lbnQgIT09ICd1bmRlZmluZWQnICYmICEhV1hFbnZpcm9ubWVudC5wbGF0Zm9ybTtcbnZhciB3ZWV4UGxhdGZvcm0gPSBpbldlZXggJiYgV1hFbnZpcm9ubWVudC5wbGF0Zm9ybS50b0xvd2VyQ2FzZSgpO1xudmFyIFVBID0gaW5Ccm93c2VyICYmIHdpbmRvdy5uYXZpZ2F0b3IudXNlckFnZW50LnRvTG93ZXJDYXNlKCk7XG52YXIgaXNJRSA9IFVBICYmIC9tc2llfHRyaWRlbnQvLnRlc3QoVUEpO1xudmFyIGlzSUU5ID0gVUEgJiYgVUEuaW5kZXhPZignbXNpZSA5LjAnKSA+IDA7XG52YXIgaXNFZGdlID0gVUEgJiYgVUEuaW5kZXhPZignZWRnZS8nKSA+IDA7XG52YXIgaXNBbmRyb2lkID0gKFVBICYmIFVBLmluZGV4T2YoJ2FuZHJvaWQnKSA+IDApIHx8ICh3ZWV4UGxhdGZvcm0gPT09ICdhbmRyb2lkJyk7XG52YXIgaXNJT1MgPSAoVUEgJiYgL2lwaG9uZXxpcGFkfGlwb2R8aW9zLy50ZXN0KFVBKSkgfHwgKHdlZXhQbGF0Zm9ybSA9PT0gJ2lvcycpO1xudmFyIGlzQ2hyb21lID0gVUEgJiYgL2Nocm9tZVxcL1xcZCsvLnRlc3QoVUEpICYmICFpc0VkZ2U7XG5cbi8vIEZpcmVmb3ggaGFzIGEgXCJ3YXRjaFwiIGZ1bmN0aW9uIG9uIE9iamVjdC5wcm90b3R5cGUuLi5cbnZhciBuYXRpdmVXYXRjaCA9ICh7fSkud2F0Y2g7XG5cbnZhciBzdXBwb3J0c1Bhc3NpdmUgPSBmYWxzZTtcbmlmIChpbkJyb3dzZXIpIHtcbiAgdHJ5IHtcbiAgICB2YXIgb3B0cyA9IHt9O1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvcHRzLCAncGFzc2l2ZScsICh7XG4gICAgICBnZXQ6IGZ1bmN0aW9uIGdldCAoKSB7XG4gICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgICAgIHN1cHBvcnRzUGFzc2l2ZSA9IHRydWU7XG4gICAgICB9XG4gICAgfSkpOyAvLyBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svZmxvdy9pc3N1ZXMvMjg1XG4gICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ3Rlc3QtcGFzc2l2ZScsIG51bGwsIG9wdHMpO1xuICB9IGNhdGNoIChlKSB7fVxufVxuXG4vLyB0aGlzIG5lZWRzIHRvIGJlIGxhenktZXZhbGVkIGJlY2F1c2UgdnVlIG1heSBiZSByZXF1aXJlZCBiZWZvcmVcbi8vIHZ1ZS1zZXJ2ZXItcmVuZGVyZXIgY2FuIHNldCBWVUVfRU5WXG52YXIgX2lzU2VydmVyO1xudmFyIGlzU2VydmVyUmVuZGVyaW5nID0gZnVuY3Rpb24gKCkge1xuICBpZiAoX2lzU2VydmVyID09PSB1bmRlZmluZWQpIHtcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICBpZiAoIWluQnJvd3NlciAmJiB0eXBlb2YgZ2xvYmFsICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgLy8gZGV0ZWN0IHByZXNlbmNlIG9mIHZ1ZS1zZXJ2ZXItcmVuZGVyZXIgYW5kIGF2b2lkXG4gICAgICAvLyBXZWJwYWNrIHNoaW1taW5nIHRoZSBwcm9jZXNzXG4gICAgICBfaXNTZXJ2ZXIgPSBnbG9iYWxbJ3Byb2Nlc3MnXS5lbnYuVlVFX0VOViA9PT0gJ3NlcnZlcic7XG4gICAgfSBlbHNlIHtcbiAgICAgIF9pc1NlcnZlciA9IGZhbHNlO1xuICAgIH1cbiAgfVxuICByZXR1cm4gX2lzU2VydmVyXG59O1xuXG4vLyBkZXRlY3QgZGV2dG9vbHNcbnZhciBkZXZ0b29scyA9IGluQnJvd3NlciAmJiB3aW5kb3cuX19WVUVfREVWVE9PTFNfR0xPQkFMX0hPT0tfXztcblxuLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbmZ1bmN0aW9uIGlzTmF0aXZlIChDdG9yKSB7XG4gIHJldHVybiB0eXBlb2YgQ3RvciA9PT0gJ2Z1bmN0aW9uJyAmJiAvbmF0aXZlIGNvZGUvLnRlc3QoQ3Rvci50b1N0cmluZygpKVxufVxuXG52YXIgaGFzU3ltYm9sID1cbiAgdHlwZW9mIFN5bWJvbCAhPT0gJ3VuZGVmaW5lZCcgJiYgaXNOYXRpdmUoU3ltYm9sKSAmJlxuICB0eXBlb2YgUmVmbGVjdCAhPT0gJ3VuZGVmaW5lZCcgJiYgaXNOYXRpdmUoUmVmbGVjdC5vd25LZXlzKTtcblxudmFyIF9TZXQ7XG4vKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi8gLy8gJGZsb3ctZGlzYWJsZS1saW5lXG5pZiAodHlwZW9mIFNldCAhPT0gJ3VuZGVmaW5lZCcgJiYgaXNOYXRpdmUoU2V0KSkge1xuICAvLyB1c2UgbmF0aXZlIFNldCB3aGVuIGF2YWlsYWJsZS5cbiAgX1NldCA9IFNldDtcbn0gZWxzZSB7XG4gIC8vIGEgbm9uLXN0YW5kYXJkIFNldCBwb2x5ZmlsbCB0aGF0IG9ubHkgd29ya3Mgd2l0aCBwcmltaXRpdmUga2V5cy5cbiAgX1NldCA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gU2V0ICgpIHtcbiAgICAgIHRoaXMuc2V0ID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICB9XG4gICAgU2V0LnByb3RvdHlwZS5oYXMgPSBmdW5jdGlvbiBoYXMgKGtleSkge1xuICAgICAgcmV0dXJuIHRoaXMuc2V0W2tleV0gPT09IHRydWVcbiAgICB9O1xuICAgIFNldC5wcm90b3R5cGUuYWRkID0gZnVuY3Rpb24gYWRkIChrZXkpIHtcbiAgICAgIHRoaXMuc2V0W2tleV0gPSB0cnVlO1xuICAgIH07XG4gICAgU2V0LnByb3RvdHlwZS5jbGVhciA9IGZ1bmN0aW9uIGNsZWFyICgpIHtcbiAgICAgIHRoaXMuc2V0ID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICB9O1xuXG4gICAgcmV0dXJuIFNldDtcbiAgfSgpKTtcbn1cblxuLyogICovXG5cbnZhciB3YXJuID0gbm9vcDtcbnZhciB0aXAgPSBub29wO1xudmFyIGdlbmVyYXRlQ29tcG9uZW50VHJhY2UgPSAobm9vcCk7IC8vIHdvcmsgYXJvdW5kIGZsb3cgY2hlY2tcbnZhciBmb3JtYXRDb21wb25lbnROYW1lID0gKG5vb3ApO1xuXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICB2YXIgaGFzQ29uc29sZSA9IHR5cGVvZiBjb25zb2xlICE9PSAndW5kZWZpbmVkJztcbiAgdmFyIGNsYXNzaWZ5UkUgPSAvKD86XnxbLV9dKShcXHcpL2c7XG4gIHZhciBjbGFzc2lmeSA9IGZ1bmN0aW9uIChzdHIpIHsgcmV0dXJuIHN0clxuICAgIC5yZXBsYWNlKGNsYXNzaWZ5UkUsIGZ1bmN0aW9uIChjKSB7IHJldHVybiBjLnRvVXBwZXJDYXNlKCk7IH0pXG4gICAgLnJlcGxhY2UoL1stX10vZywgJycpOyB9O1xuXG4gIHdhcm4gPSBmdW5jdGlvbiAobXNnLCB2bSkge1xuICAgIHZhciB0cmFjZSA9IHZtID8gZ2VuZXJhdGVDb21wb25lbnRUcmFjZSh2bSkgOiAnJztcblxuICAgIGlmIChjb25maWcud2FybkhhbmRsZXIpIHtcbiAgICAgIGNvbmZpZy53YXJuSGFuZGxlci5jYWxsKG51bGwsIG1zZywgdm0sIHRyYWNlKTtcbiAgICB9IGVsc2UgaWYgKGhhc0NvbnNvbGUgJiYgKCFjb25maWcuc2lsZW50KSkge1xuICAgICAgY29uc29sZS5lcnJvcigoXCJbVnVlIHdhcm5dOiBcIiArIG1zZyArIHRyYWNlKSk7XG4gICAgfVxuICB9O1xuXG4gIHRpcCA9IGZ1bmN0aW9uIChtc2csIHZtKSB7XG4gICAgaWYgKGhhc0NvbnNvbGUgJiYgKCFjb25maWcuc2lsZW50KSkge1xuICAgICAgY29uc29sZS53YXJuKFwiW1Z1ZSB0aXBdOiBcIiArIG1zZyArIChcbiAgICAgICAgdm0gPyBnZW5lcmF0ZUNvbXBvbmVudFRyYWNlKHZtKSA6ICcnXG4gICAgICApKTtcbiAgICB9XG4gIH07XG5cbiAgZm9ybWF0Q29tcG9uZW50TmFtZSA9IGZ1bmN0aW9uICh2bSwgaW5jbHVkZUZpbGUpIHtcbiAgICBpZiAodm0uJHJvb3QgPT09IHZtKSB7XG4gICAgICByZXR1cm4gJzxSb290PidcbiAgICB9XG4gICAgdmFyIG9wdGlvbnMgPSB0eXBlb2Ygdm0gPT09ICdmdW5jdGlvbicgJiYgdm0uY2lkICE9IG51bGxcbiAgICAgID8gdm0ub3B0aW9uc1xuICAgICAgOiB2bS5faXNWdWVcbiAgICAgICAgPyB2bS4kb3B0aW9ucyB8fCB2bS5jb25zdHJ1Y3Rvci5vcHRpb25zXG4gICAgICAgIDogdm0gfHwge307XG4gICAgdmFyIG5hbWUgPSBvcHRpb25zLm5hbWUgfHwgb3B0aW9ucy5fY29tcG9uZW50VGFnO1xuICAgIHZhciBmaWxlID0gb3B0aW9ucy5fX2ZpbGU7XG4gICAgaWYgKCFuYW1lICYmIGZpbGUpIHtcbiAgICAgIHZhciBtYXRjaCA9IGZpbGUubWF0Y2goLyhbXi9cXFxcXSspXFwudnVlJC8pO1xuICAgICAgbmFtZSA9IG1hdGNoICYmIG1hdGNoWzFdO1xuICAgIH1cblxuICAgIHJldHVybiAoXG4gICAgICAobmFtZSA/IChcIjxcIiArIChjbGFzc2lmeShuYW1lKSkgKyBcIj5cIikgOiBcIjxBbm9ueW1vdXM+XCIpICtcbiAgICAgIChmaWxlICYmIGluY2x1ZGVGaWxlICE9PSBmYWxzZSA/IChcIiBhdCBcIiArIGZpbGUpIDogJycpXG4gICAgKVxuICB9O1xuXG4gIHZhciByZXBlYXQgPSBmdW5jdGlvbiAoc3RyLCBuKSB7XG4gICAgdmFyIHJlcyA9ICcnO1xuICAgIHdoaWxlIChuKSB7XG4gICAgICBpZiAobiAlIDIgPT09IDEpIHsgcmVzICs9IHN0cjsgfVxuICAgICAgaWYgKG4gPiAxKSB7IHN0ciArPSBzdHI7IH1cbiAgICAgIG4gPj49IDE7XG4gICAgfVxuICAgIHJldHVybiByZXNcbiAgfTtcblxuICBnZW5lcmF0ZUNvbXBvbmVudFRyYWNlID0gZnVuY3Rpb24gKHZtKSB7XG4gICAgaWYgKHZtLl9pc1Z1ZSAmJiB2bS4kcGFyZW50KSB7XG4gICAgICB2YXIgdHJlZSA9IFtdO1xuICAgICAgdmFyIGN1cnJlbnRSZWN1cnNpdmVTZXF1ZW5jZSA9IDA7XG4gICAgICB3aGlsZSAodm0pIHtcbiAgICAgICAgaWYgKHRyZWUubGVuZ3RoID4gMCkge1xuICAgICAgICAgIHZhciBsYXN0ID0gdHJlZVt0cmVlLmxlbmd0aCAtIDFdO1xuICAgICAgICAgIGlmIChsYXN0LmNvbnN0cnVjdG9yID09PSB2bS5jb25zdHJ1Y3Rvcikge1xuICAgICAgICAgICAgY3VycmVudFJlY3Vyc2l2ZVNlcXVlbmNlKys7XG4gICAgICAgICAgICB2bSA9IHZtLiRwYXJlbnQ7XG4gICAgICAgICAgICBjb250aW51ZVxuICAgICAgICAgIH0gZWxzZSBpZiAoY3VycmVudFJlY3Vyc2l2ZVNlcXVlbmNlID4gMCkge1xuICAgICAgICAgICAgdHJlZVt0cmVlLmxlbmd0aCAtIDFdID0gW2xhc3QsIGN1cnJlbnRSZWN1cnNpdmVTZXF1ZW5jZV07XG4gICAgICAgICAgICBjdXJyZW50UmVjdXJzaXZlU2VxdWVuY2UgPSAwO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0cmVlLnB1c2godm0pO1xuICAgICAgICB2bSA9IHZtLiRwYXJlbnQ7XG4gICAgICB9XG4gICAgICByZXR1cm4gJ1xcblxcbmZvdW5kIGluXFxuXFxuJyArIHRyZWVcbiAgICAgICAgLm1hcChmdW5jdGlvbiAodm0sIGkpIHsgcmV0dXJuIChcIlwiICsgKGkgPT09IDAgPyAnLS0tPiAnIDogcmVwZWF0KCcgJywgNSArIGkgKiAyKSkgKyAoQXJyYXkuaXNBcnJheSh2bSlcbiAgICAgICAgICAgID8gKChmb3JtYXRDb21wb25lbnROYW1lKHZtWzBdKSkgKyBcIi4uLiAoXCIgKyAodm1bMV0pICsgXCIgcmVjdXJzaXZlIGNhbGxzKVwiKVxuICAgICAgICAgICAgOiBmb3JtYXRDb21wb25lbnROYW1lKHZtKSkpOyB9KVxuICAgICAgICAuam9pbignXFxuJylcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIChcIlxcblxcbihmb3VuZCBpbiBcIiArIChmb3JtYXRDb21wb25lbnROYW1lKHZtKSkgKyBcIilcIilcbiAgICB9XG4gIH07XG59XG5cbi8qICAqL1xuXG5cbnZhciB1aWQgPSAwO1xuXG4vKipcbiAqIEEgZGVwIGlzIGFuIG9ic2VydmFibGUgdGhhdCBjYW4gaGF2ZSBtdWx0aXBsZVxuICogZGlyZWN0aXZlcyBzdWJzY3JpYmluZyB0byBpdC5cbiAqL1xudmFyIERlcCA9IGZ1bmN0aW9uIERlcCAoKSB7XG4gIHRoaXMuaWQgPSB1aWQrKztcbiAgdGhpcy5zdWJzID0gW107XG59O1xuXG5EZXAucHJvdG90eXBlLmFkZFN1YiA9IGZ1bmN0aW9uIGFkZFN1YiAoc3ViKSB7XG4gIHRoaXMuc3Vicy5wdXNoKHN1Yik7XG59O1xuXG5EZXAucHJvdG90eXBlLnJlbW92ZVN1YiA9IGZ1bmN0aW9uIHJlbW92ZVN1YiAoc3ViKSB7XG4gIHJlbW92ZSh0aGlzLnN1YnMsIHN1Yik7XG59O1xuXG5EZXAucHJvdG90eXBlLmRlcGVuZCA9IGZ1bmN0aW9uIGRlcGVuZCAoKSB7XG4gIGlmIChEZXAudGFyZ2V0KSB7XG4gICAgRGVwLnRhcmdldC5hZGREZXAodGhpcyk7XG4gIH1cbn07XG5cbkRlcC5wcm90b3R5cGUubm90aWZ5ID0gZnVuY3Rpb24gbm90aWZ5ICgpIHtcbiAgLy8gc3RhYmlsaXplIHRoZSBzdWJzY3JpYmVyIGxpc3QgZmlyc3RcbiAgdmFyIHN1YnMgPSB0aGlzLnN1YnMuc2xpY2UoKTtcbiAgZm9yICh2YXIgaSA9IDAsIGwgPSBzdWJzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgIHN1YnNbaV0udXBkYXRlKCk7XG4gIH1cbn07XG5cbi8vIHRoZSBjdXJyZW50IHRhcmdldCB3YXRjaGVyIGJlaW5nIGV2YWx1YXRlZC5cbi8vIHRoaXMgaXMgZ2xvYmFsbHkgdW5pcXVlIGJlY2F1c2UgdGhlcmUgY291bGQgYmUgb25seSBvbmVcbi8vIHdhdGNoZXIgYmVpbmcgZXZhbHVhdGVkIGF0IGFueSB0aW1lLlxuRGVwLnRhcmdldCA9IG51bGw7XG52YXIgdGFyZ2V0U3RhY2sgPSBbXTtcblxuZnVuY3Rpb24gcHVzaFRhcmdldCAoX3RhcmdldCkge1xuICBpZiAoRGVwLnRhcmdldCkgeyB0YXJnZXRTdGFjay5wdXNoKERlcC50YXJnZXQpOyB9XG4gIERlcC50YXJnZXQgPSBfdGFyZ2V0O1xufVxuXG5mdW5jdGlvbiBwb3BUYXJnZXQgKCkge1xuICBEZXAudGFyZ2V0ID0gdGFyZ2V0U3RhY2sucG9wKCk7XG59XG5cbi8qICAqL1xuXG52YXIgVk5vZGUgPSBmdW5jdGlvbiBWTm9kZSAoXG4gIHRhZyxcbiAgZGF0YSxcbiAgY2hpbGRyZW4sXG4gIHRleHQsXG4gIGVsbSxcbiAgY29udGV4dCxcbiAgY29tcG9uZW50T3B0aW9ucyxcbiAgYXN5bmNGYWN0b3J5XG4pIHtcbiAgdGhpcy50YWcgPSB0YWc7XG4gIHRoaXMuZGF0YSA9IGRhdGE7XG4gIHRoaXMuY2hpbGRyZW4gPSBjaGlsZHJlbjtcbiAgdGhpcy50ZXh0ID0gdGV4dDtcbiAgdGhpcy5lbG0gPSBlbG07XG4gIHRoaXMubnMgPSB1bmRlZmluZWQ7XG4gIHRoaXMuY29udGV4dCA9IGNvbnRleHQ7XG4gIHRoaXMuZm5Db250ZXh0ID0gdW5kZWZpbmVkO1xuICB0aGlzLmZuT3B0aW9ucyA9IHVuZGVmaW5lZDtcbiAgdGhpcy5mblNjb3BlSWQgPSB1bmRlZmluZWQ7XG4gIHRoaXMua2V5ID0gZGF0YSAmJiBkYXRhLmtleTtcbiAgdGhpcy5jb21wb25lbnRPcHRpb25zID0gY29tcG9uZW50T3B0aW9ucztcbiAgdGhpcy5jb21wb25lbnRJbnN0YW5jZSA9IHVuZGVmaW5lZDtcbiAgdGhpcy5wYXJlbnQgPSB1bmRlZmluZWQ7XG4gIHRoaXMucmF3ID0gZmFsc2U7XG4gIHRoaXMuaXNTdGF0aWMgPSBmYWxzZTtcbiAgdGhpcy5pc1Jvb3RJbnNlcnQgPSB0cnVlO1xuICB0aGlzLmlzQ29tbWVudCA9IGZhbHNlO1xuICB0aGlzLmlzQ2xvbmVkID0gZmFsc2U7XG4gIHRoaXMuaXNPbmNlID0gZmFsc2U7XG4gIHRoaXMuYXN5bmNGYWN0b3J5ID0gYXN5bmNGYWN0b3J5O1xuICB0aGlzLmFzeW5jTWV0YSA9IHVuZGVmaW5lZDtcbiAgdGhpcy5pc0FzeW5jUGxhY2Vob2xkZXIgPSBmYWxzZTtcbn07XG5cbnZhciBwcm90b3R5cGVBY2Nlc3NvcnMgPSB7IGNoaWxkOiB7IGNvbmZpZ3VyYWJsZTogdHJ1ZSB9IH07XG5cbi8vIERFUFJFQ0FURUQ6IGFsaWFzIGZvciBjb21wb25lbnRJbnN0YW5jZSBmb3IgYmFja3dhcmRzIGNvbXBhdC5cbi8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG5wcm90b3R5cGVBY2Nlc3NvcnMuY2hpbGQuZ2V0ID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gdGhpcy5jb21wb25lbnRJbnN0YW5jZVxufTtcblxuT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoIFZOb2RlLnByb3RvdHlwZSwgcHJvdG90eXBlQWNjZXNzb3JzICk7XG5cbnZhciBjcmVhdGVFbXB0eVZOb2RlID0gZnVuY3Rpb24gKHRleHQpIHtcbiAgaWYgKCB0ZXh0ID09PSB2b2lkIDAgKSB0ZXh0ID0gJyc7XG5cbiAgdmFyIG5vZGUgPSBuZXcgVk5vZGUoKTtcbiAgbm9kZS50ZXh0ID0gdGV4dDtcbiAgbm9kZS5pc0NvbW1lbnQgPSB0cnVlO1xuICByZXR1cm4gbm9kZVxufTtcblxuZnVuY3Rpb24gY3JlYXRlVGV4dFZOb2RlICh2YWwpIHtcbiAgcmV0dXJuIG5ldyBWTm9kZSh1bmRlZmluZWQsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCBTdHJpbmcodmFsKSlcbn1cblxuLy8gb3B0aW1pemVkIHNoYWxsb3cgY2xvbmVcbi8vIHVzZWQgZm9yIHN0YXRpYyBub2RlcyBhbmQgc2xvdCBub2RlcyBiZWNhdXNlIHRoZXkgbWF5IGJlIHJldXNlZCBhY3Jvc3Ncbi8vIG11bHRpcGxlIHJlbmRlcnMsIGNsb25pbmcgdGhlbSBhdm9pZHMgZXJyb3JzIHdoZW4gRE9NIG1hbmlwdWxhdGlvbnMgcmVseVxuLy8gb24gdGhlaXIgZWxtIHJlZmVyZW5jZS5cbmZ1bmN0aW9uIGNsb25lVk5vZGUgKHZub2RlLCBkZWVwKSB7XG4gIHZhciBjb21wb25lbnRPcHRpb25zID0gdm5vZGUuY29tcG9uZW50T3B0aW9ucztcbiAgdmFyIGNsb25lZCA9IG5ldyBWTm9kZShcbiAgICB2bm9kZS50YWcsXG4gICAgdm5vZGUuZGF0YSxcbiAgICB2bm9kZS5jaGlsZHJlbixcbiAgICB2bm9kZS50ZXh0LFxuICAgIHZub2RlLmVsbSxcbiAgICB2bm9kZS5jb250ZXh0LFxuICAgIGNvbXBvbmVudE9wdGlvbnMsXG4gICAgdm5vZGUuYXN5bmNGYWN0b3J5XG4gICk7XG4gIGNsb25lZC5ucyA9IHZub2RlLm5zO1xuICBjbG9uZWQuaXNTdGF0aWMgPSB2bm9kZS5pc1N0YXRpYztcbiAgY2xvbmVkLmtleSA9IHZub2RlLmtleTtcbiAgY2xvbmVkLmlzQ29tbWVudCA9IHZub2RlLmlzQ29tbWVudDtcbiAgY2xvbmVkLmZuQ29udGV4dCA9IHZub2RlLmZuQ29udGV4dDtcbiAgY2xvbmVkLmZuT3B0aW9ucyA9IHZub2RlLmZuT3B0aW9ucztcbiAgY2xvbmVkLmZuU2NvcGVJZCA9IHZub2RlLmZuU2NvcGVJZDtcbiAgY2xvbmVkLmlzQ2xvbmVkID0gdHJ1ZTtcbiAgaWYgKGRlZXApIHtcbiAgICBpZiAodm5vZGUuY2hpbGRyZW4pIHtcbiAgICAgIGNsb25lZC5jaGlsZHJlbiA9IGNsb25lVk5vZGVzKHZub2RlLmNoaWxkcmVuLCB0cnVlKTtcbiAgICB9XG4gICAgaWYgKGNvbXBvbmVudE9wdGlvbnMgJiYgY29tcG9uZW50T3B0aW9ucy5jaGlsZHJlbikge1xuICAgICAgY29tcG9uZW50T3B0aW9ucy5jaGlsZHJlbiA9IGNsb25lVk5vZGVzKGNvbXBvbmVudE9wdGlvbnMuY2hpbGRyZW4sIHRydWUpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gY2xvbmVkXG59XG5cbmZ1bmN0aW9uIGNsb25lVk5vZGVzICh2bm9kZXMsIGRlZXApIHtcbiAgdmFyIGxlbiA9IHZub2Rlcy5sZW5ndGg7XG4gIHZhciByZXMgPSBuZXcgQXJyYXkobGVuKTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgIHJlc1tpXSA9IGNsb25lVk5vZGUodm5vZGVzW2ldLCBkZWVwKTtcbiAgfVxuICByZXR1cm4gcmVzXG59XG5cbi8qXG4gKiBub3QgdHlwZSBjaGVja2luZyB0aGlzIGZpbGUgYmVjYXVzZSBmbG93IGRvZXNuJ3QgcGxheSB3ZWxsIHdpdGhcbiAqIGR5bmFtaWNhbGx5IGFjY2Vzc2luZyBtZXRob2RzIG9uIEFycmF5IHByb3RvdHlwZVxuICovXG5cbnZhciBhcnJheVByb3RvID0gQXJyYXkucHJvdG90eXBlO1xudmFyIGFycmF5TWV0aG9kcyA9IE9iamVjdC5jcmVhdGUoYXJyYXlQcm90byk7W1xuICAncHVzaCcsXG4gICdwb3AnLFxuICAnc2hpZnQnLFxuICAndW5zaGlmdCcsXG4gICdzcGxpY2UnLFxuICAnc29ydCcsXG4gICdyZXZlcnNlJ1xuXS5mb3JFYWNoKGZ1bmN0aW9uIChtZXRob2QpIHtcbiAgLy8gY2FjaGUgb3JpZ2luYWwgbWV0aG9kXG4gIHZhciBvcmlnaW5hbCA9IGFycmF5UHJvdG9bbWV0aG9kXTtcbiAgZGVmKGFycmF5TWV0aG9kcywgbWV0aG9kLCBmdW5jdGlvbiBtdXRhdG9yICgpIHtcbiAgICB2YXIgYXJncyA9IFtdLCBsZW4gPSBhcmd1bWVudHMubGVuZ3RoO1xuICAgIHdoaWxlICggbGVuLS0gKSBhcmdzWyBsZW4gXSA9IGFyZ3VtZW50c1sgbGVuIF07XG5cbiAgICB2YXIgcmVzdWx0ID0gb3JpZ2luYWwuYXBwbHkodGhpcywgYXJncyk7XG4gICAgdmFyIG9iID0gdGhpcy5fX29iX187XG4gICAgdmFyIGluc2VydGVkO1xuICAgIHN3aXRjaCAobWV0aG9kKSB7XG4gICAgICBjYXNlICdwdXNoJzpcbiAgICAgIGNhc2UgJ3Vuc2hpZnQnOlxuICAgICAgICBpbnNlcnRlZCA9IGFyZ3M7XG4gICAgICAgIGJyZWFrXG4gICAgICBjYXNlICdzcGxpY2UnOlxuICAgICAgICBpbnNlcnRlZCA9IGFyZ3Muc2xpY2UoMik7XG4gICAgICAgIGJyZWFrXG4gICAgfVxuICAgIGlmIChpbnNlcnRlZCkgeyBvYi5vYnNlcnZlQXJyYXkoaW5zZXJ0ZWQpOyB9XG4gICAgLy8gbm90aWZ5IGNoYW5nZVxuICAgIG9iLmRlcC5ub3RpZnkoKTtcbiAgICByZXR1cm4gcmVzdWx0XG4gIH0pO1xufSk7XG5cbi8qICAqL1xuXG52YXIgYXJyYXlLZXlzID0gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMoYXJyYXlNZXRob2RzKTtcblxuLyoqXG4gKiBCeSBkZWZhdWx0LCB3aGVuIGEgcmVhY3RpdmUgcHJvcGVydHkgaXMgc2V0LCB0aGUgbmV3IHZhbHVlIGlzXG4gKiBhbHNvIGNvbnZlcnRlZCB0byBiZWNvbWUgcmVhY3RpdmUuIEhvd2V2ZXIgd2hlbiBwYXNzaW5nIGRvd24gcHJvcHMsXG4gKiB3ZSBkb24ndCB3YW50IHRvIGZvcmNlIGNvbnZlcnNpb24gYmVjYXVzZSB0aGUgdmFsdWUgbWF5IGJlIGEgbmVzdGVkIHZhbHVlXG4gKiB1bmRlciBhIGZyb3plbiBkYXRhIHN0cnVjdHVyZS4gQ29udmVydGluZyBpdCB3b3VsZCBkZWZlYXQgdGhlIG9wdGltaXphdGlvbi5cbiAqL1xudmFyIG9ic2VydmVyU3RhdGUgPSB7XG4gIHNob3VsZENvbnZlcnQ6IHRydWVcbn07XG5cbi8qKlxuICogT2JzZXJ2ZXIgY2xhc3MgdGhhdCBhcmUgYXR0YWNoZWQgdG8gZWFjaCBvYnNlcnZlZFxuICogb2JqZWN0LiBPbmNlIGF0dGFjaGVkLCB0aGUgb2JzZXJ2ZXIgY29udmVydHMgdGFyZ2V0XG4gKiBvYmplY3QncyBwcm9wZXJ0eSBrZXlzIGludG8gZ2V0dGVyL3NldHRlcnMgdGhhdFxuICogY29sbGVjdCBkZXBlbmRlbmNpZXMgYW5kIGRpc3BhdGNoZXMgdXBkYXRlcy5cbiAqL1xudmFyIE9ic2VydmVyID0gZnVuY3Rpb24gT2JzZXJ2ZXIgKHZhbHVlKSB7XG4gIHRoaXMudmFsdWUgPSB2YWx1ZTtcbiAgdGhpcy5kZXAgPSBuZXcgRGVwKCk7XG4gIHRoaXMudm1Db3VudCA9IDA7XG4gIGRlZih2YWx1ZSwgJ19fb2JfXycsIHRoaXMpO1xuICBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICB2YXIgYXVnbWVudCA9IGhhc1Byb3RvXG4gICAgICA/IHByb3RvQXVnbWVudFxuICAgICAgOiBjb3B5QXVnbWVudDtcbiAgICBhdWdtZW50KHZhbHVlLCBhcnJheU1ldGhvZHMsIGFycmF5S2V5cyk7XG4gICAgdGhpcy5vYnNlcnZlQXJyYXkodmFsdWUpO1xuICB9IGVsc2Uge1xuICAgIHRoaXMud2Fsayh2YWx1ZSk7XG4gIH1cbn07XG5cbi8qKlxuICogV2FsayB0aHJvdWdoIGVhY2ggcHJvcGVydHkgYW5kIGNvbnZlcnQgdGhlbSBpbnRvXG4gKiBnZXR0ZXIvc2V0dGVycy4gVGhpcyBtZXRob2Qgc2hvdWxkIG9ubHkgYmUgY2FsbGVkIHdoZW5cbiAqIHZhbHVlIHR5cGUgaXMgT2JqZWN0LlxuICovXG5PYnNlcnZlci5wcm90b3R5cGUud2FsayA9IGZ1bmN0aW9uIHdhbGsgKG9iaikge1xuICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKG9iaik7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7IGkrKykge1xuICAgIGRlZmluZVJlYWN0aXZlKG9iaiwga2V5c1tpXSwgb2JqW2tleXNbaV1dKTtcbiAgfVxufTtcblxuLyoqXG4gKiBPYnNlcnZlIGEgbGlzdCBvZiBBcnJheSBpdGVtcy5cbiAqL1xuT2JzZXJ2ZXIucHJvdG90eXBlLm9ic2VydmVBcnJheSA9IGZ1bmN0aW9uIG9ic2VydmVBcnJheSAoaXRlbXMpIHtcbiAgZm9yICh2YXIgaSA9IDAsIGwgPSBpdGVtcy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICBvYnNlcnZlKGl0ZW1zW2ldKTtcbiAgfVxufTtcblxuLy8gaGVscGVyc1xuXG4vKipcbiAqIEF1Z21lbnQgYW4gdGFyZ2V0IE9iamVjdCBvciBBcnJheSBieSBpbnRlcmNlcHRpbmdcbiAqIHRoZSBwcm90b3R5cGUgY2hhaW4gdXNpbmcgX19wcm90b19fXG4gKi9cbmZ1bmN0aW9uIHByb3RvQXVnbWVudCAodGFyZ2V0LCBzcmMsIGtleXMpIHtcbiAgLyogZXNsaW50LWRpc2FibGUgbm8tcHJvdG8gKi9cbiAgdGFyZ2V0Ll9fcHJvdG9fXyA9IHNyYztcbiAgLyogZXNsaW50LWVuYWJsZSBuby1wcm90byAqL1xufVxuXG4vKipcbiAqIEF1Z21lbnQgYW4gdGFyZ2V0IE9iamVjdCBvciBBcnJheSBieSBkZWZpbmluZ1xuICogaGlkZGVuIHByb3BlcnRpZXMuXG4gKi9cbi8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG5mdW5jdGlvbiBjb3B5QXVnbWVudCAodGFyZ2V0LCBzcmMsIGtleXMpIHtcbiAgZm9yICh2YXIgaSA9IDAsIGwgPSBrZXlzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgIHZhciBrZXkgPSBrZXlzW2ldO1xuICAgIGRlZih0YXJnZXQsIGtleSwgc3JjW2tleV0pO1xuICB9XG59XG5cbi8qKlxuICogQXR0ZW1wdCB0byBjcmVhdGUgYW4gb2JzZXJ2ZXIgaW5zdGFuY2UgZm9yIGEgdmFsdWUsXG4gKiByZXR1cm5zIHRoZSBuZXcgb2JzZXJ2ZXIgaWYgc3VjY2Vzc2Z1bGx5IG9ic2VydmVkLFxuICogb3IgdGhlIGV4aXN0aW5nIG9ic2VydmVyIGlmIHRoZSB2YWx1ZSBhbHJlYWR5IGhhcyBvbmUuXG4gKi9cbmZ1bmN0aW9uIG9ic2VydmUgKHZhbHVlLCBhc1Jvb3REYXRhKSB7XG4gIGlmICghaXNPYmplY3QodmFsdWUpIHx8IHZhbHVlIGluc3RhbmNlb2YgVk5vZGUpIHtcbiAgICByZXR1cm5cbiAgfVxuICB2YXIgb2I7XG4gIGlmIChoYXNPd24odmFsdWUsICdfX29iX18nKSAmJiB2YWx1ZS5fX29iX18gaW5zdGFuY2VvZiBPYnNlcnZlcikge1xuICAgIG9iID0gdmFsdWUuX19vYl9fO1xuICB9IGVsc2UgaWYgKFxuICAgIG9ic2VydmVyU3RhdGUuc2hvdWxkQ29udmVydCAmJlxuICAgICFpc1NlcnZlclJlbmRlcmluZygpICYmXG4gICAgKEFycmF5LmlzQXJyYXkodmFsdWUpIHx8IGlzUGxhaW5PYmplY3QodmFsdWUpKSAmJlxuICAgIE9iamVjdC5pc0V4dGVuc2libGUodmFsdWUpICYmXG4gICAgIXZhbHVlLl9pc1Z1ZVxuICApIHtcbiAgICBvYiA9IG5ldyBPYnNlcnZlcih2YWx1ZSk7XG4gIH1cbiAgaWYgKGFzUm9vdERhdGEgJiYgb2IpIHtcbiAgICBvYi52bUNvdW50Kys7XG4gIH1cbiAgcmV0dXJuIG9iXG59XG5cbi8qKlxuICogRGVmaW5lIGEgcmVhY3RpdmUgcHJvcGVydHkgb24gYW4gT2JqZWN0LlxuICovXG5mdW5jdGlvbiBkZWZpbmVSZWFjdGl2ZSAoXG4gIG9iaixcbiAga2V5LFxuICB2YWwsXG4gIGN1c3RvbVNldHRlcixcbiAgc2hhbGxvd1xuKSB7XG4gIHZhciBkZXAgPSBuZXcgRGVwKCk7XG5cbiAgdmFyIHByb3BlcnR5ID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihvYmosIGtleSk7XG4gIGlmIChwcm9wZXJ0eSAmJiBwcm9wZXJ0eS5jb25maWd1cmFibGUgPT09IGZhbHNlKSB7XG4gICAgcmV0dXJuXG4gIH1cblxuICAvLyBjYXRlciBmb3IgcHJlLWRlZmluZWQgZ2V0dGVyL3NldHRlcnNcbiAgdmFyIGdldHRlciA9IHByb3BlcnR5ICYmIHByb3BlcnR5LmdldDtcbiAgdmFyIHNldHRlciA9IHByb3BlcnR5ICYmIHByb3BlcnR5LnNldDtcblxuICB2YXIgY2hpbGRPYiA9ICFzaGFsbG93ICYmIG9ic2VydmUodmFsKTtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iaiwga2V5LCB7XG4gICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgZ2V0OiBmdW5jdGlvbiByZWFjdGl2ZUdldHRlciAoKSB7XG4gICAgICB2YXIgdmFsdWUgPSBnZXR0ZXIgPyBnZXR0ZXIuY2FsbChvYmopIDogdmFsO1xuICAgICAgaWYgKERlcC50YXJnZXQpIHtcbiAgICAgICAgZGVwLmRlcGVuZCgpO1xuICAgICAgICBpZiAoY2hpbGRPYikge1xuICAgICAgICAgIGNoaWxkT2IuZGVwLmRlcGVuZCgpO1xuICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgICAgICAgICAgZGVwZW5kQXJyYXkodmFsdWUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHZhbHVlXG4gICAgfSxcbiAgICBzZXQ6IGZ1bmN0aW9uIHJlYWN0aXZlU2V0dGVyIChuZXdWYWwpIHtcbiAgICAgIHZhciB2YWx1ZSA9IGdldHRlciA/IGdldHRlci5jYWxsKG9iaikgOiB2YWw7XG4gICAgICAvKiBlc2xpbnQtZGlzYWJsZSBuby1zZWxmLWNvbXBhcmUgKi9cbiAgICAgIGlmIChuZXdWYWwgPT09IHZhbHVlIHx8IChuZXdWYWwgIT09IG5ld1ZhbCAmJiB2YWx1ZSAhPT0gdmFsdWUpKSB7XG4gICAgICAgIHJldHVyblxuICAgICAgfVxuICAgICAgLyogZXNsaW50LWVuYWJsZSBuby1zZWxmLWNvbXBhcmUgKi9cbiAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIGN1c3RvbVNldHRlcikge1xuICAgICAgICBjdXN0b21TZXR0ZXIoKTtcbiAgICAgIH1cbiAgICAgIGlmIChzZXR0ZXIpIHtcbiAgICAgICAgc2V0dGVyLmNhbGwob2JqLCBuZXdWYWwpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFsID0gbmV3VmFsO1xuICAgICAgfVxuICAgICAgY2hpbGRPYiA9ICFzaGFsbG93ICYmIG9ic2VydmUobmV3VmFsKTtcbiAgICAgIGRlcC5ub3RpZnkoKTtcbiAgICB9XG4gIH0pO1xufVxuXG4vKipcbiAqIFNldCBhIHByb3BlcnR5IG9uIGFuIG9iamVjdC4gQWRkcyB0aGUgbmV3IHByb3BlcnR5IGFuZFxuICogdHJpZ2dlcnMgY2hhbmdlIG5vdGlmaWNhdGlvbiBpZiB0aGUgcHJvcGVydHkgZG9lc24ndFxuICogYWxyZWFkeSBleGlzdC5cbiAqL1xuZnVuY3Rpb24gc2V0ICh0YXJnZXQsIGtleSwgdmFsKSB7XG4gIGlmIChBcnJheS5pc0FycmF5KHRhcmdldCkgJiYgaXNWYWxpZEFycmF5SW5kZXgoa2V5KSkge1xuICAgIHRhcmdldC5sZW5ndGggPSBNYXRoLm1heCh0YXJnZXQubGVuZ3RoLCBrZXkpO1xuICAgIHRhcmdldC5zcGxpY2Uoa2V5LCAxLCB2YWwpO1xuICAgIHJldHVybiB2YWxcbiAgfVxuICBpZiAoa2V5IGluIHRhcmdldCAmJiAhKGtleSBpbiBPYmplY3QucHJvdG90eXBlKSkge1xuICAgIHRhcmdldFtrZXldID0gdmFsO1xuICAgIHJldHVybiB2YWxcbiAgfVxuICB2YXIgb2IgPSAodGFyZ2V0KS5fX29iX187XG4gIGlmICh0YXJnZXQuX2lzVnVlIHx8IChvYiAmJiBvYi52bUNvdW50KSkge1xuICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgd2FybihcbiAgICAgICdBdm9pZCBhZGRpbmcgcmVhY3RpdmUgcHJvcGVydGllcyB0byBhIFZ1ZSBpbnN0YW5jZSBvciBpdHMgcm9vdCAkZGF0YSAnICtcbiAgICAgICdhdCBydW50aW1lIC0gZGVjbGFyZSBpdCB1cGZyb250IGluIHRoZSBkYXRhIG9wdGlvbi4nXG4gICAgKTtcbiAgICByZXR1cm4gdmFsXG4gIH1cbiAgaWYgKCFvYikge1xuICAgIHRhcmdldFtrZXldID0gdmFsO1xuICAgIHJldHVybiB2YWxcbiAgfVxuICBkZWZpbmVSZWFjdGl2ZShvYi52YWx1ZSwga2V5LCB2YWwpO1xuICBvYi5kZXAubm90aWZ5KCk7XG4gIHJldHVybiB2YWxcbn1cblxuLyoqXG4gKiBEZWxldGUgYSBwcm9wZXJ0eSBhbmQgdHJpZ2dlciBjaGFuZ2UgaWYgbmVjZXNzYXJ5LlxuICovXG5mdW5jdGlvbiBkZWwgKHRhcmdldCwga2V5KSB7XG4gIGlmIChBcnJheS5pc0FycmF5KHRhcmdldCkgJiYgaXNWYWxpZEFycmF5SW5kZXgoa2V5KSkge1xuICAgIHRhcmdldC5zcGxpY2Uoa2V5LCAxKTtcbiAgICByZXR1cm5cbiAgfVxuICB2YXIgb2IgPSAodGFyZ2V0KS5fX29iX187XG4gIGlmICh0YXJnZXQuX2lzVnVlIHx8IChvYiAmJiBvYi52bUNvdW50KSkge1xuICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgd2FybihcbiAgICAgICdBdm9pZCBkZWxldGluZyBwcm9wZXJ0aWVzIG9uIGEgVnVlIGluc3RhbmNlIG9yIGl0cyByb290ICRkYXRhICcgK1xuICAgICAgJy0ganVzdCBzZXQgaXQgdG8gbnVsbC4nXG4gICAgKTtcbiAgICByZXR1cm5cbiAgfVxuICBpZiAoIWhhc093bih0YXJnZXQsIGtleSkpIHtcbiAgICByZXR1cm5cbiAgfVxuICBkZWxldGUgdGFyZ2V0W2tleV07XG4gIGlmICghb2IpIHtcbiAgICByZXR1cm5cbiAgfVxuICBvYi5kZXAubm90aWZ5KCk7XG59XG5cbi8qKlxuICogQ29sbGVjdCBkZXBlbmRlbmNpZXMgb24gYXJyYXkgZWxlbWVudHMgd2hlbiB0aGUgYXJyYXkgaXMgdG91Y2hlZCwgc2luY2VcbiAqIHdlIGNhbm5vdCBpbnRlcmNlcHQgYXJyYXkgZWxlbWVudCBhY2Nlc3MgbGlrZSBwcm9wZXJ0eSBnZXR0ZXJzLlxuICovXG5mdW5jdGlvbiBkZXBlbmRBcnJheSAodmFsdWUpIHtcbiAgZm9yICh2YXIgZSA9ICh2b2lkIDApLCBpID0gMCwgbCA9IHZhbHVlLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgIGUgPSB2YWx1ZVtpXTtcbiAgICBlICYmIGUuX19vYl9fICYmIGUuX19vYl9fLmRlcC5kZXBlbmQoKTtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShlKSkge1xuICAgICAgZGVwZW5kQXJyYXkoZSk7XG4gICAgfVxuICB9XG59XG5cbi8qICAqL1xuXG4vKipcbiAqIE9wdGlvbiBvdmVyd3JpdGluZyBzdHJhdGVnaWVzIGFyZSBmdW5jdGlvbnMgdGhhdCBoYW5kbGVcbiAqIGhvdyB0byBtZXJnZSBhIHBhcmVudCBvcHRpb24gdmFsdWUgYW5kIGEgY2hpbGQgb3B0aW9uXG4gKiB2YWx1ZSBpbnRvIHRoZSBmaW5hbCB2YWx1ZS5cbiAqL1xudmFyIHN0cmF0cyA9IGNvbmZpZy5vcHRpb25NZXJnZVN0cmF0ZWdpZXM7XG5cbi8qKlxuICogT3B0aW9ucyB3aXRoIHJlc3RyaWN0aW9uc1xuICovXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICBzdHJhdHMuZWwgPSBzdHJhdHMucHJvcHNEYXRhID0gZnVuY3Rpb24gKHBhcmVudCwgY2hpbGQsIHZtLCBrZXkpIHtcbiAgICBpZiAoIXZtKSB7XG4gICAgICB3YXJuKFxuICAgICAgICBcIm9wdGlvbiBcXFwiXCIgKyBrZXkgKyBcIlxcXCIgY2FuIG9ubHkgYmUgdXNlZCBkdXJpbmcgaW5zdGFuY2UgXCIgK1xuICAgICAgICAnY3JlYXRpb24gd2l0aCB0aGUgYG5ld2Aga2V5d29yZC4nXG4gICAgICApO1xuICAgIH1cbiAgICByZXR1cm4gZGVmYXVsdFN0cmF0KHBhcmVudCwgY2hpbGQpXG4gIH07XG59XG5cbi8qKlxuICogSGVscGVyIHRoYXQgcmVjdXJzaXZlbHkgbWVyZ2VzIHR3byBkYXRhIG9iamVjdHMgdG9nZXRoZXIuXG4gKi9cbmZ1bmN0aW9uIG1lcmdlRGF0YSAodG8sIGZyb20pIHtcbiAgaWYgKCFmcm9tKSB7IHJldHVybiB0byB9XG4gIHZhciBrZXksIHRvVmFsLCBmcm9tVmFsO1xuICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKGZyb20pO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyBpKyspIHtcbiAgICBrZXkgPSBrZXlzW2ldO1xuICAgIHRvVmFsID0gdG9ba2V5XTtcbiAgICBmcm9tVmFsID0gZnJvbVtrZXldO1xuICAgIGlmICghaGFzT3duKHRvLCBrZXkpKSB7XG4gICAgICBzZXQodG8sIGtleSwgZnJvbVZhbCk7XG4gICAgfSBlbHNlIGlmIChpc1BsYWluT2JqZWN0KHRvVmFsKSAmJiBpc1BsYWluT2JqZWN0KGZyb21WYWwpKSB7XG4gICAgICBtZXJnZURhdGEodG9WYWwsIGZyb21WYWwpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gdG9cbn1cblxuLyoqXG4gKiBEYXRhXG4gKi9cbmZ1bmN0aW9uIG1lcmdlRGF0YU9yRm4gKFxuICBwYXJlbnRWYWwsXG4gIGNoaWxkVmFsLFxuICB2bVxuKSB7XG4gIGlmICghdm0pIHtcbiAgICAvLyBpbiBhIFZ1ZS5leHRlbmQgbWVyZ2UsIGJvdGggc2hvdWxkIGJlIGZ1bmN0aW9uc1xuICAgIGlmICghY2hpbGRWYWwpIHtcbiAgICAgIHJldHVybiBwYXJlbnRWYWxcbiAgICB9XG4gICAgaWYgKCFwYXJlbnRWYWwpIHtcbiAgICAgIHJldHVybiBjaGlsZFZhbFxuICAgIH1cbiAgICAvLyB3aGVuIHBhcmVudFZhbCAmIGNoaWxkVmFsIGFyZSBib3RoIHByZXNlbnQsXG4gICAgLy8gd2UgbmVlZCB0byByZXR1cm4gYSBmdW5jdGlvbiB0aGF0IHJldHVybnMgdGhlXG4gICAgLy8gbWVyZ2VkIHJlc3VsdCBvZiBib3RoIGZ1bmN0aW9ucy4uLiBubyBuZWVkIHRvXG4gICAgLy8gY2hlY2sgaWYgcGFyZW50VmFsIGlzIGEgZnVuY3Rpb24gaGVyZSBiZWNhdXNlXG4gICAgLy8gaXQgaGFzIHRvIGJlIGEgZnVuY3Rpb24gdG8gcGFzcyBwcmV2aW91cyBtZXJnZXMuXG4gICAgcmV0dXJuIGZ1bmN0aW9uIG1lcmdlZERhdGFGbiAoKSB7XG4gICAgICByZXR1cm4gbWVyZ2VEYXRhKFxuICAgICAgICB0eXBlb2YgY2hpbGRWYWwgPT09ICdmdW5jdGlvbicgPyBjaGlsZFZhbC5jYWxsKHRoaXMsIHRoaXMpIDogY2hpbGRWYWwsXG4gICAgICAgIHR5cGVvZiBwYXJlbnRWYWwgPT09ICdmdW5jdGlvbicgPyBwYXJlbnRWYWwuY2FsbCh0aGlzLCB0aGlzKSA6IHBhcmVudFZhbFxuICAgICAgKVxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gbWVyZ2VkSW5zdGFuY2VEYXRhRm4gKCkge1xuICAgICAgLy8gaW5zdGFuY2UgbWVyZ2VcbiAgICAgIHZhciBpbnN0YW5jZURhdGEgPSB0eXBlb2YgY2hpbGRWYWwgPT09ICdmdW5jdGlvbidcbiAgICAgICAgPyBjaGlsZFZhbC5jYWxsKHZtLCB2bSlcbiAgICAgICAgOiBjaGlsZFZhbDtcbiAgICAgIHZhciBkZWZhdWx0RGF0YSA9IHR5cGVvZiBwYXJlbnRWYWwgPT09ICdmdW5jdGlvbidcbiAgICAgICAgPyBwYXJlbnRWYWwuY2FsbCh2bSwgdm0pXG4gICAgICAgIDogcGFyZW50VmFsO1xuICAgICAgaWYgKGluc3RhbmNlRGF0YSkge1xuICAgICAgICByZXR1cm4gbWVyZ2VEYXRhKGluc3RhbmNlRGF0YSwgZGVmYXVsdERhdGEpXG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gZGVmYXVsdERhdGFcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuc3RyYXRzLmRhdGEgPSBmdW5jdGlvbiAoXG4gIHBhcmVudFZhbCxcbiAgY2hpbGRWYWwsXG4gIHZtXG4pIHtcbiAgaWYgKCF2bSkge1xuICAgIGlmIChjaGlsZFZhbCAmJiB0eXBlb2YgY2hpbGRWYWwgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgd2FybihcbiAgICAgICAgJ1RoZSBcImRhdGFcIiBvcHRpb24gc2hvdWxkIGJlIGEgZnVuY3Rpb24gJyArXG4gICAgICAgICd0aGF0IHJldHVybnMgYSBwZXItaW5zdGFuY2UgdmFsdWUgaW4gY29tcG9uZW50ICcgK1xuICAgICAgICAnZGVmaW5pdGlvbnMuJyxcbiAgICAgICAgdm1cbiAgICAgICk7XG5cbiAgICAgIHJldHVybiBwYXJlbnRWYWxcbiAgICB9XG4gICAgcmV0dXJuIG1lcmdlRGF0YU9yRm4ocGFyZW50VmFsLCBjaGlsZFZhbClcbiAgfVxuXG4gIHJldHVybiBtZXJnZURhdGFPckZuKHBhcmVudFZhbCwgY2hpbGRWYWwsIHZtKVxufTtcblxuLyoqXG4gKiBIb29rcyBhbmQgcHJvcHMgYXJlIG1lcmdlZCBhcyBhcnJheXMuXG4gKi9cbmZ1bmN0aW9uIG1lcmdlSG9vayAoXG4gIHBhcmVudFZhbCxcbiAgY2hpbGRWYWxcbikge1xuICByZXR1cm4gY2hpbGRWYWxcbiAgICA/IHBhcmVudFZhbFxuICAgICAgPyBwYXJlbnRWYWwuY29uY2F0KGNoaWxkVmFsKVxuICAgICAgOiBBcnJheS5pc0FycmF5KGNoaWxkVmFsKVxuICAgICAgICA/IGNoaWxkVmFsXG4gICAgICAgIDogW2NoaWxkVmFsXVxuICAgIDogcGFyZW50VmFsXG59XG5cbkxJRkVDWUNMRV9IT09LUy5mb3JFYWNoKGZ1bmN0aW9uIChob29rKSB7XG4gIHN0cmF0c1tob29rXSA9IG1lcmdlSG9vaztcbn0pO1xuXG4vKipcbiAqIEFzc2V0c1xuICpcbiAqIFdoZW4gYSB2bSBpcyBwcmVzZW50IChpbnN0YW5jZSBjcmVhdGlvbiksIHdlIG5lZWQgdG8gZG9cbiAqIGEgdGhyZWUtd2F5IG1lcmdlIGJldHdlZW4gY29uc3RydWN0b3Igb3B0aW9ucywgaW5zdGFuY2VcbiAqIG9wdGlvbnMgYW5kIHBhcmVudCBvcHRpb25zLlxuICovXG5mdW5jdGlvbiBtZXJnZUFzc2V0cyAoXG4gIHBhcmVudFZhbCxcbiAgY2hpbGRWYWwsXG4gIHZtLFxuICBrZXlcbikge1xuICB2YXIgcmVzID0gT2JqZWN0LmNyZWF0ZShwYXJlbnRWYWwgfHwgbnVsbCk7XG4gIGlmIChjaGlsZFZhbCkge1xuICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgYXNzZXJ0T2JqZWN0VHlwZShrZXksIGNoaWxkVmFsLCB2bSk7XG4gICAgcmV0dXJuIGV4dGVuZChyZXMsIGNoaWxkVmFsKVxuICB9IGVsc2Uge1xuICAgIHJldHVybiByZXNcbiAgfVxufVxuXG5BU1NFVF9UWVBFUy5mb3JFYWNoKGZ1bmN0aW9uICh0eXBlKSB7XG4gIHN0cmF0c1t0eXBlICsgJ3MnXSA9IG1lcmdlQXNzZXRzO1xufSk7XG5cbi8qKlxuICogV2F0Y2hlcnMuXG4gKlxuICogV2F0Y2hlcnMgaGFzaGVzIHNob3VsZCBub3Qgb3ZlcndyaXRlIG9uZVxuICogYW5vdGhlciwgc28gd2UgbWVyZ2UgdGhlbSBhcyBhcnJheXMuXG4gKi9cbnN0cmF0cy53YXRjaCA9IGZ1bmN0aW9uIChcbiAgcGFyZW50VmFsLFxuICBjaGlsZFZhbCxcbiAgdm0sXG4gIGtleVxuKSB7XG4gIC8vIHdvcmsgYXJvdW5kIEZpcmVmb3gncyBPYmplY3QucHJvdG90eXBlLndhdGNoLi4uXG4gIGlmIChwYXJlbnRWYWwgPT09IG5hdGl2ZVdhdGNoKSB7IHBhcmVudFZhbCA9IHVuZGVmaW5lZDsgfVxuICBpZiAoY2hpbGRWYWwgPT09IG5hdGl2ZVdhdGNoKSB7IGNoaWxkVmFsID0gdW5kZWZpbmVkOyB9XG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICBpZiAoIWNoaWxkVmFsKSB7IHJldHVybiBPYmplY3QuY3JlYXRlKHBhcmVudFZhbCB8fCBudWxsKSB9XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgYXNzZXJ0T2JqZWN0VHlwZShrZXksIGNoaWxkVmFsLCB2bSk7XG4gIH1cbiAgaWYgKCFwYXJlbnRWYWwpIHsgcmV0dXJuIGNoaWxkVmFsIH1cbiAgdmFyIHJldCA9IHt9O1xuICBleHRlbmQocmV0LCBwYXJlbnRWYWwpO1xuICBmb3IgKHZhciBrZXkkMSBpbiBjaGlsZFZhbCkge1xuICAgIHZhciBwYXJlbnQgPSByZXRba2V5JDFdO1xuICAgIHZhciBjaGlsZCA9IGNoaWxkVmFsW2tleSQxXTtcbiAgICBpZiAocGFyZW50ICYmICFBcnJheS5pc0FycmF5KHBhcmVudCkpIHtcbiAgICAgIHBhcmVudCA9IFtwYXJlbnRdO1xuICAgIH1cbiAgICByZXRba2V5JDFdID0gcGFyZW50XG4gICAgICA/IHBhcmVudC5jb25jYXQoY2hpbGQpXG4gICAgICA6IEFycmF5LmlzQXJyYXkoY2hpbGQpID8gY2hpbGQgOiBbY2hpbGRdO1xuICB9XG4gIHJldHVybiByZXRcbn07XG5cbi8qKlxuICogT3RoZXIgb2JqZWN0IGhhc2hlcy5cbiAqL1xuc3RyYXRzLnByb3BzID1cbnN0cmF0cy5tZXRob2RzID1cbnN0cmF0cy5pbmplY3QgPVxuc3RyYXRzLmNvbXB1dGVkID0gZnVuY3Rpb24gKFxuICBwYXJlbnRWYWwsXG4gIGNoaWxkVmFsLFxuICB2bSxcbiAga2V5XG4pIHtcbiAgaWYgKGNoaWxkVmFsICYmIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICBhc3NlcnRPYmplY3RUeXBlKGtleSwgY2hpbGRWYWwsIHZtKTtcbiAgfVxuICBpZiAoIXBhcmVudFZhbCkgeyByZXR1cm4gY2hpbGRWYWwgfVxuICB2YXIgcmV0ID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgZXh0ZW5kKHJldCwgcGFyZW50VmFsKTtcbiAgaWYgKGNoaWxkVmFsKSB7IGV4dGVuZChyZXQsIGNoaWxkVmFsKTsgfVxuICByZXR1cm4gcmV0XG59O1xuc3RyYXRzLnByb3ZpZGUgPSBtZXJnZURhdGFPckZuO1xuXG4vKipcbiAqIERlZmF1bHQgc3RyYXRlZ3kuXG4gKi9cbnZhciBkZWZhdWx0U3RyYXQgPSBmdW5jdGlvbiAocGFyZW50VmFsLCBjaGlsZFZhbCkge1xuICByZXR1cm4gY2hpbGRWYWwgPT09IHVuZGVmaW5lZFxuICAgID8gcGFyZW50VmFsXG4gICAgOiBjaGlsZFZhbFxufTtcblxuLyoqXG4gKiBWYWxpZGF0ZSBjb21wb25lbnQgbmFtZXNcbiAqL1xuZnVuY3Rpb24gY2hlY2tDb21wb25lbnRzIChvcHRpb25zKSB7XG4gIGZvciAodmFyIGtleSBpbiBvcHRpb25zLmNvbXBvbmVudHMpIHtcbiAgICB2YWxpZGF0ZUNvbXBvbmVudE5hbWUoa2V5KTtcbiAgfVxufVxuXG5mdW5jdGlvbiB2YWxpZGF0ZUNvbXBvbmVudE5hbWUgKG5hbWUpIHtcbiAgaWYgKCEvXlthLXpBLVpdW1xcdy1dKiQvLnRlc3QobmFtZSkpIHtcbiAgICB3YXJuKFxuICAgICAgJ0ludmFsaWQgY29tcG9uZW50IG5hbWU6IFwiJyArIG5hbWUgKyAnXCIuIENvbXBvbmVudCBuYW1lcyAnICtcbiAgICAgICdjYW4gb25seSBjb250YWluIGFscGhhbnVtZXJpYyBjaGFyYWN0ZXJzIGFuZCB0aGUgaHlwaGVuLCAnICtcbiAgICAgICdhbmQgbXVzdCBzdGFydCB3aXRoIGEgbGV0dGVyLidcbiAgICApO1xuICB9XG4gIGlmIChpc0J1aWx0SW5UYWcobmFtZSkgfHwgY29uZmlnLmlzUmVzZXJ2ZWRUYWcobmFtZSkpIHtcbiAgICB3YXJuKFxuICAgICAgJ0RvIG5vdCB1c2UgYnVpbHQtaW4gb3IgcmVzZXJ2ZWQgSFRNTCBlbGVtZW50cyBhcyBjb21wb25lbnQgJyArXG4gICAgICAnaWQ6ICcgKyBuYW1lXG4gICAgKTtcbiAgfVxufVxuXG4vKipcbiAqIEVuc3VyZSBhbGwgcHJvcHMgb3B0aW9uIHN5bnRheCBhcmUgbm9ybWFsaXplZCBpbnRvIHRoZVxuICogT2JqZWN0LWJhc2VkIGZvcm1hdC5cbiAqL1xuZnVuY3Rpb24gbm9ybWFsaXplUHJvcHMgKG9wdGlvbnMsIHZtKSB7XG4gIHZhciBwcm9wcyA9IG9wdGlvbnMucHJvcHM7XG4gIGlmICghcHJvcHMpIHsgcmV0dXJuIH1cbiAgdmFyIHJlcyA9IHt9O1xuICB2YXIgaSwgdmFsLCBuYW1lO1xuICBpZiAoQXJyYXkuaXNBcnJheShwcm9wcykpIHtcbiAgICBpID0gcHJvcHMubGVuZ3RoO1xuICAgIHdoaWxlIChpLS0pIHtcbiAgICAgIHZhbCA9IHByb3BzW2ldO1xuICAgICAgaWYgKHR5cGVvZiB2YWwgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIG5hbWUgPSBjYW1lbGl6ZSh2YWwpO1xuICAgICAgICByZXNbbmFtZV0gPSB7IHR5cGU6IG51bGwgfTtcbiAgICAgIH0gZWxzZSBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICB3YXJuKCdwcm9wcyBtdXN0IGJlIHN0cmluZ3Mgd2hlbiB1c2luZyBhcnJheSBzeW50YXguJyk7XG4gICAgICB9XG4gICAgfVxuICB9IGVsc2UgaWYgKGlzUGxhaW5PYmplY3QocHJvcHMpKSB7XG4gICAgZm9yICh2YXIga2V5IGluIHByb3BzKSB7XG4gICAgICB2YWwgPSBwcm9wc1trZXldO1xuICAgICAgbmFtZSA9IGNhbWVsaXplKGtleSk7XG4gICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiBpc1BsYWluT2JqZWN0KHZhbCkpIHtcbiAgICAgICAgdmFsaWRhdGVQcm9wT2JqZWN0KG5hbWUsIHZhbCwgdm0pO1xuICAgICAgfVxuICAgICAgcmVzW25hbWVdID0gaXNQbGFpbk9iamVjdCh2YWwpXG4gICAgICAgID8gdmFsXG4gICAgICAgIDogeyB0eXBlOiB2YWwgfTtcbiAgICB9XG4gIH0gZWxzZSBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgIHdhcm4oXG4gICAgICBcIkludmFsaWQgdmFsdWUgZm9yIG9wdGlvbiBcXFwicHJvcHNcXFwiOiBleHBlY3RlZCBhbiBBcnJheSBvciBhbiBPYmplY3QsIFwiICtcbiAgICAgIFwiYnV0IGdvdCBcIiArICh0b1Jhd1R5cGUocHJvcHMpKSArIFwiLlwiLFxuICAgICAgdm1cbiAgICApO1xuICB9XG4gIG9wdGlvbnMucHJvcHMgPSByZXM7XG59XG5cbi8qKlxuICogVmFsaWRhdGUgd2hldGhlciBhIHByb3Agb2JqZWN0IGtleXMgYXJlIHZhbGlkLlxuICovXG52YXIgcHJvcE9wdGlvbnNSRSA9IC9eKHR5cGV8ZGVmYXVsdHxyZXF1aXJlZHx2YWxpZGF0b3IpJC87XG5cbmZ1bmN0aW9uIHZhbGlkYXRlUHJvcE9iamVjdCAoXG4gIHByb3BOYW1lLFxuICBwcm9wLFxuICB2bVxuKSB7XG4gIGZvciAodmFyIGtleSBpbiBwcm9wKSB7XG4gICAgaWYgKCFwcm9wT3B0aW9uc1JFLnRlc3Qoa2V5KSkge1xuICAgICAgd2FybihcbiAgICAgICAgKFwiSW52YWxpZCBrZXkgXFxcIlwiICsga2V5ICsgXCJcXFwiIGluIHZhbGlkYXRpb24gcnVsZXMgb2JqZWN0IGZvciBwcm9wIFxcXCJcIiArIHByb3BOYW1lICsgXCJcXFwiLlwiKSxcbiAgICAgICAgdm1cbiAgICAgICk7XG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogTm9ybWFsaXplIGFsbCBpbmplY3Rpb25zIGludG8gT2JqZWN0LWJhc2VkIGZvcm1hdFxuICovXG5mdW5jdGlvbiBub3JtYWxpemVJbmplY3QgKG9wdGlvbnMsIHZtKSB7XG4gIHZhciBpbmplY3QgPSBvcHRpb25zLmluamVjdDtcbiAgdmFyIG5vcm1hbGl6ZWQgPSBvcHRpb25zLmluamVjdCA9IHt9O1xuICBpZiAoQXJyYXkuaXNBcnJheShpbmplY3QpKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBpbmplY3QubGVuZ3RoOyBpKyspIHtcbiAgICAgIG5vcm1hbGl6ZWRbaW5qZWN0W2ldXSA9IHsgZnJvbTogaW5qZWN0W2ldIH07XG4gICAgfVxuICB9IGVsc2UgaWYgKGlzUGxhaW5PYmplY3QoaW5qZWN0KSkge1xuICAgIGZvciAodmFyIGtleSBpbiBpbmplY3QpIHtcbiAgICAgIHZhciB2YWwgPSBpbmplY3Rba2V5XTtcbiAgICAgIG5vcm1hbGl6ZWRba2V5XSA9IGlzUGxhaW5PYmplY3QodmFsKVxuICAgICAgICA/IGV4dGVuZCh7IGZyb206IGtleSB9LCB2YWwpXG4gICAgICAgIDogeyBmcm9tOiB2YWwgfTtcbiAgICB9XG4gIH0gZWxzZSBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiBpbmplY3QpIHtcbiAgICB3YXJuKFxuICAgICAgXCJJbnZhbGlkIHZhbHVlIGZvciBvcHRpb24gXFxcImluamVjdFxcXCI6IGV4cGVjdGVkIGFuIEFycmF5IG9yIGFuIE9iamVjdCwgXCIgK1xuICAgICAgXCJidXQgZ290IFwiICsgKHRvUmF3VHlwZShpbmplY3QpKSArIFwiLlwiLFxuICAgICAgdm1cbiAgICApO1xuICB9XG59XG5cbi8qKlxuICogTm9ybWFsaXplIHJhdyBmdW5jdGlvbiBkaXJlY3RpdmVzIGludG8gb2JqZWN0IGZvcm1hdC5cbiAqL1xuZnVuY3Rpb24gbm9ybWFsaXplRGlyZWN0aXZlcyAob3B0aW9ucykge1xuICB2YXIgZGlycyA9IG9wdGlvbnMuZGlyZWN0aXZlcztcbiAgaWYgKGRpcnMpIHtcbiAgICBmb3IgKHZhciBrZXkgaW4gZGlycykge1xuICAgICAgdmFyIGRlZiA9IGRpcnNba2V5XTtcbiAgICAgIGlmICh0eXBlb2YgZGVmID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIGRpcnNba2V5XSA9IHsgYmluZDogZGVmLCB1cGRhdGU6IGRlZiB9O1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBhc3NlcnRPYmplY3RUeXBlIChuYW1lLCB2YWx1ZSwgdm0pIHtcbiAgaWYgKCFpc1BsYWluT2JqZWN0KHZhbHVlKSkge1xuICAgIHdhcm4oXG4gICAgICBcIkludmFsaWQgdmFsdWUgZm9yIG9wdGlvbiBcXFwiXCIgKyBuYW1lICsgXCJcXFwiOiBleHBlY3RlZCBhbiBPYmplY3QsIFwiICtcbiAgICAgIFwiYnV0IGdvdCBcIiArICh0b1Jhd1R5cGUodmFsdWUpKSArIFwiLlwiLFxuICAgICAgdm1cbiAgICApO1xuICB9XG59XG5cbi8qKlxuICogTWVyZ2UgdHdvIG9wdGlvbiBvYmplY3RzIGludG8gYSBuZXcgb25lLlxuICogQ29yZSB1dGlsaXR5IHVzZWQgaW4gYm90aCBpbnN0YW50aWF0aW9uIGFuZCBpbmhlcml0YW5jZS5cbiAqL1xuZnVuY3Rpb24gbWVyZ2VPcHRpb25zIChcbiAgcGFyZW50LFxuICBjaGlsZCxcbiAgdm1cbikge1xuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgIGNoZWNrQ29tcG9uZW50cyhjaGlsZCk7XG4gIH1cblxuICBpZiAodHlwZW9mIGNoaWxkID09PSAnZnVuY3Rpb24nKSB7XG4gICAgY2hpbGQgPSBjaGlsZC5vcHRpb25zO1xuICB9XG5cbiAgbm9ybWFsaXplUHJvcHMoY2hpbGQsIHZtKTtcbiAgbm9ybWFsaXplSW5qZWN0KGNoaWxkLCB2bSk7XG4gIG5vcm1hbGl6ZURpcmVjdGl2ZXMoY2hpbGQpO1xuICB2YXIgZXh0ZW5kc0Zyb20gPSBjaGlsZC5leHRlbmRzO1xuICBpZiAoZXh0ZW5kc0Zyb20pIHtcbiAgICBwYXJlbnQgPSBtZXJnZU9wdGlvbnMocGFyZW50LCBleHRlbmRzRnJvbSwgdm0pO1xuICB9XG4gIGlmIChjaGlsZC5taXhpbnMpIHtcbiAgICBmb3IgKHZhciBpID0gMCwgbCA9IGNoaWxkLm1peGlucy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgIHBhcmVudCA9IG1lcmdlT3B0aW9ucyhwYXJlbnQsIGNoaWxkLm1peGluc1tpXSwgdm0pO1xuICAgIH1cbiAgfVxuICB2YXIgb3B0aW9ucyA9IHt9O1xuICB2YXIga2V5O1xuICBmb3IgKGtleSBpbiBwYXJlbnQpIHtcbiAgICBtZXJnZUZpZWxkKGtleSk7XG4gIH1cbiAgZm9yIChrZXkgaW4gY2hpbGQpIHtcbiAgICBpZiAoIWhhc093bihwYXJlbnQsIGtleSkpIHtcbiAgICAgIG1lcmdlRmllbGQoa2V5KTtcbiAgICB9XG4gIH1cbiAgZnVuY3Rpb24gbWVyZ2VGaWVsZCAoa2V5KSB7XG4gICAgdmFyIHN0cmF0ID0gc3RyYXRzW2tleV0gfHwgZGVmYXVsdFN0cmF0O1xuICAgIG9wdGlvbnNba2V5XSA9IHN0cmF0KHBhcmVudFtrZXldLCBjaGlsZFtrZXldLCB2bSwga2V5KTtcbiAgfVxuICByZXR1cm4gb3B0aW9uc1xufVxuXG4vKipcbiAqIFJlc29sdmUgYW4gYXNzZXQuXG4gKiBUaGlzIGZ1bmN0aW9uIGlzIHVzZWQgYmVjYXVzZSBjaGlsZCBpbnN0YW5jZXMgbmVlZCBhY2Nlc3NcbiAqIHRvIGFzc2V0cyBkZWZpbmVkIGluIGl0cyBhbmNlc3RvciBjaGFpbi5cbiAqL1xuZnVuY3Rpb24gcmVzb2x2ZUFzc2V0IChcbiAgb3B0aW9ucyxcbiAgdHlwZSxcbiAgaWQsXG4gIHdhcm5NaXNzaW5nXG4pIHtcbiAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gIGlmICh0eXBlb2YgaWQgIT09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuXG4gIH1cbiAgdmFyIGFzc2V0cyA9IG9wdGlvbnNbdHlwZV07XG4gIC8vIGNoZWNrIGxvY2FsIHJlZ2lzdHJhdGlvbiB2YXJpYXRpb25zIGZpcnN0XG4gIGlmIChoYXNPd24oYXNzZXRzLCBpZCkpIHsgcmV0dXJuIGFzc2V0c1tpZF0gfVxuICB2YXIgY2FtZWxpemVkSWQgPSBjYW1lbGl6ZShpZCk7XG4gIGlmIChoYXNPd24oYXNzZXRzLCBjYW1lbGl6ZWRJZCkpIHsgcmV0dXJuIGFzc2V0c1tjYW1lbGl6ZWRJZF0gfVxuICB2YXIgUGFzY2FsQ2FzZUlkID0gY2FwaXRhbGl6ZShjYW1lbGl6ZWRJZCk7XG4gIGlmIChoYXNPd24oYXNzZXRzLCBQYXNjYWxDYXNlSWQpKSB7IHJldHVybiBhc3NldHNbUGFzY2FsQ2FzZUlkXSB9XG4gIC8vIGZhbGxiYWNrIHRvIHByb3RvdHlwZSBjaGFpblxuICB2YXIgcmVzID0gYXNzZXRzW2lkXSB8fCBhc3NldHNbY2FtZWxpemVkSWRdIHx8IGFzc2V0c1tQYXNjYWxDYXNlSWRdO1xuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiB3YXJuTWlzc2luZyAmJiAhcmVzKSB7XG4gICAgd2FybihcbiAgICAgICdGYWlsZWQgdG8gcmVzb2x2ZSAnICsgdHlwZS5zbGljZSgwLCAtMSkgKyAnOiAnICsgaWQsXG4gICAgICBvcHRpb25zXG4gICAgKTtcbiAgfVxuICByZXR1cm4gcmVzXG59XG5cbi8qICAqL1xuXG5mdW5jdGlvbiB2YWxpZGF0ZVByb3AgKFxuICBrZXksXG4gIHByb3BPcHRpb25zLFxuICBwcm9wc0RhdGEsXG4gIHZtXG4pIHtcbiAgdmFyIHByb3AgPSBwcm9wT3B0aW9uc1trZXldO1xuICB2YXIgYWJzZW50ID0gIWhhc093bihwcm9wc0RhdGEsIGtleSk7XG4gIHZhciB2YWx1ZSA9IHByb3BzRGF0YVtrZXldO1xuICAvLyBoYW5kbGUgYm9vbGVhbiBwcm9wc1xuICBpZiAoaXNUeXBlKEJvb2xlYW4sIHByb3AudHlwZSkpIHtcbiAgICBpZiAoYWJzZW50ICYmICFoYXNPd24ocHJvcCwgJ2RlZmF1bHQnKSkge1xuICAgICAgdmFsdWUgPSBmYWxzZTtcbiAgICB9IGVsc2UgaWYgKCFpc1R5cGUoU3RyaW5nLCBwcm9wLnR5cGUpICYmICh2YWx1ZSA9PT0gJycgfHwgdmFsdWUgPT09IGh5cGhlbmF0ZShrZXkpKSkge1xuICAgICAgdmFsdWUgPSB0cnVlO1xuICAgIH1cbiAgfVxuICAvLyBjaGVjayBkZWZhdWx0IHZhbHVlXG4gIGlmICh2YWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgdmFsdWUgPSBnZXRQcm9wRGVmYXVsdFZhbHVlKHZtLCBwcm9wLCBrZXkpO1xuICAgIC8vIHNpbmNlIHRoZSBkZWZhdWx0IHZhbHVlIGlzIGEgZnJlc2ggY29weSxcbiAgICAvLyBtYWtlIHN1cmUgdG8gb2JzZXJ2ZSBpdC5cbiAgICB2YXIgcHJldlNob3VsZENvbnZlcnQgPSBvYnNlcnZlclN0YXRlLnNob3VsZENvbnZlcnQ7XG4gICAgb2JzZXJ2ZXJTdGF0ZS5zaG91bGRDb252ZXJ0ID0gdHJ1ZTtcbiAgICBvYnNlcnZlKHZhbHVlKTtcbiAgICBvYnNlcnZlclN0YXRlLnNob3VsZENvbnZlcnQgPSBwcmV2U2hvdWxkQ29udmVydDtcbiAgfVxuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgIGFzc2VydFByb3AocHJvcCwga2V5LCB2YWx1ZSwgdm0sIGFic2VudCk7XG4gIH1cbiAgcmV0dXJuIHZhbHVlXG59XG5cbi8qKlxuICogR2V0IHRoZSBkZWZhdWx0IHZhbHVlIG9mIGEgcHJvcC5cbiAqL1xuZnVuY3Rpb24gZ2V0UHJvcERlZmF1bHRWYWx1ZSAodm0sIHByb3AsIGtleSkge1xuICAvLyBubyBkZWZhdWx0LCByZXR1cm4gdW5kZWZpbmVkXG4gIGlmICghaGFzT3duKHByb3AsICdkZWZhdWx0JykpIHtcbiAgICByZXR1cm4gdW5kZWZpbmVkXG4gIH1cbiAgdmFyIGRlZiA9IHByb3AuZGVmYXVsdDtcbiAgLy8gd2FybiBhZ2FpbnN0IG5vbi1mYWN0b3J5IGRlZmF1bHRzIGZvciBPYmplY3QgJiBBcnJheVxuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiBpc09iamVjdChkZWYpKSB7XG4gICAgd2FybihcbiAgICAgICdJbnZhbGlkIGRlZmF1bHQgdmFsdWUgZm9yIHByb3AgXCInICsga2V5ICsgJ1wiOiAnICtcbiAgICAgICdQcm9wcyB3aXRoIHR5cGUgT2JqZWN0L0FycmF5IG11c3QgdXNlIGEgZmFjdG9yeSBmdW5jdGlvbiAnICtcbiAgICAgICd0byByZXR1cm4gdGhlIGRlZmF1bHQgdmFsdWUuJyxcbiAgICAgIHZtXG4gICAgKTtcbiAgfVxuICAvLyB0aGUgcmF3IHByb3AgdmFsdWUgd2FzIGFsc28gdW5kZWZpbmVkIGZyb20gcHJldmlvdXMgcmVuZGVyLFxuICAvLyByZXR1cm4gcHJldmlvdXMgZGVmYXVsdCB2YWx1ZSB0byBhdm9pZCB1bm5lY2Vzc2FyeSB3YXRjaGVyIHRyaWdnZXJcbiAgaWYgKHZtICYmIHZtLiRvcHRpb25zLnByb3BzRGF0YSAmJlxuICAgIHZtLiRvcHRpb25zLnByb3BzRGF0YVtrZXldID09PSB1bmRlZmluZWQgJiZcbiAgICB2bS5fcHJvcHNba2V5XSAhPT0gdW5kZWZpbmVkXG4gICkge1xuICAgIHJldHVybiB2bS5fcHJvcHNba2V5XVxuICB9XG4gIC8vIGNhbGwgZmFjdG9yeSBmdW5jdGlvbiBmb3Igbm9uLUZ1bmN0aW9uIHR5cGVzXG4gIC8vIGEgdmFsdWUgaXMgRnVuY3Rpb24gaWYgaXRzIHByb3RvdHlwZSBpcyBmdW5jdGlvbiBldmVuIGFjcm9zcyBkaWZmZXJlbnQgZXhlY3V0aW9uIGNvbnRleHRcbiAgcmV0dXJuIHR5cGVvZiBkZWYgPT09ICdmdW5jdGlvbicgJiYgZ2V0VHlwZShwcm9wLnR5cGUpICE9PSAnRnVuY3Rpb24nXG4gICAgPyBkZWYuY2FsbCh2bSlcbiAgICA6IGRlZlxufVxuXG4vKipcbiAqIEFzc2VydCB3aGV0aGVyIGEgcHJvcCBpcyB2YWxpZC5cbiAqL1xuZnVuY3Rpb24gYXNzZXJ0UHJvcCAoXG4gIHByb3AsXG4gIG5hbWUsXG4gIHZhbHVlLFxuICB2bSxcbiAgYWJzZW50XG4pIHtcbiAgaWYgKHByb3AucmVxdWlyZWQgJiYgYWJzZW50KSB7XG4gICAgd2FybihcbiAgICAgICdNaXNzaW5nIHJlcXVpcmVkIHByb3A6IFwiJyArIG5hbWUgKyAnXCInLFxuICAgICAgdm1cbiAgICApO1xuICAgIHJldHVyblxuICB9XG4gIGlmICh2YWx1ZSA9PSBudWxsICYmICFwcm9wLnJlcXVpcmVkKSB7XG4gICAgcmV0dXJuXG4gIH1cbiAgdmFyIHR5cGUgPSBwcm9wLnR5cGU7XG4gIHZhciB2YWxpZCA9ICF0eXBlIHx8IHR5cGUgPT09IHRydWU7XG4gIHZhciBleHBlY3RlZFR5cGVzID0gW107XG4gIGlmICh0eXBlKSB7XG4gICAgaWYgKCFBcnJheS5pc0FycmF5KHR5cGUpKSB7XG4gICAgICB0eXBlID0gW3R5cGVdO1xuICAgIH1cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHR5cGUubGVuZ3RoICYmICF2YWxpZDsgaSsrKSB7XG4gICAgICB2YXIgYXNzZXJ0ZWRUeXBlID0gYXNzZXJ0VHlwZSh2YWx1ZSwgdHlwZVtpXSk7XG4gICAgICBleHBlY3RlZFR5cGVzLnB1c2goYXNzZXJ0ZWRUeXBlLmV4cGVjdGVkVHlwZSB8fCAnJyk7XG4gICAgICB2YWxpZCA9IGFzc2VydGVkVHlwZS52YWxpZDtcbiAgICB9XG4gIH1cbiAgaWYgKCF2YWxpZCkge1xuICAgIHdhcm4oXG4gICAgICBcIkludmFsaWQgcHJvcDogdHlwZSBjaGVjayBmYWlsZWQgZm9yIHByb3AgXFxcIlwiICsgbmFtZSArIFwiXFxcIi5cIiArXG4gICAgICBcIiBFeHBlY3RlZCBcIiArIChleHBlY3RlZFR5cGVzLm1hcChjYXBpdGFsaXplKS5qb2luKCcsICcpKSArXG4gICAgICBcIiwgZ290IFwiICsgKHRvUmF3VHlwZSh2YWx1ZSkpICsgXCIuXCIsXG4gICAgICB2bVxuICAgICk7XG4gICAgcmV0dXJuXG4gIH1cbiAgdmFyIHZhbGlkYXRvciA9IHByb3AudmFsaWRhdG9yO1xuICBpZiAodmFsaWRhdG9yKSB7XG4gICAgaWYgKCF2YWxpZGF0b3IodmFsdWUpKSB7XG4gICAgICB3YXJuKFxuICAgICAgICAnSW52YWxpZCBwcm9wOiBjdXN0b20gdmFsaWRhdG9yIGNoZWNrIGZhaWxlZCBmb3IgcHJvcCBcIicgKyBuYW1lICsgJ1wiLicsXG4gICAgICAgIHZtXG4gICAgICApO1xuICAgIH1cbiAgfVxufVxuXG52YXIgc2ltcGxlQ2hlY2tSRSA9IC9eKFN0cmluZ3xOdW1iZXJ8Qm9vbGVhbnxGdW5jdGlvbnxTeW1ib2wpJC87XG5cbmZ1bmN0aW9uIGFzc2VydFR5cGUgKHZhbHVlLCB0eXBlKSB7XG4gIHZhciB2YWxpZDtcbiAgdmFyIGV4cGVjdGVkVHlwZSA9IGdldFR5cGUodHlwZSk7XG4gIGlmIChzaW1wbGVDaGVja1JFLnRlc3QoZXhwZWN0ZWRUeXBlKSkge1xuICAgIHZhciB0ID0gdHlwZW9mIHZhbHVlO1xuICAgIHZhbGlkID0gdCA9PT0gZXhwZWN0ZWRUeXBlLnRvTG93ZXJDYXNlKCk7XG4gICAgLy8gZm9yIHByaW1pdGl2ZSB3cmFwcGVyIG9iamVjdHNcbiAgICBpZiAoIXZhbGlkICYmIHQgPT09ICdvYmplY3QnKSB7XG4gICAgICB2YWxpZCA9IHZhbHVlIGluc3RhbmNlb2YgdHlwZTtcbiAgICB9XG4gIH0gZWxzZSBpZiAoZXhwZWN0ZWRUeXBlID09PSAnT2JqZWN0Jykge1xuICAgIHZhbGlkID0gaXNQbGFpbk9iamVjdCh2YWx1ZSk7XG4gIH0gZWxzZSBpZiAoZXhwZWN0ZWRUeXBlID09PSAnQXJyYXknKSB7XG4gICAgdmFsaWQgPSBBcnJheS5pc0FycmF5KHZhbHVlKTtcbiAgfSBlbHNlIHtcbiAgICB2YWxpZCA9IHZhbHVlIGluc3RhbmNlb2YgdHlwZTtcbiAgfVxuICByZXR1cm4ge1xuICAgIHZhbGlkOiB2YWxpZCxcbiAgICBleHBlY3RlZFR5cGU6IGV4cGVjdGVkVHlwZVxuICB9XG59XG5cbi8qKlxuICogVXNlIGZ1bmN0aW9uIHN0cmluZyBuYW1lIHRvIGNoZWNrIGJ1aWx0LWluIHR5cGVzLFxuICogYmVjYXVzZSBhIHNpbXBsZSBlcXVhbGl0eSBjaGVjayB3aWxsIGZhaWwgd2hlbiBydW5uaW5nXG4gKiBhY3Jvc3MgZGlmZmVyZW50IHZtcyAvIGlmcmFtZXMuXG4gKi9cbmZ1bmN0aW9uIGdldFR5cGUgKGZuKSB7XG4gIHZhciBtYXRjaCA9IGZuICYmIGZuLnRvU3RyaW5nKCkubWF0Y2goL15cXHMqZnVuY3Rpb24gKFxcdyspLyk7XG4gIHJldHVybiBtYXRjaCA/IG1hdGNoWzFdIDogJydcbn1cblxuZnVuY3Rpb24gaXNUeXBlICh0eXBlLCBmbikge1xuICBpZiAoIUFycmF5LmlzQXJyYXkoZm4pKSB7XG4gICAgcmV0dXJuIGdldFR5cGUoZm4pID09PSBnZXRUeXBlKHR5cGUpXG4gIH1cbiAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IGZuLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgaWYgKGdldFR5cGUoZm5baV0pID09PSBnZXRUeXBlKHR5cGUpKSB7XG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIH1cbiAgfVxuICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICByZXR1cm4gZmFsc2Vcbn1cblxuLyogICovXG5cbmZ1bmN0aW9uIGhhbmRsZUVycm9yIChlcnIsIHZtLCBpbmZvKSB7XG4gIGlmICh2bSkge1xuICAgIHZhciBjdXIgPSB2bTtcbiAgICB3aGlsZSAoKGN1ciA9IGN1ci4kcGFyZW50KSkge1xuICAgICAgdmFyIGhvb2tzID0gY3VyLiRvcHRpb25zLmVycm9yQ2FwdHVyZWQ7XG4gICAgICBpZiAoaG9va3MpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBob29rcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICB2YXIgY2FwdHVyZSA9IGhvb2tzW2ldLmNhbGwoY3VyLCBlcnIsIHZtLCBpbmZvKSA9PT0gZmFsc2U7XG4gICAgICAgICAgICBpZiAoY2FwdHVyZSkgeyByZXR1cm4gfVxuICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIGdsb2JhbEhhbmRsZUVycm9yKGUsIGN1ciwgJ2Vycm9yQ2FwdHVyZWQgaG9vaycpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuICBnbG9iYWxIYW5kbGVFcnJvcihlcnIsIHZtLCBpbmZvKTtcbn1cblxuZnVuY3Rpb24gZ2xvYmFsSGFuZGxlRXJyb3IgKGVyciwgdm0sIGluZm8pIHtcbiAgaWYgKGNvbmZpZy5lcnJvckhhbmRsZXIpIHtcbiAgICB0cnkge1xuICAgICAgcmV0dXJuIGNvbmZpZy5lcnJvckhhbmRsZXIuY2FsbChudWxsLCBlcnIsIHZtLCBpbmZvKVxuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIGxvZ0Vycm9yKGUsIG51bGwsICdjb25maWcuZXJyb3JIYW5kbGVyJyk7XG4gICAgfVxuICB9XG4gIGxvZ0Vycm9yKGVyciwgdm0sIGluZm8pO1xufVxuXG5mdW5jdGlvbiBsb2dFcnJvciAoZXJyLCB2bSwgaW5mbykge1xuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgIHdhcm4oKFwiRXJyb3IgaW4gXCIgKyBpbmZvICsgXCI6IFxcXCJcIiArIChlcnIudG9TdHJpbmcoKSkgKyBcIlxcXCJcIiksIHZtKTtcbiAgfVxuICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuICBpZiAoKGluQnJvd3NlciB8fCBpbldlZXgpICYmIHR5cGVvZiBjb25zb2xlICE9PSAndW5kZWZpbmVkJykge1xuICAgIGNvbnNvbGUuZXJyb3IoZXJyKTtcbiAgfSBlbHNlIHtcbiAgICB0aHJvdyBlcnJcbiAgfVxufVxuXG4vKiAgKi9cbi8qIGdsb2JhbHMgTWVzc2FnZUNoYW5uZWwgKi9cblxudmFyIGNhbGxiYWNrcyA9IFtdO1xudmFyIHBlbmRpbmcgPSBmYWxzZTtcblxuZnVuY3Rpb24gZmx1c2hDYWxsYmFja3MgKCkge1xuICBwZW5kaW5nID0gZmFsc2U7XG4gIHZhciBjb3BpZXMgPSBjYWxsYmFja3Muc2xpY2UoMCk7XG4gIGNhbGxiYWNrcy5sZW5ndGggPSAwO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGNvcGllcy5sZW5ndGg7IGkrKykge1xuICAgIGNvcGllc1tpXSgpO1xuICB9XG59XG5cbi8vIEhlcmUgd2UgaGF2ZSBhc3luYyBkZWZlcnJpbmcgd3JhcHBlcnMgdXNpbmcgYm90aCBtaWNybyBhbmQgbWFjcm8gdGFza3MuXG4vLyBJbiA8IDIuNCB3ZSB1c2VkIG1pY3JvIHRhc2tzIGV2ZXJ5d2hlcmUsIGJ1dCB0aGVyZSBhcmUgc29tZSBzY2VuYXJpb3Mgd2hlcmVcbi8vIG1pY3JvIHRhc2tzIGhhdmUgdG9vIGhpZ2ggYSBwcmlvcml0eSBhbmQgZmlyZXMgaW4gYmV0d2VlbiBzdXBwb3NlZGx5XG4vLyBzZXF1ZW50aWFsIGV2ZW50cyAoZS5nLiAjNDUyMSwgIzY2OTApIG9yIGV2ZW4gYmV0d2VlbiBidWJibGluZyBvZiB0aGUgc2FtZVxuLy8gZXZlbnQgKCM2NTY2KS4gSG93ZXZlciwgdXNpbmcgbWFjcm8gdGFza3MgZXZlcnl3aGVyZSBhbHNvIGhhcyBzdWJ0bGUgcHJvYmxlbXNcbi8vIHdoZW4gc3RhdGUgaXMgY2hhbmdlZCByaWdodCBiZWZvcmUgcmVwYWludCAoZS5nLiAjNjgxMywgb3V0LWluIHRyYW5zaXRpb25zKS5cbi8vIEhlcmUgd2UgdXNlIG1pY3JvIHRhc2sgYnkgZGVmYXVsdCwgYnV0IGV4cG9zZSBhIHdheSB0byBmb3JjZSBtYWNybyB0YXNrIHdoZW5cbi8vIG5lZWRlZCAoZS5nLiBpbiBldmVudCBoYW5kbGVycyBhdHRhY2hlZCBieSB2LW9uKS5cbnZhciBtaWNyb1RpbWVyRnVuYztcbnZhciBtYWNyb1RpbWVyRnVuYztcbnZhciB1c2VNYWNyb1Rhc2sgPSBmYWxzZTtcblxuLy8gRGV0ZXJtaW5lIChtYWNybykgVGFzayBkZWZlciBpbXBsZW1lbnRhdGlvbi5cbi8vIFRlY2huaWNhbGx5IHNldEltbWVkaWF0ZSBzaG91bGQgYmUgdGhlIGlkZWFsIGNob2ljZSwgYnV0IGl0J3Mgb25seSBhdmFpbGFibGVcbi8vIGluIElFLiBUaGUgb25seSBwb2x5ZmlsbCB0aGF0IGNvbnNpc3RlbnRseSBxdWV1ZXMgdGhlIGNhbGxiYWNrIGFmdGVyIGFsbCBET01cbi8vIGV2ZW50cyB0cmlnZ2VyZWQgaW4gdGhlIHNhbWUgbG9vcCBpcyBieSB1c2luZyBNZXNzYWdlQ2hhbm5lbC5cbi8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuaWYgKHR5cGVvZiBzZXRJbW1lZGlhdGUgIT09ICd1bmRlZmluZWQnICYmIGlzTmF0aXZlKHNldEltbWVkaWF0ZSkpIHtcbiAgbWFjcm9UaW1lckZ1bmMgPSBmdW5jdGlvbiAoKSB7XG4gICAgc2V0SW1tZWRpYXRlKGZsdXNoQ2FsbGJhY2tzKTtcbiAgfTtcbn0gZWxzZSBpZiAodHlwZW9mIE1lc3NhZ2VDaGFubmVsICE9PSAndW5kZWZpbmVkJyAmJiAoXG4gIGlzTmF0aXZlKE1lc3NhZ2VDaGFubmVsKSB8fFxuICAvLyBQaGFudG9tSlNcbiAgTWVzc2FnZUNoYW5uZWwudG9TdHJpbmcoKSA9PT0gJ1tvYmplY3QgTWVzc2FnZUNoYW5uZWxDb25zdHJ1Y3Rvcl0nXG4pKSB7XG4gIHZhciBjaGFubmVsID0gbmV3IE1lc3NhZ2VDaGFubmVsKCk7XG4gIHZhciBwb3J0ID0gY2hhbm5lbC5wb3J0MjtcbiAgY2hhbm5lbC5wb3J0MS5vbm1lc3NhZ2UgPSBmbHVzaENhbGxiYWNrcztcbiAgbWFjcm9UaW1lckZ1bmMgPSBmdW5jdGlvbiAoKSB7XG4gICAgcG9ydC5wb3N0TWVzc2FnZSgxKTtcbiAgfTtcbn0gZWxzZSB7XG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gIG1hY3JvVGltZXJGdW5jID0gZnVuY3Rpb24gKCkge1xuICAgIHNldFRpbWVvdXQoZmx1c2hDYWxsYmFja3MsIDApO1xuICB9O1xufVxuXG4vLyBEZXRlcm1pbmUgTWljcm9UYXNrIGRlZmVyIGltcGxlbWVudGF0aW9uLlxuLyogaXN0YW5idWwgaWdub3JlIG5leHQsICRmbG93LWRpc2FibGUtbGluZSAqL1xuaWYgKHR5cGVvZiBQcm9taXNlICE9PSAndW5kZWZpbmVkJyAmJiBpc05hdGl2ZShQcm9taXNlKSkge1xuICB2YXIgcCA9IFByb21pc2UucmVzb2x2ZSgpO1xuICBtaWNyb1RpbWVyRnVuYyA9IGZ1bmN0aW9uICgpIHtcbiAgICBwLnRoZW4oZmx1c2hDYWxsYmFja3MpO1xuICAgIC8vIGluIHByb2JsZW1hdGljIFVJV2ViVmlld3MsIFByb21pc2UudGhlbiBkb2Vzbid0IGNvbXBsZXRlbHkgYnJlYWssIGJ1dFxuICAgIC8vIGl0IGNhbiBnZXQgc3R1Y2sgaW4gYSB3ZWlyZCBzdGF0ZSB3aGVyZSBjYWxsYmFja3MgYXJlIHB1c2hlZCBpbnRvIHRoZVxuICAgIC8vIG1pY3JvdGFzayBxdWV1ZSBidXQgdGhlIHF1ZXVlIGlzbid0IGJlaW5nIGZsdXNoZWQsIHVudGlsIHRoZSBicm93c2VyXG4gICAgLy8gbmVlZHMgdG8gZG8gc29tZSBvdGhlciB3b3JrLCBlLmcuIGhhbmRsZSBhIHRpbWVyLiBUaGVyZWZvcmUgd2UgY2FuXG4gICAgLy8gXCJmb3JjZVwiIHRoZSBtaWNyb3Rhc2sgcXVldWUgdG8gYmUgZmx1c2hlZCBieSBhZGRpbmcgYW4gZW1wdHkgdGltZXIuXG4gICAgaWYgKGlzSU9TKSB7IHNldFRpbWVvdXQobm9vcCk7IH1cbiAgfTtcbn0gZWxzZSB7XG4gIC8vIGZhbGxiYWNrIHRvIG1hY3JvXG4gIG1pY3JvVGltZXJGdW5jID0gbWFjcm9UaW1lckZ1bmM7XG59XG5cbi8qKlxuICogV3JhcCBhIGZ1bmN0aW9uIHNvIHRoYXQgaWYgYW55IGNvZGUgaW5zaWRlIHRyaWdnZXJzIHN0YXRlIGNoYW5nZSxcbiAqIHRoZSBjaGFuZ2VzIGFyZSBxdWV1ZWQgdXNpbmcgYSBUYXNrIGluc3RlYWQgb2YgYSBNaWNyb1Rhc2suXG4gKi9cbmZ1bmN0aW9uIHdpdGhNYWNyb1Rhc2sgKGZuKSB7XG4gIHJldHVybiBmbi5fd2l0aFRhc2sgfHwgKGZuLl93aXRoVGFzayA9IGZ1bmN0aW9uICgpIHtcbiAgICB1c2VNYWNyb1Rhc2sgPSB0cnVlO1xuICAgIHZhciByZXMgPSBmbi5hcHBseShudWxsLCBhcmd1bWVudHMpO1xuICAgIHVzZU1hY3JvVGFzayA9IGZhbHNlO1xuICAgIHJldHVybiByZXNcbiAgfSlcbn1cblxuZnVuY3Rpb24gbmV4dFRpY2sgKGNiLCBjdHgpIHtcbiAgdmFyIF9yZXNvbHZlO1xuICBjYWxsYmFja3MucHVzaChmdW5jdGlvbiAoKSB7XG4gICAgaWYgKGNiKSB7XG4gICAgICB0cnkge1xuICAgICAgICBjYi5jYWxsKGN0eCk7XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIGhhbmRsZUVycm9yKGUsIGN0eCwgJ25leHRUaWNrJyk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChfcmVzb2x2ZSkge1xuICAgICAgX3Jlc29sdmUoY3R4KTtcbiAgICB9XG4gIH0pO1xuICBpZiAoIXBlbmRpbmcpIHtcbiAgICBwZW5kaW5nID0gdHJ1ZTtcbiAgICBpZiAodXNlTWFjcm9UYXNrKSB7XG4gICAgICBtYWNyb1RpbWVyRnVuYygpO1xuICAgIH0gZWxzZSB7XG4gICAgICBtaWNyb1RpbWVyRnVuYygpO1xuICAgIH1cbiAgfVxuICAvLyAkZmxvdy1kaXNhYmxlLWxpbmVcbiAgaWYgKCFjYiAmJiB0eXBlb2YgUHJvbWlzZSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUpIHtcbiAgICAgIF9yZXNvbHZlID0gcmVzb2x2ZTtcbiAgICB9KVxuICB9XG59XG5cbi8qICAqL1xuXG52YXIgbWFyaztcbnZhciBtZWFzdXJlO1xuXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICB2YXIgcGVyZiA9IGluQnJvd3NlciAmJiB3aW5kb3cucGVyZm9ybWFuY2U7XG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICBpZiAoXG4gICAgcGVyZiAmJlxuICAgIHBlcmYubWFyayAmJlxuICAgIHBlcmYubWVhc3VyZSAmJlxuICAgIHBlcmYuY2xlYXJNYXJrcyAmJlxuICAgIHBlcmYuY2xlYXJNZWFzdXJlc1xuICApIHtcbiAgICBtYXJrID0gZnVuY3Rpb24gKHRhZykgeyByZXR1cm4gcGVyZi5tYXJrKHRhZyk7IH07XG4gICAgbWVhc3VyZSA9IGZ1bmN0aW9uIChuYW1lLCBzdGFydFRhZywgZW5kVGFnKSB7XG4gICAgICBwZXJmLm1lYXN1cmUobmFtZSwgc3RhcnRUYWcsIGVuZFRhZyk7XG4gICAgICBwZXJmLmNsZWFyTWFya3Moc3RhcnRUYWcpO1xuICAgICAgcGVyZi5jbGVhck1hcmtzKGVuZFRhZyk7XG4gICAgICBwZXJmLmNsZWFyTWVhc3VyZXMobmFtZSk7XG4gICAgfTtcbiAgfVxufVxuXG4vKiBub3QgdHlwZSBjaGVja2luZyB0aGlzIGZpbGUgYmVjYXVzZSBmbG93IGRvZXNuJ3QgcGxheSB3ZWxsIHdpdGggUHJveHkgKi9cblxudmFyIGluaXRQcm94eTtcblxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgdmFyIGFsbG93ZWRHbG9iYWxzID0gbWFrZU1hcChcbiAgICAnSW5maW5pdHksdW5kZWZpbmVkLE5hTixpc0Zpbml0ZSxpc05hTiwnICtcbiAgICAncGFyc2VGbG9hdCxwYXJzZUludCxkZWNvZGVVUkksZGVjb2RlVVJJQ29tcG9uZW50LGVuY29kZVVSSSxlbmNvZGVVUklDb21wb25lbnQsJyArXG4gICAgJ01hdGgsTnVtYmVyLERhdGUsQXJyYXksT2JqZWN0LEJvb2xlYW4sU3RyaW5nLFJlZ0V4cCxNYXAsU2V0LEpTT04sSW50bCwnICtcbiAgICAncmVxdWlyZScgLy8gZm9yIFdlYnBhY2svQnJvd3NlcmlmeVxuICApO1xuXG4gIHZhciB3YXJuTm9uUHJlc2VudCA9IGZ1bmN0aW9uICh0YXJnZXQsIGtleSkge1xuICAgIHdhcm4oXG4gICAgICBcIlByb3BlcnR5IG9yIG1ldGhvZCBcXFwiXCIgKyBrZXkgKyBcIlxcXCIgaXMgbm90IGRlZmluZWQgb24gdGhlIGluc3RhbmNlIGJ1dCBcIiArXG4gICAgICAncmVmZXJlbmNlZCBkdXJpbmcgcmVuZGVyLiBNYWtlIHN1cmUgdGhhdCB0aGlzIHByb3BlcnR5IGlzIHJlYWN0aXZlLCAnICtcbiAgICAgICdlaXRoZXIgaW4gdGhlIGRhdGEgb3B0aW9uLCBvciBmb3IgY2xhc3MtYmFzZWQgY29tcG9uZW50cywgYnkgJyArXG4gICAgICAnaW5pdGlhbGl6aW5nIHRoZSBwcm9wZXJ0eS4gJyArXG4gICAgICAnU2VlOiBodHRwczovL3Z1ZWpzLm9yZy92Mi9ndWlkZS9yZWFjdGl2aXR5Lmh0bWwjRGVjbGFyaW5nLVJlYWN0aXZlLVByb3BlcnRpZXMuJyxcbiAgICAgIHRhcmdldFxuICAgICk7XG4gIH07XG5cbiAgdmFyIGhhc1Byb3h5ID1cbiAgICB0eXBlb2YgUHJveHkgIT09ICd1bmRlZmluZWQnICYmXG4gICAgUHJveHkudG9TdHJpbmcoKS5tYXRjaCgvbmF0aXZlIGNvZGUvKTtcblxuICBpZiAoaGFzUHJveHkpIHtcbiAgICB2YXIgaXNCdWlsdEluTW9kaWZpZXIgPSBtYWtlTWFwKCdzdG9wLHByZXZlbnQsc2VsZixjdHJsLHNoaWZ0LGFsdCxtZXRhLGV4YWN0Jyk7XG4gICAgY29uZmlnLmtleUNvZGVzID0gbmV3IFByb3h5KGNvbmZpZy5rZXlDb2Rlcywge1xuICAgICAgc2V0OiBmdW5jdGlvbiBzZXQgKHRhcmdldCwga2V5LCB2YWx1ZSkge1xuICAgICAgICBpZiAoaXNCdWlsdEluTW9kaWZpZXIoa2V5KSkge1xuICAgICAgICAgIHdhcm4oKFwiQXZvaWQgb3ZlcndyaXRpbmcgYnVpbHQtaW4gbW9kaWZpZXIgaW4gY29uZmlnLmtleUNvZGVzOiAuXCIgKyBrZXkpKTtcbiAgICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0YXJnZXRba2V5XSA9IHZhbHVlO1xuICAgICAgICAgIHJldHVybiB0cnVlXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIHZhciBoYXNIYW5kbGVyID0ge1xuICAgIGhhczogZnVuY3Rpb24gaGFzICh0YXJnZXQsIGtleSkge1xuICAgICAgdmFyIGhhcyA9IGtleSBpbiB0YXJnZXQ7XG4gICAgICB2YXIgaXNBbGxvd2VkID0gYWxsb3dlZEdsb2JhbHMoa2V5KSB8fCBrZXkuY2hhckF0KDApID09PSAnXyc7XG4gICAgICBpZiAoIWhhcyAmJiAhaXNBbGxvd2VkKSB7XG4gICAgICAgIHdhcm5Ob25QcmVzZW50KHRhcmdldCwga2V5KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBoYXMgfHwgIWlzQWxsb3dlZFxuICAgIH1cbiAgfTtcblxuICB2YXIgZ2V0SGFuZGxlciA9IHtcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCAodGFyZ2V0LCBrZXkpIHtcbiAgICAgIGlmICh0eXBlb2Yga2V5ID09PSAnc3RyaW5nJyAmJiAhKGtleSBpbiB0YXJnZXQpKSB7XG4gICAgICAgIHdhcm5Ob25QcmVzZW50KHRhcmdldCwga2V5KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0YXJnZXRba2V5XVxuICAgIH1cbiAgfTtcblxuICBpbml0UHJveHkgPSBmdW5jdGlvbiBpbml0UHJveHkgKHZtKSB7XG4gICAgaWYgKGhhc1Byb3h5KSB7XG4gICAgICAvLyBkZXRlcm1pbmUgd2hpY2ggcHJveHkgaGFuZGxlciB0byB1c2VcbiAgICAgIHZhciBvcHRpb25zID0gdm0uJG9wdGlvbnM7XG4gICAgICB2YXIgaGFuZGxlcnMgPSBvcHRpb25zLnJlbmRlciAmJiBvcHRpb25zLnJlbmRlci5fd2l0aFN0cmlwcGVkXG4gICAgICAgID8gZ2V0SGFuZGxlclxuICAgICAgICA6IGhhc0hhbmRsZXI7XG4gICAgICB2bS5fcmVuZGVyUHJveHkgPSBuZXcgUHJveHkodm0sIGhhbmRsZXJzKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdm0uX3JlbmRlclByb3h5ID0gdm07XG4gICAgfVxuICB9O1xufVxuXG4vKiAgKi9cblxudmFyIHNlZW5PYmplY3RzID0gbmV3IF9TZXQoKTtcblxuLyoqXG4gKiBSZWN1cnNpdmVseSB0cmF2ZXJzZSBhbiBvYmplY3QgdG8gZXZva2UgYWxsIGNvbnZlcnRlZFxuICogZ2V0dGVycywgc28gdGhhdCBldmVyeSBuZXN0ZWQgcHJvcGVydHkgaW5zaWRlIHRoZSBvYmplY3RcbiAqIGlzIGNvbGxlY3RlZCBhcyBhIFwiZGVlcFwiIGRlcGVuZGVuY3kuXG4gKi9cbmZ1bmN0aW9uIHRyYXZlcnNlICh2YWwpIHtcbiAgX3RyYXZlcnNlKHZhbCwgc2Vlbk9iamVjdHMpO1xuICBzZWVuT2JqZWN0cy5jbGVhcigpO1xufVxuXG5mdW5jdGlvbiBfdHJhdmVyc2UgKHZhbCwgc2Vlbikge1xuICB2YXIgaSwga2V5cztcbiAgdmFyIGlzQSA9IEFycmF5LmlzQXJyYXkodmFsKTtcbiAgaWYgKCghaXNBICYmICFpc09iamVjdCh2YWwpKSB8fCBPYmplY3QuaXNGcm96ZW4odmFsKSkge1xuICAgIHJldHVyblxuICB9XG4gIGlmICh2YWwuX19vYl9fKSB7XG4gICAgdmFyIGRlcElkID0gdmFsLl9fb2JfXy5kZXAuaWQ7XG4gICAgaWYgKHNlZW4uaGFzKGRlcElkKSkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuICAgIHNlZW4uYWRkKGRlcElkKTtcbiAgfVxuICBpZiAoaXNBKSB7XG4gICAgaSA9IHZhbC5sZW5ndGg7XG4gICAgd2hpbGUgKGktLSkgeyBfdHJhdmVyc2UodmFsW2ldLCBzZWVuKTsgfVxuICB9IGVsc2Uge1xuICAgIGtleXMgPSBPYmplY3Qua2V5cyh2YWwpO1xuICAgIGkgPSBrZXlzLmxlbmd0aDtcbiAgICB3aGlsZSAoaS0tKSB7IF90cmF2ZXJzZSh2YWxba2V5c1tpXV0sIHNlZW4pOyB9XG4gIH1cbn1cblxuLyogICovXG5cbnZhciBub3JtYWxpemVFdmVudCA9IGNhY2hlZChmdW5jdGlvbiAobmFtZSkge1xuICB2YXIgcGFzc2l2ZSA9IG5hbWUuY2hhckF0KDApID09PSAnJic7XG4gIG5hbWUgPSBwYXNzaXZlID8gbmFtZS5zbGljZSgxKSA6IG5hbWU7XG4gIHZhciBvbmNlJCQxID0gbmFtZS5jaGFyQXQoMCkgPT09ICd+JzsgLy8gUHJlZml4ZWQgbGFzdCwgY2hlY2tlZCBmaXJzdFxuICBuYW1lID0gb25jZSQkMSA/IG5hbWUuc2xpY2UoMSkgOiBuYW1lO1xuICB2YXIgY2FwdHVyZSA9IG5hbWUuY2hhckF0KDApID09PSAnISc7XG4gIG5hbWUgPSBjYXB0dXJlID8gbmFtZS5zbGljZSgxKSA6IG5hbWU7XG4gIHJldHVybiB7XG4gICAgbmFtZTogbmFtZSxcbiAgICBvbmNlOiBvbmNlJCQxLFxuICAgIGNhcHR1cmU6IGNhcHR1cmUsXG4gICAgcGFzc2l2ZTogcGFzc2l2ZVxuICB9XG59KTtcblxuZnVuY3Rpb24gY3JlYXRlRm5JbnZva2VyIChmbnMpIHtcbiAgZnVuY3Rpb24gaW52b2tlciAoKSB7XG4gICAgdmFyIGFyZ3VtZW50cyQxID0gYXJndW1lbnRzO1xuXG4gICAgdmFyIGZucyA9IGludm9rZXIuZm5zO1xuICAgIGlmIChBcnJheS5pc0FycmF5KGZucykpIHtcbiAgICAgIHZhciBjbG9uZWQgPSBmbnMuc2xpY2UoKTtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY2xvbmVkLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNsb25lZFtpXS5hcHBseShudWxsLCBhcmd1bWVudHMkMSk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIHJldHVybiBoYW5kbGVyIHJldHVybiB2YWx1ZSBmb3Igc2luZ2xlIGhhbmRsZXJzXG4gICAgICByZXR1cm4gZm5zLmFwcGx5KG51bGwsIGFyZ3VtZW50cylcbiAgICB9XG4gIH1cbiAgaW52b2tlci5mbnMgPSBmbnM7XG4gIHJldHVybiBpbnZva2VyXG59XG5cbmZ1bmN0aW9uIHVwZGF0ZUxpc3RlbmVycyAoXG4gIG9uLFxuICBvbGRPbixcbiAgYWRkLFxuICByZW1vdmUkJDEsXG4gIHZtXG4pIHtcbiAgdmFyIG5hbWUsIGN1ciwgb2xkLCBldmVudDtcbiAgZm9yIChuYW1lIGluIG9uKSB7XG4gICAgY3VyID0gb25bbmFtZV07XG4gICAgb2xkID0gb2xkT25bbmFtZV07XG4gICAgZXZlbnQgPSBub3JtYWxpemVFdmVudChuYW1lKTtcbiAgICBpZiAoaXNVbmRlZihjdXIpKSB7XG4gICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIHdhcm4oXG4gICAgICAgIFwiSW52YWxpZCBoYW5kbGVyIGZvciBldmVudCBcXFwiXCIgKyAoZXZlbnQubmFtZSkgKyBcIlxcXCI6IGdvdCBcIiArIFN0cmluZyhjdXIpLFxuICAgICAgICB2bVxuICAgICAgKTtcbiAgICB9IGVsc2UgaWYgKGlzVW5kZWYob2xkKSkge1xuICAgICAgaWYgKGlzVW5kZWYoY3VyLmZucykpIHtcbiAgICAgICAgY3VyID0gb25bbmFtZV0gPSBjcmVhdGVGbkludm9rZXIoY3VyKTtcbiAgICAgIH1cbiAgICAgIGFkZChldmVudC5uYW1lLCBjdXIsIGV2ZW50Lm9uY2UsIGV2ZW50LmNhcHR1cmUsIGV2ZW50LnBhc3NpdmUpO1xuICAgIH0gZWxzZSBpZiAoY3VyICE9PSBvbGQpIHtcbiAgICAgIG9sZC5mbnMgPSBjdXI7XG4gICAgICBvbltuYW1lXSA9IG9sZDtcbiAgICB9XG4gIH1cbiAgZm9yIChuYW1lIGluIG9sZE9uKSB7XG4gICAgaWYgKGlzVW5kZWYob25bbmFtZV0pKSB7XG4gICAgICBldmVudCA9IG5vcm1hbGl6ZUV2ZW50KG5hbWUpO1xuICAgICAgcmVtb3ZlJCQxKGV2ZW50Lm5hbWUsIG9sZE9uW25hbWVdLCBldmVudC5jYXB0dXJlKTtcbiAgICB9XG4gIH1cbn1cblxuLyogICovXG5cbmZ1bmN0aW9uIG1lcmdlVk5vZGVIb29rIChkZWYsIGhvb2tLZXksIGhvb2spIHtcbiAgaWYgKGRlZiBpbnN0YW5jZW9mIFZOb2RlKSB7XG4gICAgZGVmID0gZGVmLmRhdGEuaG9vayB8fCAoZGVmLmRhdGEuaG9vayA9IHt9KTtcbiAgfVxuICB2YXIgaW52b2tlcjtcbiAgdmFyIG9sZEhvb2sgPSBkZWZbaG9va0tleV07XG5cbiAgZnVuY3Rpb24gd3JhcHBlZEhvb2sgKCkge1xuICAgIGhvb2suYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAvLyBpbXBvcnRhbnQ6IHJlbW92ZSBtZXJnZWQgaG9vayB0byBlbnN1cmUgaXQncyBjYWxsZWQgb25seSBvbmNlXG4gICAgLy8gYW5kIHByZXZlbnQgbWVtb3J5IGxlYWtcbiAgICByZW1vdmUoaW52b2tlci5mbnMsIHdyYXBwZWRIb29rKTtcbiAgfVxuXG4gIGlmIChpc1VuZGVmKG9sZEhvb2spKSB7XG4gICAgLy8gbm8gZXhpc3RpbmcgaG9va1xuICAgIGludm9rZXIgPSBjcmVhdGVGbkludm9rZXIoW3dyYXBwZWRIb29rXSk7XG4gIH0gZWxzZSB7XG4gICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgaWYgKGlzRGVmKG9sZEhvb2suZm5zKSAmJiBpc1RydWUob2xkSG9vay5tZXJnZWQpKSB7XG4gICAgICAvLyBhbHJlYWR5IGEgbWVyZ2VkIGludm9rZXJcbiAgICAgIGludm9rZXIgPSBvbGRIb29rO1xuICAgICAgaW52b2tlci5mbnMucHVzaCh3cmFwcGVkSG9vayk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIGV4aXN0aW5nIHBsYWluIGhvb2tcbiAgICAgIGludm9rZXIgPSBjcmVhdGVGbkludm9rZXIoW29sZEhvb2ssIHdyYXBwZWRIb29rXSk7XG4gICAgfVxuICB9XG5cbiAgaW52b2tlci5tZXJnZWQgPSB0cnVlO1xuICBkZWZbaG9va0tleV0gPSBpbnZva2VyO1xufVxuXG4vKiAgKi9cblxuZnVuY3Rpb24gZXh0cmFjdFByb3BzRnJvbVZOb2RlRGF0YSAoXG4gIGRhdGEsXG4gIEN0b3IsXG4gIHRhZ1xuKSB7XG4gIC8vIHdlIGFyZSBvbmx5IGV4dHJhY3RpbmcgcmF3IHZhbHVlcyBoZXJlLlxuICAvLyB2YWxpZGF0aW9uIGFuZCBkZWZhdWx0IHZhbHVlcyBhcmUgaGFuZGxlZCBpbiB0aGUgY2hpbGRcbiAgLy8gY29tcG9uZW50IGl0c2VsZi5cbiAgdmFyIHByb3BPcHRpb25zID0gQ3Rvci5vcHRpb25zLnByb3BzO1xuICBpZiAoaXNVbmRlZihwcm9wT3B0aW9ucykpIHtcbiAgICByZXR1cm5cbiAgfVxuICB2YXIgcmVzID0ge307XG4gIHZhciBhdHRycyA9IGRhdGEuYXR0cnM7XG4gIHZhciBwcm9wcyA9IGRhdGEucHJvcHM7XG4gIGlmIChpc0RlZihhdHRycykgfHwgaXNEZWYocHJvcHMpKSB7XG4gICAgZm9yICh2YXIga2V5IGluIHByb3BPcHRpb25zKSB7XG4gICAgICB2YXIgYWx0S2V5ID0gaHlwaGVuYXRlKGtleSk7XG4gICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICB2YXIga2V5SW5Mb3dlckNhc2UgPSBrZXkudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgaWYgKFxuICAgICAgICAgIGtleSAhPT0ga2V5SW5Mb3dlckNhc2UgJiZcbiAgICAgICAgICBhdHRycyAmJiBoYXNPd24oYXR0cnMsIGtleUluTG93ZXJDYXNlKVxuICAgICAgICApIHtcbiAgICAgICAgICB0aXAoXG4gICAgICAgICAgICBcIlByb3AgXFxcIlwiICsga2V5SW5Mb3dlckNhc2UgKyBcIlxcXCIgaXMgcGFzc2VkIHRvIGNvbXBvbmVudCBcIiArXG4gICAgICAgICAgICAoZm9ybWF0Q29tcG9uZW50TmFtZSh0YWcgfHwgQ3RvcikpICsgXCIsIGJ1dCB0aGUgZGVjbGFyZWQgcHJvcCBuYW1lIGlzXCIgK1xuICAgICAgICAgICAgXCIgXFxcIlwiICsga2V5ICsgXCJcXFwiLiBcIiArXG4gICAgICAgICAgICBcIk5vdGUgdGhhdCBIVE1MIGF0dHJpYnV0ZXMgYXJlIGNhc2UtaW5zZW5zaXRpdmUgYW5kIGNhbWVsQ2FzZWQgXCIgK1xuICAgICAgICAgICAgXCJwcm9wcyBuZWVkIHRvIHVzZSB0aGVpciBrZWJhYi1jYXNlIGVxdWl2YWxlbnRzIHdoZW4gdXNpbmcgaW4tRE9NIFwiICtcbiAgICAgICAgICAgIFwidGVtcGxhdGVzLiBZb3Ugc2hvdWxkIHByb2JhYmx5IHVzZSBcXFwiXCIgKyBhbHRLZXkgKyBcIlxcXCIgaW5zdGVhZCBvZiBcXFwiXCIgKyBrZXkgKyBcIlxcXCIuXCJcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBjaGVja1Byb3AocmVzLCBwcm9wcywga2V5LCBhbHRLZXksIHRydWUpIHx8XG4gICAgICBjaGVja1Byb3AocmVzLCBhdHRycywga2V5LCBhbHRLZXksIGZhbHNlKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc1xufVxuXG5mdW5jdGlvbiBjaGVja1Byb3AgKFxuICByZXMsXG4gIGhhc2gsXG4gIGtleSxcbiAgYWx0S2V5LFxuICBwcmVzZXJ2ZVxuKSB7XG4gIGlmIChpc0RlZihoYXNoKSkge1xuICAgIGlmIChoYXNPd24oaGFzaCwga2V5KSkge1xuICAgICAgcmVzW2tleV0gPSBoYXNoW2tleV07XG4gICAgICBpZiAoIXByZXNlcnZlKSB7XG4gICAgICAgIGRlbGV0ZSBoYXNoW2tleV07XG4gICAgICB9XG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIH0gZWxzZSBpZiAoaGFzT3duKGhhc2gsIGFsdEtleSkpIHtcbiAgICAgIHJlc1trZXldID0gaGFzaFthbHRLZXldO1xuICAgICAgaWYgKCFwcmVzZXJ2ZSkge1xuICAgICAgICBkZWxldGUgaGFzaFthbHRLZXldO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRydWVcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGZhbHNlXG59XG5cbi8qICAqL1xuXG4vLyBUaGUgdGVtcGxhdGUgY29tcGlsZXIgYXR0ZW1wdHMgdG8gbWluaW1pemUgdGhlIG5lZWQgZm9yIG5vcm1hbGl6YXRpb24gYnlcbi8vIHN0YXRpY2FsbHkgYW5hbHl6aW5nIHRoZSB0ZW1wbGF0ZSBhdCBjb21waWxlIHRpbWUuXG4vL1xuLy8gRm9yIHBsYWluIEhUTUwgbWFya3VwLCBub3JtYWxpemF0aW9uIGNhbiBiZSBjb21wbGV0ZWx5IHNraXBwZWQgYmVjYXVzZSB0aGVcbi8vIGdlbmVyYXRlZCByZW5kZXIgZnVuY3Rpb24gaXMgZ3VhcmFudGVlZCB0byByZXR1cm4gQXJyYXk8Vk5vZGU+LiBUaGVyZSBhcmVcbi8vIHR3byBjYXNlcyB3aGVyZSBleHRyYSBub3JtYWxpemF0aW9uIGlzIG5lZWRlZDpcblxuLy8gMS4gV2hlbiB0aGUgY2hpbGRyZW4gY29udGFpbnMgY29tcG9uZW50cyAtIGJlY2F1c2UgYSBmdW5jdGlvbmFsIGNvbXBvbmVudFxuLy8gbWF5IHJldHVybiBhbiBBcnJheSBpbnN0ZWFkIG9mIGEgc2luZ2xlIHJvb3QuIEluIHRoaXMgY2FzZSwganVzdCBhIHNpbXBsZVxuLy8gbm9ybWFsaXphdGlvbiBpcyBuZWVkZWQgLSBpZiBhbnkgY2hpbGQgaXMgYW4gQXJyYXksIHdlIGZsYXR0ZW4gdGhlIHdob2xlXG4vLyB0aGluZyB3aXRoIEFycmF5LnByb3RvdHlwZS5jb25jYXQuIEl0IGlzIGd1YXJhbnRlZWQgdG8gYmUgb25seSAxLWxldmVsIGRlZXBcbi8vIGJlY2F1c2UgZnVuY3Rpb25hbCBjb21wb25lbnRzIGFscmVhZHkgbm9ybWFsaXplIHRoZWlyIG93biBjaGlsZHJlbi5cbmZ1bmN0aW9uIHNpbXBsZU5vcm1hbGl6ZUNoaWxkcmVuIChjaGlsZHJlbikge1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkoY2hpbGRyZW5baV0pKSB7XG4gICAgICByZXR1cm4gQXJyYXkucHJvdG90eXBlLmNvbmNhdC5hcHBseShbXSwgY2hpbGRyZW4pXG4gICAgfVxuICB9XG4gIHJldHVybiBjaGlsZHJlblxufVxuXG4vLyAyLiBXaGVuIHRoZSBjaGlsZHJlbiBjb250YWlucyBjb25zdHJ1Y3RzIHRoYXQgYWx3YXlzIGdlbmVyYXRlZCBuZXN0ZWQgQXJyYXlzLFxuLy8gZS5nLiA8dGVtcGxhdGU+LCA8c2xvdD4sIHYtZm9yLCBvciB3aGVuIHRoZSBjaGlsZHJlbiBpcyBwcm92aWRlZCBieSB1c2VyXG4vLyB3aXRoIGhhbmQtd3JpdHRlbiByZW5kZXIgZnVuY3Rpb25zIC8gSlNYLiBJbiBzdWNoIGNhc2VzIGEgZnVsbCBub3JtYWxpemF0aW9uXG4vLyBpcyBuZWVkZWQgdG8gY2F0ZXIgdG8gYWxsIHBvc3NpYmxlIHR5cGVzIG9mIGNoaWxkcmVuIHZhbHVlcy5cbmZ1bmN0aW9uIG5vcm1hbGl6ZUNoaWxkcmVuIChjaGlsZHJlbikge1xuICByZXR1cm4gaXNQcmltaXRpdmUoY2hpbGRyZW4pXG4gICAgPyBbY3JlYXRlVGV4dFZOb2RlKGNoaWxkcmVuKV1cbiAgICA6IEFycmF5LmlzQXJyYXkoY2hpbGRyZW4pXG4gICAgICA/IG5vcm1hbGl6ZUFycmF5Q2hpbGRyZW4oY2hpbGRyZW4pXG4gICAgICA6IHVuZGVmaW5lZFxufVxuXG5mdW5jdGlvbiBpc1RleHROb2RlIChub2RlKSB7XG4gIHJldHVybiBpc0RlZihub2RlKSAmJiBpc0RlZihub2RlLnRleHQpICYmIGlzRmFsc2Uobm9kZS5pc0NvbW1lbnQpXG59XG5cbmZ1bmN0aW9uIG5vcm1hbGl6ZUFycmF5Q2hpbGRyZW4gKGNoaWxkcmVuLCBuZXN0ZWRJbmRleCkge1xuICB2YXIgcmVzID0gW107XG4gIHZhciBpLCBjLCBsYXN0SW5kZXgsIGxhc3Q7XG4gIGZvciAoaSA9IDA7IGkgPCBjaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgIGMgPSBjaGlsZHJlbltpXTtcbiAgICBpZiAoaXNVbmRlZihjKSB8fCB0eXBlb2YgYyA9PT0gJ2Jvb2xlYW4nKSB7IGNvbnRpbnVlIH1cbiAgICBsYXN0SW5kZXggPSByZXMubGVuZ3RoIC0gMTtcbiAgICBsYXN0ID0gcmVzW2xhc3RJbmRleF07XG4gICAgLy8gIG5lc3RlZFxuICAgIGlmIChBcnJheS5pc0FycmF5KGMpKSB7XG4gICAgICBpZiAoYy5sZW5ndGggPiAwKSB7XG4gICAgICAgIGMgPSBub3JtYWxpemVBcnJheUNoaWxkcmVuKGMsICgobmVzdGVkSW5kZXggfHwgJycpICsgXCJfXCIgKyBpKSk7XG4gICAgICAgIC8vIG1lcmdlIGFkamFjZW50IHRleHQgbm9kZXNcbiAgICAgICAgaWYgKGlzVGV4dE5vZGUoY1swXSkgJiYgaXNUZXh0Tm9kZShsYXN0KSkge1xuICAgICAgICAgIHJlc1tsYXN0SW5kZXhdID0gY3JlYXRlVGV4dFZOb2RlKGxhc3QudGV4dCArIChjWzBdKS50ZXh0KTtcbiAgICAgICAgICBjLnNoaWZ0KCk7XG4gICAgICAgIH1cbiAgICAgICAgcmVzLnB1c2guYXBwbHkocmVzLCBjKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGlzUHJpbWl0aXZlKGMpKSB7XG4gICAgICBpZiAoaXNUZXh0Tm9kZShsYXN0KSkge1xuICAgICAgICAvLyBtZXJnZSBhZGphY2VudCB0ZXh0IG5vZGVzXG4gICAgICAgIC8vIHRoaXMgaXMgbmVjZXNzYXJ5IGZvciBTU1IgaHlkcmF0aW9uIGJlY2F1c2UgdGV4dCBub2RlcyBhcmVcbiAgICAgICAgLy8gZXNzZW50aWFsbHkgbWVyZ2VkIHdoZW4gcmVuZGVyZWQgdG8gSFRNTCBzdHJpbmdzXG4gICAgICAgIHJlc1tsYXN0SW5kZXhdID0gY3JlYXRlVGV4dFZOb2RlKGxhc3QudGV4dCArIGMpO1xuICAgICAgfSBlbHNlIGlmIChjICE9PSAnJykge1xuICAgICAgICAvLyBjb252ZXJ0IHByaW1pdGl2ZSB0byB2bm9kZVxuICAgICAgICByZXMucHVzaChjcmVhdGVUZXh0Vk5vZGUoYykpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoaXNUZXh0Tm9kZShjKSAmJiBpc1RleHROb2RlKGxhc3QpKSB7XG4gICAgICAgIC8vIG1lcmdlIGFkamFjZW50IHRleHQgbm9kZXNcbiAgICAgICAgcmVzW2xhc3RJbmRleF0gPSBjcmVhdGVUZXh0Vk5vZGUobGFzdC50ZXh0ICsgYy50ZXh0KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIGRlZmF1bHQga2V5IGZvciBuZXN0ZWQgYXJyYXkgY2hpbGRyZW4gKGxpa2VseSBnZW5lcmF0ZWQgYnkgdi1mb3IpXG4gICAgICAgIGlmIChpc1RydWUoY2hpbGRyZW4uX2lzVkxpc3QpICYmXG4gICAgICAgICAgaXNEZWYoYy50YWcpICYmXG4gICAgICAgICAgaXNVbmRlZihjLmtleSkgJiZcbiAgICAgICAgICBpc0RlZihuZXN0ZWRJbmRleCkpIHtcbiAgICAgICAgICBjLmtleSA9IFwiX192bGlzdFwiICsgbmVzdGVkSW5kZXggKyBcIl9cIiArIGkgKyBcIl9fXCI7XG4gICAgICAgIH1cbiAgICAgICAgcmVzLnB1c2goYyk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiByZXNcbn1cblxuLyogICovXG5cbmZ1bmN0aW9uIGVuc3VyZUN0b3IgKGNvbXAsIGJhc2UpIHtcbiAgaWYgKFxuICAgIGNvbXAuX19lc01vZHVsZSB8fFxuICAgIChoYXNTeW1ib2wgJiYgY29tcFtTeW1ib2wudG9TdHJpbmdUYWddID09PSAnTW9kdWxlJylcbiAgKSB7XG4gICAgY29tcCA9IGNvbXAuZGVmYXVsdDtcbiAgfVxuICByZXR1cm4gaXNPYmplY3QoY29tcClcbiAgICA/IGJhc2UuZXh0ZW5kKGNvbXApXG4gICAgOiBjb21wXG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUFzeW5jUGxhY2Vob2xkZXIgKFxuICBmYWN0b3J5LFxuICBkYXRhLFxuICBjb250ZXh0LFxuICBjaGlsZHJlbixcbiAgdGFnXG4pIHtcbiAgdmFyIG5vZGUgPSBjcmVhdGVFbXB0eVZOb2RlKCk7XG4gIG5vZGUuYXN5bmNGYWN0b3J5ID0gZmFjdG9yeTtcbiAgbm9kZS5hc3luY01ldGEgPSB7IGRhdGE6IGRhdGEsIGNvbnRleHQ6IGNvbnRleHQsIGNoaWxkcmVuOiBjaGlsZHJlbiwgdGFnOiB0YWcgfTtcbiAgcmV0dXJuIG5vZGVcbn1cblxuZnVuY3Rpb24gcmVzb2x2ZUFzeW5jQ29tcG9uZW50IChcbiAgZmFjdG9yeSxcbiAgYmFzZUN0b3IsXG4gIGNvbnRleHRcbikge1xuICBpZiAoaXNUcnVlKGZhY3RvcnkuZXJyb3IpICYmIGlzRGVmKGZhY3RvcnkuZXJyb3JDb21wKSkge1xuICAgIHJldHVybiBmYWN0b3J5LmVycm9yQ29tcFxuICB9XG5cbiAgaWYgKGlzRGVmKGZhY3RvcnkucmVzb2x2ZWQpKSB7XG4gICAgcmV0dXJuIGZhY3RvcnkucmVzb2x2ZWRcbiAgfVxuXG4gIGlmIChpc1RydWUoZmFjdG9yeS5sb2FkaW5nKSAmJiBpc0RlZihmYWN0b3J5LmxvYWRpbmdDb21wKSkge1xuICAgIHJldHVybiBmYWN0b3J5LmxvYWRpbmdDb21wXG4gIH1cblxuICBpZiAoaXNEZWYoZmFjdG9yeS5jb250ZXh0cykpIHtcbiAgICAvLyBhbHJlYWR5IHBlbmRpbmdcbiAgICBmYWN0b3J5LmNvbnRleHRzLnB1c2goY29udGV4dCk7XG4gIH0gZWxzZSB7XG4gICAgdmFyIGNvbnRleHRzID0gZmFjdG9yeS5jb250ZXh0cyA9IFtjb250ZXh0XTtcbiAgICB2YXIgc3luYyA9IHRydWU7XG5cbiAgICB2YXIgZm9yY2VSZW5kZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICBmb3IgKHZhciBpID0gMCwgbCA9IGNvbnRleHRzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICBjb250ZXh0c1tpXS4kZm9yY2VVcGRhdGUoKTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgdmFyIHJlc29sdmUgPSBvbmNlKGZ1bmN0aW9uIChyZXMpIHtcbiAgICAgIC8vIGNhY2hlIHJlc29sdmVkXG4gICAgICBmYWN0b3J5LnJlc29sdmVkID0gZW5zdXJlQ3RvcihyZXMsIGJhc2VDdG9yKTtcbiAgICAgIC8vIGludm9rZSBjYWxsYmFja3Mgb25seSBpZiB0aGlzIGlzIG5vdCBhIHN5bmNocm9ub3VzIHJlc29sdmVcbiAgICAgIC8vIChhc3luYyByZXNvbHZlcyBhcmUgc2hpbW1lZCBhcyBzeW5jaHJvbm91cyBkdXJpbmcgU1NSKVxuICAgICAgaWYgKCFzeW5jKSB7XG4gICAgICAgIGZvcmNlUmVuZGVyKCk7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICB2YXIgcmVqZWN0ID0gb25jZShmdW5jdGlvbiAocmVhc29uKSB7XG4gICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIHdhcm4oXG4gICAgICAgIFwiRmFpbGVkIHRvIHJlc29sdmUgYXN5bmMgY29tcG9uZW50OiBcIiArIChTdHJpbmcoZmFjdG9yeSkpICtcbiAgICAgICAgKHJlYXNvbiA/IChcIlxcblJlYXNvbjogXCIgKyByZWFzb24pIDogJycpXG4gICAgICApO1xuICAgICAgaWYgKGlzRGVmKGZhY3RvcnkuZXJyb3JDb21wKSkge1xuICAgICAgICBmYWN0b3J5LmVycm9yID0gdHJ1ZTtcbiAgICAgICAgZm9yY2VSZW5kZXIoKTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIHZhciByZXMgPSBmYWN0b3J5KHJlc29sdmUsIHJlamVjdCk7XG5cbiAgICBpZiAoaXNPYmplY3QocmVzKSkge1xuICAgICAgaWYgKHR5cGVvZiByZXMudGhlbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAvLyAoKSA9PiBQcm9taXNlXG4gICAgICAgIGlmIChpc1VuZGVmKGZhY3RvcnkucmVzb2x2ZWQpKSB7XG4gICAgICAgICAgcmVzLnRoZW4ocmVzb2x2ZSwgcmVqZWN0KTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChpc0RlZihyZXMuY29tcG9uZW50KSAmJiB0eXBlb2YgcmVzLmNvbXBvbmVudC50aGVuID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHJlcy5jb21wb25lbnQudGhlbihyZXNvbHZlLCByZWplY3QpO1xuXG4gICAgICAgIGlmIChpc0RlZihyZXMuZXJyb3IpKSB7XG4gICAgICAgICAgZmFjdG9yeS5lcnJvckNvbXAgPSBlbnN1cmVDdG9yKHJlcy5lcnJvciwgYmFzZUN0b3IpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGlzRGVmKHJlcy5sb2FkaW5nKSkge1xuICAgICAgICAgIGZhY3RvcnkubG9hZGluZ0NvbXAgPSBlbnN1cmVDdG9yKHJlcy5sb2FkaW5nLCBiYXNlQ3Rvcik7XG4gICAgICAgICAgaWYgKHJlcy5kZWxheSA9PT0gMCkge1xuICAgICAgICAgICAgZmFjdG9yeS5sb2FkaW5nID0gdHJ1ZTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgIGlmIChpc1VuZGVmKGZhY3RvcnkucmVzb2x2ZWQpICYmIGlzVW5kZWYoZmFjdG9yeS5lcnJvcikpIHtcbiAgICAgICAgICAgICAgICBmYWN0b3J5LmxvYWRpbmcgPSB0cnVlO1xuICAgICAgICAgICAgICAgIGZvcmNlUmVuZGVyKCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIHJlcy5kZWxheSB8fCAyMDApO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChpc0RlZihyZXMudGltZW91dCkpIHtcbiAgICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlmIChpc1VuZGVmKGZhY3RvcnkucmVzb2x2ZWQpKSB7XG4gICAgICAgICAgICAgIHJlamVjdChcbiAgICAgICAgICAgICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nXG4gICAgICAgICAgICAgICAgICA/IChcInRpbWVvdXQgKFwiICsgKHJlcy50aW1lb3V0KSArIFwibXMpXCIpXG4gICAgICAgICAgICAgICAgICA6IG51bGxcbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9LCByZXMudGltZW91dCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBzeW5jID0gZmFsc2U7XG4gICAgLy8gcmV0dXJuIGluIGNhc2UgcmVzb2x2ZWQgc3luY2hyb25vdXNseVxuICAgIHJldHVybiBmYWN0b3J5LmxvYWRpbmdcbiAgICAgID8gZmFjdG9yeS5sb2FkaW5nQ29tcFxuICAgICAgOiBmYWN0b3J5LnJlc29sdmVkXG4gIH1cbn1cblxuLyogICovXG5cbmZ1bmN0aW9uIGlzQXN5bmNQbGFjZWhvbGRlciAobm9kZSkge1xuICByZXR1cm4gbm9kZS5pc0NvbW1lbnQgJiYgbm9kZS5hc3luY0ZhY3Rvcnlcbn1cblxuLyogICovXG5cbmZ1bmN0aW9uIGdldEZpcnN0Q29tcG9uZW50Q2hpbGQgKGNoaWxkcmVuKSB7XG4gIGlmIChBcnJheS5pc0FycmF5KGNoaWxkcmVuKSkge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBjID0gY2hpbGRyZW5baV07XG4gICAgICBpZiAoaXNEZWYoYykgJiYgKGlzRGVmKGMuY29tcG9uZW50T3B0aW9ucykgfHwgaXNBc3luY1BsYWNlaG9sZGVyKGMpKSkge1xuICAgICAgICByZXR1cm4gY1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG4vKiAgKi9cblxuLyogICovXG5cbmZ1bmN0aW9uIGluaXRFdmVudHMgKHZtKSB7XG4gIHZtLl9ldmVudHMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICB2bS5faGFzSG9va0V2ZW50ID0gZmFsc2U7XG4gIC8vIGluaXQgcGFyZW50IGF0dGFjaGVkIGV2ZW50c1xuICB2YXIgbGlzdGVuZXJzID0gdm0uJG9wdGlvbnMuX3BhcmVudExpc3RlbmVycztcbiAgaWYgKGxpc3RlbmVycykge1xuICAgIHVwZGF0ZUNvbXBvbmVudExpc3RlbmVycyh2bSwgbGlzdGVuZXJzKTtcbiAgfVxufVxuXG52YXIgdGFyZ2V0O1xuXG5mdW5jdGlvbiBhZGQgKGV2ZW50LCBmbiwgb25jZSkge1xuICBpZiAob25jZSkge1xuICAgIHRhcmdldC4kb25jZShldmVudCwgZm4pO1xuICB9IGVsc2Uge1xuICAgIHRhcmdldC4kb24oZXZlbnQsIGZuKTtcbiAgfVxufVxuXG5mdW5jdGlvbiByZW1vdmUkMSAoZXZlbnQsIGZuKSB7XG4gIHRhcmdldC4kb2ZmKGV2ZW50LCBmbik7XG59XG5cbmZ1bmN0aW9uIHVwZGF0ZUNvbXBvbmVudExpc3RlbmVycyAoXG4gIHZtLFxuICBsaXN0ZW5lcnMsXG4gIG9sZExpc3RlbmVyc1xuKSB7XG4gIHRhcmdldCA9IHZtO1xuICB1cGRhdGVMaXN0ZW5lcnMobGlzdGVuZXJzLCBvbGRMaXN0ZW5lcnMgfHwge30sIGFkZCwgcmVtb3ZlJDEsIHZtKTtcbiAgdGFyZ2V0ID0gdW5kZWZpbmVkO1xufVxuXG5mdW5jdGlvbiBldmVudHNNaXhpbiAoVnVlKSB7XG4gIHZhciBob29rUkUgPSAvXmhvb2s6LztcbiAgVnVlLnByb3RvdHlwZS4kb24gPSBmdW5jdGlvbiAoZXZlbnQsIGZuKSB7XG4gICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgICB2YXIgdm0gPSB0aGlzO1xuICAgIGlmIChBcnJheS5pc0FycmF5KGV2ZW50KSkge1xuICAgICAgZm9yICh2YXIgaSA9IDAsIGwgPSBldmVudC5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgdGhpcyQxLiRvbihldmVudFtpXSwgZm4pO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAodm0uX2V2ZW50c1tldmVudF0gfHwgKHZtLl9ldmVudHNbZXZlbnRdID0gW10pKS5wdXNoKGZuKTtcbiAgICAgIC8vIG9wdGltaXplIGhvb2s6ZXZlbnQgY29zdCBieSB1c2luZyBhIGJvb2xlYW4gZmxhZyBtYXJrZWQgYXQgcmVnaXN0cmF0aW9uXG4gICAgICAvLyBpbnN0ZWFkIG9mIGEgaGFzaCBsb29rdXBcbiAgICAgIGlmIChob29rUkUudGVzdChldmVudCkpIHtcbiAgICAgICAgdm0uX2hhc0hvb2tFdmVudCA9IHRydWU7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB2bVxuICB9O1xuXG4gIFZ1ZS5wcm90b3R5cGUuJG9uY2UgPSBmdW5jdGlvbiAoZXZlbnQsIGZuKSB7XG4gICAgdmFyIHZtID0gdGhpcztcbiAgICBmdW5jdGlvbiBvbiAoKSB7XG4gICAgICB2bS4kb2ZmKGV2ZW50LCBvbik7XG4gICAgICBmbi5hcHBseSh2bSwgYXJndW1lbnRzKTtcbiAgICB9XG4gICAgb24uZm4gPSBmbjtcbiAgICB2bS4kb24oZXZlbnQsIG9uKTtcbiAgICByZXR1cm4gdm1cbiAgfTtcblxuICBWdWUucHJvdG90eXBlLiRvZmYgPSBmdW5jdGlvbiAoZXZlbnQsIGZuKSB7XG4gICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgICB2YXIgdm0gPSB0aGlzO1xuICAgIC8vIGFsbFxuICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkge1xuICAgICAgdm0uX2V2ZW50cyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgICByZXR1cm4gdm1cbiAgICB9XG4gICAgLy8gYXJyYXkgb2YgZXZlbnRzXG4gICAgaWYgKEFycmF5LmlzQXJyYXkoZXZlbnQpKSB7XG4gICAgICBmb3IgKHZhciBpID0gMCwgbCA9IGV2ZW50Lmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICB0aGlzJDEuJG9mZihldmVudFtpXSwgZm4pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHZtXG4gICAgfVxuICAgIC8vIHNwZWNpZmljIGV2ZW50XG4gICAgdmFyIGNicyA9IHZtLl9ldmVudHNbZXZlbnRdO1xuICAgIGlmICghY2JzKSB7XG4gICAgICByZXR1cm4gdm1cbiAgICB9XG4gICAgaWYgKCFmbikge1xuICAgICAgdm0uX2V2ZW50c1tldmVudF0gPSBudWxsO1xuICAgICAgcmV0dXJuIHZtXG4gICAgfVxuICAgIGlmIChmbikge1xuICAgICAgLy8gc3BlY2lmaWMgaGFuZGxlclxuICAgICAgdmFyIGNiO1xuICAgICAgdmFyIGkkMSA9IGNicy5sZW5ndGg7XG4gICAgICB3aGlsZSAoaSQxLS0pIHtcbiAgICAgICAgY2IgPSBjYnNbaSQxXTtcbiAgICAgICAgaWYgKGNiID09PSBmbiB8fCBjYi5mbiA9PT0gZm4pIHtcbiAgICAgICAgICBjYnMuc3BsaWNlKGkkMSwgMSk7XG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdm1cbiAgfTtcblxuICBWdWUucHJvdG90eXBlLiRlbWl0ID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgdmFyIHZtID0gdGhpcztcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgdmFyIGxvd2VyQ2FzZUV2ZW50ID0gZXZlbnQudG9Mb3dlckNhc2UoKTtcbiAgICAgIGlmIChsb3dlckNhc2VFdmVudCAhPT0gZXZlbnQgJiYgdm0uX2V2ZW50c1tsb3dlckNhc2VFdmVudF0pIHtcbiAgICAgICAgdGlwKFxuICAgICAgICAgIFwiRXZlbnQgXFxcIlwiICsgbG93ZXJDYXNlRXZlbnQgKyBcIlxcXCIgaXMgZW1pdHRlZCBpbiBjb21wb25lbnQgXCIgK1xuICAgICAgICAgIChmb3JtYXRDb21wb25lbnROYW1lKHZtKSkgKyBcIiBidXQgdGhlIGhhbmRsZXIgaXMgcmVnaXN0ZXJlZCBmb3IgXFxcIlwiICsgZXZlbnQgKyBcIlxcXCIuIFwiICtcbiAgICAgICAgICBcIk5vdGUgdGhhdCBIVE1MIGF0dHJpYnV0ZXMgYXJlIGNhc2UtaW5zZW5zaXRpdmUgYW5kIHlvdSBjYW5ub3QgdXNlIFwiICtcbiAgICAgICAgICBcInYtb24gdG8gbGlzdGVuIHRvIGNhbWVsQ2FzZSBldmVudHMgd2hlbiB1c2luZyBpbi1ET00gdGVtcGxhdGVzLiBcIiArXG4gICAgICAgICAgXCJZb3Ugc2hvdWxkIHByb2JhYmx5IHVzZSBcXFwiXCIgKyAoaHlwaGVuYXRlKGV2ZW50KSkgKyBcIlxcXCIgaW5zdGVhZCBvZiBcXFwiXCIgKyBldmVudCArIFwiXFxcIi5cIlxuICAgICAgICApO1xuICAgICAgfVxuICAgIH1cbiAgICB2YXIgY2JzID0gdm0uX2V2ZW50c1tldmVudF07XG4gICAgaWYgKGNicykge1xuICAgICAgY2JzID0gY2JzLmxlbmd0aCA+IDEgPyB0b0FycmF5KGNicykgOiBjYnM7XG4gICAgICB2YXIgYXJncyA9IHRvQXJyYXkoYXJndW1lbnRzLCAxKTtcbiAgICAgIGZvciAodmFyIGkgPSAwLCBsID0gY2JzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIGNic1tpXS5hcHBseSh2bSwgYXJncyk7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICBoYW5kbGVFcnJvcihlLCB2bSwgKFwiZXZlbnQgaGFuZGxlciBmb3IgXFxcIlwiICsgZXZlbnQgKyBcIlxcXCJcIikpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB2bVxuICB9O1xufVxuXG4vKiAgKi9cblxuXG5cbi8qKlxuICogUnVudGltZSBoZWxwZXIgZm9yIHJlc29sdmluZyByYXcgY2hpbGRyZW4gVk5vZGVzIGludG8gYSBzbG90IG9iamVjdC5cbiAqL1xuZnVuY3Rpb24gcmVzb2x2ZVNsb3RzIChcbiAgY2hpbGRyZW4sXG4gIGNvbnRleHRcbikge1xuICB2YXIgc2xvdHMgPSB7fTtcbiAgaWYgKCFjaGlsZHJlbikge1xuICAgIHJldHVybiBzbG90c1xuICB9XG4gIGZvciAodmFyIGkgPSAwLCBsID0gY2hpbGRyZW4ubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgdmFyIGNoaWxkID0gY2hpbGRyZW5baV07XG4gICAgdmFyIGRhdGEgPSBjaGlsZC5kYXRhO1xuICAgIC8vIHJlbW92ZSBzbG90IGF0dHJpYnV0ZSBpZiB0aGUgbm9kZSBpcyByZXNvbHZlZCBhcyBhIFZ1ZSBzbG90IG5vZGVcbiAgICBpZiAoZGF0YSAmJiBkYXRhLmF0dHJzICYmIGRhdGEuYXR0cnMuc2xvdCkge1xuICAgICAgZGVsZXRlIGRhdGEuYXR0cnMuc2xvdDtcbiAgICB9XG4gICAgLy8gbmFtZWQgc2xvdHMgc2hvdWxkIG9ubHkgYmUgcmVzcGVjdGVkIGlmIHRoZSB2bm9kZSB3YXMgcmVuZGVyZWQgaW4gdGhlXG4gICAgLy8gc2FtZSBjb250ZXh0LlxuICAgIGlmICgoY2hpbGQuY29udGV4dCA9PT0gY29udGV4dCB8fCBjaGlsZC5mbkNvbnRleHQgPT09IGNvbnRleHQpICYmXG4gICAgICBkYXRhICYmIGRhdGEuc2xvdCAhPSBudWxsXG4gICAgKSB7XG4gICAgICB2YXIgbmFtZSA9IGRhdGEuc2xvdDtcbiAgICAgIHZhciBzbG90ID0gKHNsb3RzW25hbWVdIHx8IChzbG90c1tuYW1lXSA9IFtdKSk7XG4gICAgICBpZiAoY2hpbGQudGFnID09PSAndGVtcGxhdGUnKSB7XG4gICAgICAgIHNsb3QucHVzaC5hcHBseShzbG90LCBjaGlsZC5jaGlsZHJlbiB8fCBbXSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzbG90LnB1c2goY2hpbGQpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAoc2xvdHMuZGVmYXVsdCB8fCAoc2xvdHMuZGVmYXVsdCA9IFtdKSkucHVzaChjaGlsZCk7XG4gICAgfVxuICB9XG4gIC8vIGlnbm9yZSBzbG90cyB0aGF0IGNvbnRhaW5zIG9ubHkgd2hpdGVzcGFjZVxuICBmb3IgKHZhciBuYW1lJDEgaW4gc2xvdHMpIHtcbiAgICBpZiAoc2xvdHNbbmFtZSQxXS5ldmVyeShpc1doaXRlc3BhY2UpKSB7XG4gICAgICBkZWxldGUgc2xvdHNbbmFtZSQxXTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHNsb3RzXG59XG5cbmZ1bmN0aW9uIGlzV2hpdGVzcGFjZSAobm9kZSkge1xuICByZXR1cm4gKG5vZGUuaXNDb21tZW50ICYmICFub2RlLmFzeW5jRmFjdG9yeSkgfHwgbm9kZS50ZXh0ID09PSAnICdcbn1cblxuZnVuY3Rpb24gcmVzb2x2ZVNjb3BlZFNsb3RzIChcbiAgZm5zLCAvLyBzZWUgZmxvdy92bm9kZVxuICByZXNcbikge1xuICByZXMgPSByZXMgfHwge307XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgZm5zLmxlbmd0aDsgaSsrKSB7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkoZm5zW2ldKSkge1xuICAgICAgcmVzb2x2ZVNjb3BlZFNsb3RzKGZuc1tpXSwgcmVzKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmVzW2Zuc1tpXS5rZXldID0gZm5zW2ldLmZuO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzXG59XG5cbi8qICAqL1xuXG52YXIgYWN0aXZlSW5zdGFuY2UgPSBudWxsO1xudmFyIGlzVXBkYXRpbmdDaGlsZENvbXBvbmVudCA9IGZhbHNlO1xuXG5mdW5jdGlvbiBpbml0TGlmZWN5Y2xlICh2bSkge1xuICB2YXIgb3B0aW9ucyA9IHZtLiRvcHRpb25zO1xuXG4gIC8vIGxvY2F0ZSBmaXJzdCBub24tYWJzdHJhY3QgcGFyZW50XG4gIHZhciBwYXJlbnQgPSBvcHRpb25zLnBhcmVudDtcbiAgaWYgKHBhcmVudCAmJiAhb3B0aW9ucy5hYnN0cmFjdCkge1xuICAgIHdoaWxlIChwYXJlbnQuJG9wdGlvbnMuYWJzdHJhY3QgJiYgcGFyZW50LiRwYXJlbnQpIHtcbiAgICAgIHBhcmVudCA9IHBhcmVudC4kcGFyZW50O1xuICAgIH1cbiAgICBwYXJlbnQuJGNoaWxkcmVuLnB1c2godm0pO1xuICB9XG5cbiAgdm0uJHBhcmVudCA9IHBhcmVudDtcbiAgdm0uJHJvb3QgPSBwYXJlbnQgPyBwYXJlbnQuJHJvb3QgOiB2bTtcblxuICB2bS4kY2hpbGRyZW4gPSBbXTtcbiAgdm0uJHJlZnMgPSB7fTtcblxuICB2bS5fd2F0Y2hlciA9IG51bGw7XG4gIHZtLl9pbmFjdGl2ZSA9IG51bGw7XG4gIHZtLl9kaXJlY3RJbmFjdGl2ZSA9IGZhbHNlO1xuICB2bS5faXNNb3VudGVkID0gZmFsc2U7XG4gIHZtLl9pc0Rlc3Ryb3llZCA9IGZhbHNlO1xuICB2bS5faXNCZWluZ0Rlc3Ryb3llZCA9IGZhbHNlO1xufVxuXG5mdW5jdGlvbiBsaWZlY3ljbGVNaXhpbiAoVnVlKSB7XG4gIFZ1ZS5wcm90b3R5cGUuX3VwZGF0ZSA9IGZ1bmN0aW9uICh2bm9kZSwgaHlkcmF0aW5nKSB7XG4gICAgdmFyIHZtID0gdGhpcztcbiAgICBpZiAodm0uX2lzTW91bnRlZCkge1xuICAgICAgY2FsbEhvb2sodm0sICdiZWZvcmVVcGRhdGUnKTtcbiAgICB9XG4gICAgdmFyIHByZXZFbCA9IHZtLiRlbDtcbiAgICB2YXIgcHJldlZub2RlID0gdm0uX3Zub2RlO1xuICAgIHZhciBwcmV2QWN0aXZlSW5zdGFuY2UgPSBhY3RpdmVJbnN0YW5jZTtcbiAgICBhY3RpdmVJbnN0YW5jZSA9IHZtO1xuICAgIHZtLl92bm9kZSA9IHZub2RlO1xuICAgIC8vIFZ1ZS5wcm90b3R5cGUuX19wYXRjaF9fIGlzIGluamVjdGVkIGluIGVudHJ5IHBvaW50c1xuICAgIC8vIGJhc2VkIG9uIHRoZSByZW5kZXJpbmcgYmFja2VuZCB1c2VkLlxuICAgIGlmICghcHJldlZub2RlKSB7XG4gICAgICAvLyBpbml0aWFsIHJlbmRlclxuICAgICAgdm0uJGVsID0gdm0uX19wYXRjaF9fKFxuICAgICAgICB2bS4kZWwsIHZub2RlLCBoeWRyYXRpbmcsIGZhbHNlIC8qIHJlbW92ZU9ubHkgKi8sXG4gICAgICAgIHZtLiRvcHRpb25zLl9wYXJlbnRFbG0sXG4gICAgICAgIHZtLiRvcHRpb25zLl9yZWZFbG1cbiAgICAgICk7XG4gICAgICAvLyBubyBuZWVkIGZvciB0aGUgcmVmIG5vZGVzIGFmdGVyIGluaXRpYWwgcGF0Y2hcbiAgICAgIC8vIHRoaXMgcHJldmVudHMga2VlcGluZyBhIGRldGFjaGVkIERPTSB0cmVlIGluIG1lbW9yeSAoIzU4NTEpXG4gICAgICB2bS4kb3B0aW9ucy5fcGFyZW50RWxtID0gdm0uJG9wdGlvbnMuX3JlZkVsbSA9IG51bGw7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIHVwZGF0ZXNcbiAgICAgIHZtLiRlbCA9IHZtLl9fcGF0Y2hfXyhwcmV2Vm5vZGUsIHZub2RlKTtcbiAgICB9XG4gICAgYWN0aXZlSW5zdGFuY2UgPSBwcmV2QWN0aXZlSW5zdGFuY2U7XG4gICAgLy8gdXBkYXRlIF9fdnVlX18gcmVmZXJlbmNlXG4gICAgaWYgKHByZXZFbCkge1xuICAgICAgcHJldkVsLl9fdnVlX18gPSBudWxsO1xuICAgIH1cbiAgICBpZiAodm0uJGVsKSB7XG4gICAgICB2bS4kZWwuX192dWVfXyA9IHZtO1xuICAgIH1cbiAgICAvLyBpZiBwYXJlbnQgaXMgYW4gSE9DLCB1cGRhdGUgaXRzICRlbCBhcyB3ZWxsXG4gICAgaWYgKHZtLiR2bm9kZSAmJiB2bS4kcGFyZW50ICYmIHZtLiR2bm9kZSA9PT0gdm0uJHBhcmVudC5fdm5vZGUpIHtcbiAgICAgIHZtLiRwYXJlbnQuJGVsID0gdm0uJGVsO1xuICAgIH1cbiAgICAvLyB1cGRhdGVkIGhvb2sgaXMgY2FsbGVkIGJ5IHRoZSBzY2hlZHVsZXIgdG8gZW5zdXJlIHRoYXQgY2hpbGRyZW4gYXJlXG4gICAgLy8gdXBkYXRlZCBpbiBhIHBhcmVudCdzIHVwZGF0ZWQgaG9vay5cbiAgfTtcblxuICBWdWUucHJvdG90eXBlLiRmb3JjZVVwZGF0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgdm0gPSB0aGlzO1xuICAgIGlmICh2bS5fd2F0Y2hlcikge1xuICAgICAgdm0uX3dhdGNoZXIudXBkYXRlKCk7XG4gICAgfVxuICB9O1xuXG4gIFZ1ZS5wcm90b3R5cGUuJGRlc3Ryb3kgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHZtID0gdGhpcztcbiAgICBpZiAodm0uX2lzQmVpbmdEZXN0cm95ZWQpIHtcbiAgICAgIHJldHVyblxuICAgIH1cbiAgICBjYWxsSG9vayh2bSwgJ2JlZm9yZURlc3Ryb3knKTtcbiAgICB2bS5faXNCZWluZ0Rlc3Ryb3llZCA9IHRydWU7XG4gICAgLy8gcmVtb3ZlIHNlbGYgZnJvbSBwYXJlbnRcbiAgICB2YXIgcGFyZW50ID0gdm0uJHBhcmVudDtcbiAgICBpZiAocGFyZW50ICYmICFwYXJlbnQuX2lzQmVpbmdEZXN0cm95ZWQgJiYgIXZtLiRvcHRpb25zLmFic3RyYWN0KSB7XG4gICAgICByZW1vdmUocGFyZW50LiRjaGlsZHJlbiwgdm0pO1xuICAgIH1cbiAgICAvLyB0ZWFyZG93biB3YXRjaGVyc1xuICAgIGlmICh2bS5fd2F0Y2hlcikge1xuICAgICAgdm0uX3dhdGNoZXIudGVhcmRvd24oKTtcbiAgICB9XG4gICAgdmFyIGkgPSB2bS5fd2F0Y2hlcnMubGVuZ3RoO1xuICAgIHdoaWxlIChpLS0pIHtcbiAgICAgIHZtLl93YXRjaGVyc1tpXS50ZWFyZG93bigpO1xuICAgIH1cbiAgICAvLyByZW1vdmUgcmVmZXJlbmNlIGZyb20gZGF0YSBvYlxuICAgIC8vIGZyb3plbiBvYmplY3QgbWF5IG5vdCBoYXZlIG9ic2VydmVyLlxuICAgIGlmICh2bS5fZGF0YS5fX29iX18pIHtcbiAgICAgIHZtLl9kYXRhLl9fb2JfXy52bUNvdW50LS07XG4gICAgfVxuICAgIC8vIGNhbGwgdGhlIGxhc3QgaG9vay4uLlxuICAgIHZtLl9pc0Rlc3Ryb3llZCA9IHRydWU7XG4gICAgLy8gaW52b2tlIGRlc3Ryb3kgaG9va3Mgb24gY3VycmVudCByZW5kZXJlZCB0cmVlXG4gICAgdm0uX19wYXRjaF9fKHZtLl92bm9kZSwgbnVsbCk7XG4gICAgLy8gZmlyZSBkZXN0cm95ZWQgaG9va1xuICAgIGNhbGxIb29rKHZtLCAnZGVzdHJveWVkJyk7XG4gICAgLy8gdHVybiBvZmYgYWxsIGluc3RhbmNlIGxpc3RlbmVycy5cbiAgICB2bS4kb2ZmKCk7XG4gICAgLy8gcmVtb3ZlIF9fdnVlX18gcmVmZXJlbmNlXG4gICAgaWYgKHZtLiRlbCkge1xuICAgICAgdm0uJGVsLl9fdnVlX18gPSBudWxsO1xuICAgIH1cbiAgICAvLyByZWxlYXNlIGNpcmN1bGFyIHJlZmVyZW5jZSAoIzY3NTkpXG4gICAgaWYgKHZtLiR2bm9kZSkge1xuICAgICAgdm0uJHZub2RlLnBhcmVudCA9IG51bGw7XG4gICAgfVxuICB9O1xufVxuXG5mdW5jdGlvbiBtb3VudENvbXBvbmVudCAoXG4gIHZtLFxuICBlbCxcbiAgaHlkcmF0aW5nXG4pIHtcbiAgdm0uJGVsID0gZWw7XG4gIGlmICghdm0uJG9wdGlvbnMucmVuZGVyKSB7XG4gICAgdm0uJG9wdGlvbnMucmVuZGVyID0gY3JlYXRlRW1wdHlWTm9kZTtcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgICBpZiAoKHZtLiRvcHRpb25zLnRlbXBsYXRlICYmIHZtLiRvcHRpb25zLnRlbXBsYXRlLmNoYXJBdCgwKSAhPT0gJyMnKSB8fFxuICAgICAgICB2bS4kb3B0aW9ucy5lbCB8fCBlbCkge1xuICAgICAgICB3YXJuKFxuICAgICAgICAgICdZb3UgYXJlIHVzaW5nIHRoZSBydW50aW1lLW9ubHkgYnVpbGQgb2YgVnVlIHdoZXJlIHRoZSB0ZW1wbGF0ZSAnICtcbiAgICAgICAgICAnY29tcGlsZXIgaXMgbm90IGF2YWlsYWJsZS4gRWl0aGVyIHByZS1jb21waWxlIHRoZSB0ZW1wbGF0ZXMgaW50byAnICtcbiAgICAgICAgICAncmVuZGVyIGZ1bmN0aW9ucywgb3IgdXNlIHRoZSBjb21waWxlci1pbmNsdWRlZCBidWlsZC4nLFxuICAgICAgICAgIHZtXG4gICAgICAgICk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB3YXJuKFxuICAgICAgICAgICdGYWlsZWQgdG8gbW91bnQgY29tcG9uZW50OiB0ZW1wbGF0ZSBvciByZW5kZXIgZnVuY3Rpb24gbm90IGRlZmluZWQuJyxcbiAgICAgICAgICB2bVxuICAgICAgICApO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBjYWxsSG9vayh2bSwgJ2JlZm9yZU1vdW50Jyk7XG5cbiAgdmFyIHVwZGF0ZUNvbXBvbmVudDtcbiAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIGNvbmZpZy5wZXJmb3JtYW5jZSAmJiBtYXJrKSB7XG4gICAgdXBkYXRlQ29tcG9uZW50ID0gZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIG5hbWUgPSB2bS5fbmFtZTtcbiAgICAgIHZhciBpZCA9IHZtLl91aWQ7XG4gICAgICB2YXIgc3RhcnRUYWcgPSBcInZ1ZS1wZXJmLXN0YXJ0OlwiICsgaWQ7XG4gICAgICB2YXIgZW5kVGFnID0gXCJ2dWUtcGVyZi1lbmQ6XCIgKyBpZDtcblxuICAgICAgbWFyayhzdGFydFRhZyk7XG4gICAgICB2YXIgdm5vZGUgPSB2bS5fcmVuZGVyKCk7XG4gICAgICBtYXJrKGVuZFRhZyk7XG4gICAgICBtZWFzdXJlKChcInZ1ZSBcIiArIG5hbWUgKyBcIiByZW5kZXJcIiksIHN0YXJ0VGFnLCBlbmRUYWcpO1xuXG4gICAgICBtYXJrKHN0YXJ0VGFnKTtcbiAgICAgIHZtLl91cGRhdGUodm5vZGUsIGh5ZHJhdGluZyk7XG4gICAgICBtYXJrKGVuZFRhZyk7XG4gICAgICBtZWFzdXJlKChcInZ1ZSBcIiArIG5hbWUgKyBcIiBwYXRjaFwiKSwgc3RhcnRUYWcsIGVuZFRhZyk7XG4gICAgfTtcbiAgfSBlbHNlIHtcbiAgICB1cGRhdGVDb21wb25lbnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICB2bS5fdXBkYXRlKHZtLl9yZW5kZXIoKSwgaHlkcmF0aW5nKTtcbiAgICB9O1xuICB9XG5cbiAgLy8gd2Ugc2V0IHRoaXMgdG8gdm0uX3dhdGNoZXIgaW5zaWRlIHRoZSB3YXRjaGVyJ3MgY29uc3RydWN0b3JcbiAgLy8gc2luY2UgdGhlIHdhdGNoZXIncyBpbml0aWFsIHBhdGNoIG1heSBjYWxsICRmb3JjZVVwZGF0ZSAoZS5nLiBpbnNpZGUgY2hpbGRcbiAgLy8gY29tcG9uZW50J3MgbW91bnRlZCBob29rKSwgd2hpY2ggcmVsaWVzIG9uIHZtLl93YXRjaGVyIGJlaW5nIGFscmVhZHkgZGVmaW5lZFxuICBuZXcgV2F0Y2hlcih2bSwgdXBkYXRlQ29tcG9uZW50LCBub29wLCBudWxsLCB0cnVlIC8qIGlzUmVuZGVyV2F0Y2hlciAqLyk7XG4gIGh5ZHJhdGluZyA9IGZhbHNlO1xuXG4gIC8vIG1hbnVhbGx5IG1vdW50ZWQgaW5zdGFuY2UsIGNhbGwgbW91bnRlZCBvbiBzZWxmXG4gIC8vIG1vdW50ZWQgaXMgY2FsbGVkIGZvciByZW5kZXItY3JlYXRlZCBjaGlsZCBjb21wb25lbnRzIGluIGl0cyBpbnNlcnRlZCBob29rXG4gIGlmICh2bS4kdm5vZGUgPT0gbnVsbCkge1xuICAgIHZtLl9pc01vdW50ZWQgPSB0cnVlO1xuICAgIGNhbGxIb29rKHZtLCAnbW91bnRlZCcpO1xuICB9XG4gIHJldHVybiB2bVxufVxuXG5mdW5jdGlvbiB1cGRhdGVDaGlsZENvbXBvbmVudCAoXG4gIHZtLFxuICBwcm9wc0RhdGEsXG4gIGxpc3RlbmVycyxcbiAgcGFyZW50Vm5vZGUsXG4gIHJlbmRlckNoaWxkcmVuXG4pIHtcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICBpc1VwZGF0aW5nQ2hpbGRDb21wb25lbnQgPSB0cnVlO1xuICB9XG5cbiAgLy8gZGV0ZXJtaW5lIHdoZXRoZXIgY29tcG9uZW50IGhhcyBzbG90IGNoaWxkcmVuXG4gIC8vIHdlIG5lZWQgdG8gZG8gdGhpcyBiZWZvcmUgb3ZlcndyaXRpbmcgJG9wdGlvbnMuX3JlbmRlckNoaWxkcmVuXG4gIHZhciBoYXNDaGlsZHJlbiA9ICEhKFxuICAgIHJlbmRlckNoaWxkcmVuIHx8ICAgICAgICAgICAgICAgLy8gaGFzIG5ldyBzdGF0aWMgc2xvdHNcbiAgICB2bS4kb3B0aW9ucy5fcmVuZGVyQ2hpbGRyZW4gfHwgIC8vIGhhcyBvbGQgc3RhdGljIHNsb3RzXG4gICAgcGFyZW50Vm5vZGUuZGF0YS5zY29wZWRTbG90cyB8fCAvLyBoYXMgbmV3IHNjb3BlZCBzbG90c1xuICAgIHZtLiRzY29wZWRTbG90cyAhPT0gZW1wdHlPYmplY3QgLy8gaGFzIG9sZCBzY29wZWQgc2xvdHNcbiAgKTtcblxuICB2bS4kb3B0aW9ucy5fcGFyZW50Vm5vZGUgPSBwYXJlbnRWbm9kZTtcbiAgdm0uJHZub2RlID0gcGFyZW50Vm5vZGU7IC8vIHVwZGF0ZSB2bSdzIHBsYWNlaG9sZGVyIG5vZGUgd2l0aG91dCByZS1yZW5kZXJcblxuICBpZiAodm0uX3Zub2RlKSB7IC8vIHVwZGF0ZSBjaGlsZCB0cmVlJ3MgcGFyZW50XG4gICAgdm0uX3Zub2RlLnBhcmVudCA9IHBhcmVudFZub2RlO1xuICB9XG4gIHZtLiRvcHRpb25zLl9yZW5kZXJDaGlsZHJlbiA9IHJlbmRlckNoaWxkcmVuO1xuXG4gIC8vIHVwZGF0ZSAkYXR0cnMgYW5kICRsaXN0ZW5lcnMgaGFzaFxuICAvLyB0aGVzZSBhcmUgYWxzbyByZWFjdGl2ZSBzbyB0aGV5IG1heSB0cmlnZ2VyIGNoaWxkIHVwZGF0ZSBpZiB0aGUgY2hpbGRcbiAgLy8gdXNlZCB0aGVtIGR1cmluZyByZW5kZXJcbiAgdm0uJGF0dHJzID0gKHBhcmVudFZub2RlLmRhdGEgJiYgcGFyZW50Vm5vZGUuZGF0YS5hdHRycykgfHwgZW1wdHlPYmplY3Q7XG4gIHZtLiRsaXN0ZW5lcnMgPSBsaXN0ZW5lcnMgfHwgZW1wdHlPYmplY3Q7XG5cbiAgLy8gdXBkYXRlIHByb3BzXG4gIGlmIChwcm9wc0RhdGEgJiYgdm0uJG9wdGlvbnMucHJvcHMpIHtcbiAgICBvYnNlcnZlclN0YXRlLnNob3VsZENvbnZlcnQgPSBmYWxzZTtcbiAgICB2YXIgcHJvcHMgPSB2bS5fcHJvcHM7XG4gICAgdmFyIHByb3BLZXlzID0gdm0uJG9wdGlvbnMuX3Byb3BLZXlzIHx8IFtdO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcEtleXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBrZXkgPSBwcm9wS2V5c1tpXTtcbiAgICAgIHByb3BzW2tleV0gPSB2YWxpZGF0ZVByb3Aoa2V5LCB2bS4kb3B0aW9ucy5wcm9wcywgcHJvcHNEYXRhLCB2bSk7XG4gICAgfVxuICAgIG9ic2VydmVyU3RhdGUuc2hvdWxkQ29udmVydCA9IHRydWU7XG4gICAgLy8ga2VlcCBhIGNvcHkgb2YgcmF3IHByb3BzRGF0YVxuICAgIHZtLiRvcHRpb25zLnByb3BzRGF0YSA9IHByb3BzRGF0YTtcbiAgfVxuXG4gIC8vIHVwZGF0ZSBsaXN0ZW5lcnNcbiAgaWYgKGxpc3RlbmVycykge1xuICAgIHZhciBvbGRMaXN0ZW5lcnMgPSB2bS4kb3B0aW9ucy5fcGFyZW50TGlzdGVuZXJzO1xuICAgIHZtLiRvcHRpb25zLl9wYXJlbnRMaXN0ZW5lcnMgPSBsaXN0ZW5lcnM7XG4gICAgdXBkYXRlQ29tcG9uZW50TGlzdGVuZXJzKHZtLCBsaXN0ZW5lcnMsIG9sZExpc3RlbmVycyk7XG4gIH1cbiAgLy8gcmVzb2x2ZSBzbG90cyArIGZvcmNlIHVwZGF0ZSBpZiBoYXMgY2hpbGRyZW5cbiAgaWYgKGhhc0NoaWxkcmVuKSB7XG4gICAgdm0uJHNsb3RzID0gcmVzb2x2ZVNsb3RzKHJlbmRlckNoaWxkcmVuLCBwYXJlbnRWbm9kZS5jb250ZXh0KTtcbiAgICB2bS4kZm9yY2VVcGRhdGUoKTtcbiAgfVxuXG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgaXNVcGRhdGluZ0NoaWxkQ29tcG9uZW50ID0gZmFsc2U7XG4gIH1cbn1cblxuZnVuY3Rpb24gaXNJbkluYWN0aXZlVHJlZSAodm0pIHtcbiAgd2hpbGUgKHZtICYmICh2bSA9IHZtLiRwYXJlbnQpKSB7XG4gICAgaWYgKHZtLl9pbmFjdGl2ZSkgeyByZXR1cm4gdHJ1ZSB9XG4gIH1cbiAgcmV0dXJuIGZhbHNlXG59XG5cbmZ1bmN0aW9uIGFjdGl2YXRlQ2hpbGRDb21wb25lbnQgKHZtLCBkaXJlY3QpIHtcbiAgaWYgKGRpcmVjdCkge1xuICAgIHZtLl9kaXJlY3RJbmFjdGl2ZSA9IGZhbHNlO1xuICAgIGlmIChpc0luSW5hY3RpdmVUcmVlKHZtKSkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuICB9IGVsc2UgaWYgKHZtLl9kaXJlY3RJbmFjdGl2ZSkge1xuICAgIHJldHVyblxuICB9XG4gIGlmICh2bS5faW5hY3RpdmUgfHwgdm0uX2luYWN0aXZlID09PSBudWxsKSB7XG4gICAgdm0uX2luYWN0aXZlID0gZmFsc2U7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB2bS4kY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgIGFjdGl2YXRlQ2hpbGRDb21wb25lbnQodm0uJGNoaWxkcmVuW2ldKTtcbiAgICB9XG4gICAgY2FsbEhvb2sodm0sICdhY3RpdmF0ZWQnKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBkZWFjdGl2YXRlQ2hpbGRDb21wb25lbnQgKHZtLCBkaXJlY3QpIHtcbiAgaWYgKGRpcmVjdCkge1xuICAgIHZtLl9kaXJlY3RJbmFjdGl2ZSA9IHRydWU7XG4gICAgaWYgKGlzSW5JbmFjdGl2ZVRyZWUodm0pKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG4gIH1cbiAgaWYgKCF2bS5faW5hY3RpdmUpIHtcbiAgICB2bS5faW5hY3RpdmUgPSB0cnVlO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdm0uJGNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgICBkZWFjdGl2YXRlQ2hpbGRDb21wb25lbnQodm0uJGNoaWxkcmVuW2ldKTtcbiAgICB9XG4gICAgY2FsbEhvb2sodm0sICdkZWFjdGl2YXRlZCcpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGNhbGxIb29rICh2bSwgaG9vaykge1xuICB2YXIgaGFuZGxlcnMgPSB2bS4kb3B0aW9uc1tob29rXTtcbiAgaWYgKGhhbmRsZXJzKSB7XG4gICAgZm9yICh2YXIgaSA9IDAsIGogPSBoYW5kbGVycy5sZW5ndGg7IGkgPCBqOyBpKyspIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGhhbmRsZXJzW2ldLmNhbGwodm0pO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBoYW5kbGVFcnJvcihlLCB2bSwgKGhvb2sgKyBcIiBob29rXCIpKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgaWYgKHZtLl9oYXNIb29rRXZlbnQpIHtcbiAgICB2bS4kZW1pdCgnaG9vazonICsgaG9vayk7XG4gIH1cbn1cblxuLyogICovXG5cblxudmFyIE1BWF9VUERBVEVfQ09VTlQgPSAxMDA7XG5cbnZhciBxdWV1ZSA9IFtdO1xudmFyIGFjdGl2YXRlZENoaWxkcmVuID0gW107XG52YXIgaGFzID0ge307XG52YXIgY2lyY3VsYXIgPSB7fTtcbnZhciB3YWl0aW5nID0gZmFsc2U7XG52YXIgZmx1c2hpbmcgPSBmYWxzZTtcbnZhciBpbmRleCA9IDA7XG5cbi8qKlxuICogUmVzZXQgdGhlIHNjaGVkdWxlcidzIHN0YXRlLlxuICovXG5mdW5jdGlvbiByZXNldFNjaGVkdWxlclN0YXRlICgpIHtcbiAgaW5kZXggPSBxdWV1ZS5sZW5ndGggPSBhY3RpdmF0ZWRDaGlsZHJlbi5sZW5ndGggPSAwO1xuICBoYXMgPSB7fTtcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICBjaXJjdWxhciA9IHt9O1xuICB9XG4gIHdhaXRpbmcgPSBmbHVzaGluZyA9IGZhbHNlO1xufVxuXG4vKipcbiAqIEZsdXNoIGJvdGggcXVldWVzIGFuZCBydW4gdGhlIHdhdGNoZXJzLlxuICovXG5mdW5jdGlvbiBmbHVzaFNjaGVkdWxlclF1ZXVlICgpIHtcbiAgZmx1c2hpbmcgPSB0cnVlO1xuICB2YXIgd2F0Y2hlciwgaWQ7XG5cbiAgLy8gU29ydCBxdWV1ZSBiZWZvcmUgZmx1c2guXG4gIC8vIFRoaXMgZW5zdXJlcyB0aGF0OlxuICAvLyAxLiBDb21wb25lbnRzIGFyZSB1cGRhdGVkIGZyb20gcGFyZW50IHRvIGNoaWxkLiAoYmVjYXVzZSBwYXJlbnQgaXMgYWx3YXlzXG4gIC8vICAgIGNyZWF0ZWQgYmVmb3JlIHRoZSBjaGlsZClcbiAgLy8gMi4gQSBjb21wb25lbnQncyB1c2VyIHdhdGNoZXJzIGFyZSBydW4gYmVmb3JlIGl0cyByZW5kZXIgd2F0Y2hlciAoYmVjYXVzZVxuICAvLyAgICB1c2VyIHdhdGNoZXJzIGFyZSBjcmVhdGVkIGJlZm9yZSB0aGUgcmVuZGVyIHdhdGNoZXIpXG4gIC8vIDMuIElmIGEgY29tcG9uZW50IGlzIGRlc3Ryb3llZCBkdXJpbmcgYSBwYXJlbnQgY29tcG9uZW50J3Mgd2F0Y2hlciBydW4sXG4gIC8vICAgIGl0cyB3YXRjaGVycyBjYW4gYmUgc2tpcHBlZC5cbiAgcXVldWUuc29ydChmdW5jdGlvbiAoYSwgYikgeyByZXR1cm4gYS5pZCAtIGIuaWQ7IH0pO1xuXG4gIC8vIGRvIG5vdCBjYWNoZSBsZW5ndGggYmVjYXVzZSBtb3JlIHdhdGNoZXJzIG1pZ2h0IGJlIHB1c2hlZFxuICAvLyBhcyB3ZSBydW4gZXhpc3Rpbmcgd2F0Y2hlcnNcbiAgZm9yIChpbmRleCA9IDA7IGluZGV4IDwgcXVldWUubGVuZ3RoOyBpbmRleCsrKSB7XG4gICAgd2F0Y2hlciA9IHF1ZXVlW2luZGV4XTtcbiAgICBpZCA9IHdhdGNoZXIuaWQ7XG4gICAgaGFzW2lkXSA9IG51bGw7XG4gICAgd2F0Y2hlci5ydW4oKTtcbiAgICAvLyBpbiBkZXYgYnVpbGQsIGNoZWNrIGFuZCBzdG9wIGNpcmN1bGFyIHVwZGF0ZXMuXG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgaGFzW2lkXSAhPSBudWxsKSB7XG4gICAgICBjaXJjdWxhcltpZF0gPSAoY2lyY3VsYXJbaWRdIHx8IDApICsgMTtcbiAgICAgIGlmIChjaXJjdWxhcltpZF0gPiBNQVhfVVBEQVRFX0NPVU5UKSB7XG4gICAgICAgIHdhcm4oXG4gICAgICAgICAgJ1lvdSBtYXkgaGF2ZSBhbiBpbmZpbml0ZSB1cGRhdGUgbG9vcCAnICsgKFxuICAgICAgICAgICAgd2F0Y2hlci51c2VyXG4gICAgICAgICAgICAgID8gKFwiaW4gd2F0Y2hlciB3aXRoIGV4cHJlc3Npb24gXFxcIlwiICsgKHdhdGNoZXIuZXhwcmVzc2lvbikgKyBcIlxcXCJcIilcbiAgICAgICAgICAgICAgOiBcImluIGEgY29tcG9uZW50IHJlbmRlciBmdW5jdGlvbi5cIlxuICAgICAgICAgICksXG4gICAgICAgICAgd2F0Y2hlci52bVxuICAgICAgICApO1xuICAgICAgICBicmVha1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8vIGtlZXAgY29waWVzIG9mIHBvc3QgcXVldWVzIGJlZm9yZSByZXNldHRpbmcgc3RhdGVcbiAgdmFyIGFjdGl2YXRlZFF1ZXVlID0gYWN0aXZhdGVkQ2hpbGRyZW4uc2xpY2UoKTtcbiAgdmFyIHVwZGF0ZWRRdWV1ZSA9IHF1ZXVlLnNsaWNlKCk7XG5cbiAgcmVzZXRTY2hlZHVsZXJTdGF0ZSgpO1xuXG4gIC8vIGNhbGwgY29tcG9uZW50IHVwZGF0ZWQgYW5kIGFjdGl2YXRlZCBob29rc1xuICBjYWxsQWN0aXZhdGVkSG9va3MoYWN0aXZhdGVkUXVldWUpO1xuICBjYWxsVXBkYXRlZEhvb2tzKHVwZGF0ZWRRdWV1ZSk7XG5cbiAgLy8gZGV2dG9vbCBob29rXG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICBpZiAoZGV2dG9vbHMgJiYgY29uZmlnLmRldnRvb2xzKSB7XG4gICAgZGV2dG9vbHMuZW1pdCgnZmx1c2gnKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBjYWxsVXBkYXRlZEhvb2tzIChxdWV1ZSkge1xuICB2YXIgaSA9IHF1ZXVlLmxlbmd0aDtcbiAgd2hpbGUgKGktLSkge1xuICAgIHZhciB3YXRjaGVyID0gcXVldWVbaV07XG4gICAgdmFyIHZtID0gd2F0Y2hlci52bTtcbiAgICBpZiAodm0uX3dhdGNoZXIgPT09IHdhdGNoZXIgJiYgdm0uX2lzTW91bnRlZCkge1xuICAgICAgY2FsbEhvb2sodm0sICd1cGRhdGVkJyk7XG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogUXVldWUgYSBrZXB0LWFsaXZlIGNvbXBvbmVudCB0aGF0IHdhcyBhY3RpdmF0ZWQgZHVyaW5nIHBhdGNoLlxuICogVGhlIHF1ZXVlIHdpbGwgYmUgcHJvY2Vzc2VkIGFmdGVyIHRoZSBlbnRpcmUgdHJlZSBoYXMgYmVlbiBwYXRjaGVkLlxuICovXG5mdW5jdGlvbiBxdWV1ZUFjdGl2YXRlZENvbXBvbmVudCAodm0pIHtcbiAgLy8gc2V0dGluZyBfaW5hY3RpdmUgdG8gZmFsc2UgaGVyZSBzbyB0aGF0IGEgcmVuZGVyIGZ1bmN0aW9uIGNhblxuICAvLyByZWx5IG9uIGNoZWNraW5nIHdoZXRoZXIgaXQncyBpbiBhbiBpbmFjdGl2ZSB0cmVlIChlLmcuIHJvdXRlci12aWV3KVxuICB2bS5faW5hY3RpdmUgPSBmYWxzZTtcbiAgYWN0aXZhdGVkQ2hpbGRyZW4ucHVzaCh2bSk7XG59XG5cbmZ1bmN0aW9uIGNhbGxBY3RpdmF0ZWRIb29rcyAocXVldWUpIHtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBxdWV1ZS5sZW5ndGg7IGkrKykge1xuICAgIHF1ZXVlW2ldLl9pbmFjdGl2ZSA9IHRydWU7XG4gICAgYWN0aXZhdGVDaGlsZENvbXBvbmVudChxdWV1ZVtpXSwgdHJ1ZSAvKiB0cnVlICovKTtcbiAgfVxufVxuXG4vKipcbiAqIFB1c2ggYSB3YXRjaGVyIGludG8gdGhlIHdhdGNoZXIgcXVldWUuXG4gKiBKb2JzIHdpdGggZHVwbGljYXRlIElEcyB3aWxsIGJlIHNraXBwZWQgdW5sZXNzIGl0J3NcbiAqIHB1c2hlZCB3aGVuIHRoZSBxdWV1ZSBpcyBiZWluZyBmbHVzaGVkLlxuICovXG5mdW5jdGlvbiBxdWV1ZVdhdGNoZXIgKHdhdGNoZXIpIHtcbiAgdmFyIGlkID0gd2F0Y2hlci5pZDtcbiAgaWYgKGhhc1tpZF0gPT0gbnVsbCkge1xuICAgIGhhc1tpZF0gPSB0cnVlO1xuICAgIGlmICghZmx1c2hpbmcpIHtcbiAgICAgIHF1ZXVlLnB1c2god2F0Y2hlcik7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIGlmIGFscmVhZHkgZmx1c2hpbmcsIHNwbGljZSB0aGUgd2F0Y2hlciBiYXNlZCBvbiBpdHMgaWRcbiAgICAgIC8vIGlmIGFscmVhZHkgcGFzdCBpdHMgaWQsIGl0IHdpbGwgYmUgcnVuIG5leHQgaW1tZWRpYXRlbHkuXG4gICAgICB2YXIgaSA9IHF1ZXVlLmxlbmd0aCAtIDE7XG4gICAgICB3aGlsZSAoaSA+IGluZGV4ICYmIHF1ZXVlW2ldLmlkID4gd2F0Y2hlci5pZCkge1xuICAgICAgICBpLS07XG4gICAgICB9XG4gICAgICBxdWV1ZS5zcGxpY2UoaSArIDEsIDAsIHdhdGNoZXIpO1xuICAgIH1cbiAgICAvLyBxdWV1ZSB0aGUgZmx1c2hcbiAgICBpZiAoIXdhaXRpbmcpIHtcbiAgICAgIHdhaXRpbmcgPSB0cnVlO1xuICAgICAgbmV4dFRpY2soZmx1c2hTY2hlZHVsZXJRdWV1ZSk7XG4gICAgfVxuICB9XG59XG5cbi8qICAqL1xuXG52YXIgdWlkJDIgPSAwO1xuXG4vKipcbiAqIEEgd2F0Y2hlciBwYXJzZXMgYW4gZXhwcmVzc2lvbiwgY29sbGVjdHMgZGVwZW5kZW5jaWVzLFxuICogYW5kIGZpcmVzIGNhbGxiYWNrIHdoZW4gdGhlIGV4cHJlc3Npb24gdmFsdWUgY2hhbmdlcy5cbiAqIFRoaXMgaXMgdXNlZCBmb3IgYm90aCB0aGUgJHdhdGNoKCkgYXBpIGFuZCBkaXJlY3RpdmVzLlxuICovXG52YXIgV2F0Y2hlciA9IGZ1bmN0aW9uIFdhdGNoZXIgKFxuICB2bSxcbiAgZXhwT3JGbixcbiAgY2IsXG4gIG9wdGlvbnMsXG4gIGlzUmVuZGVyV2F0Y2hlclxuKSB7XG4gIHRoaXMudm0gPSB2bTtcbiAgaWYgKGlzUmVuZGVyV2F0Y2hlcikge1xuICAgIHZtLl93YXRjaGVyID0gdGhpcztcbiAgfVxuICB2bS5fd2F0Y2hlcnMucHVzaCh0aGlzKTtcbiAgLy8gb3B0aW9uc1xuICBpZiAob3B0aW9ucykge1xuICAgIHRoaXMuZGVlcCA9ICEhb3B0aW9ucy5kZWVwO1xuICAgIHRoaXMudXNlciA9ICEhb3B0aW9ucy51c2VyO1xuICAgIHRoaXMubGF6eSA9ICEhb3B0aW9ucy5sYXp5O1xuICAgIHRoaXMuc3luYyA9ICEhb3B0aW9ucy5zeW5jO1xuICB9IGVsc2Uge1xuICAgIHRoaXMuZGVlcCA9IHRoaXMudXNlciA9IHRoaXMubGF6eSA9IHRoaXMuc3luYyA9IGZhbHNlO1xuICB9XG4gIHRoaXMuY2IgPSBjYjtcbiAgdGhpcy5pZCA9ICsrdWlkJDI7IC8vIHVpZCBmb3IgYmF0Y2hpbmdcbiAgdGhpcy5hY3RpdmUgPSB0cnVlO1xuICB0aGlzLmRpcnR5ID0gdGhpcy5sYXp5OyAvLyBmb3IgbGF6eSB3YXRjaGVyc1xuICB0aGlzLmRlcHMgPSBbXTtcbiAgdGhpcy5uZXdEZXBzID0gW107XG4gIHRoaXMuZGVwSWRzID0gbmV3IF9TZXQoKTtcbiAgdGhpcy5uZXdEZXBJZHMgPSBuZXcgX1NldCgpO1xuICB0aGlzLmV4cHJlc3Npb24gPSBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nXG4gICAgPyBleHBPckZuLnRvU3RyaW5nKClcbiAgICA6ICcnO1xuICAvLyBwYXJzZSBleHByZXNzaW9uIGZvciBnZXR0ZXJcbiAgaWYgKHR5cGVvZiBleHBPckZuID09PSAnZnVuY3Rpb24nKSB7XG4gICAgdGhpcy5nZXR0ZXIgPSBleHBPckZuO1xuICB9IGVsc2Uge1xuICAgIHRoaXMuZ2V0dGVyID0gcGFyc2VQYXRoKGV4cE9yRm4pO1xuICAgIGlmICghdGhpcy5nZXR0ZXIpIHtcbiAgICAgIHRoaXMuZ2V0dGVyID0gZnVuY3Rpb24gKCkge307XG4gICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIHdhcm4oXG4gICAgICAgIFwiRmFpbGVkIHdhdGNoaW5nIHBhdGg6IFxcXCJcIiArIGV4cE9yRm4gKyBcIlxcXCIgXCIgK1xuICAgICAgICAnV2F0Y2hlciBvbmx5IGFjY2VwdHMgc2ltcGxlIGRvdC1kZWxpbWl0ZWQgcGF0aHMuICcgK1xuICAgICAgICAnRm9yIGZ1bGwgY29udHJvbCwgdXNlIGEgZnVuY3Rpb24gaW5zdGVhZC4nLFxuICAgICAgICB2bVxuICAgICAgKTtcbiAgICB9XG4gIH1cbiAgdGhpcy52YWx1ZSA9IHRoaXMubGF6eVxuICAgID8gdW5kZWZpbmVkXG4gICAgOiB0aGlzLmdldCgpO1xufTtcblxuLyoqXG4gKiBFdmFsdWF0ZSB0aGUgZ2V0dGVyLCBhbmQgcmUtY29sbGVjdCBkZXBlbmRlbmNpZXMuXG4gKi9cbldhdGNoZXIucHJvdG90eXBlLmdldCA9IGZ1bmN0aW9uIGdldCAoKSB7XG4gIHB1c2hUYXJnZXQodGhpcyk7XG4gIHZhciB2YWx1ZTtcbiAgdmFyIHZtID0gdGhpcy52bTtcbiAgdHJ5IHtcbiAgICB2YWx1ZSA9IHRoaXMuZ2V0dGVyLmNhbGwodm0sIHZtKTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIGlmICh0aGlzLnVzZXIpIHtcbiAgICAgIGhhbmRsZUVycm9yKGUsIHZtLCAoXCJnZXR0ZXIgZm9yIHdhdGNoZXIgXFxcIlwiICsgKHRoaXMuZXhwcmVzc2lvbikgKyBcIlxcXCJcIikpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBlXG4gICAgfVxuICB9IGZpbmFsbHkge1xuICAgIC8vIFwidG91Y2hcIiBldmVyeSBwcm9wZXJ0eSBzbyB0aGV5IGFyZSBhbGwgdHJhY2tlZCBhc1xuICAgIC8vIGRlcGVuZGVuY2llcyBmb3IgZGVlcCB3YXRjaGluZ1xuICAgIGlmICh0aGlzLmRlZXApIHtcbiAgICAgIHRyYXZlcnNlKHZhbHVlKTtcbiAgICB9XG4gICAgcG9wVGFyZ2V0KCk7XG4gICAgdGhpcy5jbGVhbnVwRGVwcygpO1xuICB9XG4gIHJldHVybiB2YWx1ZVxufTtcblxuLyoqXG4gKiBBZGQgYSBkZXBlbmRlbmN5IHRvIHRoaXMgZGlyZWN0aXZlLlxuICovXG5XYXRjaGVyLnByb3RvdHlwZS5hZGREZXAgPSBmdW5jdGlvbiBhZGREZXAgKGRlcCkge1xuICB2YXIgaWQgPSBkZXAuaWQ7XG4gIGlmICghdGhpcy5uZXdEZXBJZHMuaGFzKGlkKSkge1xuICAgIHRoaXMubmV3RGVwSWRzLmFkZChpZCk7XG4gICAgdGhpcy5uZXdEZXBzLnB1c2goZGVwKTtcbiAgICBpZiAoIXRoaXMuZGVwSWRzLmhhcyhpZCkpIHtcbiAgICAgIGRlcC5hZGRTdWIodGhpcyk7XG4gICAgfVxuICB9XG59O1xuXG4vKipcbiAqIENsZWFuIHVwIGZvciBkZXBlbmRlbmN5IGNvbGxlY3Rpb24uXG4gKi9cbldhdGNoZXIucHJvdG90eXBlLmNsZWFudXBEZXBzID0gZnVuY3Rpb24gY2xlYW51cERlcHMgKCkge1xuICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gIHZhciBpID0gdGhpcy5kZXBzLmxlbmd0aDtcbiAgd2hpbGUgKGktLSkge1xuICAgIHZhciBkZXAgPSB0aGlzJDEuZGVwc1tpXTtcbiAgICBpZiAoIXRoaXMkMS5uZXdEZXBJZHMuaGFzKGRlcC5pZCkpIHtcbiAgICAgIGRlcC5yZW1vdmVTdWIodGhpcyQxKTtcbiAgICB9XG4gIH1cbiAgdmFyIHRtcCA9IHRoaXMuZGVwSWRzO1xuICB0aGlzLmRlcElkcyA9IHRoaXMubmV3RGVwSWRzO1xuICB0aGlzLm5ld0RlcElkcyA9IHRtcDtcbiAgdGhpcy5uZXdEZXBJZHMuY2xlYXIoKTtcbiAgdG1wID0gdGhpcy5kZXBzO1xuICB0aGlzLmRlcHMgPSB0aGlzLm5ld0RlcHM7XG4gIHRoaXMubmV3RGVwcyA9IHRtcDtcbiAgdGhpcy5uZXdEZXBzLmxlbmd0aCA9IDA7XG59O1xuXG4vKipcbiAqIFN1YnNjcmliZXIgaW50ZXJmYWNlLlxuICogV2lsbCBiZSBjYWxsZWQgd2hlbiBhIGRlcGVuZGVuY3kgY2hhbmdlcy5cbiAqL1xuV2F0Y2hlci5wcm90b3R5cGUudXBkYXRlID0gZnVuY3Rpb24gdXBkYXRlICgpIHtcbiAgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cbiAgaWYgKHRoaXMubGF6eSkge1xuICAgIHRoaXMuZGlydHkgPSB0cnVlO1xuICB9IGVsc2UgaWYgKHRoaXMuc3luYykge1xuICAgIHRoaXMucnVuKCk7XG4gIH0gZWxzZSB7XG4gICAgcXVldWVXYXRjaGVyKHRoaXMpO1xuICB9XG59O1xuXG4vKipcbiAqIFNjaGVkdWxlciBqb2IgaW50ZXJmYWNlLlxuICogV2lsbCBiZSBjYWxsZWQgYnkgdGhlIHNjaGVkdWxlci5cbiAqL1xuV2F0Y2hlci5wcm90b3R5cGUucnVuID0gZnVuY3Rpb24gcnVuICgpIHtcbiAgaWYgKHRoaXMuYWN0aXZlKSB7XG4gICAgdmFyIHZhbHVlID0gdGhpcy5nZXQoKTtcbiAgICBpZiAoXG4gICAgICB2YWx1ZSAhPT0gdGhpcy52YWx1ZSB8fFxuICAgICAgLy8gRGVlcCB3YXRjaGVycyBhbmQgd2F0Y2hlcnMgb24gT2JqZWN0L0FycmF5cyBzaG91bGQgZmlyZSBldmVuXG4gICAgICAvLyB3aGVuIHRoZSB2YWx1ZSBpcyB0aGUgc2FtZSwgYmVjYXVzZSB0aGUgdmFsdWUgbWF5XG4gICAgICAvLyBoYXZlIG11dGF0ZWQuXG4gICAgICBpc09iamVjdCh2YWx1ZSkgfHxcbiAgICAgIHRoaXMuZGVlcFxuICAgICkge1xuICAgICAgLy8gc2V0IG5ldyB2YWx1ZVxuICAgICAgdmFyIG9sZFZhbHVlID0gdGhpcy52YWx1ZTtcbiAgICAgIHRoaXMudmFsdWUgPSB2YWx1ZTtcbiAgICAgIGlmICh0aGlzLnVzZXIpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICB0aGlzLmNiLmNhbGwodGhpcy52bSwgdmFsdWUsIG9sZFZhbHVlKTtcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgIGhhbmRsZUVycm9yKGUsIHRoaXMudm0sIChcImNhbGxiYWNrIGZvciB3YXRjaGVyIFxcXCJcIiArICh0aGlzLmV4cHJlc3Npb24pICsgXCJcXFwiXCIpKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5jYi5jYWxsKHRoaXMudm0sIHZhbHVlLCBvbGRWYWx1ZSk7XG4gICAgICB9XG4gICAgfVxuICB9XG59O1xuXG4vKipcbiAqIEV2YWx1YXRlIHRoZSB2YWx1ZSBvZiB0aGUgd2F0Y2hlci5cbiAqIFRoaXMgb25seSBnZXRzIGNhbGxlZCBmb3IgbGF6eSB3YXRjaGVycy5cbiAqL1xuV2F0Y2hlci5wcm90b3R5cGUuZXZhbHVhdGUgPSBmdW5jdGlvbiBldmFsdWF0ZSAoKSB7XG4gIHRoaXMudmFsdWUgPSB0aGlzLmdldCgpO1xuICB0aGlzLmRpcnR5ID0gZmFsc2U7XG59O1xuXG4vKipcbiAqIERlcGVuZCBvbiBhbGwgZGVwcyBjb2xsZWN0ZWQgYnkgdGhpcyB3YXRjaGVyLlxuICovXG5XYXRjaGVyLnByb3RvdHlwZS5kZXBlbmQgPSBmdW5jdGlvbiBkZXBlbmQgKCkge1xuICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gIHZhciBpID0gdGhpcy5kZXBzLmxlbmd0aDtcbiAgd2hpbGUgKGktLSkge1xuICAgIHRoaXMkMS5kZXBzW2ldLmRlcGVuZCgpO1xuICB9XG59O1xuXG4vKipcbiAqIFJlbW92ZSBzZWxmIGZyb20gYWxsIGRlcGVuZGVuY2llcycgc3Vic2NyaWJlciBsaXN0LlxuICovXG5XYXRjaGVyLnByb3RvdHlwZS50ZWFyZG93biA9IGZ1bmN0aW9uIHRlYXJkb3duICgpIHtcbiAgICB2YXIgdGhpcyQxID0gdGhpcztcblxuICBpZiAodGhpcy5hY3RpdmUpIHtcbiAgICAvLyByZW1vdmUgc2VsZiBmcm9tIHZtJ3Mgd2F0Y2hlciBsaXN0XG4gICAgLy8gdGhpcyBpcyBhIHNvbWV3aGF0IGV4cGVuc2l2ZSBvcGVyYXRpb24gc28gd2Ugc2tpcCBpdFxuICAgIC8vIGlmIHRoZSB2bSBpcyBiZWluZyBkZXN0cm95ZWQuXG4gICAgaWYgKCF0aGlzLnZtLl9pc0JlaW5nRGVzdHJveWVkKSB7XG4gICAgICByZW1vdmUodGhpcy52bS5fd2F0Y2hlcnMsIHRoaXMpO1xuICAgIH1cbiAgICB2YXIgaSA9IHRoaXMuZGVwcy5sZW5ndGg7XG4gICAgd2hpbGUgKGktLSkge1xuICAgICAgdGhpcyQxLmRlcHNbaV0ucmVtb3ZlU3ViKHRoaXMkMSk7XG4gICAgfVxuICAgIHRoaXMuYWN0aXZlID0gZmFsc2U7XG4gIH1cbn07XG5cbi8qICAqL1xuXG52YXIgc2hhcmVkUHJvcGVydHlEZWZpbml0aW9uID0ge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBjb25maWd1cmFibGU6IHRydWUsXG4gIGdldDogbm9vcCxcbiAgc2V0OiBub29wXG59O1xuXG5mdW5jdGlvbiBwcm94eSAodGFyZ2V0LCBzb3VyY2VLZXksIGtleSkge1xuICBzaGFyZWRQcm9wZXJ0eURlZmluaXRpb24uZ2V0ID0gZnVuY3Rpb24gcHJveHlHZXR0ZXIgKCkge1xuICAgIHJldHVybiB0aGlzW3NvdXJjZUtleV1ba2V5XVxuICB9O1xuICBzaGFyZWRQcm9wZXJ0eURlZmluaXRpb24uc2V0ID0gZnVuY3Rpb24gcHJveHlTZXR0ZXIgKHZhbCkge1xuICAgIHRoaXNbc291cmNlS2V5XVtrZXldID0gdmFsO1xuICB9O1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHNoYXJlZFByb3BlcnR5RGVmaW5pdGlvbik7XG59XG5cbmZ1bmN0aW9uIGluaXRTdGF0ZSAodm0pIHtcbiAgdm0uX3dhdGNoZXJzID0gW107XG4gIHZhciBvcHRzID0gdm0uJG9wdGlvbnM7XG4gIGlmIChvcHRzLnByb3BzKSB7IGluaXRQcm9wcyh2bSwgb3B0cy5wcm9wcyk7IH1cbiAgaWYgKG9wdHMubWV0aG9kcykgeyBpbml0TWV0aG9kcyh2bSwgb3B0cy5tZXRob2RzKTsgfVxuICBpZiAob3B0cy5kYXRhKSB7XG4gICAgaW5pdERhdGEodm0pO1xuICB9IGVsc2Uge1xuICAgIG9ic2VydmUodm0uX2RhdGEgPSB7fSwgdHJ1ZSAvKiBhc1Jvb3REYXRhICovKTtcbiAgfVxuICBpZiAob3B0cy5jb21wdXRlZCkgeyBpbml0Q29tcHV0ZWQodm0sIG9wdHMuY29tcHV0ZWQpOyB9XG4gIGlmIChvcHRzLndhdGNoICYmIG9wdHMud2F0Y2ggIT09IG5hdGl2ZVdhdGNoKSB7XG4gICAgaW5pdFdhdGNoKHZtLCBvcHRzLndhdGNoKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBpbml0UHJvcHMgKHZtLCBwcm9wc09wdGlvbnMpIHtcbiAgdmFyIHByb3BzRGF0YSA9IHZtLiRvcHRpb25zLnByb3BzRGF0YSB8fCB7fTtcbiAgdmFyIHByb3BzID0gdm0uX3Byb3BzID0ge307XG4gIC8vIGNhY2hlIHByb3Aga2V5cyBzbyB0aGF0IGZ1dHVyZSBwcm9wcyB1cGRhdGVzIGNhbiBpdGVyYXRlIHVzaW5nIEFycmF5XG4gIC8vIGluc3RlYWQgb2YgZHluYW1pYyBvYmplY3Qga2V5IGVudW1lcmF0aW9uLlxuICB2YXIga2V5cyA9IHZtLiRvcHRpb25zLl9wcm9wS2V5cyA9IFtdO1xuICB2YXIgaXNSb290ID0gIXZtLiRwYXJlbnQ7XG4gIC8vIHJvb3QgaW5zdGFuY2UgcHJvcHMgc2hvdWxkIGJlIGNvbnZlcnRlZFxuICBvYnNlcnZlclN0YXRlLnNob3VsZENvbnZlcnQgPSBpc1Jvb3Q7XG4gIHZhciBsb29wID0gZnVuY3Rpb24gKCBrZXkgKSB7XG4gICAga2V5cy5wdXNoKGtleSk7XG4gICAgdmFyIHZhbHVlID0gdmFsaWRhdGVQcm9wKGtleSwgcHJvcHNPcHRpb25zLCBwcm9wc0RhdGEsIHZtKTtcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICB2YXIgaHlwaGVuYXRlZEtleSA9IGh5cGhlbmF0ZShrZXkpO1xuICAgICAgaWYgKGlzUmVzZXJ2ZWRBdHRyaWJ1dGUoaHlwaGVuYXRlZEtleSkgfHxcbiAgICAgICAgICBjb25maWcuaXNSZXNlcnZlZEF0dHIoaHlwaGVuYXRlZEtleSkpIHtcbiAgICAgICAgd2FybihcbiAgICAgICAgICAoXCJcXFwiXCIgKyBoeXBoZW5hdGVkS2V5ICsgXCJcXFwiIGlzIGEgcmVzZXJ2ZWQgYXR0cmlidXRlIGFuZCBjYW5ub3QgYmUgdXNlZCBhcyBjb21wb25lbnQgcHJvcC5cIiksXG4gICAgICAgICAgdm1cbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIGRlZmluZVJlYWN0aXZlKHByb3BzLCBrZXksIHZhbHVlLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh2bS4kcGFyZW50ICYmICFpc1VwZGF0aW5nQ2hpbGRDb21wb25lbnQpIHtcbiAgICAgICAgICB3YXJuKFxuICAgICAgICAgICAgXCJBdm9pZCBtdXRhdGluZyBhIHByb3AgZGlyZWN0bHkgc2luY2UgdGhlIHZhbHVlIHdpbGwgYmUgXCIgK1xuICAgICAgICAgICAgXCJvdmVyd3JpdHRlbiB3aGVuZXZlciB0aGUgcGFyZW50IGNvbXBvbmVudCByZS1yZW5kZXJzLiBcIiArXG4gICAgICAgICAgICBcIkluc3RlYWQsIHVzZSBhIGRhdGEgb3IgY29tcHV0ZWQgcHJvcGVydHkgYmFzZWQgb24gdGhlIHByb3AncyBcIiArXG4gICAgICAgICAgICBcInZhbHVlLiBQcm9wIGJlaW5nIG11dGF0ZWQ6IFxcXCJcIiArIGtleSArIFwiXFxcIlwiLFxuICAgICAgICAgICAgdm1cbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgZGVmaW5lUmVhY3RpdmUocHJvcHMsIGtleSwgdmFsdWUpO1xuICAgIH1cbiAgICAvLyBzdGF0aWMgcHJvcHMgYXJlIGFscmVhZHkgcHJveGllZCBvbiB0aGUgY29tcG9uZW50J3MgcHJvdG90eXBlXG4gICAgLy8gZHVyaW5nIFZ1ZS5leHRlbmQoKS4gV2Ugb25seSBuZWVkIHRvIHByb3h5IHByb3BzIGRlZmluZWQgYXRcbiAgICAvLyBpbnN0YW50aWF0aW9uIGhlcmUuXG4gICAgaWYgKCEoa2V5IGluIHZtKSkge1xuICAgICAgcHJveHkodm0sIFwiX3Byb3BzXCIsIGtleSk7XG4gICAgfVxuICB9O1xuXG4gIGZvciAodmFyIGtleSBpbiBwcm9wc09wdGlvbnMpIGxvb3AoIGtleSApO1xuICBvYnNlcnZlclN0YXRlLnNob3VsZENvbnZlcnQgPSB0cnVlO1xufVxuXG5mdW5jdGlvbiBpbml0RGF0YSAodm0pIHtcbiAgdmFyIGRhdGEgPSB2bS4kb3B0aW9ucy5kYXRhO1xuICBkYXRhID0gdm0uX2RhdGEgPSB0eXBlb2YgZGF0YSA9PT0gJ2Z1bmN0aW9uJ1xuICAgID8gZ2V0RGF0YShkYXRhLCB2bSlcbiAgICA6IGRhdGEgfHwge307XG4gIGlmICghaXNQbGFpbk9iamVjdChkYXRhKSkge1xuICAgIGRhdGEgPSB7fTtcbiAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIHdhcm4oXG4gICAgICAnZGF0YSBmdW5jdGlvbnMgc2hvdWxkIHJldHVybiBhbiBvYmplY3Q6XFxuJyArXG4gICAgICAnaHR0cHM6Ly92dWVqcy5vcmcvdjIvZ3VpZGUvY29tcG9uZW50cy5odG1sI2RhdGEtTXVzdC1CZS1hLUZ1bmN0aW9uJyxcbiAgICAgIHZtXG4gICAgKTtcbiAgfVxuICAvLyBwcm94eSBkYXRhIG9uIGluc3RhbmNlXG4gIHZhciBrZXlzID0gT2JqZWN0LmtleXMoZGF0YSk7XG4gIHZhciBwcm9wcyA9IHZtLiRvcHRpb25zLnByb3BzO1xuICB2YXIgbWV0aG9kcyA9IHZtLiRvcHRpb25zLm1ldGhvZHM7XG4gIHZhciBpID0ga2V5cy5sZW5ndGg7XG4gIHdoaWxlIChpLS0pIHtcbiAgICB2YXIga2V5ID0ga2V5c1tpXTtcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgaWYgKG1ldGhvZHMgJiYgaGFzT3duKG1ldGhvZHMsIGtleSkpIHtcbiAgICAgICAgd2FybihcbiAgICAgICAgICAoXCJNZXRob2QgXFxcIlwiICsga2V5ICsgXCJcXFwiIGhhcyBhbHJlYWR5IGJlZW4gZGVmaW5lZCBhcyBhIGRhdGEgcHJvcGVydHkuXCIpLFxuICAgICAgICAgIHZtXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChwcm9wcyAmJiBoYXNPd24ocHJvcHMsIGtleSkpIHtcbiAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgd2FybihcbiAgICAgICAgXCJUaGUgZGF0YSBwcm9wZXJ0eSBcXFwiXCIgKyBrZXkgKyBcIlxcXCIgaXMgYWxyZWFkeSBkZWNsYXJlZCBhcyBhIHByb3AuIFwiICtcbiAgICAgICAgXCJVc2UgcHJvcCBkZWZhdWx0IHZhbHVlIGluc3RlYWQuXCIsXG4gICAgICAgIHZtXG4gICAgICApO1xuICAgIH0gZWxzZSBpZiAoIWlzUmVzZXJ2ZWQoa2V5KSkge1xuICAgICAgcHJveHkodm0sIFwiX2RhdGFcIiwga2V5KTtcbiAgICB9XG4gIH1cbiAgLy8gb2JzZXJ2ZSBkYXRhXG4gIG9ic2VydmUoZGF0YSwgdHJ1ZSAvKiBhc1Jvb3REYXRhICovKTtcbn1cblxuZnVuY3Rpb24gZ2V0RGF0YSAoZGF0YSwgdm0pIHtcbiAgdHJ5IHtcbiAgICByZXR1cm4gZGF0YS5jYWxsKHZtLCB2bSlcbiAgfSBjYXRjaCAoZSkge1xuICAgIGhhbmRsZUVycm9yKGUsIHZtLCBcImRhdGEoKVwiKTtcbiAgICByZXR1cm4ge31cbiAgfVxufVxuXG52YXIgY29tcHV0ZWRXYXRjaGVyT3B0aW9ucyA9IHsgbGF6eTogdHJ1ZSB9O1xuXG5mdW5jdGlvbiBpbml0Q29tcHV0ZWQgKHZtLCBjb21wdXRlZCkge1xuICAvLyAkZmxvdy1kaXNhYmxlLWxpbmVcbiAgdmFyIHdhdGNoZXJzID0gdm0uX2NvbXB1dGVkV2F0Y2hlcnMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAvLyBjb21wdXRlZCBwcm9wZXJ0aWVzIGFyZSBqdXN0IGdldHRlcnMgZHVyaW5nIFNTUlxuICB2YXIgaXNTU1IgPSBpc1NlcnZlclJlbmRlcmluZygpO1xuXG4gIGZvciAodmFyIGtleSBpbiBjb21wdXRlZCkge1xuICAgIHZhciB1c2VyRGVmID0gY29tcHV0ZWRba2V5XTtcbiAgICB2YXIgZ2V0dGVyID0gdHlwZW9mIHVzZXJEZWYgPT09ICdmdW5jdGlvbicgPyB1c2VyRGVmIDogdXNlckRlZi5nZXQ7XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgZ2V0dGVyID09IG51bGwpIHtcbiAgICAgIHdhcm4oXG4gICAgICAgIChcIkdldHRlciBpcyBtaXNzaW5nIGZvciBjb21wdXRlZCBwcm9wZXJ0eSBcXFwiXCIgKyBrZXkgKyBcIlxcXCIuXCIpLFxuICAgICAgICB2bVxuICAgICAgKTtcbiAgICB9XG5cbiAgICBpZiAoIWlzU1NSKSB7XG4gICAgICAvLyBjcmVhdGUgaW50ZXJuYWwgd2F0Y2hlciBmb3IgdGhlIGNvbXB1dGVkIHByb3BlcnR5LlxuICAgICAgd2F0Y2hlcnNba2V5XSA9IG5ldyBXYXRjaGVyKFxuICAgICAgICB2bSxcbiAgICAgICAgZ2V0dGVyIHx8IG5vb3AsXG4gICAgICAgIG5vb3AsXG4gICAgICAgIGNvbXB1dGVkV2F0Y2hlck9wdGlvbnNcbiAgICAgICk7XG4gICAgfVxuXG4gICAgLy8gY29tcG9uZW50LWRlZmluZWQgY29tcHV0ZWQgcHJvcGVydGllcyBhcmUgYWxyZWFkeSBkZWZpbmVkIG9uIHRoZVxuICAgIC8vIGNvbXBvbmVudCBwcm90b3R5cGUuIFdlIG9ubHkgbmVlZCB0byBkZWZpbmUgY29tcHV0ZWQgcHJvcGVydGllcyBkZWZpbmVkXG4gICAgLy8gYXQgaW5zdGFudGlhdGlvbiBoZXJlLlxuICAgIGlmICghKGtleSBpbiB2bSkpIHtcbiAgICAgIGRlZmluZUNvbXB1dGVkKHZtLCBrZXksIHVzZXJEZWYpO1xuICAgIH0gZWxzZSBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgaWYgKGtleSBpbiB2bS4kZGF0YSkge1xuICAgICAgICB3YXJuKChcIlRoZSBjb21wdXRlZCBwcm9wZXJ0eSBcXFwiXCIgKyBrZXkgKyBcIlxcXCIgaXMgYWxyZWFkeSBkZWZpbmVkIGluIGRhdGEuXCIpLCB2bSk7XG4gICAgICB9IGVsc2UgaWYgKHZtLiRvcHRpb25zLnByb3BzICYmIGtleSBpbiB2bS4kb3B0aW9ucy5wcm9wcykge1xuICAgICAgICB3YXJuKChcIlRoZSBjb21wdXRlZCBwcm9wZXJ0eSBcXFwiXCIgKyBrZXkgKyBcIlxcXCIgaXMgYWxyZWFkeSBkZWZpbmVkIGFzIGEgcHJvcC5cIiksIHZtKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gZGVmaW5lQ29tcHV0ZWQgKFxuICB0YXJnZXQsXG4gIGtleSxcbiAgdXNlckRlZlxuKSB7XG4gIHZhciBzaG91bGRDYWNoZSA9ICFpc1NlcnZlclJlbmRlcmluZygpO1xuICBpZiAodHlwZW9mIHVzZXJEZWYgPT09ICdmdW5jdGlvbicpIHtcbiAgICBzaGFyZWRQcm9wZXJ0eURlZmluaXRpb24uZ2V0ID0gc2hvdWxkQ2FjaGVcbiAgICAgID8gY3JlYXRlQ29tcHV0ZWRHZXR0ZXIoa2V5KVxuICAgICAgOiB1c2VyRGVmO1xuICAgIHNoYXJlZFByb3BlcnR5RGVmaW5pdGlvbi5zZXQgPSBub29wO1xuICB9IGVsc2Uge1xuICAgIHNoYXJlZFByb3BlcnR5RGVmaW5pdGlvbi5nZXQgPSB1c2VyRGVmLmdldFxuICAgICAgPyBzaG91bGRDYWNoZSAmJiB1c2VyRGVmLmNhY2hlICE9PSBmYWxzZVxuICAgICAgICA/IGNyZWF0ZUNvbXB1dGVkR2V0dGVyKGtleSlcbiAgICAgICAgOiB1c2VyRGVmLmdldFxuICAgICAgOiBub29wO1xuICAgIHNoYXJlZFByb3BlcnR5RGVmaW5pdGlvbi5zZXQgPSB1c2VyRGVmLnNldFxuICAgICAgPyB1c2VyRGVmLnNldFxuICAgICAgOiBub29wO1xuICB9XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmXG4gICAgICBzaGFyZWRQcm9wZXJ0eURlZmluaXRpb24uc2V0ID09PSBub29wKSB7XG4gICAgc2hhcmVkUHJvcGVydHlEZWZpbml0aW9uLnNldCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHdhcm4oXG4gICAgICAgIChcIkNvbXB1dGVkIHByb3BlcnR5IFxcXCJcIiArIGtleSArIFwiXFxcIiB3YXMgYXNzaWduZWQgdG8gYnV0IGl0IGhhcyBubyBzZXR0ZXIuXCIpLFxuICAgICAgICB0aGlzXG4gICAgICApO1xuICAgIH07XG4gIH1cbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCBzaGFyZWRQcm9wZXJ0eURlZmluaXRpb24pO1xufVxuXG5mdW5jdGlvbiBjcmVhdGVDb21wdXRlZEdldHRlciAoa2V5KSB7XG4gIHJldHVybiBmdW5jdGlvbiBjb21wdXRlZEdldHRlciAoKSB7XG4gICAgdmFyIHdhdGNoZXIgPSB0aGlzLl9jb21wdXRlZFdhdGNoZXJzICYmIHRoaXMuX2NvbXB1dGVkV2F0Y2hlcnNba2V5XTtcbiAgICBpZiAod2F0Y2hlcikge1xuICAgICAgaWYgKHdhdGNoZXIuZGlydHkpIHtcbiAgICAgICAgd2F0Y2hlci5ldmFsdWF0ZSgpO1xuICAgICAgfVxuICAgICAgaWYgKERlcC50YXJnZXQpIHtcbiAgICAgICAgd2F0Y2hlci5kZXBlbmQoKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB3YXRjaGVyLnZhbHVlXG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGluaXRNZXRob2RzICh2bSwgbWV0aG9kcykge1xuICB2YXIgcHJvcHMgPSB2bS4kb3B0aW9ucy5wcm9wcztcbiAgZm9yICh2YXIga2V5IGluIG1ldGhvZHMpIHtcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgaWYgKG1ldGhvZHNba2V5XSA9PSBudWxsKSB7XG4gICAgICAgIHdhcm4oXG4gICAgICAgICAgXCJNZXRob2QgXFxcIlwiICsga2V5ICsgXCJcXFwiIGhhcyBhbiB1bmRlZmluZWQgdmFsdWUgaW4gdGhlIGNvbXBvbmVudCBkZWZpbml0aW9uLiBcIiArXG4gICAgICAgICAgXCJEaWQgeW91IHJlZmVyZW5jZSB0aGUgZnVuY3Rpb24gY29ycmVjdGx5P1wiLFxuICAgICAgICAgIHZtXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICBpZiAocHJvcHMgJiYgaGFzT3duKHByb3BzLCBrZXkpKSB7XG4gICAgICAgIHdhcm4oXG4gICAgICAgICAgKFwiTWV0aG9kIFxcXCJcIiArIGtleSArIFwiXFxcIiBoYXMgYWxyZWFkeSBiZWVuIGRlZmluZWQgYXMgYSBwcm9wLlwiKSxcbiAgICAgICAgICB2bVxuICAgICAgICApO1xuICAgICAgfVxuICAgICAgaWYgKChrZXkgaW4gdm0pICYmIGlzUmVzZXJ2ZWQoa2V5KSkge1xuICAgICAgICB3YXJuKFxuICAgICAgICAgIFwiTWV0aG9kIFxcXCJcIiArIGtleSArIFwiXFxcIiBjb25mbGljdHMgd2l0aCBhbiBleGlzdGluZyBWdWUgaW5zdGFuY2UgbWV0aG9kLiBcIiArXG4gICAgICAgICAgXCJBdm9pZCBkZWZpbmluZyBjb21wb25lbnQgbWV0aG9kcyB0aGF0IHN0YXJ0IHdpdGggXyBvciAkLlwiXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgfVxuICAgIHZtW2tleV0gPSBtZXRob2RzW2tleV0gPT0gbnVsbCA/IG5vb3AgOiBiaW5kKG1ldGhvZHNba2V5XSwgdm0pO1xuICB9XG59XG5cbmZ1bmN0aW9uIGluaXRXYXRjaCAodm0sIHdhdGNoKSB7XG4gIGZvciAodmFyIGtleSBpbiB3YXRjaCkge1xuICAgIHZhciBoYW5kbGVyID0gd2F0Y2hba2V5XTtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShoYW5kbGVyKSkge1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBoYW5kbGVyLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNyZWF0ZVdhdGNoZXIodm0sIGtleSwgaGFuZGxlcltpXSk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGNyZWF0ZVdhdGNoZXIodm0sIGtleSwgaGFuZGxlcik7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZVdhdGNoZXIgKFxuICB2bSxcbiAga2V5T3JGbixcbiAgaGFuZGxlcixcbiAgb3B0aW9uc1xuKSB7XG4gIGlmIChpc1BsYWluT2JqZWN0KGhhbmRsZXIpKSB7XG4gICAgb3B0aW9ucyA9IGhhbmRsZXI7XG4gICAgaGFuZGxlciA9IGhhbmRsZXIuaGFuZGxlcjtcbiAgfVxuICBpZiAodHlwZW9mIGhhbmRsZXIgPT09ICdzdHJpbmcnKSB7XG4gICAgaGFuZGxlciA9IHZtW2hhbmRsZXJdO1xuICB9XG4gIHJldHVybiB2bS4kd2F0Y2goa2V5T3JGbiwgaGFuZGxlciwgb3B0aW9ucylcbn1cblxuZnVuY3Rpb24gc3RhdGVNaXhpbiAoVnVlKSB7XG4gIC8vIGZsb3cgc29tZWhvdyBoYXMgcHJvYmxlbXMgd2l0aCBkaXJlY3RseSBkZWNsYXJlZCBkZWZpbml0aW9uIG9iamVjdFxuICAvLyB3aGVuIHVzaW5nIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSwgc28gd2UgaGF2ZSB0byBwcm9jZWR1cmFsbHkgYnVpbGQgdXBcbiAgLy8gdGhlIG9iamVjdCBoZXJlLlxuICB2YXIgZGF0YURlZiA9IHt9O1xuICBkYXRhRGVmLmdldCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuX2RhdGEgfTtcbiAgdmFyIHByb3BzRGVmID0ge307XG4gIHByb3BzRGVmLmdldCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuX3Byb3BzIH07XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgZGF0YURlZi5zZXQgPSBmdW5jdGlvbiAobmV3RGF0YSkge1xuICAgICAgd2FybihcbiAgICAgICAgJ0F2b2lkIHJlcGxhY2luZyBpbnN0YW5jZSByb290ICRkYXRhLiAnICtcbiAgICAgICAgJ1VzZSBuZXN0ZWQgZGF0YSBwcm9wZXJ0aWVzIGluc3RlYWQuJyxcbiAgICAgICAgdGhpc1xuICAgICAgKTtcbiAgICB9O1xuICAgIHByb3BzRGVmLnNldCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHdhcm4oXCIkcHJvcHMgaXMgcmVhZG9ubHkuXCIsIHRoaXMpO1xuICAgIH07XG4gIH1cbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFZ1ZS5wcm90b3R5cGUsICckZGF0YScsIGRhdGFEZWYpO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoVnVlLnByb3RvdHlwZSwgJyRwcm9wcycsIHByb3BzRGVmKTtcblxuICBWdWUucHJvdG90eXBlLiRzZXQgPSBzZXQ7XG4gIFZ1ZS5wcm90b3R5cGUuJGRlbGV0ZSA9IGRlbDtcblxuICBWdWUucHJvdG90eXBlLiR3YXRjaCA9IGZ1bmN0aW9uIChcbiAgICBleHBPckZuLFxuICAgIGNiLFxuICAgIG9wdGlvbnNcbiAgKSB7XG4gICAgdmFyIHZtID0gdGhpcztcbiAgICBpZiAoaXNQbGFpbk9iamVjdChjYikpIHtcbiAgICAgIHJldHVybiBjcmVhdGVXYXRjaGVyKHZtLCBleHBPckZuLCBjYiwgb3B0aW9ucylcbiAgICB9XG4gICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gICAgb3B0aW9ucy51c2VyID0gdHJ1ZTtcbiAgICB2YXIgd2F0Y2hlciA9IG5ldyBXYXRjaGVyKHZtLCBleHBPckZuLCBjYiwgb3B0aW9ucyk7XG4gICAgaWYgKG9wdGlvbnMuaW1tZWRpYXRlKSB7XG4gICAgICBjYi5jYWxsKHZtLCB3YXRjaGVyLnZhbHVlKTtcbiAgICB9XG4gICAgcmV0dXJuIGZ1bmN0aW9uIHVud2F0Y2hGbiAoKSB7XG4gICAgICB3YXRjaGVyLnRlYXJkb3duKCk7XG4gICAgfVxuICB9O1xufVxuXG4vKiAgKi9cblxuZnVuY3Rpb24gaW5pdFByb3ZpZGUgKHZtKSB7XG4gIHZhciBwcm92aWRlID0gdm0uJG9wdGlvbnMucHJvdmlkZTtcbiAgaWYgKHByb3ZpZGUpIHtcbiAgICB2bS5fcHJvdmlkZWQgPSB0eXBlb2YgcHJvdmlkZSA9PT0gJ2Z1bmN0aW9uJ1xuICAgICAgPyBwcm92aWRlLmNhbGwodm0pXG4gICAgICA6IHByb3ZpZGU7XG4gIH1cbn1cblxuZnVuY3Rpb24gaW5pdEluamVjdGlvbnMgKHZtKSB7XG4gIHZhciByZXN1bHQgPSByZXNvbHZlSW5qZWN0KHZtLiRvcHRpb25zLmluamVjdCwgdm0pO1xuICBpZiAocmVzdWx0KSB7XG4gICAgb2JzZXJ2ZXJTdGF0ZS5zaG91bGRDb252ZXJ0ID0gZmFsc2U7XG4gICAgT2JqZWN0LmtleXMocmVzdWx0KS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICovXG4gICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICBkZWZpbmVSZWFjdGl2ZSh2bSwga2V5LCByZXN1bHRba2V5XSwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHdhcm4oXG4gICAgICAgICAgICBcIkF2b2lkIG11dGF0aW5nIGFuIGluamVjdGVkIHZhbHVlIGRpcmVjdGx5IHNpbmNlIHRoZSBjaGFuZ2VzIHdpbGwgYmUgXCIgK1xuICAgICAgICAgICAgXCJvdmVyd3JpdHRlbiB3aGVuZXZlciB0aGUgcHJvdmlkZWQgY29tcG9uZW50IHJlLXJlbmRlcnMuIFwiICtcbiAgICAgICAgICAgIFwiaW5qZWN0aW9uIGJlaW5nIG11dGF0ZWQ6IFxcXCJcIiArIGtleSArIFwiXFxcIlwiLFxuICAgICAgICAgICAgdm1cbiAgICAgICAgICApO1xuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGRlZmluZVJlYWN0aXZlKHZtLCBrZXksIHJlc3VsdFtrZXldKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICBvYnNlcnZlclN0YXRlLnNob3VsZENvbnZlcnQgPSB0cnVlO1xuICB9XG59XG5cbmZ1bmN0aW9uIHJlc29sdmVJbmplY3QgKGluamVjdCwgdm0pIHtcbiAgaWYgKGluamVjdCkge1xuICAgIC8vIGluamVjdCBpcyA6YW55IGJlY2F1c2UgZmxvdyBpcyBub3Qgc21hcnQgZW5vdWdoIHRvIGZpZ3VyZSBvdXQgY2FjaGVkXG4gICAgdmFyIHJlc3VsdCA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgdmFyIGtleXMgPSBoYXNTeW1ib2xcbiAgICAgID8gUmVmbGVjdC5vd25LZXlzKGluamVjdCkuZmlsdGVyKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgICAgICAgcmV0dXJuIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoaW5qZWN0LCBrZXkpLmVudW1lcmFibGVcbiAgICAgIH0pXG4gICAgICA6IE9iamVjdC5rZXlzKGluamVjdCk7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBrZXkgPSBrZXlzW2ldO1xuICAgICAgdmFyIHByb3ZpZGVLZXkgPSBpbmplY3Rba2V5XS5mcm9tO1xuICAgICAgdmFyIHNvdXJjZSA9IHZtO1xuICAgICAgd2hpbGUgKHNvdXJjZSkge1xuICAgICAgICBpZiAoc291cmNlLl9wcm92aWRlZCAmJiBwcm92aWRlS2V5IGluIHNvdXJjZS5fcHJvdmlkZWQpIHtcbiAgICAgICAgICByZXN1bHRba2V5XSA9IHNvdXJjZS5fcHJvdmlkZWRbcHJvdmlkZUtleV07XG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgfVxuICAgICAgICBzb3VyY2UgPSBzb3VyY2UuJHBhcmVudDtcbiAgICAgIH1cbiAgICAgIGlmICghc291cmNlKSB7XG4gICAgICAgIGlmICgnZGVmYXVsdCcgaW4gaW5qZWN0W2tleV0pIHtcbiAgICAgICAgICB2YXIgcHJvdmlkZURlZmF1bHQgPSBpbmplY3Rba2V5XS5kZWZhdWx0O1xuICAgICAgICAgIHJlc3VsdFtrZXldID0gdHlwZW9mIHByb3ZpZGVEZWZhdWx0ID09PSAnZnVuY3Rpb24nXG4gICAgICAgICAgICA/IHByb3ZpZGVEZWZhdWx0LmNhbGwodm0pXG4gICAgICAgICAgICA6IHByb3ZpZGVEZWZhdWx0O1xuICAgICAgICB9IGVsc2UgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgICB3YXJuKChcIkluamVjdGlvbiBcXFwiXCIgKyBrZXkgKyBcIlxcXCIgbm90IGZvdW5kXCIpLCB2bSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdFxuICB9XG59XG5cbi8qICAqL1xuXG4vKipcbiAqIFJ1bnRpbWUgaGVscGVyIGZvciByZW5kZXJpbmcgdi1mb3IgbGlzdHMuXG4gKi9cbmZ1bmN0aW9uIHJlbmRlckxpc3QgKFxuICB2YWwsXG4gIHJlbmRlclxuKSB7XG4gIHZhciByZXQsIGksIGwsIGtleXMsIGtleTtcbiAgaWYgKEFycmF5LmlzQXJyYXkodmFsKSB8fCB0eXBlb2YgdmFsID09PSAnc3RyaW5nJykge1xuICAgIHJldCA9IG5ldyBBcnJheSh2YWwubGVuZ3RoKTtcbiAgICBmb3IgKGkgPSAwLCBsID0gdmFsLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgcmV0W2ldID0gcmVuZGVyKHZhbFtpXSwgaSk7XG4gICAgfVxuICB9IGVsc2UgaWYgKHR5cGVvZiB2YWwgPT09ICdudW1iZXInKSB7XG4gICAgcmV0ID0gbmV3IEFycmF5KHZhbCk7XG4gICAgZm9yIChpID0gMDsgaSA8IHZhbDsgaSsrKSB7XG4gICAgICByZXRbaV0gPSByZW5kZXIoaSArIDEsIGkpO1xuICAgIH1cbiAgfSBlbHNlIGlmIChpc09iamVjdCh2YWwpKSB7XG4gICAga2V5cyA9IE9iamVjdC5rZXlzKHZhbCk7XG4gICAgcmV0ID0gbmV3IEFycmF5KGtleXMubGVuZ3RoKTtcbiAgICBmb3IgKGkgPSAwLCBsID0ga2V5cy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgIGtleSA9IGtleXNbaV07XG4gICAgICByZXRbaV0gPSByZW5kZXIodmFsW2tleV0sIGtleSwgaSk7XG4gICAgfVxuICB9XG4gIGlmIChpc0RlZihyZXQpKSB7XG4gICAgKHJldCkuX2lzVkxpc3QgPSB0cnVlO1xuICB9XG4gIHJldHVybiByZXRcbn1cblxuLyogICovXG5cbi8qKlxuICogUnVudGltZSBoZWxwZXIgZm9yIHJlbmRlcmluZyA8c2xvdD5cbiAqL1xuZnVuY3Rpb24gcmVuZGVyU2xvdCAoXG4gIG5hbWUsXG4gIGZhbGxiYWNrLFxuICBwcm9wcyxcbiAgYmluZE9iamVjdFxuKSB7XG4gIHZhciBzY29wZWRTbG90Rm4gPSB0aGlzLiRzY29wZWRTbG90c1tuYW1lXTtcbiAgdmFyIG5vZGVzO1xuICBpZiAoc2NvcGVkU2xvdEZuKSB7IC8vIHNjb3BlZCBzbG90XG4gICAgcHJvcHMgPSBwcm9wcyB8fCB7fTtcbiAgICBpZiAoYmluZE9iamVjdCkge1xuICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgIWlzT2JqZWN0KGJpbmRPYmplY3QpKSB7XG4gICAgICAgIHdhcm4oXG4gICAgICAgICAgJ3Nsb3Qgdi1iaW5kIHdpdGhvdXQgYXJndW1lbnQgZXhwZWN0cyBhbiBPYmplY3QnLFxuICAgICAgICAgIHRoaXNcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIHByb3BzID0gZXh0ZW5kKGV4dGVuZCh7fSwgYmluZE9iamVjdCksIHByb3BzKTtcbiAgICB9XG4gICAgbm9kZXMgPSBzY29wZWRTbG90Rm4ocHJvcHMpIHx8IGZhbGxiYWNrO1xuICB9IGVsc2Uge1xuICAgIHZhciBzbG90Tm9kZXMgPSB0aGlzLiRzbG90c1tuYW1lXTtcbiAgICAvLyB3YXJuIGR1cGxpY2F0ZSBzbG90IHVzYWdlXG4gICAgaWYgKHNsb3ROb2Rlcykge1xuICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgc2xvdE5vZGVzLl9yZW5kZXJlZCkge1xuICAgICAgICB3YXJuKFxuICAgICAgICAgIFwiRHVwbGljYXRlIHByZXNlbmNlIG9mIHNsb3QgXFxcIlwiICsgbmFtZSArIFwiXFxcIiBmb3VuZCBpbiB0aGUgc2FtZSByZW5kZXIgdHJlZSBcIiArXG4gICAgICAgICAgXCItIHRoaXMgd2lsbCBsaWtlbHkgY2F1c2UgcmVuZGVyIGVycm9ycy5cIixcbiAgICAgICAgICB0aGlzXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICBzbG90Tm9kZXMuX3JlbmRlcmVkID0gdHJ1ZTtcbiAgICB9XG4gICAgbm9kZXMgPSBzbG90Tm9kZXMgfHwgZmFsbGJhY2s7XG4gIH1cblxuICB2YXIgdGFyZ2V0ID0gcHJvcHMgJiYgcHJvcHMuc2xvdDtcbiAgaWYgKHRhcmdldCkge1xuICAgIHJldHVybiB0aGlzLiRjcmVhdGVFbGVtZW50KCd0ZW1wbGF0ZScsIHsgc2xvdDogdGFyZ2V0IH0sIG5vZGVzKVxuICB9IGVsc2Uge1xuICAgIHJldHVybiBub2Rlc1xuICB9XG59XG5cbi8qICAqL1xuXG4vKipcbiAqIFJ1bnRpbWUgaGVscGVyIGZvciByZXNvbHZpbmcgZmlsdGVyc1xuICovXG5mdW5jdGlvbiByZXNvbHZlRmlsdGVyIChpZCkge1xuICByZXR1cm4gcmVzb2x2ZUFzc2V0KHRoaXMuJG9wdGlvbnMsICdmaWx0ZXJzJywgaWQsIHRydWUpIHx8IGlkZW50aXR5XG59XG5cbi8qICAqL1xuXG4vKipcbiAqIFJ1bnRpbWUgaGVscGVyIGZvciBjaGVja2luZyBrZXlDb2RlcyBmcm9tIGNvbmZpZy5cbiAqIGV4cG9zZWQgYXMgVnVlLnByb3RvdHlwZS5fa1xuICogcGFzc2luZyBpbiBldmVudEtleU5hbWUgYXMgbGFzdCBhcmd1bWVudCBzZXBhcmF0ZWx5IGZvciBiYWNrd2FyZHMgY29tcGF0XG4gKi9cbmZ1bmN0aW9uIGNoZWNrS2V5Q29kZXMgKFxuICBldmVudEtleUNvZGUsXG4gIGtleSxcbiAgYnVpbHRJbkFsaWFzLFxuICBldmVudEtleU5hbWVcbikge1xuICB2YXIga2V5Q29kZXMgPSBjb25maWcua2V5Q29kZXNba2V5XSB8fCBidWlsdEluQWxpYXM7XG4gIGlmIChrZXlDb2Rlcykge1xuICAgIGlmIChBcnJheS5pc0FycmF5KGtleUNvZGVzKSkge1xuICAgICAgcmV0dXJuIGtleUNvZGVzLmluZGV4T2YoZXZlbnRLZXlDb2RlKSA9PT0gLTFcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIGtleUNvZGVzICE9PSBldmVudEtleUNvZGVcbiAgICB9XG4gIH0gZWxzZSBpZiAoZXZlbnRLZXlOYW1lKSB7XG4gICAgcmV0dXJuIGh5cGhlbmF0ZShldmVudEtleU5hbWUpICE9PSBrZXlcbiAgfVxufVxuXG4vKiAgKi9cblxuLyoqXG4gKiBSdW50aW1lIGhlbHBlciBmb3IgbWVyZ2luZyB2LWJpbmQ9XCJvYmplY3RcIiBpbnRvIGEgVk5vZGUncyBkYXRhLlxuICovXG5mdW5jdGlvbiBiaW5kT2JqZWN0UHJvcHMgKFxuICBkYXRhLFxuICB0YWcsXG4gIHZhbHVlLFxuICBhc1Byb3AsXG4gIGlzU3luY1xuKSB7XG4gIGlmICh2YWx1ZSkge1xuICAgIGlmICghaXNPYmplY3QodmFsdWUpKSB7XG4gICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIHdhcm4oXG4gICAgICAgICd2LWJpbmQgd2l0aG91dCBhcmd1bWVudCBleHBlY3RzIGFuIE9iamVjdCBvciBBcnJheSB2YWx1ZScsXG4gICAgICAgIHRoaXNcbiAgICAgICk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgICAgICB2YWx1ZSA9IHRvT2JqZWN0KHZhbHVlKTtcbiAgICAgIH1cbiAgICAgIHZhciBoYXNoO1xuICAgICAgdmFyIGxvb3AgPSBmdW5jdGlvbiAoIGtleSApIHtcbiAgICAgICAgaWYgKFxuICAgICAgICAgIGtleSA9PT0gJ2NsYXNzJyB8fFxuICAgICAgICAgIGtleSA9PT0gJ3N0eWxlJyB8fFxuICAgICAgICAgIGlzUmVzZXJ2ZWRBdHRyaWJ1dGUoa2V5KVxuICAgICAgICApIHtcbiAgICAgICAgICBoYXNoID0gZGF0YTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2YXIgdHlwZSA9IGRhdGEuYXR0cnMgJiYgZGF0YS5hdHRycy50eXBlO1xuICAgICAgICAgIGhhc2ggPSBhc1Byb3AgfHwgY29uZmlnLm11c3RVc2VQcm9wKHRhZywgdHlwZSwga2V5KVxuICAgICAgICAgICAgPyBkYXRhLmRvbVByb3BzIHx8IChkYXRhLmRvbVByb3BzID0ge30pXG4gICAgICAgICAgICA6IGRhdGEuYXR0cnMgfHwgKGRhdGEuYXR0cnMgPSB7fSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCEoa2V5IGluIGhhc2gpKSB7XG4gICAgICAgICAgaGFzaFtrZXldID0gdmFsdWVba2V5XTtcblxuICAgICAgICAgIGlmIChpc1N5bmMpIHtcbiAgICAgICAgICAgIHZhciBvbiA9IGRhdGEub24gfHwgKGRhdGEub24gPSB7fSk7XG4gICAgICAgICAgICBvblsoXCJ1cGRhdGU6XCIgKyBrZXkpXSA9IGZ1bmN0aW9uICgkZXZlbnQpIHtcbiAgICAgICAgICAgICAgdmFsdWVba2V5XSA9ICRldmVudDtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9O1xuXG4gICAgICBmb3IgKHZhciBrZXkgaW4gdmFsdWUpIGxvb3AoIGtleSApO1xuICAgIH1cbiAgfVxuICByZXR1cm4gZGF0YVxufVxuXG4vKiAgKi9cblxuLyoqXG4gKiBSdW50aW1lIGhlbHBlciBmb3IgcmVuZGVyaW5nIHN0YXRpYyB0cmVlcy5cbiAqL1xuZnVuY3Rpb24gcmVuZGVyU3RhdGljIChcbiAgaW5kZXgsXG4gIGlzSW5Gb3Jcbikge1xuICB2YXIgY2FjaGVkID0gdGhpcy5fc3RhdGljVHJlZXMgfHwgKHRoaXMuX3N0YXRpY1RyZWVzID0gW10pO1xuICB2YXIgdHJlZSA9IGNhY2hlZFtpbmRleF07XG4gIC8vIGlmIGhhcyBhbHJlYWR5LXJlbmRlcmVkIHN0YXRpYyB0cmVlIGFuZCBub3QgaW5zaWRlIHYtZm9yLFxuICAvLyB3ZSBjYW4gcmV1c2UgdGhlIHNhbWUgdHJlZSBieSBkb2luZyBhIHNoYWxsb3cgY2xvbmUuXG4gIGlmICh0cmVlICYmICFpc0luRm9yKSB7XG4gICAgcmV0dXJuIEFycmF5LmlzQXJyYXkodHJlZSlcbiAgICAgID8gY2xvbmVWTm9kZXModHJlZSlcbiAgICAgIDogY2xvbmVWTm9kZSh0cmVlKVxuICB9XG4gIC8vIG90aGVyd2lzZSwgcmVuZGVyIGEgZnJlc2ggdHJlZS5cbiAgdHJlZSA9IGNhY2hlZFtpbmRleF0gPSB0aGlzLiRvcHRpb25zLnN0YXRpY1JlbmRlckZuc1tpbmRleF0uY2FsbChcbiAgICB0aGlzLl9yZW5kZXJQcm94eSxcbiAgICBudWxsLFxuICAgIHRoaXMgLy8gZm9yIHJlbmRlciBmbnMgZ2VuZXJhdGVkIGZvciBmdW5jdGlvbmFsIGNvbXBvbmVudCB0ZW1wbGF0ZXNcbiAgKTtcbiAgbWFya1N0YXRpYyh0cmVlLCAoXCJfX3N0YXRpY19fXCIgKyBpbmRleCksIGZhbHNlKTtcbiAgcmV0dXJuIHRyZWVcbn1cblxuLyoqXG4gKiBSdW50aW1lIGhlbHBlciBmb3Igdi1vbmNlLlxuICogRWZmZWN0aXZlbHkgaXQgbWVhbnMgbWFya2luZyB0aGUgbm9kZSBhcyBzdGF0aWMgd2l0aCBhIHVuaXF1ZSBrZXkuXG4gKi9cbmZ1bmN0aW9uIG1hcmtPbmNlIChcbiAgdHJlZSxcbiAgaW5kZXgsXG4gIGtleVxuKSB7XG4gIG1hcmtTdGF0aWModHJlZSwgKFwiX19vbmNlX19cIiArIGluZGV4ICsgKGtleSA/IChcIl9cIiArIGtleSkgOiBcIlwiKSksIHRydWUpO1xuICByZXR1cm4gdHJlZVxufVxuXG5mdW5jdGlvbiBtYXJrU3RhdGljIChcbiAgdHJlZSxcbiAga2V5LFxuICBpc09uY2Vcbikge1xuICBpZiAoQXJyYXkuaXNBcnJheSh0cmVlKSkge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdHJlZS5sZW5ndGg7IGkrKykge1xuICAgICAgaWYgKHRyZWVbaV0gJiYgdHlwZW9mIHRyZWVbaV0gIT09ICdzdHJpbmcnKSB7XG4gICAgICAgIG1hcmtTdGF0aWNOb2RlKHRyZWVbaV0sIChrZXkgKyBcIl9cIiArIGkpLCBpc09uY2UpO1xuICAgICAgfVxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBtYXJrU3RhdGljTm9kZSh0cmVlLCBrZXksIGlzT25jZSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gbWFya1N0YXRpY05vZGUgKG5vZGUsIGtleSwgaXNPbmNlKSB7XG4gIG5vZGUuaXNTdGF0aWMgPSB0cnVlO1xuICBub2RlLmtleSA9IGtleTtcbiAgbm9kZS5pc09uY2UgPSBpc09uY2U7XG59XG5cbi8qICAqL1xuXG5mdW5jdGlvbiBiaW5kT2JqZWN0TGlzdGVuZXJzIChkYXRhLCB2YWx1ZSkge1xuICBpZiAodmFsdWUpIHtcbiAgICBpZiAoIWlzUGxhaW5PYmplY3QodmFsdWUpKSB7XG4gICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIHdhcm4oXG4gICAgICAgICd2LW9uIHdpdGhvdXQgYXJndW1lbnQgZXhwZWN0cyBhbiBPYmplY3QgdmFsdWUnLFxuICAgICAgICB0aGlzXG4gICAgICApO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgb24gPSBkYXRhLm9uID0gZGF0YS5vbiA/IGV4dGVuZCh7fSwgZGF0YS5vbikgOiB7fTtcbiAgICAgIGZvciAodmFyIGtleSBpbiB2YWx1ZSkge1xuICAgICAgICB2YXIgZXhpc3RpbmcgPSBvbltrZXldO1xuICAgICAgICB2YXIgb3VycyA9IHZhbHVlW2tleV07XG4gICAgICAgIG9uW2tleV0gPSBleGlzdGluZyA/IFtdLmNvbmNhdChleGlzdGluZywgb3VycykgOiBvdXJzO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gZGF0YVxufVxuXG4vKiAgKi9cblxuZnVuY3Rpb24gaW5zdGFsbFJlbmRlckhlbHBlcnMgKHRhcmdldCkge1xuICB0YXJnZXQuX28gPSBtYXJrT25jZTtcbiAgdGFyZ2V0Ll9uID0gdG9OdW1iZXI7XG4gIHRhcmdldC5fcyA9IHRvU3RyaW5nO1xuICB0YXJnZXQuX2wgPSByZW5kZXJMaXN0O1xuICB0YXJnZXQuX3QgPSByZW5kZXJTbG90O1xuICB0YXJnZXQuX3EgPSBsb29zZUVxdWFsO1xuICB0YXJnZXQuX2kgPSBsb29zZUluZGV4T2Y7XG4gIHRhcmdldC5fbSA9IHJlbmRlclN0YXRpYztcbiAgdGFyZ2V0Ll9mID0gcmVzb2x2ZUZpbHRlcjtcbiAgdGFyZ2V0Ll9rID0gY2hlY2tLZXlDb2RlcztcbiAgdGFyZ2V0Ll9iID0gYmluZE9iamVjdFByb3BzO1xuICB0YXJnZXQuX3YgPSBjcmVhdGVUZXh0Vk5vZGU7XG4gIHRhcmdldC5fZSA9IGNyZWF0ZUVtcHR5Vk5vZGU7XG4gIHRhcmdldC5fdSA9IHJlc29sdmVTY29wZWRTbG90cztcbiAgdGFyZ2V0Ll9nID0gYmluZE9iamVjdExpc3RlbmVycztcbn1cblxuLyogICovXG5cbmZ1bmN0aW9uIEZ1bmN0aW9uYWxSZW5kZXJDb250ZXh0IChcbiAgZGF0YSxcbiAgcHJvcHMsXG4gIGNoaWxkcmVuLFxuICBwYXJlbnQsXG4gIEN0b3Jcbikge1xuICB2YXIgb3B0aW9ucyA9IEN0b3Iub3B0aW9ucztcbiAgdGhpcy5kYXRhID0gZGF0YTtcbiAgdGhpcy5wcm9wcyA9IHByb3BzO1xuICB0aGlzLmNoaWxkcmVuID0gY2hpbGRyZW47XG4gIHRoaXMucGFyZW50ID0gcGFyZW50O1xuICB0aGlzLmxpc3RlbmVycyA9IGRhdGEub24gfHwgZW1wdHlPYmplY3Q7XG4gIHRoaXMuaW5qZWN0aW9ucyA9IHJlc29sdmVJbmplY3Qob3B0aW9ucy5pbmplY3QsIHBhcmVudCk7XG4gIHRoaXMuc2xvdHMgPSBmdW5jdGlvbiAoKSB7IHJldHVybiByZXNvbHZlU2xvdHMoY2hpbGRyZW4sIHBhcmVudCk7IH07XG5cbiAgLy8gZW5zdXJlIHRoZSBjcmVhdGVFbGVtZW50IGZ1bmN0aW9uIGluIGZ1bmN0aW9uYWwgY29tcG9uZW50c1xuICAvLyBnZXRzIGEgdW5pcXVlIGNvbnRleHQgLSB0aGlzIGlzIG5lY2Vzc2FyeSBmb3IgY29ycmVjdCBuYW1lZCBzbG90IGNoZWNrXG4gIHZhciBjb250ZXh0Vm0gPSBPYmplY3QuY3JlYXRlKHBhcmVudCk7XG4gIHZhciBpc0NvbXBpbGVkID0gaXNUcnVlKG9wdGlvbnMuX2NvbXBpbGVkKTtcbiAgdmFyIG5lZWROb3JtYWxpemF0aW9uID0gIWlzQ29tcGlsZWQ7XG5cbiAgLy8gc3VwcG9ydCBmb3IgY29tcGlsZWQgZnVuY3Rpb25hbCB0ZW1wbGF0ZVxuICBpZiAoaXNDb21waWxlZCkge1xuICAgIC8vIGV4cG9zaW5nICRvcHRpb25zIGZvciByZW5kZXJTdGF0aWMoKVxuICAgIHRoaXMuJG9wdGlvbnMgPSBvcHRpb25zO1xuICAgIC8vIHByZS1yZXNvbHZlIHNsb3RzIGZvciByZW5kZXJTbG90KClcbiAgICB0aGlzLiRzbG90cyA9IHRoaXMuc2xvdHMoKTtcbiAgICB0aGlzLiRzY29wZWRTbG90cyA9IGRhdGEuc2NvcGVkU2xvdHMgfHwgZW1wdHlPYmplY3Q7XG4gIH1cblxuICBpZiAob3B0aW9ucy5fc2NvcGVJZCkge1xuICAgIHRoaXMuX2MgPSBmdW5jdGlvbiAoYSwgYiwgYywgZCkge1xuICAgICAgdmFyIHZub2RlID0gY3JlYXRlRWxlbWVudChjb250ZXh0Vm0sIGEsIGIsIGMsIGQsIG5lZWROb3JtYWxpemF0aW9uKTtcbiAgICAgIGlmICh2bm9kZSkge1xuICAgICAgICB2bm9kZS5mblNjb3BlSWQgPSBvcHRpb25zLl9zY29wZUlkO1xuICAgICAgICB2bm9kZS5mbkNvbnRleHQgPSBwYXJlbnQ7XG4gICAgICB9XG4gICAgICByZXR1cm4gdm5vZGVcbiAgICB9O1xuICB9IGVsc2Uge1xuICAgIHRoaXMuX2MgPSBmdW5jdGlvbiAoYSwgYiwgYywgZCkgeyByZXR1cm4gY3JlYXRlRWxlbWVudChjb250ZXh0Vm0sIGEsIGIsIGMsIGQsIG5lZWROb3JtYWxpemF0aW9uKTsgfTtcbiAgfVxufVxuXG5pbnN0YWxsUmVuZGVySGVscGVycyhGdW5jdGlvbmFsUmVuZGVyQ29udGV4dC5wcm90b3R5cGUpO1xuXG5mdW5jdGlvbiBjcmVhdGVGdW5jdGlvbmFsQ29tcG9uZW50IChcbiAgQ3RvcixcbiAgcHJvcHNEYXRhLFxuICBkYXRhLFxuICBjb250ZXh0Vm0sXG4gIGNoaWxkcmVuXG4pIHtcbiAgdmFyIG9wdGlvbnMgPSBDdG9yLm9wdGlvbnM7XG4gIHZhciBwcm9wcyA9IHt9O1xuICB2YXIgcHJvcE9wdGlvbnMgPSBvcHRpb25zLnByb3BzO1xuICBpZiAoaXNEZWYocHJvcE9wdGlvbnMpKSB7XG4gICAgZm9yICh2YXIga2V5IGluIHByb3BPcHRpb25zKSB7XG4gICAgICBwcm9wc1trZXldID0gdmFsaWRhdGVQcm9wKGtleSwgcHJvcE9wdGlvbnMsIHByb3BzRGF0YSB8fCBlbXB0eU9iamVjdCk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGlmIChpc0RlZihkYXRhLmF0dHJzKSkgeyBtZXJnZVByb3BzKHByb3BzLCBkYXRhLmF0dHJzKTsgfVxuICAgIGlmIChpc0RlZihkYXRhLnByb3BzKSkgeyBtZXJnZVByb3BzKHByb3BzLCBkYXRhLnByb3BzKTsgfVxuICB9XG5cbiAgdmFyIHJlbmRlckNvbnRleHQgPSBuZXcgRnVuY3Rpb25hbFJlbmRlckNvbnRleHQoXG4gICAgZGF0YSxcbiAgICBwcm9wcyxcbiAgICBjaGlsZHJlbixcbiAgICBjb250ZXh0Vm0sXG4gICAgQ3RvclxuICApO1xuXG4gIHZhciB2bm9kZSA9IG9wdGlvbnMucmVuZGVyLmNhbGwobnVsbCwgcmVuZGVyQ29udGV4dC5fYywgcmVuZGVyQ29udGV4dCk7XG5cbiAgaWYgKHZub2RlIGluc3RhbmNlb2YgVk5vZGUpIHtcbiAgICB2bm9kZS5mbkNvbnRleHQgPSBjb250ZXh0Vm07XG4gICAgdm5vZGUuZm5PcHRpb25zID0gb3B0aW9ucztcbiAgICBpZiAoZGF0YS5zbG90KSB7XG4gICAgICAodm5vZGUuZGF0YSB8fCAodm5vZGUuZGF0YSA9IHt9KSkuc2xvdCA9IGRhdGEuc2xvdDtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gdm5vZGVcbn1cblxuZnVuY3Rpb24gbWVyZ2VQcm9wcyAodG8sIGZyb20pIHtcbiAgZm9yICh2YXIga2V5IGluIGZyb20pIHtcbiAgICB0b1tjYW1lbGl6ZShrZXkpXSA9IGZyb21ba2V5XTtcbiAgfVxufVxuXG4vKiAgKi9cblxuLy8gaG9va3MgdG8gYmUgaW52b2tlZCBvbiBjb21wb25lbnQgVk5vZGVzIGR1cmluZyBwYXRjaFxudmFyIGNvbXBvbmVudFZOb2RlSG9va3MgPSB7XG4gIGluaXQ6IGZ1bmN0aW9uIGluaXQgKFxuICAgIHZub2RlLFxuICAgIGh5ZHJhdGluZyxcbiAgICBwYXJlbnRFbG0sXG4gICAgcmVmRWxtXG4gICkge1xuICAgIGlmICghdm5vZGUuY29tcG9uZW50SW5zdGFuY2UgfHwgdm5vZGUuY29tcG9uZW50SW5zdGFuY2UuX2lzRGVzdHJveWVkKSB7XG4gICAgICB2YXIgY2hpbGQgPSB2bm9kZS5jb21wb25lbnRJbnN0YW5jZSA9IGNyZWF0ZUNvbXBvbmVudEluc3RhbmNlRm9yVm5vZGUoXG4gICAgICAgIHZub2RlLFxuICAgICAgICBhY3RpdmVJbnN0YW5jZSxcbiAgICAgICAgcGFyZW50RWxtLFxuICAgICAgICByZWZFbG1cbiAgICAgICk7XG4gICAgICBjaGlsZC4kbW91bnQoaHlkcmF0aW5nID8gdm5vZGUuZWxtIDogdW5kZWZpbmVkLCBoeWRyYXRpbmcpO1xuICAgIH0gZWxzZSBpZiAodm5vZGUuZGF0YS5rZWVwQWxpdmUpIHtcbiAgICAgIC8vIGtlcHQtYWxpdmUgY29tcG9uZW50cywgdHJlYXQgYXMgYSBwYXRjaFxuICAgICAgdmFyIG1vdW50ZWROb2RlID0gdm5vZGU7IC8vIHdvcmsgYXJvdW5kIGZsb3dcbiAgICAgIGNvbXBvbmVudFZOb2RlSG9va3MucHJlcGF0Y2gobW91bnRlZE5vZGUsIG1vdW50ZWROb2RlKTtcbiAgICB9XG4gIH0sXG5cbiAgcHJlcGF0Y2g6IGZ1bmN0aW9uIHByZXBhdGNoIChvbGRWbm9kZSwgdm5vZGUpIHtcbiAgICB2YXIgb3B0aW9ucyA9IHZub2RlLmNvbXBvbmVudE9wdGlvbnM7XG4gICAgdmFyIGNoaWxkID0gdm5vZGUuY29tcG9uZW50SW5zdGFuY2UgPSBvbGRWbm9kZS5jb21wb25lbnRJbnN0YW5jZTtcbiAgICB1cGRhdGVDaGlsZENvbXBvbmVudChcbiAgICAgIGNoaWxkLFxuICAgICAgb3B0aW9ucy5wcm9wc0RhdGEsIC8vIHVwZGF0ZWQgcHJvcHNcbiAgICAgIG9wdGlvbnMubGlzdGVuZXJzLCAvLyB1cGRhdGVkIGxpc3RlbmVyc1xuICAgICAgdm5vZGUsIC8vIG5ldyBwYXJlbnQgdm5vZGVcbiAgICAgIG9wdGlvbnMuY2hpbGRyZW4gLy8gbmV3IGNoaWxkcmVuXG4gICAgKTtcbiAgfSxcblxuICBpbnNlcnQ6IGZ1bmN0aW9uIGluc2VydCAodm5vZGUpIHtcbiAgICB2YXIgY29udGV4dCA9IHZub2RlLmNvbnRleHQ7XG4gICAgdmFyIGNvbXBvbmVudEluc3RhbmNlID0gdm5vZGUuY29tcG9uZW50SW5zdGFuY2U7XG4gICAgaWYgKCFjb21wb25lbnRJbnN0YW5jZS5faXNNb3VudGVkKSB7XG4gICAgICBjb21wb25lbnRJbnN0YW5jZS5faXNNb3VudGVkID0gdHJ1ZTtcbiAgICAgIGNhbGxIb29rKGNvbXBvbmVudEluc3RhbmNlLCAnbW91bnRlZCcpO1xuICAgIH1cbiAgICBpZiAodm5vZGUuZGF0YS5rZWVwQWxpdmUpIHtcbiAgICAgIGlmIChjb250ZXh0Ll9pc01vdW50ZWQpIHtcbiAgICAgICAgLy8gdnVlLXJvdXRlciMxMjEyXG4gICAgICAgIC8vIER1cmluZyB1cGRhdGVzLCBhIGtlcHQtYWxpdmUgY29tcG9uZW50J3MgY2hpbGQgY29tcG9uZW50cyBtYXlcbiAgICAgICAgLy8gY2hhbmdlLCBzbyBkaXJlY3RseSB3YWxraW5nIHRoZSB0cmVlIGhlcmUgbWF5IGNhbGwgYWN0aXZhdGVkIGhvb2tzXG4gICAgICAgIC8vIG9uIGluY29ycmVjdCBjaGlsZHJlbi4gSW5zdGVhZCB3ZSBwdXNoIHRoZW0gaW50byBhIHF1ZXVlIHdoaWNoIHdpbGxcbiAgICAgICAgLy8gYmUgcHJvY2Vzc2VkIGFmdGVyIHRoZSB3aG9sZSBwYXRjaCBwcm9jZXNzIGVuZGVkLlxuICAgICAgICBxdWV1ZUFjdGl2YXRlZENvbXBvbmVudChjb21wb25lbnRJbnN0YW5jZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBhY3RpdmF0ZUNoaWxkQ29tcG9uZW50KGNvbXBvbmVudEluc3RhbmNlLCB0cnVlIC8qIGRpcmVjdCAqLyk7XG4gICAgICB9XG4gICAgfVxuICB9LFxuXG4gIGRlc3Ryb3k6IGZ1bmN0aW9uIGRlc3Ryb3kgKHZub2RlKSB7XG4gICAgdmFyIGNvbXBvbmVudEluc3RhbmNlID0gdm5vZGUuY29tcG9uZW50SW5zdGFuY2U7XG4gICAgaWYgKCFjb21wb25lbnRJbnN0YW5jZS5faXNEZXN0cm95ZWQpIHtcbiAgICAgIGlmICghdm5vZGUuZGF0YS5rZWVwQWxpdmUpIHtcbiAgICAgICAgY29tcG9uZW50SW5zdGFuY2UuJGRlc3Ryb3koKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGRlYWN0aXZhdGVDaGlsZENvbXBvbmVudChjb21wb25lbnRJbnN0YW5jZSwgdHJ1ZSAvKiBkaXJlY3QgKi8pO1xuICAgICAgfVxuICAgIH1cbiAgfVxufTtcblxudmFyIGhvb2tzVG9NZXJnZSA9IE9iamVjdC5rZXlzKGNvbXBvbmVudFZOb2RlSG9va3MpO1xuXG5mdW5jdGlvbiBjcmVhdGVDb21wb25lbnQgKFxuICBDdG9yLFxuICBkYXRhLFxuICBjb250ZXh0LFxuICBjaGlsZHJlbixcbiAgdGFnXG4pIHtcbiAgaWYgKGlzVW5kZWYoQ3RvcikpIHtcbiAgICByZXR1cm5cbiAgfVxuXG4gIHZhciBiYXNlQ3RvciA9IGNvbnRleHQuJG9wdGlvbnMuX2Jhc2U7XG5cbiAgLy8gcGxhaW4gb3B0aW9ucyBvYmplY3Q6IHR1cm4gaXQgaW50byBhIGNvbnN0cnVjdG9yXG4gIGlmIChpc09iamVjdChDdG9yKSkge1xuICAgIEN0b3IgPSBiYXNlQ3Rvci5leHRlbmQoQ3Rvcik7XG4gIH1cblxuICAvLyBpZiBhdCB0aGlzIHN0YWdlIGl0J3Mgbm90IGEgY29uc3RydWN0b3Igb3IgYW4gYXN5bmMgY29tcG9uZW50IGZhY3RvcnksXG4gIC8vIHJlamVjdC5cbiAgaWYgKHR5cGVvZiBDdG9yICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIHdhcm4oKFwiSW52YWxpZCBDb21wb25lbnQgZGVmaW5pdGlvbjogXCIgKyAoU3RyaW5nKEN0b3IpKSksIGNvbnRleHQpO1xuICAgIH1cbiAgICByZXR1cm5cbiAgfVxuXG4gIC8vIGFzeW5jIGNvbXBvbmVudFxuICB2YXIgYXN5bmNGYWN0b3J5O1xuICBpZiAoaXNVbmRlZihDdG9yLmNpZCkpIHtcbiAgICBhc3luY0ZhY3RvcnkgPSBDdG9yO1xuICAgIEN0b3IgPSByZXNvbHZlQXN5bmNDb21wb25lbnQoYXN5bmNGYWN0b3J5LCBiYXNlQ3RvciwgY29udGV4dCk7XG4gICAgaWYgKEN0b3IgPT09IHVuZGVmaW5lZCkge1xuICAgICAgLy8gcmV0dXJuIGEgcGxhY2Vob2xkZXIgbm9kZSBmb3IgYXN5bmMgY29tcG9uZW50LCB3aGljaCBpcyByZW5kZXJlZFxuICAgICAgLy8gYXMgYSBjb21tZW50IG5vZGUgYnV0IHByZXNlcnZlcyBhbGwgdGhlIHJhdyBpbmZvcm1hdGlvbiBmb3IgdGhlIG5vZGUuXG4gICAgICAvLyB0aGUgaW5mb3JtYXRpb24gd2lsbCBiZSB1c2VkIGZvciBhc3luYyBzZXJ2ZXItcmVuZGVyaW5nIGFuZCBoeWRyYXRpb24uXG4gICAgICByZXR1cm4gY3JlYXRlQXN5bmNQbGFjZWhvbGRlcihcbiAgICAgICAgYXN5bmNGYWN0b3J5LFxuICAgICAgICBkYXRhLFxuICAgICAgICBjb250ZXh0LFxuICAgICAgICBjaGlsZHJlbixcbiAgICAgICAgdGFnXG4gICAgICApXG4gICAgfVxuICB9XG5cbiAgZGF0YSA9IGRhdGEgfHwge307XG5cbiAgLy8gcmVzb2x2ZSBjb25zdHJ1Y3RvciBvcHRpb25zIGluIGNhc2UgZ2xvYmFsIG1peGlucyBhcmUgYXBwbGllZCBhZnRlclxuICAvLyBjb21wb25lbnQgY29uc3RydWN0b3IgY3JlYXRpb25cbiAgcmVzb2x2ZUNvbnN0cnVjdG9yT3B0aW9ucyhDdG9yKTtcblxuICAvLyB0cmFuc2Zvcm0gY29tcG9uZW50IHYtbW9kZWwgZGF0YSBpbnRvIHByb3BzICYgZXZlbnRzXG4gIGlmIChpc0RlZihkYXRhLm1vZGVsKSkge1xuICAgIHRyYW5zZm9ybU1vZGVsKEN0b3Iub3B0aW9ucywgZGF0YSk7XG4gIH1cblxuICAvLyBleHRyYWN0IHByb3BzXG4gIHZhciBwcm9wc0RhdGEgPSBleHRyYWN0UHJvcHNGcm9tVk5vZGVEYXRhKGRhdGEsIEN0b3IsIHRhZyk7XG5cbiAgLy8gZnVuY3Rpb25hbCBjb21wb25lbnRcbiAgaWYgKGlzVHJ1ZShDdG9yLm9wdGlvbnMuZnVuY3Rpb25hbCkpIHtcbiAgICByZXR1cm4gY3JlYXRlRnVuY3Rpb25hbENvbXBvbmVudChDdG9yLCBwcm9wc0RhdGEsIGRhdGEsIGNvbnRleHQsIGNoaWxkcmVuKVxuICB9XG5cbiAgLy8gZXh0cmFjdCBsaXN0ZW5lcnMsIHNpbmNlIHRoZXNlIG5lZWRzIHRvIGJlIHRyZWF0ZWQgYXNcbiAgLy8gY2hpbGQgY29tcG9uZW50IGxpc3RlbmVycyBpbnN0ZWFkIG9mIERPTSBsaXN0ZW5lcnNcbiAgdmFyIGxpc3RlbmVycyA9IGRhdGEub247XG4gIC8vIHJlcGxhY2Ugd2l0aCBsaXN0ZW5lcnMgd2l0aCAubmF0aXZlIG1vZGlmaWVyXG4gIC8vIHNvIGl0IGdldHMgcHJvY2Vzc2VkIGR1cmluZyBwYXJlbnQgY29tcG9uZW50IHBhdGNoLlxuICBkYXRhLm9uID0gZGF0YS5uYXRpdmVPbjtcblxuICBpZiAoaXNUcnVlKEN0b3Iub3B0aW9ucy5hYnN0cmFjdCkpIHtcbiAgICAvLyBhYnN0cmFjdCBjb21wb25lbnRzIGRvIG5vdCBrZWVwIGFueXRoaW5nXG4gICAgLy8gb3RoZXIgdGhhbiBwcm9wcyAmIGxpc3RlbmVycyAmIHNsb3RcblxuICAgIC8vIHdvcmsgYXJvdW5kIGZsb3dcbiAgICB2YXIgc2xvdCA9IGRhdGEuc2xvdDtcbiAgICBkYXRhID0ge307XG4gICAgaWYgKHNsb3QpIHtcbiAgICAgIGRhdGEuc2xvdCA9IHNsb3Q7XG4gICAgfVxuICB9XG5cbiAgLy8gbWVyZ2UgY29tcG9uZW50IG1hbmFnZW1lbnQgaG9va3Mgb250byB0aGUgcGxhY2Vob2xkZXIgbm9kZVxuICBtZXJnZUhvb2tzKGRhdGEpO1xuXG4gIC8vIHJldHVybiBhIHBsYWNlaG9sZGVyIHZub2RlXG4gIHZhciBuYW1lID0gQ3Rvci5vcHRpb25zLm5hbWUgfHwgdGFnO1xuICB2YXIgdm5vZGUgPSBuZXcgVk5vZGUoXG4gICAgKFwidnVlLWNvbXBvbmVudC1cIiArIChDdG9yLmNpZCkgKyAobmFtZSA/IChcIi1cIiArIG5hbWUpIDogJycpKSxcbiAgICBkYXRhLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCBjb250ZXh0LFxuICAgIHsgQ3RvcjogQ3RvciwgcHJvcHNEYXRhOiBwcm9wc0RhdGEsIGxpc3RlbmVyczogbGlzdGVuZXJzLCB0YWc6IHRhZywgY2hpbGRyZW46IGNoaWxkcmVuIH0sXG4gICAgYXN5bmNGYWN0b3J5XG4gICk7XG4gIHJldHVybiB2bm9kZVxufVxuXG5mdW5jdGlvbiBjcmVhdGVDb21wb25lbnRJbnN0YW5jZUZvclZub2RlIChcbiAgdm5vZGUsIC8vIHdlIGtub3cgaXQncyBNb3VudGVkQ29tcG9uZW50Vk5vZGUgYnV0IGZsb3cgZG9lc24ndFxuICBwYXJlbnQsIC8vIGFjdGl2ZUluc3RhbmNlIGluIGxpZmVjeWNsZSBzdGF0ZVxuICBwYXJlbnRFbG0sXG4gIHJlZkVsbVxuKSB7XG4gIHZhciBvcHRpb25zID0ge1xuICAgIF9pc0NvbXBvbmVudDogdHJ1ZSxcbiAgICBwYXJlbnQ6IHBhcmVudCxcbiAgICBfcGFyZW50Vm5vZGU6IHZub2RlLFxuICAgIF9wYXJlbnRFbG06IHBhcmVudEVsbSB8fCBudWxsLFxuICAgIF9yZWZFbG06IHJlZkVsbSB8fCBudWxsXG4gIH07XG4gIC8vIGNoZWNrIGlubGluZS10ZW1wbGF0ZSByZW5kZXIgZnVuY3Rpb25zXG4gIHZhciBpbmxpbmVUZW1wbGF0ZSA9IHZub2RlLmRhdGEuaW5saW5lVGVtcGxhdGU7XG4gIGlmIChpc0RlZihpbmxpbmVUZW1wbGF0ZSkpIHtcbiAgICBvcHRpb25zLnJlbmRlciA9IGlubGluZVRlbXBsYXRlLnJlbmRlcjtcbiAgICBvcHRpb25zLnN0YXRpY1JlbmRlckZucyA9IGlubGluZVRlbXBsYXRlLnN0YXRpY1JlbmRlckZucztcbiAgfVxuICByZXR1cm4gbmV3IHZub2RlLmNvbXBvbmVudE9wdGlvbnMuQ3RvcihvcHRpb25zKVxufVxuXG5mdW5jdGlvbiBtZXJnZUhvb2tzIChkYXRhKSB7XG4gIGlmICghZGF0YS5ob29rKSB7XG4gICAgZGF0YS5ob29rID0ge307XG4gIH1cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBob29rc1RvTWVyZ2UubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIga2V5ID0gaG9va3NUb01lcmdlW2ldO1xuICAgIHZhciBmcm9tUGFyZW50ID0gZGF0YS5ob29rW2tleV07XG4gICAgdmFyIG91cnMgPSBjb21wb25lbnRWTm9kZUhvb2tzW2tleV07XG4gICAgZGF0YS5ob29rW2tleV0gPSBmcm9tUGFyZW50ID8gbWVyZ2VIb29rJDEob3VycywgZnJvbVBhcmVudCkgOiBvdXJzO1xuICB9XG59XG5cbmZ1bmN0aW9uIG1lcmdlSG9vayQxIChvbmUsIHR3bykge1xuICByZXR1cm4gZnVuY3Rpb24gKGEsIGIsIGMsIGQpIHtcbiAgICBvbmUoYSwgYiwgYywgZCk7XG4gICAgdHdvKGEsIGIsIGMsIGQpO1xuICB9XG59XG5cbi8vIHRyYW5zZm9ybSBjb21wb25lbnQgdi1tb2RlbCBpbmZvICh2YWx1ZSBhbmQgY2FsbGJhY2spIGludG9cbi8vIHByb3AgYW5kIGV2ZW50IGhhbmRsZXIgcmVzcGVjdGl2ZWx5LlxuZnVuY3Rpb24gdHJhbnNmb3JtTW9kZWwgKG9wdGlvbnMsIGRhdGEpIHtcbiAgdmFyIHByb3AgPSAob3B0aW9ucy5tb2RlbCAmJiBvcHRpb25zLm1vZGVsLnByb3ApIHx8ICd2YWx1ZSc7XG4gIHZhciBldmVudCA9IChvcHRpb25zLm1vZGVsICYmIG9wdGlvbnMubW9kZWwuZXZlbnQpIHx8ICdpbnB1dCc7KGRhdGEucHJvcHMgfHwgKGRhdGEucHJvcHMgPSB7fSkpW3Byb3BdID0gZGF0YS5tb2RlbC52YWx1ZTtcbiAgdmFyIG9uID0gZGF0YS5vbiB8fCAoZGF0YS5vbiA9IHt9KTtcbiAgaWYgKGlzRGVmKG9uW2V2ZW50XSkpIHtcbiAgICBvbltldmVudF0gPSBbZGF0YS5tb2RlbC5jYWxsYmFja10uY29uY2F0KG9uW2V2ZW50XSk7XG4gIH0gZWxzZSB7XG4gICAgb25bZXZlbnRdID0gZGF0YS5tb2RlbC5jYWxsYmFjaztcbiAgfVxufVxuXG4vKiAgKi9cblxudmFyIFNJTVBMRV9OT1JNQUxJWkUgPSAxO1xudmFyIEFMV0FZU19OT1JNQUxJWkUgPSAyO1xuXG4vLyB3cmFwcGVyIGZ1bmN0aW9uIGZvciBwcm92aWRpbmcgYSBtb3JlIGZsZXhpYmxlIGludGVyZmFjZVxuLy8gd2l0aG91dCBnZXR0aW5nIHllbGxlZCBhdCBieSBmbG93XG5mdW5jdGlvbiBjcmVhdGVFbGVtZW50IChcbiAgY29udGV4dCxcbiAgdGFnLFxuICBkYXRhLFxuICBjaGlsZHJlbixcbiAgbm9ybWFsaXphdGlvblR5cGUsXG4gIGFsd2F5c05vcm1hbGl6ZVxuKSB7XG4gIGlmIChBcnJheS5pc0FycmF5KGRhdGEpIHx8IGlzUHJpbWl0aXZlKGRhdGEpKSB7XG4gICAgbm9ybWFsaXphdGlvblR5cGUgPSBjaGlsZHJlbjtcbiAgICBjaGlsZHJlbiA9IGRhdGE7XG4gICAgZGF0YSA9IHVuZGVmaW5lZDtcbiAgfVxuICBpZiAoaXNUcnVlKGFsd2F5c05vcm1hbGl6ZSkpIHtcbiAgICBub3JtYWxpemF0aW9uVHlwZSA9IEFMV0FZU19OT1JNQUxJWkU7XG4gIH1cbiAgcmV0dXJuIF9jcmVhdGVFbGVtZW50KGNvbnRleHQsIHRhZywgZGF0YSwgY2hpbGRyZW4sIG5vcm1hbGl6YXRpb25UeXBlKVxufVxuXG5mdW5jdGlvbiBfY3JlYXRlRWxlbWVudCAoXG4gIGNvbnRleHQsXG4gIHRhZyxcbiAgZGF0YSxcbiAgY2hpbGRyZW4sXG4gIG5vcm1hbGl6YXRpb25UeXBlXG4pIHtcbiAgaWYgKGlzRGVmKGRhdGEpICYmIGlzRGVmKChkYXRhKS5fX29iX18pKSB7XG4gICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiB3YXJuKFxuICAgICAgXCJBdm9pZCB1c2luZyBvYnNlcnZlZCBkYXRhIG9iamVjdCBhcyB2bm9kZSBkYXRhOiBcIiArIChKU09OLnN0cmluZ2lmeShkYXRhKSkgKyBcIlxcblwiICtcbiAgICAgICdBbHdheXMgY3JlYXRlIGZyZXNoIHZub2RlIGRhdGEgb2JqZWN0cyBpbiBlYWNoIHJlbmRlciEnLFxuICAgICAgY29udGV4dFxuICAgICk7XG4gICAgcmV0dXJuIGNyZWF0ZUVtcHR5Vk5vZGUoKVxuICB9XG4gIC8vIG9iamVjdCBzeW50YXggaW4gdi1iaW5kXG4gIGlmIChpc0RlZihkYXRhKSAmJiBpc0RlZihkYXRhLmlzKSkge1xuICAgIHRhZyA9IGRhdGEuaXM7XG4gIH1cbiAgaWYgKCF0YWcpIHtcbiAgICAvLyBpbiBjYXNlIG9mIGNvbXBvbmVudCA6aXMgc2V0IHRvIGZhbHN5IHZhbHVlXG4gICAgcmV0dXJuIGNyZWF0ZUVtcHR5Vk5vZGUoKVxuICB9XG4gIC8vIHdhcm4gYWdhaW5zdCBub24tcHJpbWl0aXZlIGtleVxuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJlxuICAgIGlzRGVmKGRhdGEpICYmIGlzRGVmKGRhdGEua2V5KSAmJiAhaXNQcmltaXRpdmUoZGF0YS5rZXkpXG4gICkge1xuICAgIHdhcm4oXG4gICAgICAnQXZvaWQgdXNpbmcgbm9uLXByaW1pdGl2ZSB2YWx1ZSBhcyBrZXksICcgK1xuICAgICAgJ3VzZSBzdHJpbmcvbnVtYmVyIHZhbHVlIGluc3RlYWQuJyxcbiAgICAgIGNvbnRleHRcbiAgICApO1xuICB9XG4gIC8vIHN1cHBvcnQgc2luZ2xlIGZ1bmN0aW9uIGNoaWxkcmVuIGFzIGRlZmF1bHQgc2NvcGVkIHNsb3RcbiAgaWYgKEFycmF5LmlzQXJyYXkoY2hpbGRyZW4pICYmXG4gICAgdHlwZW9mIGNoaWxkcmVuWzBdID09PSAnZnVuY3Rpb24nXG4gICkge1xuICAgIGRhdGEgPSBkYXRhIHx8IHt9O1xuICAgIGRhdGEuc2NvcGVkU2xvdHMgPSB7IGRlZmF1bHQ6IGNoaWxkcmVuWzBdIH07XG4gICAgY2hpbGRyZW4ubGVuZ3RoID0gMDtcbiAgfVxuICBpZiAobm9ybWFsaXphdGlvblR5cGUgPT09IEFMV0FZU19OT1JNQUxJWkUpIHtcbiAgICBjaGlsZHJlbiA9IG5vcm1hbGl6ZUNoaWxkcmVuKGNoaWxkcmVuKTtcbiAgfSBlbHNlIGlmIChub3JtYWxpemF0aW9uVHlwZSA9PT0gU0lNUExFX05PUk1BTElaRSkge1xuICAgIGNoaWxkcmVuID0gc2ltcGxlTm9ybWFsaXplQ2hpbGRyZW4oY2hpbGRyZW4pO1xuICB9XG4gIHZhciB2bm9kZSwgbnM7XG4gIGlmICh0eXBlb2YgdGFnID09PSAnc3RyaW5nJykge1xuICAgIHZhciBDdG9yO1xuICAgIG5zID0gKGNvbnRleHQuJHZub2RlICYmIGNvbnRleHQuJHZub2RlLm5zKSB8fCBjb25maWcuZ2V0VGFnTmFtZXNwYWNlKHRhZyk7XG4gICAgaWYgKGNvbmZpZy5pc1Jlc2VydmVkVGFnKHRhZykpIHtcbiAgICAgIC8vIHBsYXRmb3JtIGJ1aWx0LWluIGVsZW1lbnRzXG4gICAgICB2bm9kZSA9IG5ldyBWTm9kZShcbiAgICAgICAgY29uZmlnLnBhcnNlUGxhdGZvcm1UYWdOYW1lKHRhZyksIGRhdGEsIGNoaWxkcmVuLFxuICAgICAgICB1bmRlZmluZWQsIHVuZGVmaW5lZCwgY29udGV4dFxuICAgICAgKTtcbiAgICB9IGVsc2UgaWYgKGlzRGVmKEN0b3IgPSByZXNvbHZlQXNzZXQoY29udGV4dC4kb3B0aW9ucywgJ2NvbXBvbmVudHMnLCB0YWcpKSkge1xuICAgICAgLy8gY29tcG9uZW50XG4gICAgICB2bm9kZSA9IGNyZWF0ZUNvbXBvbmVudChDdG9yLCBkYXRhLCBjb250ZXh0LCBjaGlsZHJlbiwgdGFnKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gdW5rbm93biBvciB1bmxpc3RlZCBuYW1lc3BhY2VkIGVsZW1lbnRzXG4gICAgICAvLyBjaGVjayBhdCBydW50aW1lIGJlY2F1c2UgaXQgbWF5IGdldCBhc3NpZ25lZCBhIG5hbWVzcGFjZSB3aGVuIGl0c1xuICAgICAgLy8gcGFyZW50IG5vcm1hbGl6ZXMgY2hpbGRyZW5cbiAgICAgIHZub2RlID0gbmV3IFZOb2RlKFxuICAgICAgICB0YWcsIGRhdGEsIGNoaWxkcmVuLFxuICAgICAgICB1bmRlZmluZWQsIHVuZGVmaW5lZCwgY29udGV4dFxuICAgICAgKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgLy8gZGlyZWN0IGNvbXBvbmVudCBvcHRpb25zIC8gY29uc3RydWN0b3JcbiAgICB2bm9kZSA9IGNyZWF0ZUNvbXBvbmVudCh0YWcsIGRhdGEsIGNvbnRleHQsIGNoaWxkcmVuKTtcbiAgfVxuICBpZiAoaXNEZWYodm5vZGUpKSB7XG4gICAgaWYgKG5zKSB7IGFwcGx5TlModm5vZGUsIG5zKTsgfVxuICAgIHJldHVybiB2bm9kZVxuICB9IGVsc2Uge1xuICAgIHJldHVybiBjcmVhdGVFbXB0eVZOb2RlKClcbiAgfVxufVxuXG5mdW5jdGlvbiBhcHBseU5TICh2bm9kZSwgbnMsIGZvcmNlKSB7XG4gIHZub2RlLm5zID0gbnM7XG4gIGlmICh2bm9kZS50YWcgPT09ICdmb3JlaWduT2JqZWN0Jykge1xuICAgIC8vIHVzZSBkZWZhdWx0IG5hbWVzcGFjZSBpbnNpZGUgZm9yZWlnbk9iamVjdFxuICAgIG5zID0gdW5kZWZpbmVkO1xuICAgIGZvcmNlID0gdHJ1ZTtcbiAgfVxuICBpZiAoaXNEZWYodm5vZGUuY2hpbGRyZW4pKSB7XG4gICAgZm9yICh2YXIgaSA9IDAsIGwgPSB2bm9kZS5jaGlsZHJlbi5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgIHZhciBjaGlsZCA9IHZub2RlLmNoaWxkcmVuW2ldO1xuICAgICAgaWYgKGlzRGVmKGNoaWxkLnRhZykgJiYgKGlzVW5kZWYoY2hpbGQubnMpIHx8IGlzVHJ1ZShmb3JjZSkpKSB7XG4gICAgICAgIGFwcGx5TlMoY2hpbGQsIG5zLCBmb3JjZSk7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbi8qICAqL1xuXG5mdW5jdGlvbiBpbml0UmVuZGVyICh2bSkge1xuICB2bS5fdm5vZGUgPSBudWxsOyAvLyB0aGUgcm9vdCBvZiB0aGUgY2hpbGQgdHJlZVxuICB2bS5fc3RhdGljVHJlZXMgPSBudWxsOyAvLyB2LW9uY2UgY2FjaGVkIHRyZWVzXG4gIHZhciBvcHRpb25zID0gdm0uJG9wdGlvbnM7XG4gIHZhciBwYXJlbnRWbm9kZSA9IHZtLiR2bm9kZSA9IG9wdGlvbnMuX3BhcmVudFZub2RlOyAvLyB0aGUgcGxhY2Vob2xkZXIgbm9kZSBpbiBwYXJlbnQgdHJlZVxuICB2YXIgcmVuZGVyQ29udGV4dCA9IHBhcmVudFZub2RlICYmIHBhcmVudFZub2RlLmNvbnRleHQ7XG4gIHZtLiRzbG90cyA9IHJlc29sdmVTbG90cyhvcHRpb25zLl9yZW5kZXJDaGlsZHJlbiwgcmVuZGVyQ29udGV4dCk7XG4gIHZtLiRzY29wZWRTbG90cyA9IGVtcHR5T2JqZWN0O1xuICAvLyBiaW5kIHRoZSBjcmVhdGVFbGVtZW50IGZuIHRvIHRoaXMgaW5zdGFuY2VcbiAgLy8gc28gdGhhdCB3ZSBnZXQgcHJvcGVyIHJlbmRlciBjb250ZXh0IGluc2lkZSBpdC5cbiAgLy8gYXJncyBvcmRlcjogdGFnLCBkYXRhLCBjaGlsZHJlbiwgbm9ybWFsaXphdGlvblR5cGUsIGFsd2F5c05vcm1hbGl6ZVxuICAvLyBpbnRlcm5hbCB2ZXJzaW9uIGlzIHVzZWQgYnkgcmVuZGVyIGZ1bmN0aW9ucyBjb21waWxlZCBmcm9tIHRlbXBsYXRlc1xuICB2bS5fYyA9IGZ1bmN0aW9uIChhLCBiLCBjLCBkKSB7IHJldHVybiBjcmVhdGVFbGVtZW50KHZtLCBhLCBiLCBjLCBkLCBmYWxzZSk7IH07XG4gIC8vIG5vcm1hbGl6YXRpb24gaXMgYWx3YXlzIGFwcGxpZWQgZm9yIHRoZSBwdWJsaWMgdmVyc2lvbiwgdXNlZCBpblxuICAvLyB1c2VyLXdyaXR0ZW4gcmVuZGVyIGZ1bmN0aW9ucy5cbiAgdm0uJGNyZWF0ZUVsZW1lbnQgPSBmdW5jdGlvbiAoYSwgYiwgYywgZCkgeyByZXR1cm4gY3JlYXRlRWxlbWVudCh2bSwgYSwgYiwgYywgZCwgdHJ1ZSk7IH07XG5cbiAgLy8gJGF0dHJzICYgJGxpc3RlbmVycyBhcmUgZXhwb3NlZCBmb3IgZWFzaWVyIEhPQyBjcmVhdGlvbi5cbiAgLy8gdGhleSBuZWVkIHRvIGJlIHJlYWN0aXZlIHNvIHRoYXQgSE9DcyB1c2luZyB0aGVtIGFyZSBhbHdheXMgdXBkYXRlZFxuICB2YXIgcGFyZW50RGF0YSA9IHBhcmVudFZub2RlICYmIHBhcmVudFZub2RlLmRhdGE7XG5cbiAgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICBkZWZpbmVSZWFjdGl2ZSh2bSwgJyRhdHRycycsIHBhcmVudERhdGEgJiYgcGFyZW50RGF0YS5hdHRycyB8fCBlbXB0eU9iamVjdCwgZnVuY3Rpb24gKCkge1xuICAgICAgIWlzVXBkYXRpbmdDaGlsZENvbXBvbmVudCAmJiB3YXJuKFwiJGF0dHJzIGlzIHJlYWRvbmx5LlwiLCB2bSk7XG4gICAgfSwgdHJ1ZSk7XG4gICAgZGVmaW5lUmVhY3RpdmUodm0sICckbGlzdGVuZXJzJywgb3B0aW9ucy5fcGFyZW50TGlzdGVuZXJzIHx8IGVtcHR5T2JqZWN0LCBmdW5jdGlvbiAoKSB7XG4gICAgICAhaXNVcGRhdGluZ0NoaWxkQ29tcG9uZW50ICYmIHdhcm4oXCIkbGlzdGVuZXJzIGlzIHJlYWRvbmx5LlwiLCB2bSk7XG4gICAgfSwgdHJ1ZSk7XG4gIH0gZWxzZSB7XG4gICAgZGVmaW5lUmVhY3RpdmUodm0sICckYXR0cnMnLCBwYXJlbnREYXRhICYmIHBhcmVudERhdGEuYXR0cnMgfHwgZW1wdHlPYmplY3QsIG51bGwsIHRydWUpO1xuICAgIGRlZmluZVJlYWN0aXZlKHZtLCAnJGxpc3RlbmVycycsIG9wdGlvbnMuX3BhcmVudExpc3RlbmVycyB8fCBlbXB0eU9iamVjdCwgbnVsbCwgdHJ1ZSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gcmVuZGVyTWl4aW4gKFZ1ZSkge1xuICAvLyBpbnN0YWxsIHJ1bnRpbWUgY29udmVuaWVuY2UgaGVscGVyc1xuICBpbnN0YWxsUmVuZGVySGVscGVycyhWdWUucHJvdG90eXBlKTtcblxuICBWdWUucHJvdG90eXBlLiRuZXh0VGljayA9IGZ1bmN0aW9uIChmbikge1xuICAgIHJldHVybiBuZXh0VGljayhmbiwgdGhpcylcbiAgfTtcblxuICBWdWUucHJvdG90eXBlLl9yZW5kZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHZtID0gdGhpcztcbiAgICB2YXIgcmVmID0gdm0uJG9wdGlvbnM7XG4gICAgdmFyIHJlbmRlciA9IHJlZi5yZW5kZXI7XG4gICAgdmFyIF9wYXJlbnRWbm9kZSA9IHJlZi5fcGFyZW50Vm5vZGU7XG5cbiAgICBpZiAodm0uX2lzTW91bnRlZCkge1xuICAgICAgLy8gaWYgdGhlIHBhcmVudCBkaWRuJ3QgdXBkYXRlLCB0aGUgc2xvdCBub2RlcyB3aWxsIGJlIHRoZSBvbmVzIGZyb21cbiAgICAgIC8vIGxhc3QgcmVuZGVyLiBUaGV5IG5lZWQgdG8gYmUgY2xvbmVkIHRvIGVuc3VyZSBcImZyZXNobmVzc1wiIGZvciB0aGlzIHJlbmRlci5cbiAgICAgIGZvciAodmFyIGtleSBpbiB2bS4kc2xvdHMpIHtcbiAgICAgICAgdmFyIHNsb3QgPSB2bS4kc2xvdHNba2V5XTtcbiAgICAgICAgLy8gX3JlbmRlcmVkIGlzIGEgZmxhZyBhZGRlZCBieSByZW5kZXJTbG90LCBidXQgbWF5IG5vdCBiZSBwcmVzZW50XG4gICAgICAgIC8vIGlmIHRoZSBzbG90IGlzIHBhc3NlZCBmcm9tIG1hbnVhbGx5IHdyaXR0ZW4gcmVuZGVyIGZ1bmN0aW9uc1xuICAgICAgICBpZiAoc2xvdC5fcmVuZGVyZWQgfHwgKHNsb3RbMF0gJiYgc2xvdFswXS5lbG0pKSB7XG4gICAgICAgICAgdm0uJHNsb3RzW2tleV0gPSBjbG9uZVZOb2RlcyhzbG90LCB0cnVlIC8qIGRlZXAgKi8pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgdm0uJHNjb3BlZFNsb3RzID0gKF9wYXJlbnRWbm9kZSAmJiBfcGFyZW50Vm5vZGUuZGF0YS5zY29wZWRTbG90cykgfHwgZW1wdHlPYmplY3Q7XG5cbiAgICAvLyBzZXQgcGFyZW50IHZub2RlLiB0aGlzIGFsbG93cyByZW5kZXIgZnVuY3Rpb25zIHRvIGhhdmUgYWNjZXNzXG4gICAgLy8gdG8gdGhlIGRhdGEgb24gdGhlIHBsYWNlaG9sZGVyIG5vZGUuXG4gICAgdm0uJHZub2RlID0gX3BhcmVudFZub2RlO1xuICAgIC8vIHJlbmRlciBzZWxmXG4gICAgdmFyIHZub2RlO1xuICAgIHRyeSB7XG4gICAgICB2bm9kZSA9IHJlbmRlci5jYWxsKHZtLl9yZW5kZXJQcm94eSwgdm0uJGNyZWF0ZUVsZW1lbnQpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIGhhbmRsZUVycm9yKGUsIHZtLCBcInJlbmRlclwiKTtcbiAgICAgIC8vIHJldHVybiBlcnJvciByZW5kZXIgcmVzdWx0LFxuICAgICAgLy8gb3IgcHJldmlvdXMgdm5vZGUgdG8gcHJldmVudCByZW5kZXIgZXJyb3IgY2F1c2luZyBibGFuayBjb21wb25lbnRcbiAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICovXG4gICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICBpZiAodm0uJG9wdGlvbnMucmVuZGVyRXJyb3IpIHtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgdm5vZGUgPSB2bS4kb3B0aW9ucy5yZW5kZXJFcnJvci5jYWxsKHZtLl9yZW5kZXJQcm94eSwgdm0uJGNyZWF0ZUVsZW1lbnQsIGUpO1xuICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIGhhbmRsZUVycm9yKGUsIHZtLCBcInJlbmRlckVycm9yXCIpO1xuICAgICAgICAgICAgdm5vZGUgPSB2bS5fdm5vZGU7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZub2RlID0gdm0uX3Zub2RlO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2bm9kZSA9IHZtLl92bm9kZTtcbiAgICAgIH1cbiAgICB9XG4gICAgLy8gcmV0dXJuIGVtcHR5IHZub2RlIGluIGNhc2UgdGhlIHJlbmRlciBmdW5jdGlvbiBlcnJvcmVkIG91dFxuICAgIGlmICghKHZub2RlIGluc3RhbmNlb2YgVk5vZGUpKSB7XG4gICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiBBcnJheS5pc0FycmF5KHZub2RlKSkge1xuICAgICAgICB3YXJuKFxuICAgICAgICAgICdNdWx0aXBsZSByb290IG5vZGVzIHJldHVybmVkIGZyb20gcmVuZGVyIGZ1bmN0aW9uLiBSZW5kZXIgZnVuY3Rpb24gJyArXG4gICAgICAgICAgJ3Nob3VsZCByZXR1cm4gYSBzaW5nbGUgcm9vdCBub2RlLicsXG4gICAgICAgICAgdm1cbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIHZub2RlID0gY3JlYXRlRW1wdHlWTm9kZSgpO1xuICAgIH1cbiAgICAvLyBzZXQgcGFyZW50XG4gICAgdm5vZGUucGFyZW50ID0gX3BhcmVudFZub2RlO1xuICAgIHJldHVybiB2bm9kZVxuICB9O1xufVxuXG4vKiAgKi9cblxudmFyIHVpZCQxID0gMDtcblxuZnVuY3Rpb24gaW5pdE1peGluIChWdWUpIHtcbiAgVnVlLnByb3RvdHlwZS5faW5pdCA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gICAgdmFyIHZtID0gdGhpcztcbiAgICAvLyBhIHVpZFxuICAgIHZtLl91aWQgPSB1aWQkMSsrO1xuXG4gICAgdmFyIHN0YXJ0VGFnLCBlbmRUYWc7XG4gICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgY29uZmlnLnBlcmZvcm1hbmNlICYmIG1hcmspIHtcbiAgICAgIHN0YXJ0VGFnID0gXCJ2dWUtcGVyZi1zdGFydDpcIiArICh2bS5fdWlkKTtcbiAgICAgIGVuZFRhZyA9IFwidnVlLXBlcmYtZW5kOlwiICsgKHZtLl91aWQpO1xuICAgICAgbWFyayhzdGFydFRhZyk7XG4gICAgfVxuXG4gICAgLy8gYSBmbGFnIHRvIGF2b2lkIHRoaXMgYmVpbmcgb2JzZXJ2ZWRcbiAgICB2bS5faXNWdWUgPSB0cnVlO1xuICAgIC8vIG1lcmdlIG9wdGlvbnNcbiAgICBpZiAob3B0aW9ucyAmJiBvcHRpb25zLl9pc0NvbXBvbmVudCkge1xuICAgICAgLy8gb3B0aW1pemUgaW50ZXJuYWwgY29tcG9uZW50IGluc3RhbnRpYXRpb25cbiAgICAgIC8vIHNpbmNlIGR5bmFtaWMgb3B0aW9ucyBtZXJnaW5nIGlzIHByZXR0eSBzbG93LCBhbmQgbm9uZSBvZiB0aGVcbiAgICAgIC8vIGludGVybmFsIGNvbXBvbmVudCBvcHRpb25zIG5lZWRzIHNwZWNpYWwgdHJlYXRtZW50LlxuICAgICAgaW5pdEludGVybmFsQ29tcG9uZW50KHZtLCBvcHRpb25zKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdm0uJG9wdGlvbnMgPSBtZXJnZU9wdGlvbnMoXG4gICAgICAgIHJlc29sdmVDb25zdHJ1Y3Rvck9wdGlvbnModm0uY29uc3RydWN0b3IpLFxuICAgICAgICBvcHRpb25zIHx8IHt9LFxuICAgICAgICB2bVxuICAgICAgKTtcbiAgICB9XG4gICAgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgaW5pdFByb3h5KHZtKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdm0uX3JlbmRlclByb3h5ID0gdm07XG4gICAgfVxuICAgIC8vIGV4cG9zZSByZWFsIHNlbGZcbiAgICB2bS5fc2VsZiA9IHZtO1xuICAgIGluaXRMaWZlY3ljbGUodm0pO1xuICAgIGluaXRFdmVudHModm0pO1xuICAgIGluaXRSZW5kZXIodm0pO1xuICAgIGNhbGxIb29rKHZtLCAnYmVmb3JlQ3JlYXRlJyk7XG4gICAgaW5pdEluamVjdGlvbnModm0pOyAvLyByZXNvbHZlIGluamVjdGlvbnMgYmVmb3JlIGRhdGEvcHJvcHNcbiAgICBpbml0U3RhdGUodm0pO1xuICAgIGluaXRQcm92aWRlKHZtKTsgLy8gcmVzb2x2ZSBwcm92aWRlIGFmdGVyIGRhdGEvcHJvcHNcbiAgICBjYWxsSG9vayh2bSwgJ2NyZWF0ZWQnKTtcblxuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIGNvbmZpZy5wZXJmb3JtYW5jZSAmJiBtYXJrKSB7XG4gICAgICB2bS5fbmFtZSA9IGZvcm1hdENvbXBvbmVudE5hbWUodm0sIGZhbHNlKTtcbiAgICAgIG1hcmsoZW5kVGFnKTtcbiAgICAgIG1lYXN1cmUoKFwidnVlIFwiICsgKHZtLl9uYW1lKSArIFwiIGluaXRcIiksIHN0YXJ0VGFnLCBlbmRUYWcpO1xuICAgIH1cblxuICAgIGlmICh2bS4kb3B0aW9ucy5lbCkge1xuICAgICAgdm0uJG1vdW50KHZtLiRvcHRpb25zLmVsKTtcbiAgICB9XG4gIH07XG59XG5cbmZ1bmN0aW9uIGluaXRJbnRlcm5hbENvbXBvbmVudCAodm0sIG9wdGlvbnMpIHtcbiAgdmFyIG9wdHMgPSB2bS4kb3B0aW9ucyA9IE9iamVjdC5jcmVhdGUodm0uY29uc3RydWN0b3Iub3B0aW9ucyk7XG4gIC8vIGRvaW5nIHRoaXMgYmVjYXVzZSBpdCdzIGZhc3RlciB0aGFuIGR5bmFtaWMgZW51bWVyYXRpb24uXG4gIHZhciBwYXJlbnRWbm9kZSA9IG9wdGlvbnMuX3BhcmVudFZub2RlO1xuICBvcHRzLnBhcmVudCA9IG9wdGlvbnMucGFyZW50O1xuICBvcHRzLl9wYXJlbnRWbm9kZSA9IHBhcmVudFZub2RlO1xuICBvcHRzLl9wYXJlbnRFbG0gPSBvcHRpb25zLl9wYXJlbnRFbG07XG4gIG9wdHMuX3JlZkVsbSA9IG9wdGlvbnMuX3JlZkVsbTtcblxuICB2YXIgdm5vZGVDb21wb25lbnRPcHRpb25zID0gcGFyZW50Vm5vZGUuY29tcG9uZW50T3B0aW9ucztcbiAgb3B0cy5wcm9wc0RhdGEgPSB2bm9kZUNvbXBvbmVudE9wdGlvbnMucHJvcHNEYXRhO1xuICBvcHRzLl9wYXJlbnRMaXN0ZW5lcnMgPSB2bm9kZUNvbXBvbmVudE9wdGlvbnMubGlzdGVuZXJzO1xuICBvcHRzLl9yZW5kZXJDaGlsZHJlbiA9IHZub2RlQ29tcG9uZW50T3B0aW9ucy5jaGlsZHJlbjtcbiAgb3B0cy5fY29tcG9uZW50VGFnID0gdm5vZGVDb21wb25lbnRPcHRpb25zLnRhZztcblxuICBpZiAob3B0aW9ucy5yZW5kZXIpIHtcbiAgICBvcHRzLnJlbmRlciA9IG9wdGlvbnMucmVuZGVyO1xuICAgIG9wdHMuc3RhdGljUmVuZGVyRm5zID0gb3B0aW9ucy5zdGF0aWNSZW5kZXJGbnM7XG4gIH1cbn1cblxuZnVuY3Rpb24gcmVzb2x2ZUNvbnN0cnVjdG9yT3B0aW9ucyAoQ3Rvcikge1xuICB2YXIgb3B0aW9ucyA9IEN0b3Iub3B0aW9ucztcbiAgaWYgKEN0b3Iuc3VwZXIpIHtcbiAgICB2YXIgc3VwZXJPcHRpb25zID0gcmVzb2x2ZUNvbnN0cnVjdG9yT3B0aW9ucyhDdG9yLnN1cGVyKTtcbiAgICB2YXIgY2FjaGVkU3VwZXJPcHRpb25zID0gQ3Rvci5zdXBlck9wdGlvbnM7XG4gICAgaWYgKHN1cGVyT3B0aW9ucyAhPT0gY2FjaGVkU3VwZXJPcHRpb25zKSB7XG4gICAgICAvLyBzdXBlciBvcHRpb24gY2hhbmdlZCxcbiAgICAgIC8vIG5lZWQgdG8gcmVzb2x2ZSBuZXcgb3B0aW9ucy5cbiAgICAgIEN0b3Iuc3VwZXJPcHRpb25zID0gc3VwZXJPcHRpb25zO1xuICAgICAgLy8gY2hlY2sgaWYgdGhlcmUgYXJlIGFueSBsYXRlLW1vZGlmaWVkL2F0dGFjaGVkIG9wdGlvbnMgKCM0OTc2KVxuICAgICAgdmFyIG1vZGlmaWVkT3B0aW9ucyA9IHJlc29sdmVNb2RpZmllZE9wdGlvbnMoQ3Rvcik7XG4gICAgICAvLyB1cGRhdGUgYmFzZSBleHRlbmQgb3B0aW9uc1xuICAgICAgaWYgKG1vZGlmaWVkT3B0aW9ucykge1xuICAgICAgICBleHRlbmQoQ3Rvci5leHRlbmRPcHRpb25zLCBtb2RpZmllZE9wdGlvbnMpO1xuICAgICAgfVxuICAgICAgb3B0aW9ucyA9IEN0b3Iub3B0aW9ucyA9IG1lcmdlT3B0aW9ucyhzdXBlck9wdGlvbnMsIEN0b3IuZXh0ZW5kT3B0aW9ucyk7XG4gICAgICBpZiAob3B0aW9ucy5uYW1lKSB7XG4gICAgICAgIG9wdGlvbnMuY29tcG9uZW50c1tvcHRpb25zLm5hbWVdID0gQ3RvcjtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIG9wdGlvbnNcbn1cblxuZnVuY3Rpb24gcmVzb2x2ZU1vZGlmaWVkT3B0aW9ucyAoQ3Rvcikge1xuICB2YXIgbW9kaWZpZWQ7XG4gIHZhciBsYXRlc3QgPSBDdG9yLm9wdGlvbnM7XG4gIHZhciBleHRlbmRlZCA9IEN0b3IuZXh0ZW5kT3B0aW9ucztcbiAgdmFyIHNlYWxlZCA9IEN0b3Iuc2VhbGVkT3B0aW9ucztcbiAgZm9yICh2YXIga2V5IGluIGxhdGVzdCkge1xuICAgIGlmIChsYXRlc3Rba2V5XSAhPT0gc2VhbGVkW2tleV0pIHtcbiAgICAgIGlmICghbW9kaWZpZWQpIHsgbW9kaWZpZWQgPSB7fTsgfVxuICAgICAgbW9kaWZpZWRba2V5XSA9IGRlZHVwZShsYXRlc3Rba2V5XSwgZXh0ZW5kZWRba2V5XSwgc2VhbGVkW2tleV0pO1xuICAgIH1cbiAgfVxuICByZXR1cm4gbW9kaWZpZWRcbn1cblxuZnVuY3Rpb24gZGVkdXBlIChsYXRlc3QsIGV4dGVuZGVkLCBzZWFsZWQpIHtcbiAgLy8gY29tcGFyZSBsYXRlc3QgYW5kIHNlYWxlZCB0byBlbnN1cmUgbGlmZWN5Y2xlIGhvb2tzIHdvbid0IGJlIGR1cGxpY2F0ZWRcbiAgLy8gYmV0d2VlbiBtZXJnZXNcbiAgaWYgKEFycmF5LmlzQXJyYXkobGF0ZXN0KSkge1xuICAgIHZhciByZXMgPSBbXTtcbiAgICBzZWFsZWQgPSBBcnJheS5pc0FycmF5KHNlYWxlZCkgPyBzZWFsZWQgOiBbc2VhbGVkXTtcbiAgICBleHRlbmRlZCA9IEFycmF5LmlzQXJyYXkoZXh0ZW5kZWQpID8gZXh0ZW5kZWQgOiBbZXh0ZW5kZWRdO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGF0ZXN0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAvLyBwdXNoIG9yaWdpbmFsIG9wdGlvbnMgYW5kIG5vdCBzZWFsZWQgb3B0aW9ucyB0byBleGNsdWRlIGR1cGxpY2F0ZWQgb3B0aW9uc1xuICAgICAgaWYgKGV4dGVuZGVkLmluZGV4T2YobGF0ZXN0W2ldKSA+PSAwIHx8IHNlYWxlZC5pbmRleE9mKGxhdGVzdFtpXSkgPCAwKSB7XG4gICAgICAgIHJlcy5wdXNoKGxhdGVzdFtpXSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXNcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gbGF0ZXN0XG4gIH1cbn1cblxuZnVuY3Rpb24gVnVlJDMgKG9wdGlvbnMpIHtcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiZcbiAgICAhKHRoaXMgaW5zdGFuY2VvZiBWdWUkMylcbiAgKSB7XG4gICAgd2FybignVnVlIGlzIGEgY29uc3RydWN0b3IgYW5kIHNob3VsZCBiZSBjYWxsZWQgd2l0aCB0aGUgYG5ld2Aga2V5d29yZCcpO1xuICB9XG4gIHRoaXMuX2luaXQob3B0aW9ucyk7XG59XG5cbmluaXRNaXhpbihWdWUkMyk7XG5zdGF0ZU1peGluKFZ1ZSQzKTtcbmV2ZW50c01peGluKFZ1ZSQzKTtcbmxpZmVjeWNsZU1peGluKFZ1ZSQzKTtcbnJlbmRlck1peGluKFZ1ZSQzKTtcblxuLyogICovXG5cbmZ1bmN0aW9uIGluaXRVc2UgKFZ1ZSkge1xuICBWdWUudXNlID0gZnVuY3Rpb24gKHBsdWdpbikge1xuICAgIHZhciBpbnN0YWxsZWRQbHVnaW5zID0gKHRoaXMuX2luc3RhbGxlZFBsdWdpbnMgfHwgKHRoaXMuX2luc3RhbGxlZFBsdWdpbnMgPSBbXSkpO1xuICAgIGlmIChpbnN0YWxsZWRQbHVnaW5zLmluZGV4T2YocGx1Z2luKSA+IC0xKSB7XG4gICAgICByZXR1cm4gdGhpc1xuICAgIH1cblxuICAgIC8vIGFkZGl0aW9uYWwgcGFyYW1ldGVyc1xuICAgIHZhciBhcmdzID0gdG9BcnJheShhcmd1bWVudHMsIDEpO1xuICAgIGFyZ3MudW5zaGlmdCh0aGlzKTtcbiAgICBpZiAodHlwZW9mIHBsdWdpbi5pbnN0YWxsID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBwbHVnaW4uaW5zdGFsbC5hcHBseShwbHVnaW4sIGFyZ3MpO1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIHBsdWdpbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgcGx1Z2luLmFwcGx5KG51bGwsIGFyZ3MpO1xuICAgIH1cbiAgICBpbnN0YWxsZWRQbHVnaW5zLnB1c2gocGx1Z2luKTtcbiAgICByZXR1cm4gdGhpc1xuICB9O1xufVxuXG4vKiAgKi9cblxuZnVuY3Rpb24gaW5pdE1peGluJDEgKFZ1ZSkge1xuICBWdWUubWl4aW4gPSBmdW5jdGlvbiAobWl4aW4pIHtcbiAgICB0aGlzLm9wdGlvbnMgPSBtZXJnZU9wdGlvbnModGhpcy5vcHRpb25zLCBtaXhpbik7XG4gICAgcmV0dXJuIHRoaXNcbiAgfTtcbn1cblxuLyogICovXG5cbmZ1bmN0aW9uIGluaXRFeHRlbmQgKFZ1ZSkge1xuICAvKipcbiAgICogRWFjaCBpbnN0YW5jZSBjb25zdHJ1Y3RvciwgaW5jbHVkaW5nIFZ1ZSwgaGFzIGEgdW5pcXVlXG4gICAqIGNpZC4gVGhpcyBlbmFibGVzIHVzIHRvIGNyZWF0ZSB3cmFwcGVkIFwiY2hpbGRcbiAgICogY29uc3RydWN0b3JzXCIgZm9yIHByb3RvdHlwYWwgaW5oZXJpdGFuY2UgYW5kIGNhY2hlIHRoZW0uXG4gICAqL1xuICBWdWUuY2lkID0gMDtcbiAgdmFyIGNpZCA9IDE7XG5cbiAgLyoqXG4gICAqIENsYXNzIGluaGVyaXRhbmNlXG4gICAqL1xuICBWdWUuZXh0ZW5kID0gZnVuY3Rpb24gKGV4dGVuZE9wdGlvbnMpIHtcbiAgICBleHRlbmRPcHRpb25zID0gZXh0ZW5kT3B0aW9ucyB8fCB7fTtcbiAgICB2YXIgU3VwZXIgPSB0aGlzO1xuICAgIHZhciBTdXBlcklkID0gU3VwZXIuY2lkO1xuICAgIHZhciBjYWNoZWRDdG9ycyA9IGV4dGVuZE9wdGlvbnMuX0N0b3IgfHwgKGV4dGVuZE9wdGlvbnMuX0N0b3IgPSB7fSk7XG4gICAgaWYgKGNhY2hlZEN0b3JzW1N1cGVySWRdKSB7XG4gICAgICByZXR1cm4gY2FjaGVkQ3RvcnNbU3VwZXJJZF1cbiAgICB9XG5cbiAgICB2YXIgbmFtZSA9IGV4dGVuZE9wdGlvbnMubmFtZSB8fCBTdXBlci5vcHRpb25zLm5hbWU7XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgbmFtZSkge1xuICAgICAgdmFsaWRhdGVDb21wb25lbnROYW1lKG5hbWUpO1xuICAgIH1cblxuICAgIHZhciBTdWIgPSBmdW5jdGlvbiBWdWVDb21wb25lbnQgKG9wdGlvbnMpIHtcbiAgICAgIHRoaXMuX2luaXQob3B0aW9ucyk7XG4gICAgfTtcbiAgICBTdWIucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShTdXBlci5wcm90b3R5cGUpO1xuICAgIFN1Yi5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBTdWI7XG4gICAgU3ViLmNpZCA9IGNpZCsrO1xuICAgIFN1Yi5vcHRpb25zID0gbWVyZ2VPcHRpb25zKFxuICAgICAgU3VwZXIub3B0aW9ucyxcbiAgICAgIGV4dGVuZE9wdGlvbnNcbiAgICApO1xuICAgIFN1Ylsnc3VwZXInXSA9IFN1cGVyO1xuXG4gICAgLy8gRm9yIHByb3BzIGFuZCBjb21wdXRlZCBwcm9wZXJ0aWVzLCB3ZSBkZWZpbmUgdGhlIHByb3h5IGdldHRlcnMgb25cbiAgICAvLyB0aGUgVnVlIGluc3RhbmNlcyBhdCBleHRlbnNpb24gdGltZSwgb24gdGhlIGV4dGVuZGVkIHByb3RvdHlwZS4gVGhpc1xuICAgIC8vIGF2b2lkcyBPYmplY3QuZGVmaW5lUHJvcGVydHkgY2FsbHMgZm9yIGVhY2ggaW5zdGFuY2UgY3JlYXRlZC5cbiAgICBpZiAoU3ViLm9wdGlvbnMucHJvcHMpIHtcbiAgICAgIGluaXRQcm9wcyQxKFN1Yik7XG4gICAgfVxuICAgIGlmIChTdWIub3B0aW9ucy5jb21wdXRlZCkge1xuICAgICAgaW5pdENvbXB1dGVkJDEoU3ViKTtcbiAgICB9XG5cbiAgICAvLyBhbGxvdyBmdXJ0aGVyIGV4dGVuc2lvbi9taXhpbi9wbHVnaW4gdXNhZ2VcbiAgICBTdWIuZXh0ZW5kID0gU3VwZXIuZXh0ZW5kO1xuICAgIFN1Yi5taXhpbiA9IFN1cGVyLm1peGluO1xuICAgIFN1Yi51c2UgPSBTdXBlci51c2U7XG5cbiAgICAvLyBjcmVhdGUgYXNzZXQgcmVnaXN0ZXJzLCBzbyBleHRlbmRlZCBjbGFzc2VzXG4gICAgLy8gY2FuIGhhdmUgdGhlaXIgcHJpdmF0ZSBhc3NldHMgdG9vLlxuICAgIEFTU0VUX1RZUEVTLmZvckVhY2goZnVuY3Rpb24gKHR5cGUpIHtcbiAgICAgIFN1Ylt0eXBlXSA9IFN1cGVyW3R5cGVdO1xuICAgIH0pO1xuICAgIC8vIGVuYWJsZSByZWN1cnNpdmUgc2VsZi1sb29rdXBcbiAgICBpZiAobmFtZSkge1xuICAgICAgU3ViLm9wdGlvbnMuY29tcG9uZW50c1tuYW1lXSA9IFN1YjtcbiAgICB9XG5cbiAgICAvLyBrZWVwIGEgcmVmZXJlbmNlIHRvIHRoZSBzdXBlciBvcHRpb25zIGF0IGV4dGVuc2lvbiB0aW1lLlxuICAgIC8vIGxhdGVyIGF0IGluc3RhbnRpYXRpb24gd2UgY2FuIGNoZWNrIGlmIFN1cGVyJ3Mgb3B0aW9ucyBoYXZlXG4gICAgLy8gYmVlbiB1cGRhdGVkLlxuICAgIFN1Yi5zdXBlck9wdGlvbnMgPSBTdXBlci5vcHRpb25zO1xuICAgIFN1Yi5leHRlbmRPcHRpb25zID0gZXh0ZW5kT3B0aW9ucztcbiAgICBTdWIuc2VhbGVkT3B0aW9ucyA9IGV4dGVuZCh7fSwgU3ViLm9wdGlvbnMpO1xuXG4gICAgLy8gY2FjaGUgY29uc3RydWN0b3JcbiAgICBjYWNoZWRDdG9yc1tTdXBlcklkXSA9IFN1YjtcbiAgICByZXR1cm4gU3ViXG4gIH07XG59XG5cbmZ1bmN0aW9uIGluaXRQcm9wcyQxIChDb21wKSB7XG4gIHZhciBwcm9wcyA9IENvbXAub3B0aW9ucy5wcm9wcztcbiAgZm9yICh2YXIga2V5IGluIHByb3BzKSB7XG4gICAgcHJveHkoQ29tcC5wcm90b3R5cGUsIFwiX3Byb3BzXCIsIGtleSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gaW5pdENvbXB1dGVkJDEgKENvbXApIHtcbiAgdmFyIGNvbXB1dGVkID0gQ29tcC5vcHRpb25zLmNvbXB1dGVkO1xuICBmb3IgKHZhciBrZXkgaW4gY29tcHV0ZWQpIHtcbiAgICBkZWZpbmVDb21wdXRlZChDb21wLnByb3RvdHlwZSwga2V5LCBjb21wdXRlZFtrZXldKTtcbiAgfVxufVxuXG4vKiAgKi9cblxuZnVuY3Rpb24gaW5pdEFzc2V0UmVnaXN0ZXJzIChWdWUpIHtcbiAgLyoqXG4gICAqIENyZWF0ZSBhc3NldCByZWdpc3RyYXRpb24gbWV0aG9kcy5cbiAgICovXG4gIEFTU0VUX1RZUEVTLmZvckVhY2goZnVuY3Rpb24gKHR5cGUpIHtcbiAgICBWdWVbdHlwZV0gPSBmdW5jdGlvbiAoXG4gICAgICBpZCxcbiAgICAgIGRlZmluaXRpb25cbiAgICApIHtcbiAgICAgIGlmICghZGVmaW5pdGlvbikge1xuICAgICAgICByZXR1cm4gdGhpcy5vcHRpb25zW3R5cGUgKyAncyddW2lkXVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIHR5cGUgPT09ICdjb21wb25lbnQnKSB7XG4gICAgICAgICAgdmFsaWRhdGVDb21wb25lbnROYW1lKGlkKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZSA9PT0gJ2NvbXBvbmVudCcgJiYgaXNQbGFpbk9iamVjdChkZWZpbml0aW9uKSkge1xuICAgICAgICAgIGRlZmluaXRpb24ubmFtZSA9IGRlZmluaXRpb24ubmFtZSB8fCBpZDtcbiAgICAgICAgICBkZWZpbml0aW9uID0gdGhpcy5vcHRpb25zLl9iYXNlLmV4dGVuZChkZWZpbml0aW9uKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZSA9PT0gJ2RpcmVjdGl2ZScgJiYgdHlwZW9mIGRlZmluaXRpb24gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICBkZWZpbml0aW9uID0geyBiaW5kOiBkZWZpbml0aW9uLCB1cGRhdGU6IGRlZmluaXRpb24gfTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLm9wdGlvbnNbdHlwZSArICdzJ11baWRdID0gZGVmaW5pdGlvbjtcbiAgICAgICAgcmV0dXJuIGRlZmluaXRpb25cbiAgICAgIH1cbiAgICB9O1xuICB9KTtcbn1cblxuLyogICovXG5cbmZ1bmN0aW9uIGdldENvbXBvbmVudE5hbWUgKG9wdHMpIHtcbiAgcmV0dXJuIG9wdHMgJiYgKG9wdHMuQ3Rvci5vcHRpb25zLm5hbWUgfHwgb3B0cy50YWcpXG59XG5cbmZ1bmN0aW9uIG1hdGNoZXMgKHBhdHRlcm4sIG5hbWUpIHtcbiAgaWYgKEFycmF5LmlzQXJyYXkocGF0dGVybikpIHtcbiAgICByZXR1cm4gcGF0dGVybi5pbmRleE9mKG5hbWUpID4gLTFcbiAgfSBlbHNlIGlmICh0eXBlb2YgcGF0dGVybiA9PT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4gcGF0dGVybi5zcGxpdCgnLCcpLmluZGV4T2YobmFtZSkgPiAtMVxuICB9IGVsc2UgaWYgKGlzUmVnRXhwKHBhdHRlcm4pKSB7XG4gICAgcmV0dXJuIHBhdHRlcm4udGVzdChuYW1lKVxuICB9XG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gIHJldHVybiBmYWxzZVxufVxuXG5mdW5jdGlvbiBwcnVuZUNhY2hlIChrZWVwQWxpdmVJbnN0YW5jZSwgZmlsdGVyKSB7XG4gIHZhciBjYWNoZSA9IGtlZXBBbGl2ZUluc3RhbmNlLmNhY2hlO1xuICB2YXIga2V5cyA9IGtlZXBBbGl2ZUluc3RhbmNlLmtleXM7XG4gIHZhciBfdm5vZGUgPSBrZWVwQWxpdmVJbnN0YW5jZS5fdm5vZGU7XG4gIGZvciAodmFyIGtleSBpbiBjYWNoZSkge1xuICAgIHZhciBjYWNoZWROb2RlID0gY2FjaGVba2V5XTtcbiAgICBpZiAoY2FjaGVkTm9kZSkge1xuICAgICAgdmFyIG5hbWUgPSBnZXRDb21wb25lbnROYW1lKGNhY2hlZE5vZGUuY29tcG9uZW50T3B0aW9ucyk7XG4gICAgICBpZiAobmFtZSAmJiAhZmlsdGVyKG5hbWUpKSB7XG4gICAgICAgIHBydW5lQ2FjaGVFbnRyeShjYWNoZSwga2V5LCBrZXlzLCBfdm5vZGUpO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBwcnVuZUNhY2hlRW50cnkgKFxuICBjYWNoZSxcbiAga2V5LFxuICBrZXlzLFxuICBjdXJyZW50XG4pIHtcbiAgdmFyIGNhY2hlZCQkMSA9IGNhY2hlW2tleV07XG4gIGlmIChjYWNoZWQkJDEgJiYgKCFjdXJyZW50IHx8IGNhY2hlZCQkMS50YWcgIT09IGN1cnJlbnQudGFnKSkge1xuICAgIGNhY2hlZCQkMS5jb21wb25lbnRJbnN0YW5jZS4kZGVzdHJveSgpO1xuICB9XG4gIGNhY2hlW2tleV0gPSBudWxsO1xuICByZW1vdmUoa2V5cywga2V5KTtcbn1cblxudmFyIHBhdHRlcm5UeXBlcyA9IFtTdHJpbmcsIFJlZ0V4cCwgQXJyYXldO1xuXG52YXIgS2VlcEFsaXZlID0ge1xuICBuYW1lOiAna2VlcC1hbGl2ZScsXG4gIGFic3RyYWN0OiB0cnVlLFxuXG4gIHByb3BzOiB7XG4gICAgaW5jbHVkZTogcGF0dGVyblR5cGVzLFxuICAgIGV4Y2x1ZGU6IHBhdHRlcm5UeXBlcyxcbiAgICBtYXg6IFtTdHJpbmcsIE51bWJlcl1cbiAgfSxcblxuICBjcmVhdGVkOiBmdW5jdGlvbiBjcmVhdGVkICgpIHtcbiAgICB0aGlzLmNhY2hlID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICB0aGlzLmtleXMgPSBbXTtcbiAgfSxcblxuICBkZXN0cm95ZWQ6IGZ1bmN0aW9uIGRlc3Ryb3llZCAoKSB7XG4gICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgICBmb3IgKHZhciBrZXkgaW4gdGhpcyQxLmNhY2hlKSB7XG4gICAgICBwcnVuZUNhY2hlRW50cnkodGhpcyQxLmNhY2hlLCBrZXksIHRoaXMkMS5rZXlzKTtcbiAgICB9XG4gIH0sXG5cbiAgd2F0Y2g6IHtcbiAgICBpbmNsdWRlOiBmdW5jdGlvbiBpbmNsdWRlICh2YWwpIHtcbiAgICAgIHBydW5lQ2FjaGUodGhpcywgZnVuY3Rpb24gKG5hbWUpIHsgcmV0dXJuIG1hdGNoZXModmFsLCBuYW1lKTsgfSk7XG4gICAgfSxcbiAgICBleGNsdWRlOiBmdW5jdGlvbiBleGNsdWRlICh2YWwpIHtcbiAgICAgIHBydW5lQ2FjaGUodGhpcywgZnVuY3Rpb24gKG5hbWUpIHsgcmV0dXJuICFtYXRjaGVzKHZhbCwgbmFtZSk7IH0pO1xuICAgIH1cbiAgfSxcblxuICByZW5kZXI6IGZ1bmN0aW9uIHJlbmRlciAoKSB7XG4gICAgdmFyIHNsb3QgPSB0aGlzLiRzbG90cy5kZWZhdWx0O1xuICAgIHZhciB2bm9kZSA9IGdldEZpcnN0Q29tcG9uZW50Q2hpbGQoc2xvdCk7XG4gICAgdmFyIGNvbXBvbmVudE9wdGlvbnMgPSB2bm9kZSAmJiB2bm9kZS5jb21wb25lbnRPcHRpb25zO1xuICAgIGlmIChjb21wb25lbnRPcHRpb25zKSB7XG4gICAgICAvLyBjaGVjayBwYXR0ZXJuXG4gICAgICB2YXIgbmFtZSA9IGdldENvbXBvbmVudE5hbWUoY29tcG9uZW50T3B0aW9ucyk7XG4gICAgICB2YXIgcmVmID0gdGhpcztcbiAgICAgIHZhciBpbmNsdWRlID0gcmVmLmluY2x1ZGU7XG4gICAgICB2YXIgZXhjbHVkZSA9IHJlZi5leGNsdWRlO1xuICAgICAgaWYgKFxuICAgICAgICAvLyBub3QgaW5jbHVkZWRcbiAgICAgICAgKGluY2x1ZGUgJiYgKCFuYW1lIHx8ICFtYXRjaGVzKGluY2x1ZGUsIG5hbWUpKSkgfHxcbiAgICAgICAgLy8gZXhjbHVkZWRcbiAgICAgICAgKGV4Y2x1ZGUgJiYgbmFtZSAmJiBtYXRjaGVzKGV4Y2x1ZGUsIG5hbWUpKVxuICAgICAgKSB7XG4gICAgICAgIHJldHVybiB2bm9kZVxuICAgICAgfVxuXG4gICAgICB2YXIgcmVmJDEgPSB0aGlzO1xuICAgICAgdmFyIGNhY2hlID0gcmVmJDEuY2FjaGU7XG4gICAgICB2YXIga2V5cyA9IHJlZiQxLmtleXM7XG4gICAgICB2YXIga2V5ID0gdm5vZGUua2V5ID09IG51bGxcbiAgICAgICAgLy8gc2FtZSBjb25zdHJ1Y3RvciBtYXkgZ2V0IHJlZ2lzdGVyZWQgYXMgZGlmZmVyZW50IGxvY2FsIGNvbXBvbmVudHNcbiAgICAgICAgLy8gc28gY2lkIGFsb25lIGlzIG5vdCBlbm91Z2ggKCMzMjY5KVxuICAgICAgICA/IGNvbXBvbmVudE9wdGlvbnMuQ3Rvci5jaWQgKyAoY29tcG9uZW50T3B0aW9ucy50YWcgPyAoXCI6OlwiICsgKGNvbXBvbmVudE9wdGlvbnMudGFnKSkgOiAnJylcbiAgICAgICAgOiB2bm9kZS5rZXk7XG4gICAgICBpZiAoY2FjaGVba2V5XSkge1xuICAgICAgICB2bm9kZS5jb21wb25lbnRJbnN0YW5jZSA9IGNhY2hlW2tleV0uY29tcG9uZW50SW5zdGFuY2U7XG4gICAgICAgIC8vIG1ha2UgY3VycmVudCBrZXkgZnJlc2hlc3RcbiAgICAgICAgcmVtb3ZlKGtleXMsIGtleSk7XG4gICAgICAgIGtleXMucHVzaChrZXkpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY2FjaGVba2V5XSA9IHZub2RlO1xuICAgICAgICBrZXlzLnB1c2goa2V5KTtcbiAgICAgICAgLy8gcHJ1bmUgb2xkZXN0IGVudHJ5XG4gICAgICAgIGlmICh0aGlzLm1heCAmJiBrZXlzLmxlbmd0aCA+IHBhcnNlSW50KHRoaXMubWF4KSkge1xuICAgICAgICAgIHBydW5lQ2FjaGVFbnRyeShjYWNoZSwga2V5c1swXSwga2V5cywgdGhpcy5fdm5vZGUpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHZub2RlLmRhdGEua2VlcEFsaXZlID0gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIHZub2RlIHx8IChzbG90ICYmIHNsb3RbMF0pXG4gIH1cbn07XG5cbnZhciBidWlsdEluQ29tcG9uZW50cyA9IHtcbiAgS2VlcEFsaXZlOiBLZWVwQWxpdmVcbn07XG5cbi8qICAqL1xuXG5mdW5jdGlvbiBpbml0R2xvYmFsQVBJIChWdWUpIHtcbiAgLy8gY29uZmlnXG4gIHZhciBjb25maWdEZWYgPSB7fTtcbiAgY29uZmlnRGVmLmdldCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGNvbmZpZzsgfTtcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICBjb25maWdEZWYuc2V0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgd2FybihcbiAgICAgICAgJ0RvIG5vdCByZXBsYWNlIHRoZSBWdWUuY29uZmlnIG9iamVjdCwgc2V0IGluZGl2aWR1YWwgZmllbGRzIGluc3RlYWQuJ1xuICAgICAgKTtcbiAgICB9O1xuICB9XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShWdWUsICdjb25maWcnLCBjb25maWdEZWYpO1xuXG4gIC8vIGV4cG9zZWQgdXRpbCBtZXRob2RzLlxuICAvLyBOT1RFOiB0aGVzZSBhcmUgbm90IGNvbnNpZGVyZWQgcGFydCBvZiB0aGUgcHVibGljIEFQSSAtIGF2b2lkIHJlbHlpbmcgb25cbiAgLy8gdGhlbSB1bmxlc3MgeW91IGFyZSBhd2FyZSBvZiB0aGUgcmlzay5cbiAgVnVlLnV0aWwgPSB7XG4gICAgd2Fybjogd2FybixcbiAgICBleHRlbmQ6IGV4dGVuZCxcbiAgICBtZXJnZU9wdGlvbnM6IG1lcmdlT3B0aW9ucyxcbiAgICBkZWZpbmVSZWFjdGl2ZTogZGVmaW5lUmVhY3RpdmVcbiAgfTtcblxuICBWdWUuc2V0ID0gc2V0O1xuICBWdWUuZGVsZXRlID0gZGVsO1xuICBWdWUubmV4dFRpY2sgPSBuZXh0VGljaztcblxuICBWdWUub3B0aW9ucyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gIEFTU0VUX1RZUEVTLmZvckVhY2goZnVuY3Rpb24gKHR5cGUpIHtcbiAgICBWdWUub3B0aW9uc1t0eXBlICsgJ3MnXSA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gIH0pO1xuXG4gIC8vIHRoaXMgaXMgdXNlZCB0byBpZGVudGlmeSB0aGUgXCJiYXNlXCIgY29uc3RydWN0b3IgdG8gZXh0ZW5kIGFsbCBwbGFpbi1vYmplY3RcbiAgLy8gY29tcG9uZW50cyB3aXRoIGluIFdlZXgncyBtdWx0aS1pbnN0YW5jZSBzY2VuYXJpb3MuXG4gIFZ1ZS5vcHRpb25zLl9iYXNlID0gVnVlO1xuXG4gIGV4dGVuZChWdWUub3B0aW9ucy5jb21wb25lbnRzLCBidWlsdEluQ29tcG9uZW50cyk7XG5cbiAgaW5pdFVzZShWdWUpO1xuICBpbml0TWl4aW4kMShWdWUpO1xuICBpbml0RXh0ZW5kKFZ1ZSk7XG4gIGluaXRBc3NldFJlZ2lzdGVycyhWdWUpO1xufVxuXG5pbml0R2xvYmFsQVBJKFZ1ZSQzKTtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KFZ1ZSQzLnByb3RvdHlwZSwgJyRpc1NlcnZlcicsIHtcbiAgZ2V0OiBpc1NlcnZlclJlbmRlcmluZ1xufSk7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShWdWUkMy5wcm90b3R5cGUsICckc3NyQ29udGV4dCcsIHtcbiAgZ2V0OiBmdW5jdGlvbiBnZXQgKCkge1xuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgcmV0dXJuIHRoaXMuJHZub2RlICYmIHRoaXMuJHZub2RlLnNzckNvbnRleHRcbiAgfVxufSk7XG5cblZ1ZSQzLnZlcnNpb24gPSAnMi41LjExJztcblxuLyogICovXG5cbi8vIHRoZXNlIGFyZSByZXNlcnZlZCBmb3Igd2ViIGJlY2F1c2UgdGhleSBhcmUgZGlyZWN0bHkgY29tcGlsZWQgYXdheVxuLy8gZHVyaW5nIHRlbXBsYXRlIGNvbXBpbGF0aW9uXG52YXIgaXNSZXNlcnZlZEF0dHIgPSBtYWtlTWFwKCdzdHlsZSxjbGFzcycpO1xuXG4vLyBhdHRyaWJ1dGVzIHRoYXQgc2hvdWxkIGJlIHVzaW5nIHByb3BzIGZvciBiaW5kaW5nXG52YXIgYWNjZXB0VmFsdWUgPSBtYWtlTWFwKCdpbnB1dCx0ZXh0YXJlYSxvcHRpb24sc2VsZWN0LHByb2dyZXNzJyk7XG52YXIgbXVzdFVzZVByb3AgPSBmdW5jdGlvbiAodGFnLCB0eXBlLCBhdHRyKSB7XG4gIHJldHVybiAoXG4gICAgKGF0dHIgPT09ICd2YWx1ZScgJiYgYWNjZXB0VmFsdWUodGFnKSkgJiYgdHlwZSAhPT0gJ2J1dHRvbicgfHxcbiAgICAoYXR0ciA9PT0gJ3NlbGVjdGVkJyAmJiB0YWcgPT09ICdvcHRpb24nKSB8fFxuICAgIChhdHRyID09PSAnY2hlY2tlZCcgJiYgdGFnID09PSAnaW5wdXQnKSB8fFxuICAgIChhdHRyID09PSAnbXV0ZWQnICYmIHRhZyA9PT0gJ3ZpZGVvJylcbiAgKVxufTtcblxudmFyIGlzRW51bWVyYXRlZEF0dHIgPSBtYWtlTWFwKCdjb250ZW50ZWRpdGFibGUsZHJhZ2dhYmxlLHNwZWxsY2hlY2snKTtcblxudmFyIGlzQm9vbGVhbkF0dHIgPSBtYWtlTWFwKFxuICAnYWxsb3dmdWxsc2NyZWVuLGFzeW5jLGF1dG9mb2N1cyxhdXRvcGxheSxjaGVja2VkLGNvbXBhY3QsY29udHJvbHMsZGVjbGFyZSwnICtcbiAgJ2RlZmF1bHQsZGVmYXVsdGNoZWNrZWQsZGVmYXVsdG11dGVkLGRlZmF1bHRzZWxlY3RlZCxkZWZlcixkaXNhYmxlZCwnICtcbiAgJ2VuYWJsZWQsZm9ybW5vdmFsaWRhdGUsaGlkZGVuLGluZGV0ZXJtaW5hdGUsaW5lcnQsaXNtYXAsaXRlbXNjb3BlLGxvb3AsbXVsdGlwbGUsJyArXG4gICdtdXRlZCxub2hyZWYsbm9yZXNpemUsbm9zaGFkZSxub3ZhbGlkYXRlLG5vd3JhcCxvcGVuLHBhdXNlb25leGl0LHJlYWRvbmx5LCcgK1xuICAncmVxdWlyZWQscmV2ZXJzZWQsc2NvcGVkLHNlYW1sZXNzLHNlbGVjdGVkLHNvcnRhYmxlLHRyYW5zbGF0ZSwnICtcbiAgJ3RydWVzcGVlZCx0eXBlbXVzdG1hdGNoLHZpc2libGUnXG4pO1xuXG52YXIgeGxpbmtOUyA9ICdodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hsaW5rJztcblxudmFyIGlzWGxpbmsgPSBmdW5jdGlvbiAobmFtZSkge1xuICByZXR1cm4gbmFtZS5jaGFyQXQoNSkgPT09ICc6JyAmJiBuYW1lLnNsaWNlKDAsIDUpID09PSAneGxpbmsnXG59O1xuXG52YXIgZ2V0WGxpbmtQcm9wID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgcmV0dXJuIGlzWGxpbmsobmFtZSkgPyBuYW1lLnNsaWNlKDYsIG5hbWUubGVuZ3RoKSA6ICcnXG59O1xuXG52YXIgaXNGYWxzeUF0dHJWYWx1ZSA9IGZ1bmN0aW9uICh2YWwpIHtcbiAgcmV0dXJuIHZhbCA9PSBudWxsIHx8IHZhbCA9PT0gZmFsc2Vcbn07XG5cbi8qICAqL1xuXG5mdW5jdGlvbiBnZW5DbGFzc0ZvclZub2RlICh2bm9kZSkge1xuICB2YXIgZGF0YSA9IHZub2RlLmRhdGE7XG4gIHZhciBwYXJlbnROb2RlID0gdm5vZGU7XG4gIHZhciBjaGlsZE5vZGUgPSB2bm9kZTtcbiAgd2hpbGUgKGlzRGVmKGNoaWxkTm9kZS5jb21wb25lbnRJbnN0YW5jZSkpIHtcbiAgICBjaGlsZE5vZGUgPSBjaGlsZE5vZGUuY29tcG9uZW50SW5zdGFuY2UuX3Zub2RlO1xuICAgIGlmIChjaGlsZE5vZGUgJiYgY2hpbGROb2RlLmRhdGEpIHtcbiAgICAgIGRhdGEgPSBtZXJnZUNsYXNzRGF0YShjaGlsZE5vZGUuZGF0YSwgZGF0YSk7XG4gICAgfVxuICB9XG4gIHdoaWxlIChpc0RlZihwYXJlbnROb2RlID0gcGFyZW50Tm9kZS5wYXJlbnQpKSB7XG4gICAgaWYgKHBhcmVudE5vZGUgJiYgcGFyZW50Tm9kZS5kYXRhKSB7XG4gICAgICBkYXRhID0gbWVyZ2VDbGFzc0RhdGEoZGF0YSwgcGFyZW50Tm9kZS5kYXRhKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlbmRlckNsYXNzKGRhdGEuc3RhdGljQ2xhc3MsIGRhdGEuY2xhc3MpXG59XG5cbmZ1bmN0aW9uIG1lcmdlQ2xhc3NEYXRhIChjaGlsZCwgcGFyZW50KSB7XG4gIHJldHVybiB7XG4gICAgc3RhdGljQ2xhc3M6IGNvbmNhdChjaGlsZC5zdGF0aWNDbGFzcywgcGFyZW50LnN0YXRpY0NsYXNzKSxcbiAgICBjbGFzczogaXNEZWYoY2hpbGQuY2xhc3MpXG4gICAgICA/IFtjaGlsZC5jbGFzcywgcGFyZW50LmNsYXNzXVxuICAgICAgOiBwYXJlbnQuY2xhc3NcbiAgfVxufVxuXG5mdW5jdGlvbiByZW5kZXJDbGFzcyAoXG4gIHN0YXRpY0NsYXNzLFxuICBkeW5hbWljQ2xhc3Ncbikge1xuICBpZiAoaXNEZWYoc3RhdGljQ2xhc3MpIHx8IGlzRGVmKGR5bmFtaWNDbGFzcykpIHtcbiAgICByZXR1cm4gY29uY2F0KHN0YXRpY0NsYXNzLCBzdHJpbmdpZnlDbGFzcyhkeW5hbWljQ2xhc3MpKVxuICB9XG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gIHJldHVybiAnJ1xufVxuXG5mdW5jdGlvbiBjb25jYXQgKGEsIGIpIHtcbiAgcmV0dXJuIGEgPyBiID8gKGEgKyAnICcgKyBiKSA6IGEgOiAoYiB8fCAnJylcbn1cblxuZnVuY3Rpb24gc3RyaW5naWZ5Q2xhc3MgKHZhbHVlKSB7XG4gIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgIHJldHVybiBzdHJpbmdpZnlBcnJheSh2YWx1ZSlcbiAgfVxuICBpZiAoaXNPYmplY3QodmFsdWUpKSB7XG4gICAgcmV0dXJuIHN0cmluZ2lmeU9iamVjdCh2YWx1ZSlcbiAgfVxuICBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJykge1xuICAgIHJldHVybiB2YWx1ZVxuICB9XG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gIHJldHVybiAnJ1xufVxuXG5mdW5jdGlvbiBzdHJpbmdpZnlBcnJheSAodmFsdWUpIHtcbiAgdmFyIHJlcyA9ICcnO1xuICB2YXIgc3RyaW5naWZpZWQ7XG4gIGZvciAodmFyIGkgPSAwLCBsID0gdmFsdWUubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgaWYgKGlzRGVmKHN0cmluZ2lmaWVkID0gc3RyaW5naWZ5Q2xhc3ModmFsdWVbaV0pKSAmJiBzdHJpbmdpZmllZCAhPT0gJycpIHtcbiAgICAgIGlmIChyZXMpIHsgcmVzICs9ICcgJzsgfVxuICAgICAgcmVzICs9IHN0cmluZ2lmaWVkO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzXG59XG5cbmZ1bmN0aW9uIHN0cmluZ2lmeU9iamVjdCAodmFsdWUpIHtcbiAgdmFyIHJlcyA9ICcnO1xuICBmb3IgKHZhciBrZXkgaW4gdmFsdWUpIHtcbiAgICBpZiAodmFsdWVba2V5XSkge1xuICAgICAgaWYgKHJlcykgeyByZXMgKz0gJyAnOyB9XG4gICAgICByZXMgKz0ga2V5O1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzXG59XG5cbi8qICAqL1xuXG52YXIgbmFtZXNwYWNlTWFwID0ge1xuICBzdmc6ICdodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZycsXG4gIG1hdGg6ICdodHRwOi8vd3d3LnczLm9yZy8xOTk4L01hdGgvTWF0aE1MJ1xufTtcblxudmFyIGlzSFRNTFRhZyA9IG1ha2VNYXAoXG4gICdodG1sLGJvZHksYmFzZSxoZWFkLGxpbmssbWV0YSxzdHlsZSx0aXRsZSwnICtcbiAgJ2FkZHJlc3MsYXJ0aWNsZSxhc2lkZSxmb290ZXIsaGVhZGVyLGgxLGgyLGgzLGg0LGg1LGg2LGhncm91cCxuYXYsc2VjdGlvbiwnICtcbiAgJ2RpdixkZCxkbCxkdCxmaWdjYXB0aW9uLGZpZ3VyZSxwaWN0dXJlLGhyLGltZyxsaSxtYWluLG9sLHAscHJlLHVsLCcgK1xuICAnYSxiLGFiYnIsYmRpLGJkbyxicixjaXRlLGNvZGUsZGF0YSxkZm4sZW0saSxrYmQsbWFyayxxLHJwLHJ0LHJ0YyxydWJ5LCcgK1xuICAncyxzYW1wLHNtYWxsLHNwYW4sc3Ryb25nLHN1YixzdXAsdGltZSx1LHZhcix3YnIsYXJlYSxhdWRpbyxtYXAsdHJhY2ssdmlkZW8sJyArXG4gICdlbWJlZCxvYmplY3QscGFyYW0sc291cmNlLGNhbnZhcyxzY3JpcHQsbm9zY3JpcHQsZGVsLGlucywnICtcbiAgJ2NhcHRpb24sY29sLGNvbGdyb3VwLHRhYmxlLHRoZWFkLHRib2R5LHRkLHRoLHRyLCcgK1xuICAnYnV0dG9uLGRhdGFsaXN0LGZpZWxkc2V0LGZvcm0saW5wdXQsbGFiZWwsbGVnZW5kLG1ldGVyLG9wdGdyb3VwLG9wdGlvbiwnICtcbiAgJ291dHB1dCxwcm9ncmVzcyxzZWxlY3QsdGV4dGFyZWEsJyArXG4gICdkZXRhaWxzLGRpYWxvZyxtZW51LG1lbnVpdGVtLHN1bW1hcnksJyArXG4gICdjb250ZW50LGVsZW1lbnQsc2hhZG93LHRlbXBsYXRlLGJsb2NrcXVvdGUsaWZyYW1lLHRmb290J1xuKTtcblxuLy8gdGhpcyBtYXAgaXMgaW50ZW50aW9uYWxseSBzZWxlY3RpdmUsIG9ubHkgY292ZXJpbmcgU1ZHIGVsZW1lbnRzIHRoYXQgbWF5XG4vLyBjb250YWluIGNoaWxkIGVsZW1lbnRzLlxudmFyIGlzU1ZHID0gbWFrZU1hcChcbiAgJ3N2ZyxhbmltYXRlLGNpcmNsZSxjbGlwcGF0aCxjdXJzb3IsZGVmcyxkZXNjLGVsbGlwc2UsZmlsdGVyLGZvbnQtZmFjZSwnICtcbiAgJ2ZvcmVpZ25PYmplY3QsZyxnbHlwaCxpbWFnZSxsaW5lLG1hcmtlcixtYXNrLG1pc3NpbmctZ2x5cGgscGF0aCxwYXR0ZXJuLCcgK1xuICAncG9seWdvbixwb2x5bGluZSxyZWN0LHN3aXRjaCxzeW1ib2wsdGV4dCx0ZXh0cGF0aCx0c3Bhbix1c2UsdmlldycsXG4gIHRydWVcbik7XG5cbnZhciBpc1ByZVRhZyA9IGZ1bmN0aW9uICh0YWcpIHsgcmV0dXJuIHRhZyA9PT0gJ3ByZSc7IH07XG5cbnZhciBpc1Jlc2VydmVkVGFnID0gZnVuY3Rpb24gKHRhZykge1xuICByZXR1cm4gaXNIVE1MVGFnKHRhZykgfHwgaXNTVkcodGFnKVxufTtcblxuZnVuY3Rpb24gZ2V0VGFnTmFtZXNwYWNlICh0YWcpIHtcbiAgaWYgKGlzU1ZHKHRhZykpIHtcbiAgICByZXR1cm4gJ3N2ZydcbiAgfVxuICAvLyBiYXNpYyBzdXBwb3J0IGZvciBNYXRoTUxcbiAgLy8gbm90ZSBpdCBkb2Vzbid0IHN1cHBvcnQgb3RoZXIgTWF0aE1MIGVsZW1lbnRzIGJlaW5nIGNvbXBvbmVudCByb290c1xuICBpZiAodGFnID09PSAnbWF0aCcpIHtcbiAgICByZXR1cm4gJ21hdGgnXG4gIH1cbn1cblxudmFyIHVua25vd25FbGVtZW50Q2FjaGUgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuZnVuY3Rpb24gaXNVbmtub3duRWxlbWVudCAodGFnKSB7XG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICBpZiAoIWluQnJvd3Nlcikge1xuICAgIHJldHVybiB0cnVlXG4gIH1cbiAgaWYgKGlzUmVzZXJ2ZWRUYWcodGFnKSkge1xuICAgIHJldHVybiBmYWxzZVxuICB9XG4gIHRhZyA9IHRhZy50b0xvd2VyQ2FzZSgpO1xuICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgaWYgKHVua25vd25FbGVtZW50Q2FjaGVbdGFnXSAhPSBudWxsKSB7XG4gICAgcmV0dXJuIHVua25vd25FbGVtZW50Q2FjaGVbdGFnXVxuICB9XG4gIHZhciBlbCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQodGFnKTtcbiAgaWYgKHRhZy5pbmRleE9mKCctJykgPiAtMSkge1xuICAgIC8vIGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9hLzI4MjEwMzY0LzEwNzAyNDRcbiAgICByZXR1cm4gKHVua25vd25FbGVtZW50Q2FjaGVbdGFnXSA9IChcbiAgICAgIGVsLmNvbnN0cnVjdG9yID09PSB3aW5kb3cuSFRNTFVua25vd25FbGVtZW50IHx8XG4gICAgICBlbC5jb25zdHJ1Y3RvciA9PT0gd2luZG93LkhUTUxFbGVtZW50XG4gICAgKSlcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gKHVua25vd25FbGVtZW50Q2FjaGVbdGFnXSA9IC9IVE1MVW5rbm93bkVsZW1lbnQvLnRlc3QoZWwudG9TdHJpbmcoKSkpXG4gIH1cbn1cblxudmFyIGlzVGV4dElucHV0VHlwZSA9IG1ha2VNYXAoJ3RleHQsbnVtYmVyLHBhc3N3b3JkLHNlYXJjaCxlbWFpbCx0ZWwsdXJsJyk7XG5cbi8qICAqL1xuXG4vKipcbiAqIFF1ZXJ5IGFuIGVsZW1lbnQgc2VsZWN0b3IgaWYgaXQncyBub3QgYW4gZWxlbWVudCBhbHJlYWR5LlxuICovXG5mdW5jdGlvbiBxdWVyeSAoZWwpIHtcbiAgaWYgKHR5cGVvZiBlbCA9PT0gJ3N0cmluZycpIHtcbiAgICB2YXIgc2VsZWN0ZWQgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKGVsKTtcbiAgICBpZiAoIXNlbGVjdGVkKSB7XG4gICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIHdhcm4oXG4gICAgICAgICdDYW5ub3QgZmluZCBlbGVtZW50OiAnICsgZWxcbiAgICAgICk7XG4gICAgICByZXR1cm4gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2JylcbiAgICB9XG4gICAgcmV0dXJuIHNlbGVjdGVkXG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGVsXG4gIH1cbn1cblxuLyogICovXG5cbmZ1bmN0aW9uIGNyZWF0ZUVsZW1lbnQkMSAodGFnTmFtZSwgdm5vZGUpIHtcbiAgdmFyIGVsbSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQodGFnTmFtZSk7XG4gIGlmICh0YWdOYW1lICE9PSAnc2VsZWN0Jykge1xuICAgIHJldHVybiBlbG1cbiAgfVxuICAvLyBmYWxzZSBvciBudWxsIHdpbGwgcmVtb3ZlIHRoZSBhdHRyaWJ1dGUgYnV0IHVuZGVmaW5lZCB3aWxsIG5vdFxuICBpZiAodm5vZGUuZGF0YSAmJiB2bm9kZS5kYXRhLmF0dHJzICYmIHZub2RlLmRhdGEuYXR0cnMubXVsdGlwbGUgIT09IHVuZGVmaW5lZCkge1xuICAgIGVsbS5zZXRBdHRyaWJ1dGUoJ211bHRpcGxlJywgJ211bHRpcGxlJyk7XG4gIH1cbiAgcmV0dXJuIGVsbVxufVxuXG5mdW5jdGlvbiBjcmVhdGVFbGVtZW50TlMgKG5hbWVzcGFjZSwgdGFnTmFtZSkge1xuICByZXR1cm4gZG9jdW1lbnQuY3JlYXRlRWxlbWVudE5TKG5hbWVzcGFjZU1hcFtuYW1lc3BhY2VdLCB0YWdOYW1lKVxufVxuXG5mdW5jdGlvbiBjcmVhdGVUZXh0Tm9kZSAodGV4dCkge1xuICByZXR1cm4gZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUodGV4dClcbn1cblxuZnVuY3Rpb24gY3JlYXRlQ29tbWVudCAodGV4dCkge1xuICByZXR1cm4gZG9jdW1lbnQuY3JlYXRlQ29tbWVudCh0ZXh0KVxufVxuXG5mdW5jdGlvbiBpbnNlcnRCZWZvcmUgKHBhcmVudE5vZGUsIG5ld05vZGUsIHJlZmVyZW5jZU5vZGUpIHtcbiAgcGFyZW50Tm9kZS5pbnNlcnRCZWZvcmUobmV3Tm9kZSwgcmVmZXJlbmNlTm9kZSk7XG59XG5cbmZ1bmN0aW9uIHJlbW92ZUNoaWxkIChub2RlLCBjaGlsZCkge1xuICBub2RlLnJlbW92ZUNoaWxkKGNoaWxkKTtcbn1cblxuZnVuY3Rpb24gYXBwZW5kQ2hpbGQgKG5vZGUsIGNoaWxkKSB7XG4gIG5vZGUuYXBwZW5kQ2hpbGQoY2hpbGQpO1xufVxuXG5mdW5jdGlvbiBwYXJlbnROb2RlIChub2RlKSB7XG4gIHJldHVybiBub2RlLnBhcmVudE5vZGVcbn1cblxuZnVuY3Rpb24gbmV4dFNpYmxpbmcgKG5vZGUpIHtcbiAgcmV0dXJuIG5vZGUubmV4dFNpYmxpbmdcbn1cblxuZnVuY3Rpb24gdGFnTmFtZSAobm9kZSkge1xuICByZXR1cm4gbm9kZS50YWdOYW1lXG59XG5cbmZ1bmN0aW9uIHNldFRleHRDb250ZW50IChub2RlLCB0ZXh0KSB7XG4gIG5vZGUudGV4dENvbnRlbnQgPSB0ZXh0O1xufVxuXG5mdW5jdGlvbiBzZXRBdHRyaWJ1dGUgKG5vZGUsIGtleSwgdmFsKSB7XG4gIG5vZGUuc2V0QXR0cmlidXRlKGtleSwgdmFsKTtcbn1cblxuXG52YXIgbm9kZU9wcyA9IE9iamVjdC5mcmVlemUoe1xuXHRjcmVhdGVFbGVtZW50OiBjcmVhdGVFbGVtZW50JDEsXG5cdGNyZWF0ZUVsZW1lbnROUzogY3JlYXRlRWxlbWVudE5TLFxuXHRjcmVhdGVUZXh0Tm9kZTogY3JlYXRlVGV4dE5vZGUsXG5cdGNyZWF0ZUNvbW1lbnQ6IGNyZWF0ZUNvbW1lbnQsXG5cdGluc2VydEJlZm9yZTogaW5zZXJ0QmVmb3JlLFxuXHRyZW1vdmVDaGlsZDogcmVtb3ZlQ2hpbGQsXG5cdGFwcGVuZENoaWxkOiBhcHBlbmRDaGlsZCxcblx0cGFyZW50Tm9kZTogcGFyZW50Tm9kZSxcblx0bmV4dFNpYmxpbmc6IG5leHRTaWJsaW5nLFxuXHR0YWdOYW1lOiB0YWdOYW1lLFxuXHRzZXRUZXh0Q29udGVudDogc2V0VGV4dENvbnRlbnQsXG5cdHNldEF0dHJpYnV0ZTogc2V0QXR0cmlidXRlXG59KTtcblxuLyogICovXG5cbnZhciByZWYgPSB7XG4gIGNyZWF0ZTogZnVuY3Rpb24gY3JlYXRlIChfLCB2bm9kZSkge1xuICAgIHJlZ2lzdGVyUmVmKHZub2RlKTtcbiAgfSxcbiAgdXBkYXRlOiBmdW5jdGlvbiB1cGRhdGUgKG9sZFZub2RlLCB2bm9kZSkge1xuICAgIGlmIChvbGRWbm9kZS5kYXRhLnJlZiAhPT0gdm5vZGUuZGF0YS5yZWYpIHtcbiAgICAgIHJlZ2lzdGVyUmVmKG9sZFZub2RlLCB0cnVlKTtcbiAgICAgIHJlZ2lzdGVyUmVmKHZub2RlKTtcbiAgICB9XG4gIH0sXG4gIGRlc3Ryb3k6IGZ1bmN0aW9uIGRlc3Ryb3kgKHZub2RlKSB7XG4gICAgcmVnaXN0ZXJSZWYodm5vZGUsIHRydWUpO1xuICB9XG59O1xuXG5mdW5jdGlvbiByZWdpc3RlclJlZiAodm5vZGUsIGlzUmVtb3ZhbCkge1xuICB2YXIga2V5ID0gdm5vZGUuZGF0YS5yZWY7XG4gIGlmICgha2V5KSB7IHJldHVybiB9XG5cbiAgdmFyIHZtID0gdm5vZGUuY29udGV4dDtcbiAgdmFyIHJlZiA9IHZub2RlLmNvbXBvbmVudEluc3RhbmNlIHx8IHZub2RlLmVsbTtcbiAgdmFyIHJlZnMgPSB2bS4kcmVmcztcbiAgaWYgKGlzUmVtb3ZhbCkge1xuICAgIGlmIChBcnJheS5pc0FycmF5KHJlZnNba2V5XSkpIHtcbiAgICAgIHJlbW92ZShyZWZzW2tleV0sIHJlZik7XG4gICAgfSBlbHNlIGlmIChyZWZzW2tleV0gPT09IHJlZikge1xuICAgICAgcmVmc1trZXldID0gdW5kZWZpbmVkO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBpZiAodm5vZGUuZGF0YS5yZWZJbkZvcikge1xuICAgICAgaWYgKCFBcnJheS5pc0FycmF5KHJlZnNba2V5XSkpIHtcbiAgICAgICAgcmVmc1trZXldID0gW3JlZl07XG4gICAgICB9IGVsc2UgaWYgKHJlZnNba2V5XS5pbmRleE9mKHJlZikgPCAwKSB7XG4gICAgICAgIC8vICRmbG93LWRpc2FibGUtbGluZVxuICAgICAgICByZWZzW2tleV0ucHVzaChyZWYpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICByZWZzW2tleV0gPSByZWY7XG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogVmlydHVhbCBET00gcGF0Y2hpbmcgYWxnb3JpdGhtIGJhc2VkIG9uIFNuYWJiZG9tIGJ5XG4gKiBTaW1vbiBGcmlpcyBWaW5kdW0gKEBwYWxkZXBpbmQpXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2VcbiAqIGh0dHBzOi8vZ2l0aHViLmNvbS9wYWxkZXBpbmQvc25hYmJkb20vYmxvYi9tYXN0ZXIvTElDRU5TRVxuICpcbiAqIG1vZGlmaWVkIGJ5IEV2YW4gWW91IChAeXl4OTkwODAzKVxuICpcbiAqIE5vdCB0eXBlLWNoZWNraW5nIHRoaXMgYmVjYXVzZSB0aGlzIGZpbGUgaXMgcGVyZi1jcml0aWNhbCBhbmQgdGhlIGNvc3RcbiAqIG9mIG1ha2luZyBmbG93IHVuZGVyc3RhbmQgaXQgaXMgbm90IHdvcnRoIGl0LlxuICovXG5cbnZhciBlbXB0eU5vZGUgPSBuZXcgVk5vZGUoJycsIHt9LCBbXSk7XG5cbnZhciBob29rcyA9IFsnY3JlYXRlJywgJ2FjdGl2YXRlJywgJ3VwZGF0ZScsICdyZW1vdmUnLCAnZGVzdHJveSddO1xuXG5mdW5jdGlvbiBzYW1lVm5vZGUgKGEsIGIpIHtcbiAgcmV0dXJuIChcbiAgICBhLmtleSA9PT0gYi5rZXkgJiYgKFxuICAgICAgKFxuICAgICAgICBhLnRhZyA9PT0gYi50YWcgJiZcbiAgICAgICAgYS5pc0NvbW1lbnQgPT09IGIuaXNDb21tZW50ICYmXG4gICAgICAgIGlzRGVmKGEuZGF0YSkgPT09IGlzRGVmKGIuZGF0YSkgJiZcbiAgICAgICAgc2FtZUlucHV0VHlwZShhLCBiKVxuICAgICAgKSB8fCAoXG4gICAgICAgIGlzVHJ1ZShhLmlzQXN5bmNQbGFjZWhvbGRlcikgJiZcbiAgICAgICAgYS5hc3luY0ZhY3RvcnkgPT09IGIuYXN5bmNGYWN0b3J5ICYmXG4gICAgICAgIGlzVW5kZWYoYi5hc3luY0ZhY3RvcnkuZXJyb3IpXG4gICAgICApXG4gICAgKVxuICApXG59XG5cbmZ1bmN0aW9uIHNhbWVJbnB1dFR5cGUgKGEsIGIpIHtcbiAgaWYgKGEudGFnICE9PSAnaW5wdXQnKSB7IHJldHVybiB0cnVlIH1cbiAgdmFyIGk7XG4gIHZhciB0eXBlQSA9IGlzRGVmKGkgPSBhLmRhdGEpICYmIGlzRGVmKGkgPSBpLmF0dHJzKSAmJiBpLnR5cGU7XG4gIHZhciB0eXBlQiA9IGlzRGVmKGkgPSBiLmRhdGEpICYmIGlzRGVmKGkgPSBpLmF0dHJzKSAmJiBpLnR5cGU7XG4gIHJldHVybiB0eXBlQSA9PT0gdHlwZUIgfHwgaXNUZXh0SW5wdXRUeXBlKHR5cGVBKSAmJiBpc1RleHRJbnB1dFR5cGUodHlwZUIpXG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUtleVRvT2xkSWR4IChjaGlsZHJlbiwgYmVnaW5JZHgsIGVuZElkeCkge1xuICB2YXIgaSwga2V5O1xuICB2YXIgbWFwID0ge307XG4gIGZvciAoaSA9IGJlZ2luSWR4OyBpIDw9IGVuZElkeDsgKytpKSB7XG4gICAga2V5ID0gY2hpbGRyZW5baV0ua2V5O1xuICAgIGlmIChpc0RlZihrZXkpKSB7IG1hcFtrZXldID0gaTsgfVxuICB9XG4gIHJldHVybiBtYXBcbn1cblxuZnVuY3Rpb24gY3JlYXRlUGF0Y2hGdW5jdGlvbiAoYmFja2VuZCkge1xuICB2YXIgaSwgajtcbiAgdmFyIGNicyA9IHt9O1xuXG4gIHZhciBtb2R1bGVzID0gYmFja2VuZC5tb2R1bGVzO1xuICB2YXIgbm9kZU9wcyA9IGJhY2tlbmQubm9kZU9wcztcblxuICBmb3IgKGkgPSAwOyBpIDwgaG9va3MubGVuZ3RoOyArK2kpIHtcbiAgICBjYnNbaG9va3NbaV1dID0gW107XG4gICAgZm9yIChqID0gMDsgaiA8IG1vZHVsZXMubGVuZ3RoOyArK2opIHtcbiAgICAgIGlmIChpc0RlZihtb2R1bGVzW2pdW2hvb2tzW2ldXSkpIHtcbiAgICAgICAgY2JzW2hvb2tzW2ldXS5wdXNoKG1vZHVsZXNbal1baG9va3NbaV1dKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBlbXB0eU5vZGVBdCAoZWxtKSB7XG4gICAgcmV0dXJuIG5ldyBWTm9kZShub2RlT3BzLnRhZ05hbWUoZWxtKS50b0xvd2VyQ2FzZSgpLCB7fSwgW10sIHVuZGVmaW5lZCwgZWxtKVxuICB9XG5cbiAgZnVuY3Rpb24gY3JlYXRlUm1DYiAoY2hpbGRFbG0sIGxpc3RlbmVycykge1xuICAgIGZ1bmN0aW9uIHJlbW92ZSAoKSB7XG4gICAgICBpZiAoLS1yZW1vdmUubGlzdGVuZXJzID09PSAwKSB7XG4gICAgICAgIHJlbW92ZU5vZGUoY2hpbGRFbG0pO1xuICAgICAgfVxuICAgIH1cbiAgICByZW1vdmUubGlzdGVuZXJzID0gbGlzdGVuZXJzO1xuICAgIHJldHVybiByZW1vdmVcbiAgfVxuXG4gIGZ1bmN0aW9uIHJlbW92ZU5vZGUgKGVsKSB7XG4gICAgdmFyIHBhcmVudCA9IG5vZGVPcHMucGFyZW50Tm9kZShlbCk7XG4gICAgLy8gZWxlbWVudCBtYXkgaGF2ZSBhbHJlYWR5IGJlZW4gcmVtb3ZlZCBkdWUgdG8gdi1odG1sIC8gdi10ZXh0XG4gICAgaWYgKGlzRGVmKHBhcmVudCkpIHtcbiAgICAgIG5vZGVPcHMucmVtb3ZlQ2hpbGQocGFyZW50LCBlbCk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gaXNVbmtub3duRWxlbWVudCQkMSAodm5vZGUsIGluVlByZSkge1xuICAgIHJldHVybiAoXG4gICAgICAhaW5WUHJlICYmXG4gICAgICAhdm5vZGUubnMgJiZcbiAgICAgICEoXG4gICAgICAgIGNvbmZpZy5pZ25vcmVkRWxlbWVudHMubGVuZ3RoICYmXG4gICAgICAgIGNvbmZpZy5pZ25vcmVkRWxlbWVudHMuc29tZShmdW5jdGlvbiAoaWdub3JlKSB7XG4gICAgICAgICAgcmV0dXJuIGlzUmVnRXhwKGlnbm9yZSlcbiAgICAgICAgICAgID8gaWdub3JlLnRlc3Qodm5vZGUudGFnKVxuICAgICAgICAgICAgOiBpZ25vcmUgPT09IHZub2RlLnRhZ1xuICAgICAgICB9KVxuICAgICAgKSAmJlxuICAgICAgY29uZmlnLmlzVW5rbm93bkVsZW1lbnQodm5vZGUudGFnKVxuICAgIClcbiAgfVxuXG4gIHZhciBjcmVhdGluZ0VsbUluVlByZSA9IDA7XG4gIGZ1bmN0aW9uIGNyZWF0ZUVsbSAodm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSwgcGFyZW50RWxtLCByZWZFbG0sIG5lc3RlZCkge1xuICAgIHZub2RlLmlzUm9vdEluc2VydCA9ICFuZXN0ZWQ7IC8vIGZvciB0cmFuc2l0aW9uIGVudGVyIGNoZWNrXG4gICAgaWYgKGNyZWF0ZUNvbXBvbmVudCh2bm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlLCBwYXJlbnRFbG0sIHJlZkVsbSkpIHtcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIHZhciBkYXRhID0gdm5vZGUuZGF0YTtcbiAgICB2YXIgY2hpbGRyZW4gPSB2bm9kZS5jaGlsZHJlbjtcbiAgICB2YXIgdGFnID0gdm5vZGUudGFnO1xuICAgIGlmIChpc0RlZih0YWcpKSB7XG4gICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICBpZiAoZGF0YSAmJiBkYXRhLnByZSkge1xuICAgICAgICAgIGNyZWF0aW5nRWxtSW5WUHJlKys7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlzVW5rbm93bkVsZW1lbnQkJDEodm5vZGUsIGNyZWF0aW5nRWxtSW5WUHJlKSkge1xuICAgICAgICAgIHdhcm4oXG4gICAgICAgICAgICAnVW5rbm93biBjdXN0b20gZWxlbWVudDogPCcgKyB0YWcgKyAnPiAtIGRpZCB5b3UgJyArXG4gICAgICAgICAgICAncmVnaXN0ZXIgdGhlIGNvbXBvbmVudCBjb3JyZWN0bHk/IEZvciByZWN1cnNpdmUgY29tcG9uZW50cywgJyArXG4gICAgICAgICAgICAnbWFrZSBzdXJlIHRvIHByb3ZpZGUgdGhlIFwibmFtZVwiIG9wdGlvbi4nLFxuICAgICAgICAgICAgdm5vZGUuY29udGV4dFxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHZub2RlLmVsbSA9IHZub2RlLm5zXG4gICAgICAgID8gbm9kZU9wcy5jcmVhdGVFbGVtZW50TlModm5vZGUubnMsIHRhZylcbiAgICAgICAgOiBub2RlT3BzLmNyZWF0ZUVsZW1lbnQodGFnLCB2bm9kZSk7XG4gICAgICBzZXRTY29wZSh2bm9kZSk7XG5cbiAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgICAge1xuICAgICAgICBjcmVhdGVDaGlsZHJlbih2bm9kZSwgY2hpbGRyZW4sIGluc2VydGVkVm5vZGVRdWV1ZSk7XG4gICAgICAgIGlmIChpc0RlZihkYXRhKSkge1xuICAgICAgICAgIGludm9rZUNyZWF0ZUhvb2tzKHZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUpO1xuICAgICAgICB9XG4gICAgICAgIGluc2VydChwYXJlbnRFbG0sIHZub2RlLmVsbSwgcmVmRWxtKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgZGF0YSAmJiBkYXRhLnByZSkge1xuICAgICAgICBjcmVhdGluZ0VsbUluVlByZS0tO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoaXNUcnVlKHZub2RlLmlzQ29tbWVudCkpIHtcbiAgICAgIHZub2RlLmVsbSA9IG5vZGVPcHMuY3JlYXRlQ29tbWVudCh2bm9kZS50ZXh0KTtcbiAgICAgIGluc2VydChwYXJlbnRFbG0sIHZub2RlLmVsbSwgcmVmRWxtKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdm5vZGUuZWxtID0gbm9kZU9wcy5jcmVhdGVUZXh0Tm9kZSh2bm9kZS50ZXh0KTtcbiAgICAgIGluc2VydChwYXJlbnRFbG0sIHZub2RlLmVsbSwgcmVmRWxtKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBjcmVhdGVDb21wb25lbnQgKHZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUsIHBhcmVudEVsbSwgcmVmRWxtKSB7XG4gICAgdmFyIGkgPSB2bm9kZS5kYXRhO1xuICAgIGlmIChpc0RlZihpKSkge1xuICAgICAgdmFyIGlzUmVhY3RpdmF0ZWQgPSBpc0RlZih2bm9kZS5jb21wb25lbnRJbnN0YW5jZSkgJiYgaS5rZWVwQWxpdmU7XG4gICAgICBpZiAoaXNEZWYoaSA9IGkuaG9vaykgJiYgaXNEZWYoaSA9IGkuaW5pdCkpIHtcbiAgICAgICAgaSh2bm9kZSwgZmFsc2UgLyogaHlkcmF0aW5nICovLCBwYXJlbnRFbG0sIHJlZkVsbSk7XG4gICAgICB9XG4gICAgICAvLyBhZnRlciBjYWxsaW5nIHRoZSBpbml0IGhvb2ssIGlmIHRoZSB2bm9kZSBpcyBhIGNoaWxkIGNvbXBvbmVudFxuICAgICAgLy8gaXQgc2hvdWxkJ3ZlIGNyZWF0ZWQgYSBjaGlsZCBpbnN0YW5jZSBhbmQgbW91bnRlZCBpdC4gdGhlIGNoaWxkXG4gICAgICAvLyBjb21wb25lbnQgYWxzbyBoYXMgc2V0IHRoZSBwbGFjZWhvbGRlciB2bm9kZSdzIGVsbS5cbiAgICAgIC8vIGluIHRoYXQgY2FzZSB3ZSBjYW4ganVzdCByZXR1cm4gdGhlIGVsZW1lbnQgYW5kIGJlIGRvbmUuXG4gICAgICBpZiAoaXNEZWYodm5vZGUuY29tcG9uZW50SW5zdGFuY2UpKSB7XG4gICAgICAgIGluaXRDb21wb25lbnQodm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSk7XG4gICAgICAgIGlmIChpc1RydWUoaXNSZWFjdGl2YXRlZCkpIHtcbiAgICAgICAgICByZWFjdGl2YXRlQ29tcG9uZW50KHZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUsIHBhcmVudEVsbSwgcmVmRWxtKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGluaXRDb21wb25lbnQgKHZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUpIHtcbiAgICBpZiAoaXNEZWYodm5vZGUuZGF0YS5wZW5kaW5nSW5zZXJ0KSkge1xuICAgICAgaW5zZXJ0ZWRWbm9kZVF1ZXVlLnB1c2guYXBwbHkoaW5zZXJ0ZWRWbm9kZVF1ZXVlLCB2bm9kZS5kYXRhLnBlbmRpbmdJbnNlcnQpO1xuICAgICAgdm5vZGUuZGF0YS5wZW5kaW5nSW5zZXJ0ID0gbnVsbDtcbiAgICB9XG4gICAgdm5vZGUuZWxtID0gdm5vZGUuY29tcG9uZW50SW5zdGFuY2UuJGVsO1xuICAgIGlmIChpc1BhdGNoYWJsZSh2bm9kZSkpIHtcbiAgICAgIGludm9rZUNyZWF0ZUhvb2tzKHZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUpO1xuICAgICAgc2V0U2NvcGUodm5vZGUpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBlbXB0eSBjb21wb25lbnQgcm9vdC5cbiAgICAgIC8vIHNraXAgYWxsIGVsZW1lbnQtcmVsYXRlZCBtb2R1bGVzIGV4Y2VwdCBmb3IgcmVmICgjMzQ1NSlcbiAgICAgIHJlZ2lzdGVyUmVmKHZub2RlKTtcbiAgICAgIC8vIG1ha2Ugc3VyZSB0byBpbnZva2UgdGhlIGluc2VydCBob29rXG4gICAgICBpbnNlcnRlZFZub2RlUXVldWUucHVzaCh2bm9kZSk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gcmVhY3RpdmF0ZUNvbXBvbmVudCAodm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSwgcGFyZW50RWxtLCByZWZFbG0pIHtcbiAgICB2YXIgaTtcbiAgICAvLyBoYWNrIGZvciAjNDMzOTogYSByZWFjdGl2YXRlZCBjb21wb25lbnQgd2l0aCBpbm5lciB0cmFuc2l0aW9uXG4gICAgLy8gZG9lcyBub3QgdHJpZ2dlciBiZWNhdXNlIHRoZSBpbm5lciBub2RlJ3MgY3JlYXRlZCBob29rcyBhcmUgbm90IGNhbGxlZFxuICAgIC8vIGFnYWluLiBJdCdzIG5vdCBpZGVhbCB0byBpbnZvbHZlIG1vZHVsZS1zcGVjaWZpYyBsb2dpYyBpbiBoZXJlIGJ1dFxuICAgIC8vIHRoZXJlIGRvZXNuJ3Qgc2VlbSB0byBiZSBhIGJldHRlciB3YXkgdG8gZG8gaXQuXG4gICAgdmFyIGlubmVyTm9kZSA9IHZub2RlO1xuICAgIHdoaWxlIChpbm5lck5vZGUuY29tcG9uZW50SW5zdGFuY2UpIHtcbiAgICAgIGlubmVyTm9kZSA9IGlubmVyTm9kZS5jb21wb25lbnRJbnN0YW5jZS5fdm5vZGU7XG4gICAgICBpZiAoaXNEZWYoaSA9IGlubmVyTm9kZS5kYXRhKSAmJiBpc0RlZihpID0gaS50cmFuc2l0aW9uKSkge1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgY2JzLmFjdGl2YXRlLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgY2JzLmFjdGl2YXRlW2ldKGVtcHR5Tm9kZSwgaW5uZXJOb2RlKTtcbiAgICAgICAgfVxuICAgICAgICBpbnNlcnRlZFZub2RlUXVldWUucHVzaChpbm5lck5vZGUpO1xuICAgICAgICBicmVha1xuICAgICAgfVxuICAgIH1cbiAgICAvLyB1bmxpa2UgYSBuZXdseSBjcmVhdGVkIGNvbXBvbmVudCxcbiAgICAvLyBhIHJlYWN0aXZhdGVkIGtlZXAtYWxpdmUgY29tcG9uZW50IGRvZXNuJ3QgaW5zZXJ0IGl0c2VsZlxuICAgIGluc2VydChwYXJlbnRFbG0sIHZub2RlLmVsbSwgcmVmRWxtKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGluc2VydCAocGFyZW50LCBlbG0sIHJlZiQkMSkge1xuICAgIGlmIChpc0RlZihwYXJlbnQpKSB7XG4gICAgICBpZiAoaXNEZWYocmVmJCQxKSkge1xuICAgICAgICBpZiAocmVmJCQxLnBhcmVudE5vZGUgPT09IHBhcmVudCkge1xuICAgICAgICAgIG5vZGVPcHMuaW5zZXJ0QmVmb3JlKHBhcmVudCwgZWxtLCByZWYkJDEpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBub2RlT3BzLmFwcGVuZENoaWxkKHBhcmVudCwgZWxtKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBjcmVhdGVDaGlsZHJlbiAodm5vZGUsIGNoaWxkcmVuLCBpbnNlcnRlZFZub2RlUXVldWUpIHtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShjaGlsZHJlbikpIHtcbiAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgIGNoZWNrRHVwbGljYXRlS2V5cyhjaGlsZHJlbik7XG4gICAgICB9XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNoaWxkcmVuLmxlbmd0aDsgKytpKSB7XG4gICAgICAgIGNyZWF0ZUVsbShjaGlsZHJlbltpXSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlLCB2bm9kZS5lbG0sIG51bGwsIHRydWUpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoaXNQcmltaXRpdmUodm5vZGUudGV4dCkpIHtcbiAgICAgIG5vZGVPcHMuYXBwZW5kQ2hpbGQodm5vZGUuZWxtLCBub2RlT3BzLmNyZWF0ZVRleHROb2RlKHZub2RlLnRleHQpKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBpc1BhdGNoYWJsZSAodm5vZGUpIHtcbiAgICB3aGlsZSAodm5vZGUuY29tcG9uZW50SW5zdGFuY2UpIHtcbiAgICAgIHZub2RlID0gdm5vZGUuY29tcG9uZW50SW5zdGFuY2UuX3Zub2RlO1xuICAgIH1cbiAgICByZXR1cm4gaXNEZWYodm5vZGUudGFnKVxuICB9XG5cbiAgZnVuY3Rpb24gaW52b2tlQ3JlYXRlSG9va3MgKHZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUpIHtcbiAgICBmb3IgKHZhciBpJDEgPSAwOyBpJDEgPCBjYnMuY3JlYXRlLmxlbmd0aDsgKytpJDEpIHtcbiAgICAgIGNicy5jcmVhdGVbaSQxXShlbXB0eU5vZGUsIHZub2RlKTtcbiAgICB9XG4gICAgaSA9IHZub2RlLmRhdGEuaG9vazsgLy8gUmV1c2UgdmFyaWFibGVcbiAgICBpZiAoaXNEZWYoaSkpIHtcbiAgICAgIGlmIChpc0RlZihpLmNyZWF0ZSkpIHsgaS5jcmVhdGUoZW1wdHlOb2RlLCB2bm9kZSk7IH1cbiAgICAgIGlmIChpc0RlZihpLmluc2VydCkpIHsgaW5zZXJ0ZWRWbm9kZVF1ZXVlLnB1c2godm5vZGUpOyB9XG4gICAgfVxuICB9XG5cbiAgLy8gc2V0IHNjb3BlIGlkIGF0dHJpYnV0ZSBmb3Igc2NvcGVkIENTUy5cbiAgLy8gdGhpcyBpcyBpbXBsZW1lbnRlZCBhcyBhIHNwZWNpYWwgY2FzZSB0byBhdm9pZCB0aGUgb3ZlcmhlYWRcbiAgLy8gb2YgZ29pbmcgdGhyb3VnaCB0aGUgbm9ybWFsIGF0dHJpYnV0ZSBwYXRjaGluZyBwcm9jZXNzLlxuICBmdW5jdGlvbiBzZXRTY29wZSAodm5vZGUpIHtcbiAgICB2YXIgaTtcbiAgICBpZiAoaXNEZWYoaSA9IHZub2RlLmZuU2NvcGVJZCkpIHtcbiAgICAgIG5vZGVPcHMuc2V0QXR0cmlidXRlKHZub2RlLmVsbSwgaSwgJycpO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgYW5jZXN0b3IgPSB2bm9kZTtcbiAgICAgIHdoaWxlIChhbmNlc3Rvcikge1xuICAgICAgICBpZiAoaXNEZWYoaSA9IGFuY2VzdG9yLmNvbnRleHQpICYmIGlzRGVmKGkgPSBpLiRvcHRpb25zLl9zY29wZUlkKSkge1xuICAgICAgICAgIG5vZGVPcHMuc2V0QXR0cmlidXRlKHZub2RlLmVsbSwgaSwgJycpO1xuICAgICAgICB9XG4gICAgICAgIGFuY2VzdG9yID0gYW5jZXN0b3IucGFyZW50O1xuICAgICAgfVxuICAgIH1cbiAgICAvLyBmb3Igc2xvdCBjb250ZW50IHRoZXkgc2hvdWxkIGFsc28gZ2V0IHRoZSBzY29wZUlkIGZyb20gdGhlIGhvc3QgaW5zdGFuY2UuXG4gICAgaWYgKGlzRGVmKGkgPSBhY3RpdmVJbnN0YW5jZSkgJiZcbiAgICAgIGkgIT09IHZub2RlLmNvbnRleHQgJiZcbiAgICAgIGkgIT09IHZub2RlLmZuQ29udGV4dCAmJlxuICAgICAgaXNEZWYoaSA9IGkuJG9wdGlvbnMuX3Njb3BlSWQpXG4gICAgKSB7XG4gICAgICBub2RlT3BzLnNldEF0dHJpYnV0ZSh2bm9kZS5lbG0sIGksICcnKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBhZGRWbm9kZXMgKHBhcmVudEVsbSwgcmVmRWxtLCB2bm9kZXMsIHN0YXJ0SWR4LCBlbmRJZHgsIGluc2VydGVkVm5vZGVRdWV1ZSkge1xuICAgIGZvciAoOyBzdGFydElkeCA8PSBlbmRJZHg7ICsrc3RhcnRJZHgpIHtcbiAgICAgIGNyZWF0ZUVsbSh2bm9kZXNbc3RhcnRJZHhdLCBpbnNlcnRlZFZub2RlUXVldWUsIHBhcmVudEVsbSwgcmVmRWxtKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBpbnZva2VEZXN0cm95SG9vayAodm5vZGUpIHtcbiAgICB2YXIgaSwgajtcbiAgICB2YXIgZGF0YSA9IHZub2RlLmRhdGE7XG4gICAgaWYgKGlzRGVmKGRhdGEpKSB7XG4gICAgICBpZiAoaXNEZWYoaSA9IGRhdGEuaG9vaykgJiYgaXNEZWYoaSA9IGkuZGVzdHJveSkpIHsgaSh2bm9kZSk7IH1cbiAgICAgIGZvciAoaSA9IDA7IGkgPCBjYnMuZGVzdHJveS5sZW5ndGg7ICsraSkgeyBjYnMuZGVzdHJveVtpXSh2bm9kZSk7IH1cbiAgICB9XG4gICAgaWYgKGlzRGVmKGkgPSB2bm9kZS5jaGlsZHJlbikpIHtcbiAgICAgIGZvciAoaiA9IDA7IGogPCB2bm9kZS5jaGlsZHJlbi5sZW5ndGg7ICsraikge1xuICAgICAgICBpbnZva2VEZXN0cm95SG9vayh2bm9kZS5jaGlsZHJlbltqXSk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gcmVtb3ZlVm5vZGVzIChwYXJlbnRFbG0sIHZub2Rlcywgc3RhcnRJZHgsIGVuZElkeCkge1xuICAgIGZvciAoOyBzdGFydElkeCA8PSBlbmRJZHg7ICsrc3RhcnRJZHgpIHtcbiAgICAgIHZhciBjaCA9IHZub2Rlc1tzdGFydElkeF07XG4gICAgICBpZiAoaXNEZWYoY2gpKSB7XG4gICAgICAgIGlmIChpc0RlZihjaC50YWcpKSB7XG4gICAgICAgICAgcmVtb3ZlQW5kSW52b2tlUmVtb3ZlSG9vayhjaCk7XG4gICAgICAgICAgaW52b2tlRGVzdHJveUhvb2soY2gpO1xuICAgICAgICB9IGVsc2UgeyAvLyBUZXh0IG5vZGVcbiAgICAgICAgICByZW1vdmVOb2RlKGNoLmVsbSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiByZW1vdmVBbmRJbnZva2VSZW1vdmVIb29rICh2bm9kZSwgcm0pIHtcbiAgICBpZiAoaXNEZWYocm0pIHx8IGlzRGVmKHZub2RlLmRhdGEpKSB7XG4gICAgICB2YXIgaTtcbiAgICAgIHZhciBsaXN0ZW5lcnMgPSBjYnMucmVtb3ZlLmxlbmd0aCArIDE7XG4gICAgICBpZiAoaXNEZWYocm0pKSB7XG4gICAgICAgIC8vIHdlIGhhdmUgYSByZWN1cnNpdmVseSBwYXNzZWQgZG93biBybSBjYWxsYmFja1xuICAgICAgICAvLyBpbmNyZWFzZSB0aGUgbGlzdGVuZXJzIGNvdW50XG4gICAgICAgIHJtLmxpc3RlbmVycyArPSBsaXN0ZW5lcnM7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBkaXJlY3RseSByZW1vdmluZ1xuICAgICAgICBybSA9IGNyZWF0ZVJtQ2Iodm5vZGUuZWxtLCBsaXN0ZW5lcnMpO1xuICAgICAgfVxuICAgICAgLy8gcmVjdXJzaXZlbHkgaW52b2tlIGhvb2tzIG9uIGNoaWxkIGNvbXBvbmVudCByb290IG5vZGVcbiAgICAgIGlmIChpc0RlZihpID0gdm5vZGUuY29tcG9uZW50SW5zdGFuY2UpICYmIGlzRGVmKGkgPSBpLl92bm9kZSkgJiYgaXNEZWYoaS5kYXRhKSkge1xuICAgICAgICByZW1vdmVBbmRJbnZva2VSZW1vdmVIb29rKGksIHJtKTtcbiAgICAgIH1cbiAgICAgIGZvciAoaSA9IDA7IGkgPCBjYnMucmVtb3ZlLmxlbmd0aDsgKytpKSB7XG4gICAgICAgIGNicy5yZW1vdmVbaV0odm5vZGUsIHJtKTtcbiAgICAgIH1cbiAgICAgIGlmIChpc0RlZihpID0gdm5vZGUuZGF0YS5ob29rKSAmJiBpc0RlZihpID0gaS5yZW1vdmUpKSB7XG4gICAgICAgIGkodm5vZGUsIHJtKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJtKCk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlbW92ZU5vZGUodm5vZGUuZWxtKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiB1cGRhdGVDaGlsZHJlbiAocGFyZW50RWxtLCBvbGRDaCwgbmV3Q2gsIGluc2VydGVkVm5vZGVRdWV1ZSwgcmVtb3ZlT25seSkge1xuICAgIHZhciBvbGRTdGFydElkeCA9IDA7XG4gICAgdmFyIG5ld1N0YXJ0SWR4ID0gMDtcbiAgICB2YXIgb2xkRW5kSWR4ID0gb2xkQ2gubGVuZ3RoIC0gMTtcbiAgICB2YXIgb2xkU3RhcnRWbm9kZSA9IG9sZENoWzBdO1xuICAgIHZhciBvbGRFbmRWbm9kZSA9IG9sZENoW29sZEVuZElkeF07XG4gICAgdmFyIG5ld0VuZElkeCA9IG5ld0NoLmxlbmd0aCAtIDE7XG4gICAgdmFyIG5ld1N0YXJ0Vm5vZGUgPSBuZXdDaFswXTtcbiAgICB2YXIgbmV3RW5kVm5vZGUgPSBuZXdDaFtuZXdFbmRJZHhdO1xuICAgIHZhciBvbGRLZXlUb0lkeCwgaWR4SW5PbGQsIHZub2RlVG9Nb3ZlLCByZWZFbG07XG5cbiAgICAvLyByZW1vdmVPbmx5IGlzIGEgc3BlY2lhbCBmbGFnIHVzZWQgb25seSBieSA8dHJhbnNpdGlvbi1ncm91cD5cbiAgICAvLyB0byBlbnN1cmUgcmVtb3ZlZCBlbGVtZW50cyBzdGF5IGluIGNvcnJlY3QgcmVsYXRpdmUgcG9zaXRpb25zXG4gICAgLy8gZHVyaW5nIGxlYXZpbmcgdHJhbnNpdGlvbnNcbiAgICB2YXIgY2FuTW92ZSA9ICFyZW1vdmVPbmx5O1xuXG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIGNoZWNrRHVwbGljYXRlS2V5cyhuZXdDaCk7XG4gICAgfVxuXG4gICAgd2hpbGUgKG9sZFN0YXJ0SWR4IDw9IG9sZEVuZElkeCAmJiBuZXdTdGFydElkeCA8PSBuZXdFbmRJZHgpIHtcbiAgICAgIGlmIChpc1VuZGVmKG9sZFN0YXJ0Vm5vZGUpKSB7XG4gICAgICAgIG9sZFN0YXJ0Vm5vZGUgPSBvbGRDaFsrK29sZFN0YXJ0SWR4XTsgLy8gVm5vZGUgaGFzIGJlZW4gbW92ZWQgbGVmdFxuICAgICAgfSBlbHNlIGlmIChpc1VuZGVmKG9sZEVuZFZub2RlKSkge1xuICAgICAgICBvbGRFbmRWbm9kZSA9IG9sZENoWy0tb2xkRW5kSWR4XTtcbiAgICAgIH0gZWxzZSBpZiAoc2FtZVZub2RlKG9sZFN0YXJ0Vm5vZGUsIG5ld1N0YXJ0Vm5vZGUpKSB7XG4gICAgICAgIHBhdGNoVm5vZGUob2xkU3RhcnRWbm9kZSwgbmV3U3RhcnRWbm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlKTtcbiAgICAgICAgb2xkU3RhcnRWbm9kZSA9IG9sZENoWysrb2xkU3RhcnRJZHhdO1xuICAgICAgICBuZXdTdGFydFZub2RlID0gbmV3Q2hbKytuZXdTdGFydElkeF07XG4gICAgICB9IGVsc2UgaWYgKHNhbWVWbm9kZShvbGRFbmRWbm9kZSwgbmV3RW5kVm5vZGUpKSB7XG4gICAgICAgIHBhdGNoVm5vZGUob2xkRW5kVm5vZGUsIG5ld0VuZFZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUpO1xuICAgICAgICBvbGRFbmRWbm9kZSA9IG9sZENoWy0tb2xkRW5kSWR4XTtcbiAgICAgICAgbmV3RW5kVm5vZGUgPSBuZXdDaFstLW5ld0VuZElkeF07XG4gICAgICB9IGVsc2UgaWYgKHNhbWVWbm9kZShvbGRTdGFydFZub2RlLCBuZXdFbmRWbm9kZSkpIHsgLy8gVm5vZGUgbW92ZWQgcmlnaHRcbiAgICAgICAgcGF0Y2hWbm9kZShvbGRTdGFydFZub2RlLCBuZXdFbmRWbm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlKTtcbiAgICAgICAgY2FuTW92ZSAmJiBub2RlT3BzLmluc2VydEJlZm9yZShwYXJlbnRFbG0sIG9sZFN0YXJ0Vm5vZGUuZWxtLCBub2RlT3BzLm5leHRTaWJsaW5nKG9sZEVuZFZub2RlLmVsbSkpO1xuICAgICAgICBvbGRTdGFydFZub2RlID0gb2xkQ2hbKytvbGRTdGFydElkeF07XG4gICAgICAgIG5ld0VuZFZub2RlID0gbmV3Q2hbLS1uZXdFbmRJZHhdO1xuICAgICAgfSBlbHNlIGlmIChzYW1lVm5vZGUob2xkRW5kVm5vZGUsIG5ld1N0YXJ0Vm5vZGUpKSB7IC8vIFZub2RlIG1vdmVkIGxlZnRcbiAgICAgICAgcGF0Y2hWbm9kZShvbGRFbmRWbm9kZSwgbmV3U3RhcnRWbm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlKTtcbiAgICAgICAgY2FuTW92ZSAmJiBub2RlT3BzLmluc2VydEJlZm9yZShwYXJlbnRFbG0sIG9sZEVuZFZub2RlLmVsbSwgb2xkU3RhcnRWbm9kZS5lbG0pO1xuICAgICAgICBvbGRFbmRWbm9kZSA9IG9sZENoWy0tb2xkRW5kSWR4XTtcbiAgICAgICAgbmV3U3RhcnRWbm9kZSA9IG5ld0NoWysrbmV3U3RhcnRJZHhdO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKGlzVW5kZWYob2xkS2V5VG9JZHgpKSB7IG9sZEtleVRvSWR4ID0gY3JlYXRlS2V5VG9PbGRJZHgob2xkQ2gsIG9sZFN0YXJ0SWR4LCBvbGRFbmRJZHgpOyB9XG4gICAgICAgIGlkeEluT2xkID0gaXNEZWYobmV3U3RhcnRWbm9kZS5rZXkpXG4gICAgICAgICAgPyBvbGRLZXlUb0lkeFtuZXdTdGFydFZub2RlLmtleV1cbiAgICAgICAgICA6IGZpbmRJZHhJbk9sZChuZXdTdGFydFZub2RlLCBvbGRDaCwgb2xkU3RhcnRJZHgsIG9sZEVuZElkeCk7XG4gICAgICAgIGlmIChpc1VuZGVmKGlkeEluT2xkKSkgeyAvLyBOZXcgZWxlbWVudFxuICAgICAgICAgIGNyZWF0ZUVsbShuZXdTdGFydFZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUsIHBhcmVudEVsbSwgb2xkU3RhcnRWbm9kZS5lbG0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZub2RlVG9Nb3ZlID0gb2xkQ2hbaWR4SW5PbGRdO1xuICAgICAgICAgIGlmIChzYW1lVm5vZGUodm5vZGVUb01vdmUsIG5ld1N0YXJ0Vm5vZGUpKSB7XG4gICAgICAgICAgICBwYXRjaFZub2RlKHZub2RlVG9Nb3ZlLCBuZXdTdGFydFZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUpO1xuICAgICAgICAgICAgb2xkQ2hbaWR4SW5PbGRdID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgY2FuTW92ZSAmJiBub2RlT3BzLmluc2VydEJlZm9yZShwYXJlbnRFbG0sIHZub2RlVG9Nb3ZlLmVsbSwgb2xkU3RhcnRWbm9kZS5lbG0pO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBzYW1lIGtleSBidXQgZGlmZmVyZW50IGVsZW1lbnQuIHRyZWF0IGFzIG5ldyBlbGVtZW50XG4gICAgICAgICAgICBjcmVhdGVFbG0obmV3U3RhcnRWbm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlLCBwYXJlbnRFbG0sIG9sZFN0YXJ0Vm5vZGUuZWxtKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgbmV3U3RhcnRWbm9kZSA9IG5ld0NoWysrbmV3U3RhcnRJZHhdO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAob2xkU3RhcnRJZHggPiBvbGRFbmRJZHgpIHtcbiAgICAgIHJlZkVsbSA9IGlzVW5kZWYobmV3Q2hbbmV3RW5kSWR4ICsgMV0pID8gbnVsbCA6IG5ld0NoW25ld0VuZElkeCArIDFdLmVsbTtcbiAgICAgIGFkZFZub2RlcyhwYXJlbnRFbG0sIHJlZkVsbSwgbmV3Q2gsIG5ld1N0YXJ0SWR4LCBuZXdFbmRJZHgsIGluc2VydGVkVm5vZGVRdWV1ZSk7XG4gICAgfSBlbHNlIGlmIChuZXdTdGFydElkeCA+IG5ld0VuZElkeCkge1xuICAgICAgcmVtb3ZlVm5vZGVzKHBhcmVudEVsbSwgb2xkQ2gsIG9sZFN0YXJ0SWR4LCBvbGRFbmRJZHgpO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGNoZWNrRHVwbGljYXRlS2V5cyAoY2hpbGRyZW4pIHtcbiAgICB2YXIgc2VlbktleXMgPSB7fTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgdm5vZGUgPSBjaGlsZHJlbltpXTtcbiAgICAgIHZhciBrZXkgPSB2bm9kZS5rZXk7XG4gICAgICBpZiAoaXNEZWYoa2V5KSkge1xuICAgICAgICBpZiAoc2VlbktleXNba2V5XSkge1xuICAgICAgICAgIHdhcm4oXG4gICAgICAgICAgICAoXCJEdXBsaWNhdGUga2V5cyBkZXRlY3RlZDogJ1wiICsga2V5ICsgXCInLiBUaGlzIG1heSBjYXVzZSBhbiB1cGRhdGUgZXJyb3IuXCIpLFxuICAgICAgICAgICAgdm5vZGUuY29udGV4dFxuICAgICAgICAgICk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgc2VlbktleXNba2V5XSA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBmaW5kSWR4SW5PbGQgKG5vZGUsIG9sZENoLCBzdGFydCwgZW5kKSB7XG4gICAgZm9yICh2YXIgaSA9IHN0YXJ0OyBpIDwgZW5kOyBpKyspIHtcbiAgICAgIHZhciBjID0gb2xkQ2hbaV07XG4gICAgICBpZiAoaXNEZWYoYykgJiYgc2FtZVZub2RlKG5vZGUsIGMpKSB7IHJldHVybiBpIH1cbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBwYXRjaFZub2RlIChvbGRWbm9kZSwgdm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSwgcmVtb3ZlT25seSkge1xuICAgIGlmIChvbGRWbm9kZSA9PT0gdm5vZGUpIHtcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIHZhciBlbG0gPSB2bm9kZS5lbG0gPSBvbGRWbm9kZS5lbG07XG5cbiAgICBpZiAoaXNUcnVlKG9sZFZub2RlLmlzQXN5bmNQbGFjZWhvbGRlcikpIHtcbiAgICAgIGlmIChpc0RlZih2bm9kZS5hc3luY0ZhY3RvcnkucmVzb2x2ZWQpKSB7XG4gICAgICAgIGh5ZHJhdGUob2xkVm5vZGUuZWxtLCB2bm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZub2RlLmlzQXN5bmNQbGFjZWhvbGRlciA9IHRydWU7XG4gICAgICB9XG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICAvLyByZXVzZSBlbGVtZW50IGZvciBzdGF0aWMgdHJlZXMuXG4gICAgLy8gbm90ZSB3ZSBvbmx5IGRvIHRoaXMgaWYgdGhlIHZub2RlIGlzIGNsb25lZCAtXG4gICAgLy8gaWYgdGhlIG5ldyBub2RlIGlzIG5vdCBjbG9uZWQgaXQgbWVhbnMgdGhlIHJlbmRlciBmdW5jdGlvbnMgaGF2ZSBiZWVuXG4gICAgLy8gcmVzZXQgYnkgdGhlIGhvdC1yZWxvYWQtYXBpIGFuZCB3ZSBuZWVkIHRvIGRvIGEgcHJvcGVyIHJlLXJlbmRlci5cbiAgICBpZiAoaXNUcnVlKHZub2RlLmlzU3RhdGljKSAmJlxuICAgICAgaXNUcnVlKG9sZFZub2RlLmlzU3RhdGljKSAmJlxuICAgICAgdm5vZGUua2V5ID09PSBvbGRWbm9kZS5rZXkgJiZcbiAgICAgIChpc1RydWUodm5vZGUuaXNDbG9uZWQpIHx8IGlzVHJ1ZSh2bm9kZS5pc09uY2UpKVxuICAgICkge1xuICAgICAgdm5vZGUuY29tcG9uZW50SW5zdGFuY2UgPSBvbGRWbm9kZS5jb21wb25lbnRJbnN0YW5jZTtcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIHZhciBpO1xuICAgIHZhciBkYXRhID0gdm5vZGUuZGF0YTtcbiAgICBpZiAoaXNEZWYoZGF0YSkgJiYgaXNEZWYoaSA9IGRhdGEuaG9vaykgJiYgaXNEZWYoaSA9IGkucHJlcGF0Y2gpKSB7XG4gICAgICBpKG9sZFZub2RlLCB2bm9kZSk7XG4gICAgfVxuXG4gICAgdmFyIG9sZENoID0gb2xkVm5vZGUuY2hpbGRyZW47XG4gICAgdmFyIGNoID0gdm5vZGUuY2hpbGRyZW47XG4gICAgaWYgKGlzRGVmKGRhdGEpICYmIGlzUGF0Y2hhYmxlKHZub2RlKSkge1xuICAgICAgZm9yIChpID0gMDsgaSA8IGNicy51cGRhdGUubGVuZ3RoOyArK2kpIHsgY2JzLnVwZGF0ZVtpXShvbGRWbm9kZSwgdm5vZGUpOyB9XG4gICAgICBpZiAoaXNEZWYoaSA9IGRhdGEuaG9vaykgJiYgaXNEZWYoaSA9IGkudXBkYXRlKSkgeyBpKG9sZFZub2RlLCB2bm9kZSk7IH1cbiAgICB9XG4gICAgaWYgKGlzVW5kZWYodm5vZGUudGV4dCkpIHtcbiAgICAgIGlmIChpc0RlZihvbGRDaCkgJiYgaXNEZWYoY2gpKSB7XG4gICAgICAgIGlmIChvbGRDaCAhPT0gY2gpIHsgdXBkYXRlQ2hpbGRyZW4oZWxtLCBvbGRDaCwgY2gsIGluc2VydGVkVm5vZGVRdWV1ZSwgcmVtb3ZlT25seSk7IH1cbiAgICAgIH0gZWxzZSBpZiAoaXNEZWYoY2gpKSB7XG4gICAgICAgIGlmIChpc0RlZihvbGRWbm9kZS50ZXh0KSkgeyBub2RlT3BzLnNldFRleHRDb250ZW50KGVsbSwgJycpOyB9XG4gICAgICAgIGFkZFZub2RlcyhlbG0sIG51bGwsIGNoLCAwLCBjaC5sZW5ndGggLSAxLCBpbnNlcnRlZFZub2RlUXVldWUpO1xuICAgICAgfSBlbHNlIGlmIChpc0RlZihvbGRDaCkpIHtcbiAgICAgICAgcmVtb3ZlVm5vZGVzKGVsbSwgb2xkQ2gsIDAsIG9sZENoLmxlbmd0aCAtIDEpO1xuICAgICAgfSBlbHNlIGlmIChpc0RlZihvbGRWbm9kZS50ZXh0KSkge1xuICAgICAgICBub2RlT3BzLnNldFRleHRDb250ZW50KGVsbSwgJycpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAob2xkVm5vZGUudGV4dCAhPT0gdm5vZGUudGV4dCkge1xuICAgICAgbm9kZU9wcy5zZXRUZXh0Q29udGVudChlbG0sIHZub2RlLnRleHQpO1xuICAgIH1cbiAgICBpZiAoaXNEZWYoZGF0YSkpIHtcbiAgICAgIGlmIChpc0RlZihpID0gZGF0YS5ob29rKSAmJiBpc0RlZihpID0gaS5wb3N0cGF0Y2gpKSB7IGkob2xkVm5vZGUsIHZub2RlKTsgfVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGludm9rZUluc2VydEhvb2sgKHZub2RlLCBxdWV1ZSwgaW5pdGlhbCkge1xuICAgIC8vIGRlbGF5IGluc2VydCBob29rcyBmb3IgY29tcG9uZW50IHJvb3Qgbm9kZXMsIGludm9rZSB0aGVtIGFmdGVyIHRoZVxuICAgIC8vIGVsZW1lbnQgaXMgcmVhbGx5IGluc2VydGVkXG4gICAgaWYgKGlzVHJ1ZShpbml0aWFsKSAmJiBpc0RlZih2bm9kZS5wYXJlbnQpKSB7XG4gICAgICB2bm9kZS5wYXJlbnQuZGF0YS5wZW5kaW5nSW5zZXJ0ID0gcXVldWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcXVldWUubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgcXVldWVbaV0uZGF0YS5ob29rLmluc2VydChxdWV1ZVtpXSk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgdmFyIGh5ZHJhdGlvbkJhaWxlZCA9IGZhbHNlO1xuICAvLyBsaXN0IG9mIG1vZHVsZXMgdGhhdCBjYW4gc2tpcCBjcmVhdGUgaG9vayBkdXJpbmcgaHlkcmF0aW9uIGJlY2F1c2UgdGhleVxuICAvLyBhcmUgYWxyZWFkeSByZW5kZXJlZCBvbiB0aGUgY2xpZW50IG9yIGhhcyBubyBuZWVkIGZvciBpbml0aWFsaXphdGlvblxuICAvLyBOb3RlOiBzdHlsZSBpcyBleGNsdWRlZCBiZWNhdXNlIGl0IHJlbGllcyBvbiBpbml0aWFsIGNsb25lIGZvciBmdXR1cmVcbiAgLy8gZGVlcCB1cGRhdGVzICgjNzA2MykuXG4gIHZhciBpc1JlbmRlcmVkTW9kdWxlID0gbWFrZU1hcCgnYXR0cnMsY2xhc3Msc3RhdGljQ2xhc3Msc3RhdGljU3R5bGUsa2V5Jyk7XG5cbiAgLy8gTm90ZTogdGhpcyBpcyBhIGJyb3dzZXItb25seSBmdW5jdGlvbiBzbyB3ZSBjYW4gYXNzdW1lIGVsbXMgYXJlIERPTSBub2Rlcy5cbiAgZnVuY3Rpb24gaHlkcmF0ZSAoZWxtLCB2bm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlLCBpblZQcmUpIHtcbiAgICB2YXIgaTtcbiAgICB2YXIgdGFnID0gdm5vZGUudGFnO1xuICAgIHZhciBkYXRhID0gdm5vZGUuZGF0YTtcbiAgICB2YXIgY2hpbGRyZW4gPSB2bm9kZS5jaGlsZHJlbjtcbiAgICBpblZQcmUgPSBpblZQcmUgfHwgKGRhdGEgJiYgZGF0YS5wcmUpO1xuICAgIHZub2RlLmVsbSA9IGVsbTtcblxuICAgIGlmIChpc1RydWUodm5vZGUuaXNDb21tZW50KSAmJiBpc0RlZih2bm9kZS5hc3luY0ZhY3RvcnkpKSB7XG4gICAgICB2bm9kZS5pc0FzeW5jUGxhY2Vob2xkZXIgPSB0cnVlO1xuICAgICAgcmV0dXJuIHRydWVcbiAgICB9XG4gICAgLy8gYXNzZXJ0IG5vZGUgbWF0Y2hcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgaWYgKCFhc3NlcnROb2RlTWF0Y2goZWxtLCB2bm9kZSwgaW5WUHJlKSkge1xuICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGlzRGVmKGRhdGEpKSB7XG4gICAgICBpZiAoaXNEZWYoaSA9IGRhdGEuaG9vaykgJiYgaXNEZWYoaSA9IGkuaW5pdCkpIHsgaSh2bm9kZSwgdHJ1ZSAvKiBoeWRyYXRpbmcgKi8pOyB9XG4gICAgICBpZiAoaXNEZWYoaSA9IHZub2RlLmNvbXBvbmVudEluc3RhbmNlKSkge1xuICAgICAgICAvLyBjaGlsZCBjb21wb25lbnQuIGl0IHNob3VsZCBoYXZlIGh5ZHJhdGVkIGl0cyBvd24gdHJlZS5cbiAgICAgICAgaW5pdENvbXBvbmVudCh2bm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlKTtcbiAgICAgICAgcmV0dXJuIHRydWVcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGlzRGVmKHRhZykpIHtcbiAgICAgIGlmIChpc0RlZihjaGlsZHJlbikpIHtcbiAgICAgICAgLy8gZW1wdHkgZWxlbWVudCwgYWxsb3cgY2xpZW50IHRvIHBpY2sgdXAgYW5kIHBvcHVsYXRlIGNoaWxkcmVuXG4gICAgICAgIGlmICghZWxtLmhhc0NoaWxkTm9kZXMoKSkge1xuICAgICAgICAgIGNyZWF0ZUNoaWxkcmVuKHZub2RlLCBjaGlsZHJlbiwgaW5zZXJ0ZWRWbm9kZVF1ZXVlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyB2LWh0bWwgYW5kIGRvbVByb3BzOiBpbm5lckhUTUxcbiAgICAgICAgICBpZiAoaXNEZWYoaSA9IGRhdGEpICYmIGlzRGVmKGkgPSBpLmRvbVByb3BzKSAmJiBpc0RlZihpID0gaS5pbm5lckhUTUwpKSB7XG4gICAgICAgICAgICBpZiAoaSAhPT0gZWxtLmlubmVySFRNTCkge1xuICAgICAgICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICAgICAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiZcbiAgICAgICAgICAgICAgICB0eXBlb2YgY29uc29sZSAhPT0gJ3VuZGVmaW5lZCcgJiZcbiAgICAgICAgICAgICAgICAhaHlkcmF0aW9uQmFpbGVkXG4gICAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgIGh5ZHJhdGlvbkJhaWxlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgY29uc29sZS53YXJuKCdQYXJlbnQ6ICcsIGVsbSk7XG4gICAgICAgICAgICAgICAgY29uc29sZS53YXJuKCdzZXJ2ZXIgaW5uZXJIVE1MOiAnLCBpKTtcbiAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oJ2NsaWVudCBpbm5lckhUTUw6ICcsIGVsbS5pbm5lckhUTUwpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBpdGVyYXRlIGFuZCBjb21wYXJlIGNoaWxkcmVuIGxpc3RzXG4gICAgICAgICAgICB2YXIgY2hpbGRyZW5NYXRjaCA9IHRydWU7XG4gICAgICAgICAgICB2YXIgY2hpbGROb2RlID0gZWxtLmZpcnN0Q2hpbGQ7XG4gICAgICAgICAgICBmb3IgKHZhciBpJDEgPSAwOyBpJDEgPCBjaGlsZHJlbi5sZW5ndGg7IGkkMSsrKSB7XG4gICAgICAgICAgICAgIGlmICghY2hpbGROb2RlIHx8ICFoeWRyYXRlKGNoaWxkTm9kZSwgY2hpbGRyZW5baSQxXSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlLCBpblZQcmUpKSB7XG4gICAgICAgICAgICAgICAgY2hpbGRyZW5NYXRjaCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIGJyZWFrXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgY2hpbGROb2RlID0gY2hpbGROb2RlLm5leHRTaWJsaW5nO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gaWYgY2hpbGROb2RlIGlzIG5vdCBudWxsLCBpdCBtZWFucyB0aGUgYWN0dWFsIGNoaWxkTm9kZXMgbGlzdCBpc1xuICAgICAgICAgICAgLy8gbG9uZ2VyIHRoYW4gdGhlIHZpcnR1YWwgY2hpbGRyZW4gbGlzdC5cbiAgICAgICAgICAgIGlmICghY2hpbGRyZW5NYXRjaCB8fCBjaGlsZE5vZGUpIHtcbiAgICAgICAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgICAgICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmXG4gICAgICAgICAgICAgICAgdHlwZW9mIGNvbnNvbGUgIT09ICd1bmRlZmluZWQnICYmXG4gICAgICAgICAgICAgICAgIWh5ZHJhdGlvbkJhaWxlZFxuICAgICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICBoeWRyYXRpb25CYWlsZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybignUGFyZW50OiAnLCBlbG0pO1xuICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybignTWlzbWF0Y2hpbmcgY2hpbGROb2RlcyB2cy4gVk5vZGVzOiAnLCBlbG0uY2hpbGROb2RlcywgY2hpbGRyZW4pO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKGlzRGVmKGRhdGEpKSB7XG4gICAgICAgIHZhciBmdWxsSW52b2tlID0gZmFsc2U7XG4gICAgICAgIGZvciAodmFyIGtleSBpbiBkYXRhKSB7XG4gICAgICAgICAgaWYgKCFpc1JlbmRlcmVkTW9kdWxlKGtleSkpIHtcbiAgICAgICAgICAgIGZ1bGxJbnZva2UgPSB0cnVlO1xuICAgICAgICAgICAgaW52b2tlQ3JlYXRlSG9va3Modm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSk7XG4gICAgICAgICAgICBicmVha1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoIWZ1bGxJbnZva2UgJiYgZGF0YVsnY2xhc3MnXSkge1xuICAgICAgICAgIC8vIGVuc3VyZSBjb2xsZWN0aW5nIGRlcHMgZm9yIGRlZXAgY2xhc3MgYmluZGluZ3MgZm9yIGZ1dHVyZSB1cGRhdGVzXG4gICAgICAgICAgdHJhdmVyc2UoZGF0YVsnY2xhc3MnXSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGVsbS5kYXRhICE9PSB2bm9kZS50ZXh0KSB7XG4gICAgICBlbG0uZGF0YSA9IHZub2RlLnRleHQ7XG4gICAgfVxuICAgIHJldHVybiB0cnVlXG4gIH1cblxuICBmdW5jdGlvbiBhc3NlcnROb2RlTWF0Y2ggKG5vZGUsIHZub2RlLCBpblZQcmUpIHtcbiAgICBpZiAoaXNEZWYodm5vZGUudGFnKSkge1xuICAgICAgcmV0dXJuIHZub2RlLnRhZy5pbmRleE9mKCd2dWUtY29tcG9uZW50JykgPT09IDAgfHwgKFxuICAgICAgICAhaXNVbmtub3duRWxlbWVudCQkMSh2bm9kZSwgaW5WUHJlKSAmJlxuICAgICAgICB2bm9kZS50YWcudG9Mb3dlckNhc2UoKSA9PT0gKG5vZGUudGFnTmFtZSAmJiBub2RlLnRhZ05hbWUudG9Mb3dlckNhc2UoKSlcbiAgICAgIClcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIG5vZGUubm9kZVR5cGUgPT09ICh2bm9kZS5pc0NvbW1lbnQgPyA4IDogMylcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZnVuY3Rpb24gcGF0Y2ggKG9sZFZub2RlLCB2bm9kZSwgaHlkcmF0aW5nLCByZW1vdmVPbmx5LCBwYXJlbnRFbG0sIHJlZkVsbSkge1xuICAgIGlmIChpc1VuZGVmKHZub2RlKSkge1xuICAgICAgaWYgKGlzRGVmKG9sZFZub2RlKSkgeyBpbnZva2VEZXN0cm95SG9vayhvbGRWbm9kZSk7IH1cbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIHZhciBpc0luaXRpYWxQYXRjaCA9IGZhbHNlO1xuICAgIHZhciBpbnNlcnRlZFZub2RlUXVldWUgPSBbXTtcblxuICAgIGlmIChpc1VuZGVmKG9sZFZub2RlKSkge1xuICAgICAgLy8gZW1wdHkgbW91bnQgKGxpa2VseSBhcyBjb21wb25lbnQpLCBjcmVhdGUgbmV3IHJvb3QgZWxlbWVudFxuICAgICAgaXNJbml0aWFsUGF0Y2ggPSB0cnVlO1xuICAgICAgY3JlYXRlRWxtKHZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUsIHBhcmVudEVsbSwgcmVmRWxtKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIGlzUmVhbEVsZW1lbnQgPSBpc0RlZihvbGRWbm9kZS5ub2RlVHlwZSk7XG4gICAgICBpZiAoIWlzUmVhbEVsZW1lbnQgJiYgc2FtZVZub2RlKG9sZFZub2RlLCB2bm9kZSkpIHtcbiAgICAgICAgLy8gcGF0Y2ggZXhpc3Rpbmcgcm9vdCBub2RlXG4gICAgICAgIHBhdGNoVm5vZGUob2xkVm5vZGUsIHZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUsIHJlbW92ZU9ubHkpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKGlzUmVhbEVsZW1lbnQpIHtcbiAgICAgICAgICAvLyBtb3VudGluZyB0byBhIHJlYWwgZWxlbWVudFxuICAgICAgICAgIC8vIGNoZWNrIGlmIHRoaXMgaXMgc2VydmVyLXJlbmRlcmVkIGNvbnRlbnQgYW5kIGlmIHdlIGNhbiBwZXJmb3JtXG4gICAgICAgICAgLy8gYSBzdWNjZXNzZnVsIGh5ZHJhdGlvbi5cbiAgICAgICAgICBpZiAob2xkVm5vZGUubm9kZVR5cGUgPT09IDEgJiYgb2xkVm5vZGUuaGFzQXR0cmlidXRlKFNTUl9BVFRSKSkge1xuICAgICAgICAgICAgb2xkVm5vZGUucmVtb3ZlQXR0cmlidXRlKFNTUl9BVFRSKTtcbiAgICAgICAgICAgIGh5ZHJhdGluZyA9IHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChpc1RydWUoaHlkcmF0aW5nKSkge1xuICAgICAgICAgICAgaWYgKGh5ZHJhdGUob2xkVm5vZGUsIHZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUpKSB7XG4gICAgICAgICAgICAgIGludm9rZUluc2VydEhvb2sodm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSwgdHJ1ZSk7XG4gICAgICAgICAgICAgIHJldHVybiBvbGRWbm9kZVxuICAgICAgICAgICAgfSBlbHNlIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgICAgICAgIHdhcm4oXG4gICAgICAgICAgICAgICAgJ1RoZSBjbGllbnQtc2lkZSByZW5kZXJlZCB2aXJ0dWFsIERPTSB0cmVlIGlzIG5vdCBtYXRjaGluZyAnICtcbiAgICAgICAgICAgICAgICAnc2VydmVyLXJlbmRlcmVkIGNvbnRlbnQuIFRoaXMgaXMgbGlrZWx5IGNhdXNlZCBieSBpbmNvcnJlY3QgJyArXG4gICAgICAgICAgICAgICAgJ0hUTUwgbWFya3VwLCBmb3IgZXhhbXBsZSBuZXN0aW5nIGJsb2NrLWxldmVsIGVsZW1lbnRzIGluc2lkZSAnICtcbiAgICAgICAgICAgICAgICAnPHA+LCBvciBtaXNzaW5nIDx0Ym9keT4uIEJhaWxpbmcgaHlkcmF0aW9uIGFuZCBwZXJmb3JtaW5nICcgK1xuICAgICAgICAgICAgICAgICdmdWxsIGNsaWVudC1zaWRlIHJlbmRlci4nXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIC8vIGVpdGhlciBub3Qgc2VydmVyLXJlbmRlcmVkLCBvciBoeWRyYXRpb24gZmFpbGVkLlxuICAgICAgICAgIC8vIGNyZWF0ZSBhbiBlbXB0eSBub2RlIGFuZCByZXBsYWNlIGl0XG4gICAgICAgICAgb2xkVm5vZGUgPSBlbXB0eU5vZGVBdChvbGRWbm9kZSk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyByZXBsYWNpbmcgZXhpc3RpbmcgZWxlbWVudFxuICAgICAgICB2YXIgb2xkRWxtID0gb2xkVm5vZGUuZWxtO1xuICAgICAgICB2YXIgcGFyZW50RWxtJDEgPSBub2RlT3BzLnBhcmVudE5vZGUob2xkRWxtKTtcblxuICAgICAgICAvLyBjcmVhdGUgbmV3IG5vZGVcbiAgICAgICAgY3JlYXRlRWxtKFxuICAgICAgICAgIHZub2RlLFxuICAgICAgICAgIGluc2VydGVkVm5vZGVRdWV1ZSxcbiAgICAgICAgICAvLyBleHRyZW1lbHkgcmFyZSBlZGdlIGNhc2U6IGRvIG5vdCBpbnNlcnQgaWYgb2xkIGVsZW1lbnQgaXMgaW4gYVxuICAgICAgICAgIC8vIGxlYXZpbmcgdHJhbnNpdGlvbi4gT25seSBoYXBwZW5zIHdoZW4gY29tYmluaW5nIHRyYW5zaXRpb24gK1xuICAgICAgICAgIC8vIGtlZXAtYWxpdmUgKyBIT0NzLiAoIzQ1OTApXG4gICAgICAgICAgb2xkRWxtLl9sZWF2ZUNiID8gbnVsbCA6IHBhcmVudEVsbSQxLFxuICAgICAgICAgIG5vZGVPcHMubmV4dFNpYmxpbmcob2xkRWxtKVxuICAgICAgICApO1xuXG4gICAgICAgIC8vIHVwZGF0ZSBwYXJlbnQgcGxhY2Vob2xkZXIgbm9kZSBlbGVtZW50LCByZWN1cnNpdmVseVxuICAgICAgICBpZiAoaXNEZWYodm5vZGUucGFyZW50KSkge1xuICAgICAgICAgIHZhciBhbmNlc3RvciA9IHZub2RlLnBhcmVudDtcbiAgICAgICAgICB2YXIgcGF0Y2hhYmxlID0gaXNQYXRjaGFibGUodm5vZGUpO1xuICAgICAgICAgIHdoaWxlIChhbmNlc3Rvcikge1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjYnMuZGVzdHJveS5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgICBjYnMuZGVzdHJveVtpXShhbmNlc3Rvcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBhbmNlc3Rvci5lbG0gPSB2bm9kZS5lbG07XG4gICAgICAgICAgICBpZiAocGF0Y2hhYmxlKSB7XG4gICAgICAgICAgICAgIGZvciAodmFyIGkkMSA9IDA7IGkkMSA8IGNicy5jcmVhdGUubGVuZ3RoOyArK2kkMSkge1xuICAgICAgICAgICAgICAgIGNicy5jcmVhdGVbaSQxXShlbXB0eU5vZGUsIGFuY2VzdG9yKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAvLyAjNjUxM1xuICAgICAgICAgICAgICAvLyBpbnZva2UgaW5zZXJ0IGhvb2tzIHRoYXQgbWF5IGhhdmUgYmVlbiBtZXJnZWQgYnkgY3JlYXRlIGhvb2tzLlxuICAgICAgICAgICAgICAvLyBlLmcuIGZvciBkaXJlY3RpdmVzIHRoYXQgdXNlcyB0aGUgXCJpbnNlcnRlZFwiIGhvb2suXG4gICAgICAgICAgICAgIHZhciBpbnNlcnQgPSBhbmNlc3Rvci5kYXRhLmhvb2suaW5zZXJ0O1xuICAgICAgICAgICAgICBpZiAoaW5zZXJ0Lm1lcmdlZCkge1xuICAgICAgICAgICAgICAgIC8vIHN0YXJ0IGF0IGluZGV4IDEgdG8gYXZvaWQgcmUtaW52b2tpbmcgY29tcG9uZW50IG1vdW50ZWQgaG9va1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGkkMiA9IDE7IGkkMiA8IGluc2VydC5mbnMubGVuZ3RoOyBpJDIrKykge1xuICAgICAgICAgICAgICAgICAgaW5zZXJ0LmZuc1tpJDJdKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICByZWdpc3RlclJlZihhbmNlc3Rvcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBhbmNlc3RvciA9IGFuY2VzdG9yLnBhcmVudDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBkZXN0cm95IG9sZCBub2RlXG4gICAgICAgIGlmIChpc0RlZihwYXJlbnRFbG0kMSkpIHtcbiAgICAgICAgICByZW1vdmVWbm9kZXMocGFyZW50RWxtJDEsIFtvbGRWbm9kZV0sIDAsIDApO1xuICAgICAgICB9IGVsc2UgaWYgKGlzRGVmKG9sZFZub2RlLnRhZykpIHtcbiAgICAgICAgICBpbnZva2VEZXN0cm95SG9vayhvbGRWbm9kZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBpbnZva2VJbnNlcnRIb29rKHZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUsIGlzSW5pdGlhbFBhdGNoKTtcbiAgICByZXR1cm4gdm5vZGUuZWxtXG4gIH1cbn1cblxuLyogICovXG5cbnZhciBkaXJlY3RpdmVzID0ge1xuICBjcmVhdGU6IHVwZGF0ZURpcmVjdGl2ZXMsXG4gIHVwZGF0ZTogdXBkYXRlRGlyZWN0aXZlcyxcbiAgZGVzdHJveTogZnVuY3Rpb24gdW5iaW5kRGlyZWN0aXZlcyAodm5vZGUpIHtcbiAgICB1cGRhdGVEaXJlY3RpdmVzKHZub2RlLCBlbXB0eU5vZGUpO1xuICB9XG59O1xuXG5mdW5jdGlvbiB1cGRhdGVEaXJlY3RpdmVzIChvbGRWbm9kZSwgdm5vZGUpIHtcbiAgaWYgKG9sZFZub2RlLmRhdGEuZGlyZWN0aXZlcyB8fCB2bm9kZS5kYXRhLmRpcmVjdGl2ZXMpIHtcbiAgICBfdXBkYXRlKG9sZFZub2RlLCB2bm9kZSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gX3VwZGF0ZSAob2xkVm5vZGUsIHZub2RlKSB7XG4gIHZhciBpc0NyZWF0ZSA9IG9sZFZub2RlID09PSBlbXB0eU5vZGU7XG4gIHZhciBpc0Rlc3Ryb3kgPSB2bm9kZSA9PT0gZW1wdHlOb2RlO1xuICB2YXIgb2xkRGlycyA9IG5vcm1hbGl6ZURpcmVjdGl2ZXMkMShvbGRWbm9kZS5kYXRhLmRpcmVjdGl2ZXMsIG9sZFZub2RlLmNvbnRleHQpO1xuICB2YXIgbmV3RGlycyA9IG5vcm1hbGl6ZURpcmVjdGl2ZXMkMSh2bm9kZS5kYXRhLmRpcmVjdGl2ZXMsIHZub2RlLmNvbnRleHQpO1xuXG4gIHZhciBkaXJzV2l0aEluc2VydCA9IFtdO1xuICB2YXIgZGlyc1dpdGhQb3N0cGF0Y2ggPSBbXTtcblxuICB2YXIga2V5LCBvbGREaXIsIGRpcjtcbiAgZm9yIChrZXkgaW4gbmV3RGlycykge1xuICAgIG9sZERpciA9IG9sZERpcnNba2V5XTtcbiAgICBkaXIgPSBuZXdEaXJzW2tleV07XG4gICAgaWYgKCFvbGREaXIpIHtcbiAgICAgIC8vIG5ldyBkaXJlY3RpdmUsIGJpbmRcbiAgICAgIGNhbGxIb29rJDEoZGlyLCAnYmluZCcsIHZub2RlLCBvbGRWbm9kZSk7XG4gICAgICBpZiAoZGlyLmRlZiAmJiBkaXIuZGVmLmluc2VydGVkKSB7XG4gICAgICAgIGRpcnNXaXRoSW5zZXJ0LnB1c2goZGlyKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgLy8gZXhpc3RpbmcgZGlyZWN0aXZlLCB1cGRhdGVcbiAgICAgIGRpci5vbGRWYWx1ZSA9IG9sZERpci52YWx1ZTtcbiAgICAgIGNhbGxIb29rJDEoZGlyLCAndXBkYXRlJywgdm5vZGUsIG9sZFZub2RlKTtcbiAgICAgIGlmIChkaXIuZGVmICYmIGRpci5kZWYuY29tcG9uZW50VXBkYXRlZCkge1xuICAgICAgICBkaXJzV2l0aFBvc3RwYXRjaC5wdXNoKGRpcik7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgaWYgKGRpcnNXaXRoSW5zZXJ0Lmxlbmd0aCkge1xuICAgIHZhciBjYWxsSW5zZXJ0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBkaXJzV2l0aEluc2VydC5sZW5ndGg7IGkrKykge1xuICAgICAgICBjYWxsSG9vayQxKGRpcnNXaXRoSW5zZXJ0W2ldLCAnaW5zZXJ0ZWQnLCB2bm9kZSwgb2xkVm5vZGUpO1xuICAgICAgfVxuICAgIH07XG4gICAgaWYgKGlzQ3JlYXRlKSB7XG4gICAgICBtZXJnZVZOb2RlSG9vayh2bm9kZSwgJ2luc2VydCcsIGNhbGxJbnNlcnQpO1xuICAgIH0gZWxzZSB7XG4gICAgICBjYWxsSW5zZXJ0KCk7XG4gICAgfVxuICB9XG5cbiAgaWYgKGRpcnNXaXRoUG9zdHBhdGNoLmxlbmd0aCkge1xuICAgIG1lcmdlVk5vZGVIb29rKHZub2RlLCAncG9zdHBhdGNoJywgZnVuY3Rpb24gKCkge1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBkaXJzV2l0aFBvc3RwYXRjaC5sZW5ndGg7IGkrKykge1xuICAgICAgICBjYWxsSG9vayQxKGRpcnNXaXRoUG9zdHBhdGNoW2ldLCAnY29tcG9uZW50VXBkYXRlZCcsIHZub2RlLCBvbGRWbm9kZSk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICBpZiAoIWlzQ3JlYXRlKSB7XG4gICAgZm9yIChrZXkgaW4gb2xkRGlycykge1xuICAgICAgaWYgKCFuZXdEaXJzW2tleV0pIHtcbiAgICAgICAgLy8gbm8gbG9uZ2VyIHByZXNlbnQsIHVuYmluZFxuICAgICAgICBjYWxsSG9vayQxKG9sZERpcnNba2V5XSwgJ3VuYmluZCcsIG9sZFZub2RlLCBvbGRWbm9kZSwgaXNEZXN0cm95KTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxudmFyIGVtcHR5TW9kaWZpZXJzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcblxuZnVuY3Rpb24gbm9ybWFsaXplRGlyZWN0aXZlcyQxIChcbiAgZGlycyxcbiAgdm1cbikge1xuICB2YXIgcmVzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgaWYgKCFkaXJzKSB7XG4gICAgLy8gJGZsb3ctZGlzYWJsZS1saW5lXG4gICAgcmV0dXJuIHJlc1xuICB9XG4gIHZhciBpLCBkaXI7XG4gIGZvciAoaSA9IDA7IGkgPCBkaXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgZGlyID0gZGlyc1tpXTtcbiAgICBpZiAoIWRpci5tb2RpZmllcnMpIHtcbiAgICAgIC8vICRmbG93LWRpc2FibGUtbGluZVxuICAgICAgZGlyLm1vZGlmaWVycyA9IGVtcHR5TW9kaWZpZXJzO1xuICAgIH1cbiAgICByZXNbZ2V0UmF3RGlyTmFtZShkaXIpXSA9IGRpcjtcbiAgICBkaXIuZGVmID0gcmVzb2x2ZUFzc2V0KHZtLiRvcHRpb25zLCAnZGlyZWN0aXZlcycsIGRpci5uYW1lLCB0cnVlKTtcbiAgfVxuICAvLyAkZmxvdy1kaXNhYmxlLWxpbmVcbiAgcmV0dXJuIHJlc1xufVxuXG5mdW5jdGlvbiBnZXRSYXdEaXJOYW1lIChkaXIpIHtcbiAgcmV0dXJuIGRpci5yYXdOYW1lIHx8ICgoZGlyLm5hbWUpICsgXCIuXCIgKyAoT2JqZWN0LmtleXMoZGlyLm1vZGlmaWVycyB8fCB7fSkuam9pbignLicpKSlcbn1cblxuZnVuY3Rpb24gY2FsbEhvb2skMSAoZGlyLCBob29rLCB2bm9kZSwgb2xkVm5vZGUsIGlzRGVzdHJveSkge1xuICB2YXIgZm4gPSBkaXIuZGVmICYmIGRpci5kZWZbaG9va107XG4gIGlmIChmbikge1xuICAgIHRyeSB7XG4gICAgICBmbih2bm9kZS5lbG0sIGRpciwgdm5vZGUsIG9sZFZub2RlLCBpc0Rlc3Ryb3kpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIGhhbmRsZUVycm9yKGUsIHZub2RlLmNvbnRleHQsIChcImRpcmVjdGl2ZSBcIiArIChkaXIubmFtZSkgKyBcIiBcIiArIGhvb2sgKyBcIiBob29rXCIpKTtcbiAgICB9XG4gIH1cbn1cblxudmFyIGJhc2VNb2R1bGVzID0gW1xuICByZWYsXG4gIGRpcmVjdGl2ZXNcbl07XG5cbi8qICAqL1xuXG5mdW5jdGlvbiB1cGRhdGVBdHRycyAob2xkVm5vZGUsIHZub2RlKSB7XG4gIHZhciBvcHRzID0gdm5vZGUuY29tcG9uZW50T3B0aW9ucztcbiAgaWYgKGlzRGVmKG9wdHMpICYmIG9wdHMuQ3Rvci5vcHRpb25zLmluaGVyaXRBdHRycyA9PT0gZmFsc2UpIHtcbiAgICByZXR1cm5cbiAgfVxuICBpZiAoaXNVbmRlZihvbGRWbm9kZS5kYXRhLmF0dHJzKSAmJiBpc1VuZGVmKHZub2RlLmRhdGEuYXR0cnMpKSB7XG4gICAgcmV0dXJuXG4gIH1cbiAgdmFyIGtleSwgY3VyLCBvbGQ7XG4gIHZhciBlbG0gPSB2bm9kZS5lbG07XG4gIHZhciBvbGRBdHRycyA9IG9sZFZub2RlLmRhdGEuYXR0cnMgfHwge307XG4gIHZhciBhdHRycyA9IHZub2RlLmRhdGEuYXR0cnMgfHwge307XG4gIC8vIGNsb25lIG9ic2VydmVkIG9iamVjdHMsIGFzIHRoZSB1c2VyIHByb2JhYmx5IHdhbnRzIHRvIG11dGF0ZSBpdFxuICBpZiAoaXNEZWYoYXR0cnMuX19vYl9fKSkge1xuICAgIGF0dHJzID0gdm5vZGUuZGF0YS5hdHRycyA9IGV4dGVuZCh7fSwgYXR0cnMpO1xuICB9XG5cbiAgZm9yIChrZXkgaW4gYXR0cnMpIHtcbiAgICBjdXIgPSBhdHRyc1trZXldO1xuICAgIG9sZCA9IG9sZEF0dHJzW2tleV07XG4gICAgaWYgKG9sZCAhPT0gY3VyKSB7XG4gICAgICBzZXRBdHRyKGVsbSwga2V5LCBjdXIpO1xuICAgIH1cbiAgfVxuICAvLyAjNDM5MTogaW4gSUU5LCBzZXR0aW5nIHR5cGUgY2FuIHJlc2V0IHZhbHVlIGZvciBpbnB1dFt0eXBlPXJhZGlvXVxuICAvLyAjNjY2NjogSUUvRWRnZSBmb3JjZXMgcHJvZ3Jlc3MgdmFsdWUgZG93biB0byAxIGJlZm9yZSBzZXR0aW5nIGEgbWF4XG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICBpZiAoKGlzSUUgfHwgaXNFZGdlKSAmJiBhdHRycy52YWx1ZSAhPT0gb2xkQXR0cnMudmFsdWUpIHtcbiAgICBzZXRBdHRyKGVsbSwgJ3ZhbHVlJywgYXR0cnMudmFsdWUpO1xuICB9XG4gIGZvciAoa2V5IGluIG9sZEF0dHJzKSB7XG4gICAgaWYgKGlzVW5kZWYoYXR0cnNba2V5XSkpIHtcbiAgICAgIGlmIChpc1hsaW5rKGtleSkpIHtcbiAgICAgICAgZWxtLnJlbW92ZUF0dHJpYnV0ZU5TKHhsaW5rTlMsIGdldFhsaW5rUHJvcChrZXkpKTtcbiAgICAgIH0gZWxzZSBpZiAoIWlzRW51bWVyYXRlZEF0dHIoa2V5KSkge1xuICAgICAgICBlbG0ucmVtb3ZlQXR0cmlidXRlKGtleSk7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIHNldEF0dHIgKGVsLCBrZXksIHZhbHVlKSB7XG4gIGlmIChpc0Jvb2xlYW5BdHRyKGtleSkpIHtcbiAgICAvLyBzZXQgYXR0cmlidXRlIGZvciBibGFuayB2YWx1ZVxuICAgIC8vIGUuZy4gPG9wdGlvbiBkaXNhYmxlZD5TZWxlY3Qgb25lPC9vcHRpb24+XG4gICAgaWYgKGlzRmFsc3lBdHRyVmFsdWUodmFsdWUpKSB7XG4gICAgICBlbC5yZW1vdmVBdHRyaWJ1dGUoa2V5KTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gdGVjaG5pY2FsbHkgYWxsb3dmdWxsc2NyZWVuIGlzIGEgYm9vbGVhbiBhdHRyaWJ1dGUgZm9yIDxpZnJhbWU+LFxuICAgICAgLy8gYnV0IEZsYXNoIGV4cGVjdHMgYSB2YWx1ZSBvZiBcInRydWVcIiB3aGVuIHVzZWQgb24gPGVtYmVkPiB0YWdcbiAgICAgIHZhbHVlID0ga2V5ID09PSAnYWxsb3dmdWxsc2NyZWVuJyAmJiBlbC50YWdOYW1lID09PSAnRU1CRUQnXG4gICAgICAgID8gJ3RydWUnXG4gICAgICAgIDoga2V5O1xuICAgICAgZWwuc2V0QXR0cmlidXRlKGtleSwgdmFsdWUpO1xuICAgIH1cbiAgfSBlbHNlIGlmIChpc0VudW1lcmF0ZWRBdHRyKGtleSkpIHtcbiAgICBlbC5zZXRBdHRyaWJ1dGUoa2V5LCBpc0ZhbHN5QXR0clZhbHVlKHZhbHVlKSB8fCB2YWx1ZSA9PT0gJ2ZhbHNlJyA/ICdmYWxzZScgOiAndHJ1ZScpO1xuICB9IGVsc2UgaWYgKGlzWGxpbmsoa2V5KSkge1xuICAgIGlmIChpc0ZhbHN5QXR0clZhbHVlKHZhbHVlKSkge1xuICAgICAgZWwucmVtb3ZlQXR0cmlidXRlTlMoeGxpbmtOUywgZ2V0WGxpbmtQcm9wKGtleSkpO1xuICAgIH0gZWxzZSB7XG4gICAgICBlbC5zZXRBdHRyaWJ1dGVOUyh4bGlua05TLCBrZXksIHZhbHVlKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgaWYgKGlzRmFsc3lBdHRyVmFsdWUodmFsdWUpKSB7XG4gICAgICBlbC5yZW1vdmVBdHRyaWJ1dGUoa2V5KTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gIzcxMzg6IElFMTAgJiAxMSBmaXJlcyBpbnB1dCBldmVudCB3aGVuIHNldHRpbmcgcGxhY2Vob2xkZXIgb25cbiAgICAgIC8vIDx0ZXh0YXJlYT4uLi4gYmxvY2sgdGhlIGZpcnN0IGlucHV0IGV2ZW50IGFuZCByZW1vdmUgdGhlIGJsb2NrZXJcbiAgICAgIC8vIGltbWVkaWF0ZWx5LlxuICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgICBpZiAoXG4gICAgICAgIGlzSUUgJiYgIWlzSUU5ICYmXG4gICAgICAgIGVsLnRhZ05hbWUgPT09ICdURVhUQVJFQScgJiZcbiAgICAgICAga2V5ID09PSAncGxhY2Vob2xkZXInICYmICFlbC5fX2llcGhcbiAgICAgICkge1xuICAgICAgICB2YXIgYmxvY2tlciA9IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgZS5zdG9wSW1tZWRpYXRlUHJvcGFnYXRpb24oKTtcbiAgICAgICAgICBlbC5yZW1vdmVFdmVudExpc3RlbmVyKCdpbnB1dCcsIGJsb2NrZXIpO1xuICAgICAgICB9O1xuICAgICAgICBlbC5hZGRFdmVudExpc3RlbmVyKCdpbnB1dCcsIGJsb2NrZXIpO1xuICAgICAgICAvLyAkZmxvdy1kaXNhYmxlLWxpbmVcbiAgICAgICAgZWwuX19pZXBoID0gdHJ1ZTsgLyogSUUgcGxhY2Vob2xkZXIgcGF0Y2hlZCAqL1xuICAgICAgfVxuICAgICAgZWwuc2V0QXR0cmlidXRlKGtleSwgdmFsdWUpO1xuICAgIH1cbiAgfVxufVxuXG52YXIgYXR0cnMgPSB7XG4gIGNyZWF0ZTogdXBkYXRlQXR0cnMsXG4gIHVwZGF0ZTogdXBkYXRlQXR0cnNcbn07XG5cbi8qICAqL1xuXG5mdW5jdGlvbiB1cGRhdGVDbGFzcyAob2xkVm5vZGUsIHZub2RlKSB7XG4gIHZhciBlbCA9IHZub2RlLmVsbTtcbiAgdmFyIGRhdGEgPSB2bm9kZS5kYXRhO1xuICB2YXIgb2xkRGF0YSA9IG9sZFZub2RlLmRhdGE7XG4gIGlmIChcbiAgICBpc1VuZGVmKGRhdGEuc3RhdGljQ2xhc3MpICYmXG4gICAgaXNVbmRlZihkYXRhLmNsYXNzKSAmJiAoXG4gICAgICBpc1VuZGVmKG9sZERhdGEpIHx8IChcbiAgICAgICAgaXNVbmRlZihvbGREYXRhLnN0YXRpY0NsYXNzKSAmJlxuICAgICAgICBpc1VuZGVmKG9sZERhdGEuY2xhc3MpXG4gICAgICApXG4gICAgKVxuICApIHtcbiAgICByZXR1cm5cbiAgfVxuXG4gIHZhciBjbHMgPSBnZW5DbGFzc0ZvclZub2RlKHZub2RlKTtcblxuICAvLyBoYW5kbGUgdHJhbnNpdGlvbiBjbGFzc2VzXG4gIHZhciB0cmFuc2l0aW9uQ2xhc3MgPSBlbC5fdHJhbnNpdGlvbkNsYXNzZXM7XG4gIGlmIChpc0RlZih0cmFuc2l0aW9uQ2xhc3MpKSB7XG4gICAgY2xzID0gY29uY2F0KGNscywgc3RyaW5naWZ5Q2xhc3ModHJhbnNpdGlvbkNsYXNzKSk7XG4gIH1cblxuICAvLyBzZXQgdGhlIGNsYXNzXG4gIGlmIChjbHMgIT09IGVsLl9wcmV2Q2xhc3MpIHtcbiAgICBlbC5zZXRBdHRyaWJ1dGUoJ2NsYXNzJywgY2xzKTtcbiAgICBlbC5fcHJldkNsYXNzID0gY2xzO1xuICB9XG59XG5cbnZhciBrbGFzcyA9IHtcbiAgY3JlYXRlOiB1cGRhdGVDbGFzcyxcbiAgdXBkYXRlOiB1cGRhdGVDbGFzc1xufTtcblxuLyogICovXG5cbnZhciB2YWxpZERpdmlzaW9uQ2hhclJFID0gL1tcXHcpLitcXC1fJFxcXV0vO1xuXG5mdW5jdGlvbiBwYXJzZUZpbHRlcnMgKGV4cCkge1xuICB2YXIgaW5TaW5nbGUgPSBmYWxzZTtcbiAgdmFyIGluRG91YmxlID0gZmFsc2U7XG4gIHZhciBpblRlbXBsYXRlU3RyaW5nID0gZmFsc2U7XG4gIHZhciBpblJlZ2V4ID0gZmFsc2U7XG4gIHZhciBjdXJseSA9IDA7XG4gIHZhciBzcXVhcmUgPSAwO1xuICB2YXIgcGFyZW4gPSAwO1xuICB2YXIgbGFzdEZpbHRlckluZGV4ID0gMDtcbiAgdmFyIGMsIHByZXYsIGksIGV4cHJlc3Npb24sIGZpbHRlcnM7XG5cbiAgZm9yIChpID0gMDsgaSA8IGV4cC5sZW5ndGg7IGkrKykge1xuICAgIHByZXYgPSBjO1xuICAgIGMgPSBleHAuY2hhckNvZGVBdChpKTtcbiAgICBpZiAoaW5TaW5nbGUpIHtcbiAgICAgIGlmIChjID09PSAweDI3ICYmIHByZXYgIT09IDB4NUMpIHsgaW5TaW5nbGUgPSBmYWxzZTsgfVxuICAgIH0gZWxzZSBpZiAoaW5Eb3VibGUpIHtcbiAgICAgIGlmIChjID09PSAweDIyICYmIHByZXYgIT09IDB4NUMpIHsgaW5Eb3VibGUgPSBmYWxzZTsgfVxuICAgIH0gZWxzZSBpZiAoaW5UZW1wbGF0ZVN0cmluZykge1xuICAgICAgaWYgKGMgPT09IDB4NjAgJiYgcHJldiAhPT0gMHg1QykgeyBpblRlbXBsYXRlU3RyaW5nID0gZmFsc2U7IH1cbiAgICB9IGVsc2UgaWYgKGluUmVnZXgpIHtcbiAgICAgIGlmIChjID09PSAweDJmICYmIHByZXYgIT09IDB4NUMpIHsgaW5SZWdleCA9IGZhbHNlOyB9XG4gICAgfSBlbHNlIGlmIChcbiAgICAgIGMgPT09IDB4N0MgJiYgLy8gcGlwZVxuICAgICAgZXhwLmNoYXJDb2RlQXQoaSArIDEpICE9PSAweDdDICYmXG4gICAgICBleHAuY2hhckNvZGVBdChpIC0gMSkgIT09IDB4N0MgJiZcbiAgICAgICFjdXJseSAmJiAhc3F1YXJlICYmICFwYXJlblxuICAgICkge1xuICAgICAgaWYgKGV4cHJlc3Npb24gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAvLyBmaXJzdCBmaWx0ZXIsIGVuZCBvZiBleHByZXNzaW9uXG4gICAgICAgIGxhc3RGaWx0ZXJJbmRleCA9IGkgKyAxO1xuICAgICAgICBleHByZXNzaW9uID0gZXhwLnNsaWNlKDAsIGkpLnRyaW0oKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHB1c2hGaWx0ZXIoKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgc3dpdGNoIChjKSB7XG4gICAgICAgIGNhc2UgMHgyMjogaW5Eb3VibGUgPSB0cnVlOyBicmVhayAgICAgICAgIC8vIFwiXG4gICAgICAgIGNhc2UgMHgyNzogaW5TaW5nbGUgPSB0cnVlOyBicmVhayAgICAgICAgIC8vICdcbiAgICAgICAgY2FzZSAweDYwOiBpblRlbXBsYXRlU3RyaW5nID0gdHJ1ZTsgYnJlYWsgLy8gYFxuICAgICAgICBjYXNlIDB4Mjg6IHBhcmVuKys7IGJyZWFrICAgICAgICAgICAgICAgICAvLyAoXG4gICAgICAgIGNhc2UgMHgyOTogcGFyZW4tLTsgYnJlYWsgICAgICAgICAgICAgICAgIC8vIClcbiAgICAgICAgY2FzZSAweDVCOiBzcXVhcmUrKzsgYnJlYWsgICAgICAgICAgICAgICAgLy8gW1xuICAgICAgICBjYXNlIDB4NUQ6IHNxdWFyZS0tOyBicmVhayAgICAgICAgICAgICAgICAvLyBdXG4gICAgICAgIGNhc2UgMHg3QjogY3VybHkrKzsgYnJlYWsgICAgICAgICAgICAgICAgIC8vIHtcbiAgICAgICAgY2FzZSAweDdEOiBjdXJseS0tOyBicmVhayAgICAgICAgICAgICAgICAgLy8gfVxuICAgICAgfVxuICAgICAgaWYgKGMgPT09IDB4MmYpIHsgLy8gL1xuICAgICAgICB2YXIgaiA9IGkgLSAxO1xuICAgICAgICB2YXIgcCA9ICh2b2lkIDApO1xuICAgICAgICAvLyBmaW5kIGZpcnN0IG5vbi13aGl0ZXNwYWNlIHByZXYgY2hhclxuICAgICAgICBmb3IgKDsgaiA+PSAwOyBqLS0pIHtcbiAgICAgICAgICBwID0gZXhwLmNoYXJBdChqKTtcbiAgICAgICAgICBpZiAocCAhPT0gJyAnKSB7IGJyZWFrIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoIXAgfHwgIXZhbGlkRGl2aXNpb25DaGFyUkUudGVzdChwKSkge1xuICAgICAgICAgIGluUmVnZXggPSB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgaWYgKGV4cHJlc3Npb24gPT09IHVuZGVmaW5lZCkge1xuICAgIGV4cHJlc3Npb24gPSBleHAuc2xpY2UoMCwgaSkudHJpbSgpO1xuICB9IGVsc2UgaWYgKGxhc3RGaWx0ZXJJbmRleCAhPT0gMCkge1xuICAgIHB1c2hGaWx0ZXIoKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHB1c2hGaWx0ZXIgKCkge1xuICAgIChmaWx0ZXJzIHx8IChmaWx0ZXJzID0gW10pKS5wdXNoKGV4cC5zbGljZShsYXN0RmlsdGVySW5kZXgsIGkpLnRyaW0oKSk7XG4gICAgbGFzdEZpbHRlckluZGV4ID0gaSArIDE7XG4gIH1cblxuICBpZiAoZmlsdGVycykge1xuICAgIGZvciAoaSA9IDA7IGkgPCBmaWx0ZXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBleHByZXNzaW9uID0gd3JhcEZpbHRlcihleHByZXNzaW9uLCBmaWx0ZXJzW2ldKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZXhwcmVzc2lvblxufVxuXG5mdW5jdGlvbiB3cmFwRmlsdGVyIChleHAsIGZpbHRlcikge1xuICB2YXIgaSA9IGZpbHRlci5pbmRleE9mKCcoJyk7XG4gIGlmIChpIDwgMCkge1xuICAgIC8vIF9mOiByZXNvbHZlRmlsdGVyXG4gICAgcmV0dXJuIChcIl9mKFxcXCJcIiArIGZpbHRlciArIFwiXFxcIikoXCIgKyBleHAgKyBcIilcIilcbiAgfSBlbHNlIHtcbiAgICB2YXIgbmFtZSA9IGZpbHRlci5zbGljZSgwLCBpKTtcbiAgICB2YXIgYXJncyA9IGZpbHRlci5zbGljZShpICsgMSk7XG4gICAgcmV0dXJuIChcIl9mKFxcXCJcIiArIG5hbWUgKyBcIlxcXCIpKFwiICsgZXhwICsgXCIsXCIgKyBhcmdzKVxuICB9XG59XG5cbi8qICAqL1xuXG5mdW5jdGlvbiBiYXNlV2FybiAobXNnKSB7XG4gIGNvbnNvbGUuZXJyb3IoKFwiW1Z1ZSBjb21waWxlcl06IFwiICsgbXNnKSk7XG59XG5cbmZ1bmN0aW9uIHBsdWNrTW9kdWxlRnVuY3Rpb24gKFxuICBtb2R1bGVzLFxuICBrZXlcbikge1xuICByZXR1cm4gbW9kdWxlc1xuICAgID8gbW9kdWxlcy5tYXAoZnVuY3Rpb24gKG0pIHsgcmV0dXJuIG1ba2V5XTsgfSkuZmlsdGVyKGZ1bmN0aW9uIChfKSB7IHJldHVybiBfOyB9KVxuICAgIDogW11cbn1cblxuZnVuY3Rpb24gYWRkUHJvcCAoZWwsIG5hbWUsIHZhbHVlKSB7XG4gIChlbC5wcm9wcyB8fCAoZWwucHJvcHMgPSBbXSkpLnB1c2goeyBuYW1lOiBuYW1lLCB2YWx1ZTogdmFsdWUgfSk7XG59XG5cbmZ1bmN0aW9uIGFkZEF0dHIgKGVsLCBuYW1lLCB2YWx1ZSkge1xuICAoZWwuYXR0cnMgfHwgKGVsLmF0dHJzID0gW10pKS5wdXNoKHsgbmFtZTogbmFtZSwgdmFsdWU6IHZhbHVlIH0pO1xufVxuXG5mdW5jdGlvbiBhZGREaXJlY3RpdmUgKFxuICBlbCxcbiAgbmFtZSxcbiAgcmF3TmFtZSxcbiAgdmFsdWUsXG4gIGFyZyxcbiAgbW9kaWZpZXJzXG4pIHtcbiAgKGVsLmRpcmVjdGl2ZXMgfHwgKGVsLmRpcmVjdGl2ZXMgPSBbXSkpLnB1c2goeyBuYW1lOiBuYW1lLCByYXdOYW1lOiByYXdOYW1lLCB2YWx1ZTogdmFsdWUsIGFyZzogYXJnLCBtb2RpZmllcnM6IG1vZGlmaWVycyB9KTtcbn1cblxuZnVuY3Rpb24gYWRkSGFuZGxlciAoXG4gIGVsLFxuICBuYW1lLFxuICB2YWx1ZSxcbiAgbW9kaWZpZXJzLFxuICBpbXBvcnRhbnQsXG4gIHdhcm5cbikge1xuICBtb2RpZmllcnMgPSBtb2RpZmllcnMgfHwgZW1wdHlPYmplY3Q7XG4gIC8vIHdhcm4gcHJldmVudCBhbmQgcGFzc2l2ZSBtb2RpZmllclxuICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgaWYgKFxuICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgd2FybiAmJlxuICAgIG1vZGlmaWVycy5wcmV2ZW50ICYmIG1vZGlmaWVycy5wYXNzaXZlXG4gICkge1xuICAgIHdhcm4oXG4gICAgICAncGFzc2l2ZSBhbmQgcHJldmVudCBjYW5cXCd0IGJlIHVzZWQgdG9nZXRoZXIuICcgK1xuICAgICAgJ1Bhc3NpdmUgaGFuZGxlciBjYW5cXCd0IHByZXZlbnQgZGVmYXVsdCBldmVudC4nXG4gICAgKTtcbiAgfVxuXG4gIC8vIGNoZWNrIGNhcHR1cmUgbW9kaWZpZXJcbiAgaWYgKG1vZGlmaWVycy5jYXB0dXJlKSB7XG4gICAgZGVsZXRlIG1vZGlmaWVycy5jYXB0dXJlO1xuICAgIG5hbWUgPSAnIScgKyBuYW1lOyAvLyBtYXJrIHRoZSBldmVudCBhcyBjYXB0dXJlZFxuICB9XG4gIGlmIChtb2RpZmllcnMub25jZSkge1xuICAgIGRlbGV0ZSBtb2RpZmllcnMub25jZTtcbiAgICBuYW1lID0gJ34nICsgbmFtZTsgLy8gbWFyayB0aGUgZXZlbnQgYXMgb25jZVxuICB9XG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICBpZiAobW9kaWZpZXJzLnBhc3NpdmUpIHtcbiAgICBkZWxldGUgbW9kaWZpZXJzLnBhc3NpdmU7XG4gICAgbmFtZSA9ICcmJyArIG5hbWU7IC8vIG1hcmsgdGhlIGV2ZW50IGFzIHBhc3NpdmVcbiAgfVxuXG4gIC8vIG5vcm1hbGl6ZSBjbGljay5yaWdodCBhbmQgY2xpY2subWlkZGxlIHNpbmNlIHRoZXkgZG9uJ3QgYWN0dWFsbHkgZmlyZVxuICAvLyB0aGlzIGlzIHRlY2huaWNhbGx5IGJyb3dzZXItc3BlY2lmaWMsIGJ1dCBhdCBsZWFzdCBmb3Igbm93IGJyb3dzZXJzIGFyZVxuICAvLyB0aGUgb25seSB0YXJnZXQgZW52cyB0aGF0IGhhdmUgcmlnaHQvbWlkZGxlIGNsaWNrcy5cbiAgaWYgKG5hbWUgPT09ICdjbGljaycpIHtcbiAgICBpZiAobW9kaWZpZXJzLnJpZ2h0KSB7XG4gICAgICBuYW1lID0gJ2NvbnRleHRtZW51JztcbiAgICAgIGRlbGV0ZSBtb2RpZmllcnMucmlnaHQ7XG4gICAgfSBlbHNlIGlmIChtb2RpZmllcnMubWlkZGxlKSB7XG4gICAgICBuYW1lID0gJ21vdXNldXAnO1xuICAgIH1cbiAgfVxuXG4gIHZhciBldmVudHM7XG4gIGlmIChtb2RpZmllcnMubmF0aXZlKSB7XG4gICAgZGVsZXRlIG1vZGlmaWVycy5uYXRpdmU7XG4gICAgZXZlbnRzID0gZWwubmF0aXZlRXZlbnRzIHx8IChlbC5uYXRpdmVFdmVudHMgPSB7fSk7XG4gIH0gZWxzZSB7XG4gICAgZXZlbnRzID0gZWwuZXZlbnRzIHx8IChlbC5ldmVudHMgPSB7fSk7XG4gIH1cblxuICB2YXIgbmV3SGFuZGxlciA9IHsgdmFsdWU6IHZhbHVlIH07XG4gIGlmIChtb2RpZmllcnMgIT09IGVtcHR5T2JqZWN0KSB7XG4gICAgbmV3SGFuZGxlci5tb2RpZmllcnMgPSBtb2RpZmllcnM7XG4gIH1cblxuICB2YXIgaGFuZGxlcnMgPSBldmVudHNbbmFtZV07XG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICBpZiAoQXJyYXkuaXNBcnJheShoYW5kbGVycykpIHtcbiAgICBpbXBvcnRhbnQgPyBoYW5kbGVycy51bnNoaWZ0KG5ld0hhbmRsZXIpIDogaGFuZGxlcnMucHVzaChuZXdIYW5kbGVyKTtcbiAgfSBlbHNlIGlmIChoYW5kbGVycykge1xuICAgIGV2ZW50c1tuYW1lXSA9IGltcG9ydGFudCA/IFtuZXdIYW5kbGVyLCBoYW5kbGVyc10gOiBbaGFuZGxlcnMsIG5ld0hhbmRsZXJdO1xuICB9IGVsc2Uge1xuICAgIGV2ZW50c1tuYW1lXSA9IG5ld0hhbmRsZXI7XG4gIH1cbn1cblxuZnVuY3Rpb24gZ2V0QmluZGluZ0F0dHIgKFxuICBlbCxcbiAgbmFtZSxcbiAgZ2V0U3RhdGljXG4pIHtcbiAgdmFyIGR5bmFtaWNWYWx1ZSA9XG4gICAgZ2V0QW5kUmVtb3ZlQXR0cihlbCwgJzonICsgbmFtZSkgfHxcbiAgICBnZXRBbmRSZW1vdmVBdHRyKGVsLCAndi1iaW5kOicgKyBuYW1lKTtcbiAgaWYgKGR5bmFtaWNWYWx1ZSAhPSBudWxsKSB7XG4gICAgcmV0dXJuIHBhcnNlRmlsdGVycyhkeW5hbWljVmFsdWUpXG4gIH0gZWxzZSBpZiAoZ2V0U3RhdGljICE9PSBmYWxzZSkge1xuICAgIHZhciBzdGF0aWNWYWx1ZSA9IGdldEFuZFJlbW92ZUF0dHIoZWwsIG5hbWUpO1xuICAgIGlmIChzdGF0aWNWYWx1ZSAhPSBudWxsKSB7XG4gICAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkoc3RhdGljVmFsdWUpXG4gICAgfVxuICB9XG59XG5cbi8vIG5vdGU6IHRoaXMgb25seSByZW1vdmVzIHRoZSBhdHRyIGZyb20gdGhlIEFycmF5IChhdHRyc0xpc3QpIHNvIHRoYXQgaXRcbi8vIGRvZXNuJ3QgZ2V0IHByb2Nlc3NlZCBieSBwcm9jZXNzQXR0cnMuXG4vLyBCeSBkZWZhdWx0IGl0IGRvZXMgTk9UIHJlbW92ZSBpdCBmcm9tIHRoZSBtYXAgKGF0dHJzTWFwKSBiZWNhdXNlIHRoZSBtYXAgaXNcbi8vIG5lZWRlZCBkdXJpbmcgY29kZWdlbi5cbmZ1bmN0aW9uIGdldEFuZFJlbW92ZUF0dHIgKFxuICBlbCxcbiAgbmFtZSxcbiAgcmVtb3ZlRnJvbU1hcFxuKSB7XG4gIHZhciB2YWw7XG4gIGlmICgodmFsID0gZWwuYXR0cnNNYXBbbmFtZV0pICE9IG51bGwpIHtcbiAgICB2YXIgbGlzdCA9IGVsLmF0dHJzTGlzdDtcbiAgICBmb3IgKHZhciBpID0gMCwgbCA9IGxpc3QubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICBpZiAobGlzdFtpXS5uYW1lID09PSBuYW1lKSB7XG4gICAgICAgIGxpc3Quc3BsaWNlKGksIDEpO1xuICAgICAgICBicmVha1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBpZiAocmVtb3ZlRnJvbU1hcCkge1xuICAgIGRlbGV0ZSBlbC5hdHRyc01hcFtuYW1lXTtcbiAgfVxuICByZXR1cm4gdmFsXG59XG5cbi8qICAqL1xuXG4vKipcbiAqIENyb3NzLXBsYXRmb3JtIGNvZGUgZ2VuZXJhdGlvbiBmb3IgY29tcG9uZW50IHYtbW9kZWxcbiAqL1xuZnVuY3Rpb24gZ2VuQ29tcG9uZW50TW9kZWwgKFxuICBlbCxcbiAgdmFsdWUsXG4gIG1vZGlmaWVyc1xuKSB7XG4gIHZhciByZWYgPSBtb2RpZmllcnMgfHwge307XG4gIHZhciBudW1iZXIgPSByZWYubnVtYmVyO1xuICB2YXIgdHJpbSA9IHJlZi50cmltO1xuXG4gIHZhciBiYXNlVmFsdWVFeHByZXNzaW9uID0gJyQkdic7XG4gIHZhciB2YWx1ZUV4cHJlc3Npb24gPSBiYXNlVmFsdWVFeHByZXNzaW9uO1xuICBpZiAodHJpbSkge1xuICAgIHZhbHVlRXhwcmVzc2lvbiA9XG4gICAgICBcIih0eXBlb2YgXCIgKyBiYXNlVmFsdWVFeHByZXNzaW9uICsgXCIgPT09ICdzdHJpbmcnXCIgK1xuICAgICAgICBcIj8gXCIgKyBiYXNlVmFsdWVFeHByZXNzaW9uICsgXCIudHJpbSgpXCIgK1xuICAgICAgICBcIjogXCIgKyBiYXNlVmFsdWVFeHByZXNzaW9uICsgXCIpXCI7XG4gIH1cbiAgaWYgKG51bWJlcikge1xuICAgIHZhbHVlRXhwcmVzc2lvbiA9IFwiX24oXCIgKyB2YWx1ZUV4cHJlc3Npb24gKyBcIilcIjtcbiAgfVxuICB2YXIgYXNzaWdubWVudCA9IGdlbkFzc2lnbm1lbnRDb2RlKHZhbHVlLCB2YWx1ZUV4cHJlc3Npb24pO1xuXG4gIGVsLm1vZGVsID0ge1xuICAgIHZhbHVlOiAoXCIoXCIgKyB2YWx1ZSArIFwiKVwiKSxcbiAgICBleHByZXNzaW9uOiAoXCJcXFwiXCIgKyB2YWx1ZSArIFwiXFxcIlwiKSxcbiAgICBjYWxsYmFjazogKFwiZnVuY3Rpb24gKFwiICsgYmFzZVZhbHVlRXhwcmVzc2lvbiArIFwiKSB7XCIgKyBhc3NpZ25tZW50ICsgXCJ9XCIpXG4gIH07XG59XG5cbi8qKlxuICogQ3Jvc3MtcGxhdGZvcm0gY29kZWdlbiBoZWxwZXIgZm9yIGdlbmVyYXRpbmcgdi1tb2RlbCB2YWx1ZSBhc3NpZ25tZW50IGNvZGUuXG4gKi9cbmZ1bmN0aW9uIGdlbkFzc2lnbm1lbnRDb2RlIChcbiAgdmFsdWUsXG4gIGFzc2lnbm1lbnRcbikge1xuICB2YXIgcmVzID0gcGFyc2VNb2RlbCh2YWx1ZSk7XG4gIGlmIChyZXMua2V5ID09PSBudWxsKSB7XG4gICAgcmV0dXJuICh2YWx1ZSArIFwiPVwiICsgYXNzaWdubWVudClcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gKFwiJHNldChcIiArIChyZXMuZXhwKSArIFwiLCBcIiArIChyZXMua2V5KSArIFwiLCBcIiArIGFzc2lnbm1lbnQgKyBcIilcIilcbiAgfVxufVxuXG4vKipcbiAqIFBhcnNlIGEgdi1tb2RlbCBleHByZXNzaW9uIGludG8gYSBiYXNlIHBhdGggYW5kIGEgZmluYWwga2V5IHNlZ21lbnQuXG4gKiBIYW5kbGVzIGJvdGggZG90LXBhdGggYW5kIHBvc3NpYmxlIHNxdWFyZSBicmFja2V0cy5cbiAqXG4gKiBQb3NzaWJsZSBjYXNlczpcbiAqXG4gKiAtIHRlc3RcbiAqIC0gdGVzdFtrZXldXG4gKiAtIHRlc3RbdGVzdDFba2V5XV1cbiAqIC0gdGVzdFtcImFcIl1ba2V5XVxuICogLSB4eHgudGVzdFthW2FdLnRlc3QxW2tleV1dXG4gKiAtIHRlc3QueHh4LmFbXCJhc2FcIl1bdGVzdDFba2V5XV1cbiAqXG4gKi9cblxudmFyIGxlbjtcbnZhciBzdHI7XG52YXIgY2hyO1xudmFyIGluZGV4JDE7XG52YXIgZXhwcmVzc2lvblBvcztcbnZhciBleHByZXNzaW9uRW5kUG9zO1xuXG5cblxuZnVuY3Rpb24gcGFyc2VNb2RlbCAodmFsKSB7XG4gIGxlbiA9IHZhbC5sZW5ndGg7XG5cbiAgaWYgKHZhbC5pbmRleE9mKCdbJykgPCAwIHx8IHZhbC5sYXN0SW5kZXhPZignXScpIDwgbGVuIC0gMSkge1xuICAgIGluZGV4JDEgPSB2YWwubGFzdEluZGV4T2YoJy4nKTtcbiAgICBpZiAoaW5kZXgkMSA+IC0xKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBleHA6IHZhbC5zbGljZSgwLCBpbmRleCQxKSxcbiAgICAgICAga2V5OiAnXCInICsgdmFsLnNsaWNlKGluZGV4JDEgKyAxKSArICdcIidcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgZXhwOiB2YWwsXG4gICAgICAgIGtleTogbnVsbFxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHN0ciA9IHZhbDtcbiAgaW5kZXgkMSA9IGV4cHJlc3Npb25Qb3MgPSBleHByZXNzaW9uRW5kUG9zID0gMDtcblxuICB3aGlsZSAoIWVvZigpKSB7XG4gICAgY2hyID0gbmV4dCgpO1xuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgIGlmIChpc1N0cmluZ1N0YXJ0KGNocikpIHtcbiAgICAgIHBhcnNlU3RyaW5nKGNocik7XG4gICAgfSBlbHNlIGlmIChjaHIgPT09IDB4NUIpIHtcbiAgICAgIHBhcnNlQnJhY2tldChjaHIpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB7XG4gICAgZXhwOiB2YWwuc2xpY2UoMCwgZXhwcmVzc2lvblBvcyksXG4gICAga2V5OiB2YWwuc2xpY2UoZXhwcmVzc2lvblBvcyArIDEsIGV4cHJlc3Npb25FbmRQb3MpXG4gIH1cbn1cblxuZnVuY3Rpb24gbmV4dCAoKSB7XG4gIHJldHVybiBzdHIuY2hhckNvZGVBdCgrK2luZGV4JDEpXG59XG5cbmZ1bmN0aW9uIGVvZiAoKSB7XG4gIHJldHVybiBpbmRleCQxID49IGxlblxufVxuXG5mdW5jdGlvbiBpc1N0cmluZ1N0YXJ0IChjaHIpIHtcbiAgcmV0dXJuIGNociA9PT0gMHgyMiB8fCBjaHIgPT09IDB4Mjdcbn1cblxuZnVuY3Rpb24gcGFyc2VCcmFja2V0IChjaHIpIHtcbiAgdmFyIGluQnJhY2tldCA9IDE7XG4gIGV4cHJlc3Npb25Qb3MgPSBpbmRleCQxO1xuICB3aGlsZSAoIWVvZigpKSB7XG4gICAgY2hyID0gbmV4dCgpO1xuICAgIGlmIChpc1N0cmluZ1N0YXJ0KGNocikpIHtcbiAgICAgIHBhcnNlU3RyaW5nKGNocik7XG4gICAgICBjb250aW51ZVxuICAgIH1cbiAgICBpZiAoY2hyID09PSAweDVCKSB7IGluQnJhY2tldCsrOyB9XG4gICAgaWYgKGNociA9PT0gMHg1RCkgeyBpbkJyYWNrZXQtLTsgfVxuICAgIGlmIChpbkJyYWNrZXQgPT09IDApIHtcbiAgICAgIGV4cHJlc3Npb25FbmRQb3MgPSBpbmRleCQxO1xuICAgICAgYnJlYWtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gcGFyc2VTdHJpbmcgKGNocikge1xuICB2YXIgc3RyaW5nUXVvdGUgPSBjaHI7XG4gIHdoaWxlICghZW9mKCkpIHtcbiAgICBjaHIgPSBuZXh0KCk7XG4gICAgaWYgKGNociA9PT0gc3RyaW5nUXVvdGUpIHtcbiAgICAgIGJyZWFrXG4gICAgfVxuICB9XG59XG5cbi8qICAqL1xuXG52YXIgd2FybiQxO1xuXG4vLyBpbiBzb21lIGNhc2VzLCB0aGUgZXZlbnQgdXNlZCBoYXMgdG8gYmUgZGV0ZXJtaW5lZCBhdCBydW50aW1lXG4vLyBzbyB3ZSB1c2VkIHNvbWUgcmVzZXJ2ZWQgdG9rZW5zIGR1cmluZyBjb21waWxlLlxudmFyIFJBTkdFX1RPS0VOID0gJ19fcic7XG52YXIgQ0hFQ0tCT1hfUkFESU9fVE9LRU4gPSAnX19jJztcblxuZnVuY3Rpb24gbW9kZWwgKFxuICBlbCxcbiAgZGlyLFxuICBfd2FyblxuKSB7XG4gIHdhcm4kMSA9IF93YXJuO1xuICB2YXIgdmFsdWUgPSBkaXIudmFsdWU7XG4gIHZhciBtb2RpZmllcnMgPSBkaXIubW9kaWZpZXJzO1xuICB2YXIgdGFnID0gZWwudGFnO1xuICB2YXIgdHlwZSA9IGVsLmF0dHJzTWFwLnR5cGU7XG5cbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAvLyBpbnB1dHMgd2l0aCB0eXBlPVwiZmlsZVwiIGFyZSByZWFkIG9ubHkgYW5kIHNldHRpbmcgdGhlIGlucHV0J3NcbiAgICAvLyB2YWx1ZSB3aWxsIHRocm93IGFuIGVycm9yLlxuICAgIGlmICh0YWcgPT09ICdpbnB1dCcgJiYgdHlwZSA9PT0gJ2ZpbGUnKSB7XG4gICAgICB3YXJuJDEoXG4gICAgICAgIFwiPFwiICsgKGVsLnRhZykgKyBcIiB2LW1vZGVsPVxcXCJcIiArIHZhbHVlICsgXCJcXFwiIHR5cGU9XFxcImZpbGVcXFwiPjpcXG5cIiArXG4gICAgICAgIFwiRmlsZSBpbnB1dHMgYXJlIHJlYWQgb25seS4gVXNlIGEgdi1vbjpjaGFuZ2UgbGlzdGVuZXIgaW5zdGVhZC5cIlxuICAgICAgKTtcbiAgICB9XG4gIH1cblxuICBpZiAoZWwuY29tcG9uZW50KSB7XG4gICAgZ2VuQ29tcG9uZW50TW9kZWwoZWwsIHZhbHVlLCBtb2RpZmllcnMpO1xuICAgIC8vIGNvbXBvbmVudCB2LW1vZGVsIGRvZXNuJ3QgbmVlZCBleHRyYSBydW50aW1lXG4gICAgcmV0dXJuIGZhbHNlXG4gIH0gZWxzZSBpZiAodGFnID09PSAnc2VsZWN0Jykge1xuICAgIGdlblNlbGVjdChlbCwgdmFsdWUsIG1vZGlmaWVycyk7XG4gIH0gZWxzZSBpZiAodGFnID09PSAnaW5wdXQnICYmIHR5cGUgPT09ICdjaGVja2JveCcpIHtcbiAgICBnZW5DaGVja2JveE1vZGVsKGVsLCB2YWx1ZSwgbW9kaWZpZXJzKTtcbiAgfSBlbHNlIGlmICh0YWcgPT09ICdpbnB1dCcgJiYgdHlwZSA9PT0gJ3JhZGlvJykge1xuICAgIGdlblJhZGlvTW9kZWwoZWwsIHZhbHVlLCBtb2RpZmllcnMpO1xuICB9IGVsc2UgaWYgKHRhZyA9PT0gJ2lucHV0JyB8fCB0YWcgPT09ICd0ZXh0YXJlYScpIHtcbiAgICBnZW5EZWZhdWx0TW9kZWwoZWwsIHZhbHVlLCBtb2RpZmllcnMpO1xuICB9IGVsc2UgaWYgKCFjb25maWcuaXNSZXNlcnZlZFRhZyh0YWcpKSB7XG4gICAgZ2VuQ29tcG9uZW50TW9kZWwoZWwsIHZhbHVlLCBtb2RpZmllcnMpO1xuICAgIC8vIGNvbXBvbmVudCB2LW1vZGVsIGRvZXNuJ3QgbmVlZCBleHRyYSBydW50aW1lXG4gICAgcmV0dXJuIGZhbHNlXG4gIH0gZWxzZSBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgIHdhcm4kMShcbiAgICAgIFwiPFwiICsgKGVsLnRhZykgKyBcIiB2LW1vZGVsPVxcXCJcIiArIHZhbHVlICsgXCJcXFwiPjogXCIgK1xuICAgICAgXCJ2LW1vZGVsIGlzIG5vdCBzdXBwb3J0ZWQgb24gdGhpcyBlbGVtZW50IHR5cGUuIFwiICtcbiAgICAgICdJZiB5b3UgYXJlIHdvcmtpbmcgd2l0aCBjb250ZW50ZWRpdGFibGUsIGl0XFwncyByZWNvbW1lbmRlZCB0byAnICtcbiAgICAgICd3cmFwIGEgbGlicmFyeSBkZWRpY2F0ZWQgZm9yIHRoYXQgcHVycG9zZSBpbnNpZGUgYSBjdXN0b20gY29tcG9uZW50LidcbiAgICApO1xuICB9XG5cbiAgLy8gZW5zdXJlIHJ1bnRpbWUgZGlyZWN0aXZlIG1ldGFkYXRhXG4gIHJldHVybiB0cnVlXG59XG5cbmZ1bmN0aW9uIGdlbkNoZWNrYm94TW9kZWwgKFxuICBlbCxcbiAgdmFsdWUsXG4gIG1vZGlmaWVyc1xuKSB7XG4gIHZhciBudW1iZXIgPSBtb2RpZmllcnMgJiYgbW9kaWZpZXJzLm51bWJlcjtcbiAgdmFyIHZhbHVlQmluZGluZyA9IGdldEJpbmRpbmdBdHRyKGVsLCAndmFsdWUnKSB8fCAnbnVsbCc7XG4gIHZhciB0cnVlVmFsdWVCaW5kaW5nID0gZ2V0QmluZGluZ0F0dHIoZWwsICd0cnVlLXZhbHVlJykgfHwgJ3RydWUnO1xuICB2YXIgZmFsc2VWYWx1ZUJpbmRpbmcgPSBnZXRCaW5kaW5nQXR0cihlbCwgJ2ZhbHNlLXZhbHVlJykgfHwgJ2ZhbHNlJztcbiAgYWRkUHJvcChlbCwgJ2NoZWNrZWQnLFxuICAgIFwiQXJyYXkuaXNBcnJheShcIiArIHZhbHVlICsgXCIpXCIgK1xuICAgIFwiP19pKFwiICsgdmFsdWUgKyBcIixcIiArIHZhbHVlQmluZGluZyArIFwiKT4tMVwiICsgKFxuICAgICAgdHJ1ZVZhbHVlQmluZGluZyA9PT0gJ3RydWUnXG4gICAgICAgID8gKFwiOihcIiArIHZhbHVlICsgXCIpXCIpXG4gICAgICAgIDogKFwiOl9xKFwiICsgdmFsdWUgKyBcIixcIiArIHRydWVWYWx1ZUJpbmRpbmcgKyBcIilcIilcbiAgICApXG4gICk7XG4gIGFkZEhhbmRsZXIoZWwsICdjaGFuZ2UnLFxuICAgIFwidmFyICQkYT1cIiArIHZhbHVlICsgXCIsXCIgK1xuICAgICAgICAnJCRlbD0kZXZlbnQudGFyZ2V0LCcgK1xuICAgICAgICBcIiQkYz0kJGVsLmNoZWNrZWQ/KFwiICsgdHJ1ZVZhbHVlQmluZGluZyArIFwiKTooXCIgKyBmYWxzZVZhbHVlQmluZGluZyArIFwiKTtcIiArXG4gICAgJ2lmKEFycmF5LmlzQXJyYXkoJCRhKSl7JyArXG4gICAgICBcInZhciAkJHY9XCIgKyAobnVtYmVyID8gJ19uKCcgKyB2YWx1ZUJpbmRpbmcgKyAnKScgOiB2YWx1ZUJpbmRpbmcpICsgXCIsXCIgK1xuICAgICAgICAgICckJGk9X2koJCRhLCQkdik7JyArXG4gICAgICBcImlmKCQkZWwuY2hlY2tlZCl7JCRpPDAmJihcIiArIHZhbHVlICsgXCI9JCRhLmNvbmNhdChbJCR2XSkpfVwiICtcbiAgICAgIFwiZWxzZXskJGk+LTEmJihcIiArIHZhbHVlICsgXCI9JCRhLnNsaWNlKDAsJCRpKS5jb25jYXQoJCRhLnNsaWNlKCQkaSsxKSkpfVwiICtcbiAgICBcIn1lbHNle1wiICsgKGdlbkFzc2lnbm1lbnRDb2RlKHZhbHVlLCAnJCRjJykpICsgXCJ9XCIsXG4gICAgbnVsbCwgdHJ1ZVxuICApO1xufVxuXG5mdW5jdGlvbiBnZW5SYWRpb01vZGVsIChcbiAgZWwsXG4gIHZhbHVlLFxuICBtb2RpZmllcnNcbikge1xuICB2YXIgbnVtYmVyID0gbW9kaWZpZXJzICYmIG1vZGlmaWVycy5udW1iZXI7XG4gIHZhciB2YWx1ZUJpbmRpbmcgPSBnZXRCaW5kaW5nQXR0cihlbCwgJ3ZhbHVlJykgfHwgJ251bGwnO1xuICB2YWx1ZUJpbmRpbmcgPSBudW1iZXIgPyAoXCJfbihcIiArIHZhbHVlQmluZGluZyArIFwiKVwiKSA6IHZhbHVlQmluZGluZztcbiAgYWRkUHJvcChlbCwgJ2NoZWNrZWQnLCAoXCJfcShcIiArIHZhbHVlICsgXCIsXCIgKyB2YWx1ZUJpbmRpbmcgKyBcIilcIikpO1xuICBhZGRIYW5kbGVyKGVsLCAnY2hhbmdlJywgZ2VuQXNzaWdubWVudENvZGUodmFsdWUsIHZhbHVlQmluZGluZyksIG51bGwsIHRydWUpO1xufVxuXG5mdW5jdGlvbiBnZW5TZWxlY3QgKFxuICBlbCxcbiAgdmFsdWUsXG4gIG1vZGlmaWVyc1xuKSB7XG4gIHZhciBudW1iZXIgPSBtb2RpZmllcnMgJiYgbW9kaWZpZXJzLm51bWJlcjtcbiAgdmFyIHNlbGVjdGVkVmFsID0gXCJBcnJheS5wcm90b3R5cGUuZmlsdGVyXCIgK1xuICAgIFwiLmNhbGwoJGV2ZW50LnRhcmdldC5vcHRpb25zLGZ1bmN0aW9uKG8pe3JldHVybiBvLnNlbGVjdGVkfSlcIiArXG4gICAgXCIubWFwKGZ1bmN0aW9uKG8pe3ZhciB2YWwgPSBcXFwiX3ZhbHVlXFxcIiBpbiBvID8gby5fdmFsdWUgOiBvLnZhbHVlO1wiICtcbiAgICBcInJldHVybiBcIiArIChudW1iZXIgPyAnX24odmFsKScgOiAndmFsJykgKyBcIn0pXCI7XG5cbiAgdmFyIGFzc2lnbm1lbnQgPSAnJGV2ZW50LnRhcmdldC5tdWx0aXBsZSA/ICQkc2VsZWN0ZWRWYWwgOiAkJHNlbGVjdGVkVmFsWzBdJztcbiAgdmFyIGNvZGUgPSBcInZhciAkJHNlbGVjdGVkVmFsID0gXCIgKyBzZWxlY3RlZFZhbCArIFwiO1wiO1xuICBjb2RlID0gY29kZSArIFwiIFwiICsgKGdlbkFzc2lnbm1lbnRDb2RlKHZhbHVlLCBhc3NpZ25tZW50KSk7XG4gIGFkZEhhbmRsZXIoZWwsICdjaGFuZ2UnLCBjb2RlLCBudWxsLCB0cnVlKTtcbn1cblxuZnVuY3Rpb24gZ2VuRGVmYXVsdE1vZGVsIChcbiAgZWwsXG4gIHZhbHVlLFxuICBtb2RpZmllcnNcbikge1xuICB2YXIgdHlwZSA9IGVsLmF0dHJzTWFwLnR5cGU7XG5cbiAgLy8gd2FybiBpZiB2LWJpbmQ6dmFsdWUgY29uZmxpY3RzIHdpdGggdi1tb2RlbFxuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgIHZhciB2YWx1ZSQxID0gZWwuYXR0cnNNYXBbJ3YtYmluZDp2YWx1ZSddIHx8IGVsLmF0dHJzTWFwWyc6dmFsdWUnXTtcbiAgICBpZiAodmFsdWUkMSkge1xuICAgICAgdmFyIGJpbmRpbmcgPSBlbC5hdHRyc01hcFsndi1iaW5kOnZhbHVlJ10gPyAndi1iaW5kOnZhbHVlJyA6ICc6dmFsdWUnO1xuICAgICAgd2FybiQxKFxuICAgICAgICBiaW5kaW5nICsgXCI9XFxcIlwiICsgdmFsdWUkMSArIFwiXFxcIiBjb25mbGljdHMgd2l0aCB2LW1vZGVsIG9uIHRoZSBzYW1lIGVsZW1lbnQgXCIgK1xuICAgICAgICAnYmVjYXVzZSB0aGUgbGF0dGVyIGFscmVhZHkgZXhwYW5kcyB0byBhIHZhbHVlIGJpbmRpbmcgaW50ZXJuYWxseSdcbiAgICAgICk7XG4gICAgfVxuICB9XG5cbiAgdmFyIHJlZiA9IG1vZGlmaWVycyB8fCB7fTtcbiAgdmFyIGxhenkgPSByZWYubGF6eTtcbiAgdmFyIG51bWJlciA9IHJlZi5udW1iZXI7XG4gIHZhciB0cmltID0gcmVmLnRyaW07XG4gIHZhciBuZWVkQ29tcG9zaXRpb25HdWFyZCA9ICFsYXp5ICYmIHR5cGUgIT09ICdyYW5nZSc7XG4gIHZhciBldmVudCA9IGxhenlcbiAgICA/ICdjaGFuZ2UnXG4gICAgOiB0eXBlID09PSAncmFuZ2UnXG4gICAgICA/IFJBTkdFX1RPS0VOXG4gICAgICA6ICdpbnB1dCc7XG5cbiAgdmFyIHZhbHVlRXhwcmVzc2lvbiA9ICckZXZlbnQudGFyZ2V0LnZhbHVlJztcbiAgaWYgKHRyaW0pIHtcbiAgICB2YWx1ZUV4cHJlc3Npb24gPSBcIiRldmVudC50YXJnZXQudmFsdWUudHJpbSgpXCI7XG4gIH1cbiAgaWYgKG51bWJlcikge1xuICAgIHZhbHVlRXhwcmVzc2lvbiA9IFwiX24oXCIgKyB2YWx1ZUV4cHJlc3Npb24gKyBcIilcIjtcbiAgfVxuXG4gIHZhciBjb2RlID0gZ2VuQXNzaWdubWVudENvZGUodmFsdWUsIHZhbHVlRXhwcmVzc2lvbik7XG4gIGlmIChuZWVkQ29tcG9zaXRpb25HdWFyZCkge1xuICAgIGNvZGUgPSBcImlmKCRldmVudC50YXJnZXQuY29tcG9zaW5nKXJldHVybjtcIiArIGNvZGU7XG4gIH1cblxuICBhZGRQcm9wKGVsLCAndmFsdWUnLCAoXCIoXCIgKyB2YWx1ZSArIFwiKVwiKSk7XG4gIGFkZEhhbmRsZXIoZWwsIGV2ZW50LCBjb2RlLCBudWxsLCB0cnVlKTtcbiAgaWYgKHRyaW0gfHwgbnVtYmVyKSB7XG4gICAgYWRkSGFuZGxlcihlbCwgJ2JsdXInLCAnJGZvcmNlVXBkYXRlKCknKTtcbiAgfVxufVxuXG4vKiAgKi9cblxuLy8gbm9ybWFsaXplIHYtbW9kZWwgZXZlbnQgdG9rZW5zIHRoYXQgY2FuIG9ubHkgYmUgZGV0ZXJtaW5lZCBhdCBydW50aW1lLlxuLy8gaXQncyBpbXBvcnRhbnQgdG8gcGxhY2UgdGhlIGV2ZW50IGFzIHRoZSBmaXJzdCBpbiB0aGUgYXJyYXkgYmVjYXVzZVxuLy8gdGhlIHdob2xlIHBvaW50IGlzIGVuc3VyaW5nIHRoZSB2LW1vZGVsIGNhbGxiYWNrIGdldHMgY2FsbGVkIGJlZm9yZVxuLy8gdXNlci1hdHRhY2hlZCBoYW5kbGVycy5cbmZ1bmN0aW9uIG5vcm1hbGl6ZUV2ZW50cyAob24pIHtcbiAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gIGlmIChpc0RlZihvbltSQU5HRV9UT0tFTl0pKSB7XG4gICAgLy8gSUUgaW5wdXRbdHlwZT1yYW5nZV0gb25seSBzdXBwb3J0cyBgY2hhbmdlYCBldmVudFxuICAgIHZhciBldmVudCA9IGlzSUUgPyAnY2hhbmdlJyA6ICdpbnB1dCc7XG4gICAgb25bZXZlbnRdID0gW10uY29uY2F0KG9uW1JBTkdFX1RPS0VOXSwgb25bZXZlbnRdIHx8IFtdKTtcbiAgICBkZWxldGUgb25bUkFOR0VfVE9LRU5dO1xuICB9XG4gIC8vIFRoaXMgd2FzIG9yaWdpbmFsbHkgaW50ZW5kZWQgdG8gZml4ICM0NTIxIGJ1dCBubyBsb25nZXIgbmVjZXNzYXJ5XG4gIC8vIGFmdGVyIDIuNS4gS2VlcGluZyBpdCBmb3IgYmFja3dhcmRzIGNvbXBhdCB3aXRoIGdlbmVyYXRlZCBjb2RlIGZyb20gPCAyLjRcbiAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gIGlmIChpc0RlZihvbltDSEVDS0JPWF9SQURJT19UT0tFTl0pKSB7XG4gICAgb24uY2hhbmdlID0gW10uY29uY2F0KG9uW0NIRUNLQk9YX1JBRElPX1RPS0VOXSwgb24uY2hhbmdlIHx8IFtdKTtcbiAgICBkZWxldGUgb25bQ0hFQ0tCT1hfUkFESU9fVE9LRU5dO1xuICB9XG59XG5cbnZhciB0YXJnZXQkMTtcblxuZnVuY3Rpb24gY3JlYXRlT25jZUhhbmRsZXIgKGhhbmRsZXIsIGV2ZW50LCBjYXB0dXJlKSB7XG4gIHZhciBfdGFyZ2V0ID0gdGFyZ2V0JDE7IC8vIHNhdmUgY3VycmVudCB0YXJnZXQgZWxlbWVudCBpbiBjbG9zdXJlXG4gIHJldHVybiBmdW5jdGlvbiBvbmNlSGFuZGxlciAoKSB7XG4gICAgdmFyIHJlcyA9IGhhbmRsZXIuYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcbiAgICBpZiAocmVzICE9PSBudWxsKSB7XG4gICAgICByZW1vdmUkMihldmVudCwgb25jZUhhbmRsZXIsIGNhcHR1cmUsIF90YXJnZXQpO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBhZGQkMSAoXG4gIGV2ZW50LFxuICBoYW5kbGVyLFxuICBvbmNlJCQxLFxuICBjYXB0dXJlLFxuICBwYXNzaXZlXG4pIHtcbiAgaGFuZGxlciA9IHdpdGhNYWNyb1Rhc2soaGFuZGxlcik7XG4gIGlmIChvbmNlJCQxKSB7IGhhbmRsZXIgPSBjcmVhdGVPbmNlSGFuZGxlcihoYW5kbGVyLCBldmVudCwgY2FwdHVyZSk7IH1cbiAgdGFyZ2V0JDEuYWRkRXZlbnRMaXN0ZW5lcihcbiAgICBldmVudCxcbiAgICBoYW5kbGVyLFxuICAgIHN1cHBvcnRzUGFzc2l2ZVxuICAgICAgPyB7IGNhcHR1cmU6IGNhcHR1cmUsIHBhc3NpdmU6IHBhc3NpdmUgfVxuICAgICAgOiBjYXB0dXJlXG4gICk7XG59XG5cbmZ1bmN0aW9uIHJlbW92ZSQyIChcbiAgZXZlbnQsXG4gIGhhbmRsZXIsXG4gIGNhcHR1cmUsXG4gIF90YXJnZXRcbikge1xuICAoX3RhcmdldCB8fCB0YXJnZXQkMSkucmVtb3ZlRXZlbnRMaXN0ZW5lcihcbiAgICBldmVudCxcbiAgICBoYW5kbGVyLl93aXRoVGFzayB8fCBoYW5kbGVyLFxuICAgIGNhcHR1cmVcbiAgKTtcbn1cblxuZnVuY3Rpb24gdXBkYXRlRE9NTGlzdGVuZXJzIChvbGRWbm9kZSwgdm5vZGUpIHtcbiAgaWYgKGlzVW5kZWYob2xkVm5vZGUuZGF0YS5vbikgJiYgaXNVbmRlZih2bm9kZS5kYXRhLm9uKSkge1xuICAgIHJldHVyblxuICB9XG4gIHZhciBvbiA9IHZub2RlLmRhdGEub24gfHwge307XG4gIHZhciBvbGRPbiA9IG9sZFZub2RlLmRhdGEub24gfHwge307XG4gIHRhcmdldCQxID0gdm5vZGUuZWxtO1xuICBub3JtYWxpemVFdmVudHMob24pO1xuICB1cGRhdGVMaXN0ZW5lcnMob24sIG9sZE9uLCBhZGQkMSwgcmVtb3ZlJDIsIHZub2RlLmNvbnRleHQpO1xuICB0YXJnZXQkMSA9IHVuZGVmaW5lZDtcbn1cblxudmFyIGV2ZW50cyA9IHtcbiAgY3JlYXRlOiB1cGRhdGVET01MaXN0ZW5lcnMsXG4gIHVwZGF0ZTogdXBkYXRlRE9NTGlzdGVuZXJzXG59O1xuXG4vKiAgKi9cblxuZnVuY3Rpb24gdXBkYXRlRE9NUHJvcHMgKG9sZFZub2RlLCB2bm9kZSkge1xuICBpZiAoaXNVbmRlZihvbGRWbm9kZS5kYXRhLmRvbVByb3BzKSAmJiBpc1VuZGVmKHZub2RlLmRhdGEuZG9tUHJvcHMpKSB7XG4gICAgcmV0dXJuXG4gIH1cbiAgdmFyIGtleSwgY3VyO1xuICB2YXIgZWxtID0gdm5vZGUuZWxtO1xuICB2YXIgb2xkUHJvcHMgPSBvbGRWbm9kZS5kYXRhLmRvbVByb3BzIHx8IHt9O1xuICB2YXIgcHJvcHMgPSB2bm9kZS5kYXRhLmRvbVByb3BzIHx8IHt9O1xuICAvLyBjbG9uZSBvYnNlcnZlZCBvYmplY3RzLCBhcyB0aGUgdXNlciBwcm9iYWJseSB3YW50cyB0byBtdXRhdGUgaXRcbiAgaWYgKGlzRGVmKHByb3BzLl9fb2JfXykpIHtcbiAgICBwcm9wcyA9IHZub2RlLmRhdGEuZG9tUHJvcHMgPSBleHRlbmQoe30sIHByb3BzKTtcbiAgfVxuXG4gIGZvciAoa2V5IGluIG9sZFByb3BzKSB7XG4gICAgaWYgKGlzVW5kZWYocHJvcHNba2V5XSkpIHtcbiAgICAgIGVsbVtrZXldID0gJyc7XG4gICAgfVxuICB9XG4gIGZvciAoa2V5IGluIHByb3BzKSB7XG4gICAgY3VyID0gcHJvcHNba2V5XTtcbiAgICAvLyBpZ25vcmUgY2hpbGRyZW4gaWYgdGhlIG5vZGUgaGFzIHRleHRDb250ZW50IG9yIGlubmVySFRNTCxcbiAgICAvLyBhcyB0aGVzZSB3aWxsIHRocm93IGF3YXkgZXhpc3RpbmcgRE9NIG5vZGVzIGFuZCBjYXVzZSByZW1vdmFsIGVycm9yc1xuICAgIC8vIG9uIHN1YnNlcXVlbnQgcGF0Y2hlcyAoIzMzNjApXG4gICAgaWYgKGtleSA9PT0gJ3RleHRDb250ZW50JyB8fCBrZXkgPT09ICdpbm5lckhUTUwnKSB7XG4gICAgICBpZiAodm5vZGUuY2hpbGRyZW4pIHsgdm5vZGUuY2hpbGRyZW4ubGVuZ3RoID0gMDsgfVxuICAgICAgaWYgKGN1ciA9PT0gb2xkUHJvcHNba2V5XSkgeyBjb250aW51ZSB9XG4gICAgICAvLyAjNjYwMSB3b3JrIGFyb3VuZCBDaHJvbWUgdmVyc2lvbiA8PSA1NSBidWcgd2hlcmUgc2luZ2xlIHRleHROb2RlXG4gICAgICAvLyByZXBsYWNlZCBieSBpbm5lckhUTUwvdGV4dENvbnRlbnQgcmV0YWlucyBpdHMgcGFyZW50Tm9kZSBwcm9wZXJ0eVxuICAgICAgaWYgKGVsbS5jaGlsZE5vZGVzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICBlbG0ucmVtb3ZlQ2hpbGQoZWxtLmNoaWxkTm9kZXNbMF0pO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChrZXkgPT09ICd2YWx1ZScpIHtcbiAgICAgIC8vIHN0b3JlIHZhbHVlIGFzIF92YWx1ZSBhcyB3ZWxsIHNpbmNlXG4gICAgICAvLyBub24tc3RyaW5nIHZhbHVlcyB3aWxsIGJlIHN0cmluZ2lmaWVkXG4gICAgICBlbG0uX3ZhbHVlID0gY3VyO1xuICAgICAgLy8gYXZvaWQgcmVzZXR0aW5nIGN1cnNvciBwb3NpdGlvbiB3aGVuIHZhbHVlIGlzIHRoZSBzYW1lXG4gICAgICB2YXIgc3RyQ3VyID0gaXNVbmRlZihjdXIpID8gJycgOiBTdHJpbmcoY3VyKTtcbiAgICAgIGlmIChzaG91bGRVcGRhdGVWYWx1ZShlbG0sIHN0ckN1cikpIHtcbiAgICAgICAgZWxtLnZhbHVlID0gc3RyQ3VyO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBlbG1ba2V5XSA9IGN1cjtcbiAgICB9XG4gIH1cbn1cblxuLy8gY2hlY2sgcGxhdGZvcm1zL3dlYi91dGlsL2F0dHJzLmpzIGFjY2VwdFZhbHVlXG5cblxuZnVuY3Rpb24gc2hvdWxkVXBkYXRlVmFsdWUgKGVsbSwgY2hlY2tWYWwpIHtcbiAgcmV0dXJuICghZWxtLmNvbXBvc2luZyAmJiAoXG4gICAgZWxtLnRhZ05hbWUgPT09ICdPUFRJT04nIHx8XG4gICAgaXNOb3RJbkZvY3VzQW5kRGlydHkoZWxtLCBjaGVja1ZhbCkgfHxcbiAgICBpc0RpcnR5V2l0aE1vZGlmaWVycyhlbG0sIGNoZWNrVmFsKVxuICApKVxufVxuXG5mdW5jdGlvbiBpc05vdEluRm9jdXNBbmREaXJ0eSAoZWxtLCBjaGVja1ZhbCkge1xuICAvLyByZXR1cm4gdHJ1ZSB3aGVuIHRleHRib3ggKC5udW1iZXIgYW5kIC50cmltKSBsb3NlcyBmb2N1cyBhbmQgaXRzIHZhbHVlIGlzXG4gIC8vIG5vdCBlcXVhbCB0byB0aGUgdXBkYXRlZCB2YWx1ZVxuICB2YXIgbm90SW5Gb2N1cyA9IHRydWU7XG4gIC8vICM2MTU3XG4gIC8vIHdvcmsgYXJvdW5kIElFIGJ1ZyB3aGVuIGFjY2Vzc2luZyBkb2N1bWVudC5hY3RpdmVFbGVtZW50IGluIGFuIGlmcmFtZVxuICB0cnkgeyBub3RJbkZvY3VzID0gZG9jdW1lbnQuYWN0aXZlRWxlbWVudCAhPT0gZWxtOyB9IGNhdGNoIChlKSB7fVxuICByZXR1cm4gbm90SW5Gb2N1cyAmJiBlbG0udmFsdWUgIT09IGNoZWNrVmFsXG59XG5cbmZ1bmN0aW9uIGlzRGlydHlXaXRoTW9kaWZpZXJzIChlbG0sIG5ld1ZhbCkge1xuICB2YXIgdmFsdWUgPSBlbG0udmFsdWU7XG4gIHZhciBtb2RpZmllcnMgPSBlbG0uX3ZNb2RpZmllcnM7IC8vIGluamVjdGVkIGJ5IHYtbW9kZWwgcnVudGltZVxuICBpZiAoaXNEZWYobW9kaWZpZXJzKSkge1xuICAgIGlmIChtb2RpZmllcnMubGF6eSkge1xuICAgICAgLy8gaW5wdXRzIHdpdGggbGF6eSBzaG91bGQgb25seSBiZSB1cGRhdGVkIHdoZW4gbm90IGluIGZvY3VzXG4gICAgICByZXR1cm4gZmFsc2VcbiAgICB9XG4gICAgaWYgKG1vZGlmaWVycy5udW1iZXIpIHtcbiAgICAgIHJldHVybiB0b051bWJlcih2YWx1ZSkgIT09IHRvTnVtYmVyKG5ld1ZhbClcbiAgICB9XG4gICAgaWYgKG1vZGlmaWVycy50cmltKSB7XG4gICAgICByZXR1cm4gdmFsdWUudHJpbSgpICE9PSBuZXdWYWwudHJpbSgpXG4gICAgfVxuICB9XG4gIHJldHVybiB2YWx1ZSAhPT0gbmV3VmFsXG59XG5cbnZhciBkb21Qcm9wcyA9IHtcbiAgY3JlYXRlOiB1cGRhdGVET01Qcm9wcyxcbiAgdXBkYXRlOiB1cGRhdGVET01Qcm9wc1xufTtcblxuLyogICovXG5cbnZhciBwYXJzZVN0eWxlVGV4dCA9IGNhY2hlZChmdW5jdGlvbiAoY3NzVGV4dCkge1xuICB2YXIgcmVzID0ge307XG4gIHZhciBsaXN0RGVsaW1pdGVyID0gLzsoPyFbXihdKlxcKSkvZztcbiAgdmFyIHByb3BlcnR5RGVsaW1pdGVyID0gLzooLispLztcbiAgY3NzVGV4dC5zcGxpdChsaXN0RGVsaW1pdGVyKS5mb3JFYWNoKGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgaWYgKGl0ZW0pIHtcbiAgICAgIHZhciB0bXAgPSBpdGVtLnNwbGl0KHByb3BlcnR5RGVsaW1pdGVyKTtcbiAgICAgIHRtcC5sZW5ndGggPiAxICYmIChyZXNbdG1wWzBdLnRyaW0oKV0gPSB0bXBbMV0udHJpbSgpKTtcbiAgICB9XG4gIH0pO1xuICByZXR1cm4gcmVzXG59KTtcblxuLy8gbWVyZ2Ugc3RhdGljIGFuZCBkeW5hbWljIHN0eWxlIGRhdGEgb24gdGhlIHNhbWUgdm5vZGVcbmZ1bmN0aW9uIG5vcm1hbGl6ZVN0eWxlRGF0YSAoZGF0YSkge1xuICB2YXIgc3R5bGUgPSBub3JtYWxpemVTdHlsZUJpbmRpbmcoZGF0YS5zdHlsZSk7XG4gIC8vIHN0YXRpYyBzdHlsZSBpcyBwcmUtcHJvY2Vzc2VkIGludG8gYW4gb2JqZWN0IGR1cmluZyBjb21waWxhdGlvblxuICAvLyBhbmQgaXMgYWx3YXlzIGEgZnJlc2ggb2JqZWN0LCBzbyBpdCdzIHNhZmUgdG8gbWVyZ2UgaW50byBpdFxuICByZXR1cm4gZGF0YS5zdGF0aWNTdHlsZVxuICAgID8gZXh0ZW5kKGRhdGEuc3RhdGljU3R5bGUsIHN0eWxlKVxuICAgIDogc3R5bGVcbn1cblxuLy8gbm9ybWFsaXplIHBvc3NpYmxlIGFycmF5IC8gc3RyaW5nIHZhbHVlcyBpbnRvIE9iamVjdFxuZnVuY3Rpb24gbm9ybWFsaXplU3R5bGVCaW5kaW5nIChiaW5kaW5nU3R5bGUpIHtcbiAgaWYgKEFycmF5LmlzQXJyYXkoYmluZGluZ1N0eWxlKSkge1xuICAgIHJldHVybiB0b09iamVjdChiaW5kaW5nU3R5bGUpXG4gIH1cbiAgaWYgKHR5cGVvZiBiaW5kaW5nU3R5bGUgPT09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIHBhcnNlU3R5bGVUZXh0KGJpbmRpbmdTdHlsZSlcbiAgfVxuICByZXR1cm4gYmluZGluZ1N0eWxlXG59XG5cbi8qKlxuICogcGFyZW50IGNvbXBvbmVudCBzdHlsZSBzaG91bGQgYmUgYWZ0ZXIgY2hpbGQnc1xuICogc28gdGhhdCBwYXJlbnQgY29tcG9uZW50J3Mgc3R5bGUgY291bGQgb3ZlcnJpZGUgaXRcbiAqL1xuZnVuY3Rpb24gZ2V0U3R5bGUgKHZub2RlLCBjaGVja0NoaWxkKSB7XG4gIHZhciByZXMgPSB7fTtcbiAgdmFyIHN0eWxlRGF0YTtcblxuICBpZiAoY2hlY2tDaGlsZCkge1xuICAgIHZhciBjaGlsZE5vZGUgPSB2bm9kZTtcbiAgICB3aGlsZSAoY2hpbGROb2RlLmNvbXBvbmVudEluc3RhbmNlKSB7XG4gICAgICBjaGlsZE5vZGUgPSBjaGlsZE5vZGUuY29tcG9uZW50SW5zdGFuY2UuX3Zub2RlO1xuICAgICAgaWYgKFxuICAgICAgICBjaGlsZE5vZGUgJiYgY2hpbGROb2RlLmRhdGEgJiZcbiAgICAgICAgKHN0eWxlRGF0YSA9IG5vcm1hbGl6ZVN0eWxlRGF0YShjaGlsZE5vZGUuZGF0YSkpXG4gICAgICApIHtcbiAgICAgICAgZXh0ZW5kKHJlcywgc3R5bGVEYXRhKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBpZiAoKHN0eWxlRGF0YSA9IG5vcm1hbGl6ZVN0eWxlRGF0YSh2bm9kZS5kYXRhKSkpIHtcbiAgICBleHRlbmQocmVzLCBzdHlsZURhdGEpO1xuICB9XG5cbiAgdmFyIHBhcmVudE5vZGUgPSB2bm9kZTtcbiAgd2hpbGUgKChwYXJlbnROb2RlID0gcGFyZW50Tm9kZS5wYXJlbnQpKSB7XG4gICAgaWYgKHBhcmVudE5vZGUuZGF0YSAmJiAoc3R5bGVEYXRhID0gbm9ybWFsaXplU3R5bGVEYXRhKHBhcmVudE5vZGUuZGF0YSkpKSB7XG4gICAgICBleHRlbmQocmVzLCBzdHlsZURhdGEpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzXG59XG5cbi8qICAqL1xuXG52YXIgY3NzVmFyUkUgPSAvXi0tLztcbnZhciBpbXBvcnRhbnRSRSA9IC9cXHMqIWltcG9ydGFudCQvO1xudmFyIHNldFByb3AgPSBmdW5jdGlvbiAoZWwsIG5hbWUsIHZhbCkge1xuICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgaWYgKGNzc1ZhclJFLnRlc3QobmFtZSkpIHtcbiAgICBlbC5zdHlsZS5zZXRQcm9wZXJ0eShuYW1lLCB2YWwpO1xuICB9IGVsc2UgaWYgKGltcG9ydGFudFJFLnRlc3QodmFsKSkge1xuICAgIGVsLnN0eWxlLnNldFByb3BlcnR5KG5hbWUsIHZhbC5yZXBsYWNlKGltcG9ydGFudFJFLCAnJyksICdpbXBvcnRhbnQnKTtcbiAgfSBlbHNlIHtcbiAgICB2YXIgbm9ybWFsaXplZE5hbWUgPSBub3JtYWxpemUobmFtZSk7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkodmFsKSkge1xuICAgICAgLy8gU3VwcG9ydCB2YWx1ZXMgYXJyYXkgY3JlYXRlZCBieSBhdXRvcHJlZml4ZXIsIGUuZy5cbiAgICAgIC8vIHtkaXNwbGF5OiBbXCItd2Via2l0LWJveFwiLCBcIi1tcy1mbGV4Ym94XCIsIFwiZmxleFwiXX1cbiAgICAgIC8vIFNldCB0aGVtIG9uZSBieSBvbmUsIGFuZCB0aGUgYnJvd3NlciB3aWxsIG9ubHkgc2V0IHRob3NlIGl0IGNhbiByZWNvZ25pemVcbiAgICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSB2YWwubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgZWwuc3R5bGVbbm9ybWFsaXplZE5hbWVdID0gdmFsW2ldO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBlbC5zdHlsZVtub3JtYWxpemVkTmFtZV0gPSB2YWw7XG4gICAgfVxuICB9XG59O1xuXG52YXIgdmVuZG9yTmFtZXMgPSBbJ1dlYmtpdCcsICdNb3onLCAnbXMnXTtcblxudmFyIGVtcHR5U3R5bGU7XG52YXIgbm9ybWFsaXplID0gY2FjaGVkKGZ1bmN0aW9uIChwcm9wKSB7XG4gIGVtcHR5U3R5bGUgPSBlbXB0eVN0eWxlIHx8IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpLnN0eWxlO1xuICBwcm9wID0gY2FtZWxpemUocHJvcCk7XG4gIGlmIChwcm9wICE9PSAnZmlsdGVyJyAmJiAocHJvcCBpbiBlbXB0eVN0eWxlKSkge1xuICAgIHJldHVybiBwcm9wXG4gIH1cbiAgdmFyIGNhcE5hbWUgPSBwcm9wLmNoYXJBdCgwKS50b1VwcGVyQ2FzZSgpICsgcHJvcC5zbGljZSgxKTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCB2ZW5kb3JOYW1lcy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBuYW1lID0gdmVuZG9yTmFtZXNbaV0gKyBjYXBOYW1lO1xuICAgIGlmIChuYW1lIGluIGVtcHR5U3R5bGUpIHtcbiAgICAgIHJldHVybiBuYW1lXG4gICAgfVxuICB9XG59KTtcblxuZnVuY3Rpb24gdXBkYXRlU3R5bGUgKG9sZFZub2RlLCB2bm9kZSkge1xuICB2YXIgZGF0YSA9IHZub2RlLmRhdGE7XG4gIHZhciBvbGREYXRhID0gb2xkVm5vZGUuZGF0YTtcblxuICBpZiAoaXNVbmRlZihkYXRhLnN0YXRpY1N0eWxlKSAmJiBpc1VuZGVmKGRhdGEuc3R5bGUpICYmXG4gICAgaXNVbmRlZihvbGREYXRhLnN0YXRpY1N0eWxlKSAmJiBpc1VuZGVmKG9sZERhdGEuc3R5bGUpXG4gICkge1xuICAgIHJldHVyblxuICB9XG5cbiAgdmFyIGN1ciwgbmFtZTtcbiAgdmFyIGVsID0gdm5vZGUuZWxtO1xuICB2YXIgb2xkU3RhdGljU3R5bGUgPSBvbGREYXRhLnN0YXRpY1N0eWxlO1xuICB2YXIgb2xkU3R5bGVCaW5kaW5nID0gb2xkRGF0YS5ub3JtYWxpemVkU3R5bGUgfHwgb2xkRGF0YS5zdHlsZSB8fCB7fTtcblxuICAvLyBpZiBzdGF0aWMgc3R5bGUgZXhpc3RzLCBzdHlsZWJpbmRpbmcgYWxyZWFkeSBtZXJnZWQgaW50byBpdCB3aGVuIGRvaW5nIG5vcm1hbGl6ZVN0eWxlRGF0YVxuICB2YXIgb2xkU3R5bGUgPSBvbGRTdGF0aWNTdHlsZSB8fCBvbGRTdHlsZUJpbmRpbmc7XG5cbiAgdmFyIHN0eWxlID0gbm9ybWFsaXplU3R5bGVCaW5kaW5nKHZub2RlLmRhdGEuc3R5bGUpIHx8IHt9O1xuXG4gIC8vIHN0b3JlIG5vcm1hbGl6ZWQgc3R5bGUgdW5kZXIgYSBkaWZmZXJlbnQga2V5IGZvciBuZXh0IGRpZmZcbiAgLy8gbWFrZSBzdXJlIHRvIGNsb25lIGl0IGlmIGl0J3MgcmVhY3RpdmUsIHNpbmNlIHRoZSB1c2VyIGxpa2VseSB3YW50c1xuICAvLyB0byBtdXRhdGUgaXQuXG4gIHZub2RlLmRhdGEubm9ybWFsaXplZFN0eWxlID0gaXNEZWYoc3R5bGUuX19vYl9fKVxuICAgID8gZXh0ZW5kKHt9LCBzdHlsZSlcbiAgICA6IHN0eWxlO1xuXG4gIHZhciBuZXdTdHlsZSA9IGdldFN0eWxlKHZub2RlLCB0cnVlKTtcblxuICBmb3IgKG5hbWUgaW4gb2xkU3R5bGUpIHtcbiAgICBpZiAoaXNVbmRlZihuZXdTdHlsZVtuYW1lXSkpIHtcbiAgICAgIHNldFByb3AoZWwsIG5hbWUsICcnKTtcbiAgICB9XG4gIH1cbiAgZm9yIChuYW1lIGluIG5ld1N0eWxlKSB7XG4gICAgY3VyID0gbmV3U3R5bGVbbmFtZV07XG4gICAgaWYgKGN1ciAhPT0gb2xkU3R5bGVbbmFtZV0pIHtcbiAgICAgIC8vIGllOSBzZXR0aW5nIHRvIG51bGwgaGFzIG5vIGVmZmVjdCwgbXVzdCB1c2UgZW1wdHkgc3RyaW5nXG4gICAgICBzZXRQcm9wKGVsLCBuYW1lLCBjdXIgPT0gbnVsbCA/ICcnIDogY3VyKTtcbiAgICB9XG4gIH1cbn1cblxudmFyIHN0eWxlID0ge1xuICBjcmVhdGU6IHVwZGF0ZVN0eWxlLFxuICB1cGRhdGU6IHVwZGF0ZVN0eWxlXG59O1xuXG4vKiAgKi9cblxuLyoqXG4gKiBBZGQgY2xhc3Mgd2l0aCBjb21wYXRpYmlsaXR5IGZvciBTVkcgc2luY2UgY2xhc3NMaXN0IGlzIG5vdCBzdXBwb3J0ZWQgb25cbiAqIFNWRyBlbGVtZW50cyBpbiBJRVxuICovXG5mdW5jdGlvbiBhZGRDbGFzcyAoZWwsIGNscykge1xuICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgaWYgKCFjbHMgfHwgIShjbHMgPSBjbHMudHJpbSgpKSkge1xuICAgIHJldHVyblxuICB9XG5cbiAgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cbiAgaWYgKGVsLmNsYXNzTGlzdCkge1xuICAgIGlmIChjbHMuaW5kZXhPZignICcpID4gLTEpIHtcbiAgICAgIGNscy5zcGxpdCgvXFxzKy8pLmZvckVhY2goZnVuY3Rpb24gKGMpIHsgcmV0dXJuIGVsLmNsYXNzTGlzdC5hZGQoYyk7IH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBlbC5jbGFzc0xpc3QuYWRkKGNscyk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHZhciBjdXIgPSBcIiBcIiArIChlbC5nZXRBdHRyaWJ1dGUoJ2NsYXNzJykgfHwgJycpICsgXCIgXCI7XG4gICAgaWYgKGN1ci5pbmRleE9mKCcgJyArIGNscyArICcgJykgPCAwKSB7XG4gICAgICBlbC5zZXRBdHRyaWJ1dGUoJ2NsYXNzJywgKGN1ciArIGNscykudHJpbSgpKTtcbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBSZW1vdmUgY2xhc3Mgd2l0aCBjb21wYXRpYmlsaXR5IGZvciBTVkcgc2luY2UgY2xhc3NMaXN0IGlzIG5vdCBzdXBwb3J0ZWQgb25cbiAqIFNWRyBlbGVtZW50cyBpbiBJRVxuICovXG5mdW5jdGlvbiByZW1vdmVDbGFzcyAoZWwsIGNscykge1xuICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgaWYgKCFjbHMgfHwgIShjbHMgPSBjbHMudHJpbSgpKSkge1xuICAgIHJldHVyblxuICB9XG5cbiAgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cbiAgaWYgKGVsLmNsYXNzTGlzdCkge1xuICAgIGlmIChjbHMuaW5kZXhPZignICcpID4gLTEpIHtcbiAgICAgIGNscy5zcGxpdCgvXFxzKy8pLmZvckVhY2goZnVuY3Rpb24gKGMpIHsgcmV0dXJuIGVsLmNsYXNzTGlzdC5yZW1vdmUoYyk7IH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBlbC5jbGFzc0xpc3QucmVtb3ZlKGNscyk7XG4gICAgfVxuICAgIGlmICghZWwuY2xhc3NMaXN0Lmxlbmd0aCkge1xuICAgICAgZWwucmVtb3ZlQXR0cmlidXRlKCdjbGFzcycpO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICB2YXIgY3VyID0gXCIgXCIgKyAoZWwuZ2V0QXR0cmlidXRlKCdjbGFzcycpIHx8ICcnKSArIFwiIFwiO1xuICAgIHZhciB0YXIgPSAnICcgKyBjbHMgKyAnICc7XG4gICAgd2hpbGUgKGN1ci5pbmRleE9mKHRhcikgPj0gMCkge1xuICAgICAgY3VyID0gY3VyLnJlcGxhY2UodGFyLCAnICcpO1xuICAgIH1cbiAgICBjdXIgPSBjdXIudHJpbSgpO1xuICAgIGlmIChjdXIpIHtcbiAgICAgIGVsLnNldEF0dHJpYnV0ZSgnY2xhc3MnLCBjdXIpO1xuICAgIH0gZWxzZSB7XG4gICAgICBlbC5yZW1vdmVBdHRyaWJ1dGUoJ2NsYXNzJyk7XG4gICAgfVxuICB9XG59XG5cbi8qICAqL1xuXG5mdW5jdGlvbiByZXNvbHZlVHJhbnNpdGlvbiAoZGVmKSB7XG4gIGlmICghZGVmKSB7XG4gICAgcmV0dXJuXG4gIH1cbiAgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cbiAgaWYgKHR5cGVvZiBkZWYgPT09ICdvYmplY3QnKSB7XG4gICAgdmFyIHJlcyA9IHt9O1xuICAgIGlmIChkZWYuY3NzICE9PSBmYWxzZSkge1xuICAgICAgZXh0ZW5kKHJlcywgYXV0b0Nzc1RyYW5zaXRpb24oZGVmLm5hbWUgfHwgJ3YnKSk7XG4gICAgfVxuICAgIGV4dGVuZChyZXMsIGRlZik7XG4gICAgcmV0dXJuIHJlc1xuICB9IGVsc2UgaWYgKHR5cGVvZiBkZWYgPT09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIGF1dG9Dc3NUcmFuc2l0aW9uKGRlZilcbiAgfVxufVxuXG52YXIgYXV0b0Nzc1RyYW5zaXRpb24gPSBjYWNoZWQoZnVuY3Rpb24gKG5hbWUpIHtcbiAgcmV0dXJuIHtcbiAgICBlbnRlckNsYXNzOiAobmFtZSArIFwiLWVudGVyXCIpLFxuICAgIGVudGVyVG9DbGFzczogKG5hbWUgKyBcIi1lbnRlci10b1wiKSxcbiAgICBlbnRlckFjdGl2ZUNsYXNzOiAobmFtZSArIFwiLWVudGVyLWFjdGl2ZVwiKSxcbiAgICBsZWF2ZUNsYXNzOiAobmFtZSArIFwiLWxlYXZlXCIpLFxuICAgIGxlYXZlVG9DbGFzczogKG5hbWUgKyBcIi1sZWF2ZS10b1wiKSxcbiAgICBsZWF2ZUFjdGl2ZUNsYXNzOiAobmFtZSArIFwiLWxlYXZlLWFjdGl2ZVwiKVxuICB9XG59KTtcblxudmFyIGhhc1RyYW5zaXRpb24gPSBpbkJyb3dzZXIgJiYgIWlzSUU5O1xudmFyIFRSQU5TSVRJT04gPSAndHJhbnNpdGlvbic7XG52YXIgQU5JTUFUSU9OID0gJ2FuaW1hdGlvbic7XG5cbi8vIFRyYW5zaXRpb24gcHJvcGVydHkvZXZlbnQgc25pZmZpbmdcbnZhciB0cmFuc2l0aW9uUHJvcCA9ICd0cmFuc2l0aW9uJztcbnZhciB0cmFuc2l0aW9uRW5kRXZlbnQgPSAndHJhbnNpdGlvbmVuZCc7XG52YXIgYW5pbWF0aW9uUHJvcCA9ICdhbmltYXRpb24nO1xudmFyIGFuaW1hdGlvbkVuZEV2ZW50ID0gJ2FuaW1hdGlvbmVuZCc7XG5pZiAoaGFzVHJhbnNpdGlvbikge1xuICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgaWYgKHdpbmRvdy5vbnRyYW5zaXRpb25lbmQgPT09IHVuZGVmaW5lZCAmJlxuICAgIHdpbmRvdy5vbndlYmtpdHRyYW5zaXRpb25lbmQgIT09IHVuZGVmaW5lZFxuICApIHtcbiAgICB0cmFuc2l0aW9uUHJvcCA9ICdXZWJraXRUcmFuc2l0aW9uJztcbiAgICB0cmFuc2l0aW9uRW5kRXZlbnQgPSAnd2Via2l0VHJhbnNpdGlvbkVuZCc7XG4gIH1cbiAgaWYgKHdpbmRvdy5vbmFuaW1hdGlvbmVuZCA9PT0gdW5kZWZpbmVkICYmXG4gICAgd2luZG93Lm9ud2Via2l0YW5pbWF0aW9uZW5kICE9PSB1bmRlZmluZWRcbiAgKSB7XG4gICAgYW5pbWF0aW9uUHJvcCA9ICdXZWJraXRBbmltYXRpb24nO1xuICAgIGFuaW1hdGlvbkVuZEV2ZW50ID0gJ3dlYmtpdEFuaW1hdGlvbkVuZCc7XG4gIH1cbn1cblxuLy8gYmluZGluZyB0byB3aW5kb3cgaXMgbmVjZXNzYXJ5IHRvIG1ha2UgaG90IHJlbG9hZCB3b3JrIGluIElFIGluIHN0cmljdCBtb2RlXG52YXIgcmFmID0gaW5Ccm93c2VyXG4gID8gd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZVxuICAgID8gd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZS5iaW5kKHdpbmRvdylcbiAgICA6IHNldFRpbWVvdXRcbiAgOiAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqLyBmdW5jdGlvbiAoZm4pIHsgcmV0dXJuIGZuKCk7IH07XG5cbmZ1bmN0aW9uIG5leHRGcmFtZSAoZm4pIHtcbiAgcmFmKGZ1bmN0aW9uICgpIHtcbiAgICByYWYoZm4pO1xuICB9KTtcbn1cblxuZnVuY3Rpb24gYWRkVHJhbnNpdGlvbkNsYXNzIChlbCwgY2xzKSB7XG4gIHZhciB0cmFuc2l0aW9uQ2xhc3NlcyA9IGVsLl90cmFuc2l0aW9uQ2xhc3NlcyB8fCAoZWwuX3RyYW5zaXRpb25DbGFzc2VzID0gW10pO1xuICBpZiAodHJhbnNpdGlvbkNsYXNzZXMuaW5kZXhPZihjbHMpIDwgMCkge1xuICAgIHRyYW5zaXRpb25DbGFzc2VzLnB1c2goY2xzKTtcbiAgICBhZGRDbGFzcyhlbCwgY2xzKTtcbiAgfVxufVxuXG5mdW5jdGlvbiByZW1vdmVUcmFuc2l0aW9uQ2xhc3MgKGVsLCBjbHMpIHtcbiAgaWYgKGVsLl90cmFuc2l0aW9uQ2xhc3Nlcykge1xuICAgIHJlbW92ZShlbC5fdHJhbnNpdGlvbkNsYXNzZXMsIGNscyk7XG4gIH1cbiAgcmVtb3ZlQ2xhc3MoZWwsIGNscyk7XG59XG5cbmZ1bmN0aW9uIHdoZW5UcmFuc2l0aW9uRW5kcyAoXG4gIGVsLFxuICBleHBlY3RlZFR5cGUsXG4gIGNiXG4pIHtcbiAgdmFyIHJlZiA9IGdldFRyYW5zaXRpb25JbmZvKGVsLCBleHBlY3RlZFR5cGUpO1xuICB2YXIgdHlwZSA9IHJlZi50eXBlO1xuICB2YXIgdGltZW91dCA9IHJlZi50aW1lb3V0O1xuICB2YXIgcHJvcENvdW50ID0gcmVmLnByb3BDb3VudDtcbiAgaWYgKCF0eXBlKSB7IHJldHVybiBjYigpIH1cbiAgdmFyIGV2ZW50ID0gdHlwZSA9PT0gVFJBTlNJVElPTiA/IHRyYW5zaXRpb25FbmRFdmVudCA6IGFuaW1hdGlvbkVuZEV2ZW50O1xuICB2YXIgZW5kZWQgPSAwO1xuICB2YXIgZW5kID0gZnVuY3Rpb24gKCkge1xuICAgIGVsLnJlbW92ZUV2ZW50TGlzdGVuZXIoZXZlbnQsIG9uRW5kKTtcbiAgICBjYigpO1xuICB9O1xuICB2YXIgb25FbmQgPSBmdW5jdGlvbiAoZSkge1xuICAgIGlmIChlLnRhcmdldCA9PT0gZWwpIHtcbiAgICAgIGlmICgrK2VuZGVkID49IHByb3BDb3VudCkge1xuICAgICAgICBlbmQoKTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG4gIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgIGlmIChlbmRlZCA8IHByb3BDb3VudCkge1xuICAgICAgZW5kKCk7XG4gICAgfVxuICB9LCB0aW1lb3V0ICsgMSk7XG4gIGVsLmFkZEV2ZW50TGlzdGVuZXIoZXZlbnQsIG9uRW5kKTtcbn1cblxudmFyIHRyYW5zZm9ybVJFID0gL1xcYih0cmFuc2Zvcm18YWxsKSgsfCQpLztcblxuZnVuY3Rpb24gZ2V0VHJhbnNpdGlvbkluZm8gKGVsLCBleHBlY3RlZFR5cGUpIHtcbiAgdmFyIHN0eWxlcyA9IHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKGVsKTtcbiAgdmFyIHRyYW5zaXRpb25EZWxheXMgPSBzdHlsZXNbdHJhbnNpdGlvblByb3AgKyAnRGVsYXknXS5zcGxpdCgnLCAnKTtcbiAgdmFyIHRyYW5zaXRpb25EdXJhdGlvbnMgPSBzdHlsZXNbdHJhbnNpdGlvblByb3AgKyAnRHVyYXRpb24nXS5zcGxpdCgnLCAnKTtcbiAgdmFyIHRyYW5zaXRpb25UaW1lb3V0ID0gZ2V0VGltZW91dCh0cmFuc2l0aW9uRGVsYXlzLCB0cmFuc2l0aW9uRHVyYXRpb25zKTtcbiAgdmFyIGFuaW1hdGlvbkRlbGF5cyA9IHN0eWxlc1thbmltYXRpb25Qcm9wICsgJ0RlbGF5J10uc3BsaXQoJywgJyk7XG4gIHZhciBhbmltYXRpb25EdXJhdGlvbnMgPSBzdHlsZXNbYW5pbWF0aW9uUHJvcCArICdEdXJhdGlvbiddLnNwbGl0KCcsICcpO1xuICB2YXIgYW5pbWF0aW9uVGltZW91dCA9IGdldFRpbWVvdXQoYW5pbWF0aW9uRGVsYXlzLCBhbmltYXRpb25EdXJhdGlvbnMpO1xuXG4gIHZhciB0eXBlO1xuICB2YXIgdGltZW91dCA9IDA7XG4gIHZhciBwcm9wQ291bnQgPSAwO1xuICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgaWYgKGV4cGVjdGVkVHlwZSA9PT0gVFJBTlNJVElPTikge1xuICAgIGlmICh0cmFuc2l0aW9uVGltZW91dCA+IDApIHtcbiAgICAgIHR5cGUgPSBUUkFOU0lUSU9OO1xuICAgICAgdGltZW91dCA9IHRyYW5zaXRpb25UaW1lb3V0O1xuICAgICAgcHJvcENvdW50ID0gdHJhbnNpdGlvbkR1cmF0aW9ucy5sZW5ndGg7XG4gICAgfVxuICB9IGVsc2UgaWYgKGV4cGVjdGVkVHlwZSA9PT0gQU5JTUFUSU9OKSB7XG4gICAgaWYgKGFuaW1hdGlvblRpbWVvdXQgPiAwKSB7XG4gICAgICB0eXBlID0gQU5JTUFUSU9OO1xuICAgICAgdGltZW91dCA9IGFuaW1hdGlvblRpbWVvdXQ7XG4gICAgICBwcm9wQ291bnQgPSBhbmltYXRpb25EdXJhdGlvbnMubGVuZ3RoO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICB0aW1lb3V0ID0gTWF0aC5tYXgodHJhbnNpdGlvblRpbWVvdXQsIGFuaW1hdGlvblRpbWVvdXQpO1xuICAgIHR5cGUgPSB0aW1lb3V0ID4gMFxuICAgICAgPyB0cmFuc2l0aW9uVGltZW91dCA+IGFuaW1hdGlvblRpbWVvdXRcbiAgICAgICAgPyBUUkFOU0lUSU9OXG4gICAgICAgIDogQU5JTUFUSU9OXG4gICAgICA6IG51bGw7XG4gICAgcHJvcENvdW50ID0gdHlwZVxuICAgICAgPyB0eXBlID09PSBUUkFOU0lUSU9OXG4gICAgICAgID8gdHJhbnNpdGlvbkR1cmF0aW9ucy5sZW5ndGhcbiAgICAgICAgOiBhbmltYXRpb25EdXJhdGlvbnMubGVuZ3RoXG4gICAgICA6IDA7XG4gIH1cbiAgdmFyIGhhc1RyYW5zZm9ybSA9XG4gICAgdHlwZSA9PT0gVFJBTlNJVElPTiAmJlxuICAgIHRyYW5zZm9ybVJFLnRlc3Qoc3R5bGVzW3RyYW5zaXRpb25Qcm9wICsgJ1Byb3BlcnR5J10pO1xuICByZXR1cm4ge1xuICAgIHR5cGU6IHR5cGUsXG4gICAgdGltZW91dDogdGltZW91dCxcbiAgICBwcm9wQ291bnQ6IHByb3BDb3VudCxcbiAgICBoYXNUcmFuc2Zvcm06IGhhc1RyYW5zZm9ybVxuICB9XG59XG5cbmZ1bmN0aW9uIGdldFRpbWVvdXQgKGRlbGF5cywgZHVyYXRpb25zKSB7XG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gIHdoaWxlIChkZWxheXMubGVuZ3RoIDwgZHVyYXRpb25zLmxlbmd0aCkge1xuICAgIGRlbGF5cyA9IGRlbGF5cy5jb25jYXQoZGVsYXlzKTtcbiAgfVxuXG4gIHJldHVybiBNYXRoLm1heC5hcHBseShudWxsLCBkdXJhdGlvbnMubWFwKGZ1bmN0aW9uIChkLCBpKSB7XG4gICAgcmV0dXJuIHRvTXMoZCkgKyB0b01zKGRlbGF5c1tpXSlcbiAgfSkpXG59XG5cbmZ1bmN0aW9uIHRvTXMgKHMpIHtcbiAgcmV0dXJuIE51bWJlcihzLnNsaWNlKDAsIC0xKSkgKiAxMDAwXG59XG5cbi8qICAqL1xuXG5mdW5jdGlvbiBlbnRlciAodm5vZGUsIHRvZ2dsZURpc3BsYXkpIHtcbiAgdmFyIGVsID0gdm5vZGUuZWxtO1xuXG4gIC8vIGNhbGwgbGVhdmUgY2FsbGJhY2sgbm93XG4gIGlmIChpc0RlZihlbC5fbGVhdmVDYikpIHtcbiAgICBlbC5fbGVhdmVDYi5jYW5jZWxsZWQgPSB0cnVlO1xuICAgIGVsLl9sZWF2ZUNiKCk7XG4gIH1cblxuICB2YXIgZGF0YSA9IHJlc29sdmVUcmFuc2l0aW9uKHZub2RlLmRhdGEudHJhbnNpdGlvbik7XG4gIGlmIChpc1VuZGVmKGRhdGEpKSB7XG4gICAgcmV0dXJuXG4gIH1cblxuICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgaWYgKGlzRGVmKGVsLl9lbnRlckNiKSB8fCBlbC5ub2RlVHlwZSAhPT0gMSkge1xuICAgIHJldHVyblxuICB9XG5cbiAgdmFyIGNzcyA9IGRhdGEuY3NzO1xuICB2YXIgdHlwZSA9IGRhdGEudHlwZTtcbiAgdmFyIGVudGVyQ2xhc3MgPSBkYXRhLmVudGVyQ2xhc3M7XG4gIHZhciBlbnRlclRvQ2xhc3MgPSBkYXRhLmVudGVyVG9DbGFzcztcbiAgdmFyIGVudGVyQWN0aXZlQ2xhc3MgPSBkYXRhLmVudGVyQWN0aXZlQ2xhc3M7XG4gIHZhciBhcHBlYXJDbGFzcyA9IGRhdGEuYXBwZWFyQ2xhc3M7XG4gIHZhciBhcHBlYXJUb0NsYXNzID0gZGF0YS5hcHBlYXJUb0NsYXNzO1xuICB2YXIgYXBwZWFyQWN0aXZlQ2xhc3MgPSBkYXRhLmFwcGVhckFjdGl2ZUNsYXNzO1xuICB2YXIgYmVmb3JlRW50ZXIgPSBkYXRhLmJlZm9yZUVudGVyO1xuICB2YXIgZW50ZXIgPSBkYXRhLmVudGVyO1xuICB2YXIgYWZ0ZXJFbnRlciA9IGRhdGEuYWZ0ZXJFbnRlcjtcbiAgdmFyIGVudGVyQ2FuY2VsbGVkID0gZGF0YS5lbnRlckNhbmNlbGxlZDtcbiAgdmFyIGJlZm9yZUFwcGVhciA9IGRhdGEuYmVmb3JlQXBwZWFyO1xuICB2YXIgYXBwZWFyID0gZGF0YS5hcHBlYXI7XG4gIHZhciBhZnRlckFwcGVhciA9IGRhdGEuYWZ0ZXJBcHBlYXI7XG4gIHZhciBhcHBlYXJDYW5jZWxsZWQgPSBkYXRhLmFwcGVhckNhbmNlbGxlZDtcbiAgdmFyIGR1cmF0aW9uID0gZGF0YS5kdXJhdGlvbjtcblxuICAvLyBhY3RpdmVJbnN0YW5jZSB3aWxsIGFsd2F5cyBiZSB0aGUgPHRyYW5zaXRpb24+IGNvbXBvbmVudCBtYW5hZ2luZyB0aGlzXG4gIC8vIHRyYW5zaXRpb24uIE9uZSBlZGdlIGNhc2UgdG8gY2hlY2sgaXMgd2hlbiB0aGUgPHRyYW5zaXRpb24+IGlzIHBsYWNlZFxuICAvLyBhcyB0aGUgcm9vdCBub2RlIG9mIGEgY2hpbGQgY29tcG9uZW50LiBJbiB0aGF0IGNhc2Ugd2UgbmVlZCB0byBjaGVja1xuICAvLyA8dHJhbnNpdGlvbj4ncyBwYXJlbnQgZm9yIGFwcGVhciBjaGVjay5cbiAgdmFyIGNvbnRleHQgPSBhY3RpdmVJbnN0YW5jZTtcbiAgdmFyIHRyYW5zaXRpb25Ob2RlID0gYWN0aXZlSW5zdGFuY2UuJHZub2RlO1xuICB3aGlsZSAodHJhbnNpdGlvbk5vZGUgJiYgdHJhbnNpdGlvbk5vZGUucGFyZW50KSB7XG4gICAgdHJhbnNpdGlvbk5vZGUgPSB0cmFuc2l0aW9uTm9kZS5wYXJlbnQ7XG4gICAgY29udGV4dCA9IHRyYW5zaXRpb25Ob2RlLmNvbnRleHQ7XG4gIH1cblxuICB2YXIgaXNBcHBlYXIgPSAhY29udGV4dC5faXNNb3VudGVkIHx8ICF2bm9kZS5pc1Jvb3RJbnNlcnQ7XG5cbiAgaWYgKGlzQXBwZWFyICYmICFhcHBlYXIgJiYgYXBwZWFyICE9PSAnJykge1xuICAgIHJldHVyblxuICB9XG5cbiAgdmFyIHN0YXJ0Q2xhc3MgPSBpc0FwcGVhciAmJiBhcHBlYXJDbGFzc1xuICAgID8gYXBwZWFyQ2xhc3NcbiAgICA6IGVudGVyQ2xhc3M7XG4gIHZhciBhY3RpdmVDbGFzcyA9IGlzQXBwZWFyICYmIGFwcGVhckFjdGl2ZUNsYXNzXG4gICAgPyBhcHBlYXJBY3RpdmVDbGFzc1xuICAgIDogZW50ZXJBY3RpdmVDbGFzcztcbiAgdmFyIHRvQ2xhc3MgPSBpc0FwcGVhciAmJiBhcHBlYXJUb0NsYXNzXG4gICAgPyBhcHBlYXJUb0NsYXNzXG4gICAgOiBlbnRlclRvQ2xhc3M7XG5cbiAgdmFyIGJlZm9yZUVudGVySG9vayA9IGlzQXBwZWFyXG4gICAgPyAoYmVmb3JlQXBwZWFyIHx8IGJlZm9yZUVudGVyKVxuICAgIDogYmVmb3JlRW50ZXI7XG4gIHZhciBlbnRlckhvb2sgPSBpc0FwcGVhclxuICAgID8gKHR5cGVvZiBhcHBlYXIgPT09ICdmdW5jdGlvbicgPyBhcHBlYXIgOiBlbnRlcilcbiAgICA6IGVudGVyO1xuICB2YXIgYWZ0ZXJFbnRlckhvb2sgPSBpc0FwcGVhclxuICAgID8gKGFmdGVyQXBwZWFyIHx8IGFmdGVyRW50ZXIpXG4gICAgOiBhZnRlckVudGVyO1xuICB2YXIgZW50ZXJDYW5jZWxsZWRIb29rID0gaXNBcHBlYXJcbiAgICA/IChhcHBlYXJDYW5jZWxsZWQgfHwgZW50ZXJDYW5jZWxsZWQpXG4gICAgOiBlbnRlckNhbmNlbGxlZDtcblxuICB2YXIgZXhwbGljaXRFbnRlckR1cmF0aW9uID0gdG9OdW1iZXIoXG4gICAgaXNPYmplY3QoZHVyYXRpb24pXG4gICAgICA/IGR1cmF0aW9uLmVudGVyXG4gICAgICA6IGR1cmF0aW9uXG4gICk7XG5cbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgZXhwbGljaXRFbnRlckR1cmF0aW9uICE9IG51bGwpIHtcbiAgICBjaGVja0R1cmF0aW9uKGV4cGxpY2l0RW50ZXJEdXJhdGlvbiwgJ2VudGVyJywgdm5vZGUpO1xuICB9XG5cbiAgdmFyIGV4cGVjdHNDU1MgPSBjc3MgIT09IGZhbHNlICYmICFpc0lFOTtcbiAgdmFyIHVzZXJXYW50c0NvbnRyb2wgPSBnZXRIb29rQXJndW1lbnRzTGVuZ3RoKGVudGVySG9vayk7XG5cbiAgdmFyIGNiID0gZWwuX2VudGVyQ2IgPSBvbmNlKGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoZXhwZWN0c0NTUykge1xuICAgICAgcmVtb3ZlVHJhbnNpdGlvbkNsYXNzKGVsLCB0b0NsYXNzKTtcbiAgICAgIHJlbW92ZVRyYW5zaXRpb25DbGFzcyhlbCwgYWN0aXZlQ2xhc3MpO1xuICAgIH1cbiAgICBpZiAoY2IuY2FuY2VsbGVkKSB7XG4gICAgICBpZiAoZXhwZWN0c0NTUykge1xuICAgICAgICByZW1vdmVUcmFuc2l0aW9uQ2xhc3MoZWwsIHN0YXJ0Q2xhc3MpO1xuICAgICAgfVxuICAgICAgZW50ZXJDYW5jZWxsZWRIb29rICYmIGVudGVyQ2FuY2VsbGVkSG9vayhlbCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGFmdGVyRW50ZXJIb29rICYmIGFmdGVyRW50ZXJIb29rKGVsKTtcbiAgICB9XG4gICAgZWwuX2VudGVyQ2IgPSBudWxsO1xuICB9KTtcblxuICBpZiAoIXZub2RlLmRhdGEuc2hvdykge1xuICAgIC8vIHJlbW92ZSBwZW5kaW5nIGxlYXZlIGVsZW1lbnQgb24gZW50ZXIgYnkgaW5qZWN0aW5nIGFuIGluc2VydCBob29rXG4gICAgbWVyZ2VWTm9kZUhvb2sodm5vZGUsICdpbnNlcnQnLCBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgcGFyZW50ID0gZWwucGFyZW50Tm9kZTtcbiAgICAgIHZhciBwZW5kaW5nTm9kZSA9IHBhcmVudCAmJiBwYXJlbnQuX3BlbmRpbmcgJiYgcGFyZW50Ll9wZW5kaW5nW3Zub2RlLmtleV07XG4gICAgICBpZiAocGVuZGluZ05vZGUgJiZcbiAgICAgICAgcGVuZGluZ05vZGUudGFnID09PSB2bm9kZS50YWcgJiZcbiAgICAgICAgcGVuZGluZ05vZGUuZWxtLl9sZWF2ZUNiXG4gICAgICApIHtcbiAgICAgICAgcGVuZGluZ05vZGUuZWxtLl9sZWF2ZUNiKCk7XG4gICAgICB9XG4gICAgICBlbnRlckhvb2sgJiYgZW50ZXJIb29rKGVsLCBjYik7XG4gICAgfSk7XG4gIH1cblxuICAvLyBzdGFydCBlbnRlciB0cmFuc2l0aW9uXG4gIGJlZm9yZUVudGVySG9vayAmJiBiZWZvcmVFbnRlckhvb2soZWwpO1xuICBpZiAoZXhwZWN0c0NTUykge1xuICAgIGFkZFRyYW5zaXRpb25DbGFzcyhlbCwgc3RhcnRDbGFzcyk7XG4gICAgYWRkVHJhbnNpdGlvbkNsYXNzKGVsLCBhY3RpdmVDbGFzcyk7XG4gICAgbmV4dEZyYW1lKGZ1bmN0aW9uICgpIHtcbiAgICAgIGFkZFRyYW5zaXRpb25DbGFzcyhlbCwgdG9DbGFzcyk7XG4gICAgICByZW1vdmVUcmFuc2l0aW9uQ2xhc3MoZWwsIHN0YXJ0Q2xhc3MpO1xuICAgICAgaWYgKCFjYi5jYW5jZWxsZWQgJiYgIXVzZXJXYW50c0NvbnRyb2wpIHtcbiAgICAgICAgaWYgKGlzVmFsaWREdXJhdGlvbihleHBsaWNpdEVudGVyRHVyYXRpb24pKSB7XG4gICAgICAgICAgc2V0VGltZW91dChjYiwgZXhwbGljaXRFbnRlckR1cmF0aW9uKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB3aGVuVHJhbnNpdGlvbkVuZHMoZWwsIHR5cGUsIGNiKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgaWYgKHZub2RlLmRhdGEuc2hvdykge1xuICAgIHRvZ2dsZURpc3BsYXkgJiYgdG9nZ2xlRGlzcGxheSgpO1xuICAgIGVudGVySG9vayAmJiBlbnRlckhvb2soZWwsIGNiKTtcbiAgfVxuXG4gIGlmICghZXhwZWN0c0NTUyAmJiAhdXNlcldhbnRzQ29udHJvbCkge1xuICAgIGNiKCk7XG4gIH1cbn1cblxuZnVuY3Rpb24gbGVhdmUgKHZub2RlLCBybSkge1xuICB2YXIgZWwgPSB2bm9kZS5lbG07XG5cbiAgLy8gY2FsbCBlbnRlciBjYWxsYmFjayBub3dcbiAgaWYgKGlzRGVmKGVsLl9lbnRlckNiKSkge1xuICAgIGVsLl9lbnRlckNiLmNhbmNlbGxlZCA9IHRydWU7XG4gICAgZWwuX2VudGVyQ2IoKTtcbiAgfVxuXG4gIHZhciBkYXRhID0gcmVzb2x2ZVRyYW5zaXRpb24odm5vZGUuZGF0YS50cmFuc2l0aW9uKTtcbiAgaWYgKGlzVW5kZWYoZGF0YSkgfHwgZWwubm9kZVR5cGUgIT09IDEpIHtcbiAgICByZXR1cm4gcm0oKVxuICB9XG5cbiAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gIGlmIChpc0RlZihlbC5fbGVhdmVDYikpIHtcbiAgICByZXR1cm5cbiAgfVxuXG4gIHZhciBjc3MgPSBkYXRhLmNzcztcbiAgdmFyIHR5cGUgPSBkYXRhLnR5cGU7XG4gIHZhciBsZWF2ZUNsYXNzID0gZGF0YS5sZWF2ZUNsYXNzO1xuICB2YXIgbGVhdmVUb0NsYXNzID0gZGF0YS5sZWF2ZVRvQ2xhc3M7XG4gIHZhciBsZWF2ZUFjdGl2ZUNsYXNzID0gZGF0YS5sZWF2ZUFjdGl2ZUNsYXNzO1xuICB2YXIgYmVmb3JlTGVhdmUgPSBkYXRhLmJlZm9yZUxlYXZlO1xuICB2YXIgbGVhdmUgPSBkYXRhLmxlYXZlO1xuICB2YXIgYWZ0ZXJMZWF2ZSA9IGRhdGEuYWZ0ZXJMZWF2ZTtcbiAgdmFyIGxlYXZlQ2FuY2VsbGVkID0gZGF0YS5sZWF2ZUNhbmNlbGxlZDtcbiAgdmFyIGRlbGF5TGVhdmUgPSBkYXRhLmRlbGF5TGVhdmU7XG4gIHZhciBkdXJhdGlvbiA9IGRhdGEuZHVyYXRpb247XG5cbiAgdmFyIGV4cGVjdHNDU1MgPSBjc3MgIT09IGZhbHNlICYmICFpc0lFOTtcbiAgdmFyIHVzZXJXYW50c0NvbnRyb2wgPSBnZXRIb29rQXJndW1lbnRzTGVuZ3RoKGxlYXZlKTtcblxuICB2YXIgZXhwbGljaXRMZWF2ZUR1cmF0aW9uID0gdG9OdW1iZXIoXG4gICAgaXNPYmplY3QoZHVyYXRpb24pXG4gICAgICA/IGR1cmF0aW9uLmxlYXZlXG4gICAgICA6IGR1cmF0aW9uXG4gICk7XG5cbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgaXNEZWYoZXhwbGljaXRMZWF2ZUR1cmF0aW9uKSkge1xuICAgIGNoZWNrRHVyYXRpb24oZXhwbGljaXRMZWF2ZUR1cmF0aW9uLCAnbGVhdmUnLCB2bm9kZSk7XG4gIH1cblxuICB2YXIgY2IgPSBlbC5fbGVhdmVDYiA9IG9uY2UoZnVuY3Rpb24gKCkge1xuICAgIGlmIChlbC5wYXJlbnROb2RlICYmIGVsLnBhcmVudE5vZGUuX3BlbmRpbmcpIHtcbiAgICAgIGVsLnBhcmVudE5vZGUuX3BlbmRpbmdbdm5vZGUua2V5XSA9IG51bGw7XG4gICAgfVxuICAgIGlmIChleHBlY3RzQ1NTKSB7XG4gICAgICByZW1vdmVUcmFuc2l0aW9uQ2xhc3MoZWwsIGxlYXZlVG9DbGFzcyk7XG4gICAgICByZW1vdmVUcmFuc2l0aW9uQ2xhc3MoZWwsIGxlYXZlQWN0aXZlQ2xhc3MpO1xuICAgIH1cbiAgICBpZiAoY2IuY2FuY2VsbGVkKSB7XG4gICAgICBpZiAoZXhwZWN0c0NTUykge1xuICAgICAgICByZW1vdmVUcmFuc2l0aW9uQ2xhc3MoZWwsIGxlYXZlQ2xhc3MpO1xuICAgICAgfVxuICAgICAgbGVhdmVDYW5jZWxsZWQgJiYgbGVhdmVDYW5jZWxsZWQoZWwpO1xuICAgIH0gZWxzZSB7XG4gICAgICBybSgpO1xuICAgICAgYWZ0ZXJMZWF2ZSAmJiBhZnRlckxlYXZlKGVsKTtcbiAgICB9XG4gICAgZWwuX2xlYXZlQ2IgPSBudWxsO1xuICB9KTtcblxuICBpZiAoZGVsYXlMZWF2ZSkge1xuICAgIGRlbGF5TGVhdmUocGVyZm9ybUxlYXZlKTtcbiAgfSBlbHNlIHtcbiAgICBwZXJmb3JtTGVhdmUoKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHBlcmZvcm1MZWF2ZSAoKSB7XG4gICAgLy8gdGhlIGRlbGF5ZWQgbGVhdmUgbWF5IGhhdmUgYWxyZWFkeSBiZWVuIGNhbmNlbGxlZFxuICAgIGlmIChjYi5jYW5jZWxsZWQpIHtcbiAgICAgIHJldHVyblxuICAgIH1cbiAgICAvLyByZWNvcmQgbGVhdmluZyBlbGVtZW50XG4gICAgaWYgKCF2bm9kZS5kYXRhLnNob3cpIHtcbiAgICAgIChlbC5wYXJlbnROb2RlLl9wZW5kaW5nIHx8IChlbC5wYXJlbnROb2RlLl9wZW5kaW5nID0ge30pKVsodm5vZGUua2V5KV0gPSB2bm9kZTtcbiAgICB9XG4gICAgYmVmb3JlTGVhdmUgJiYgYmVmb3JlTGVhdmUoZWwpO1xuICAgIGlmIChleHBlY3RzQ1NTKSB7XG4gICAgICBhZGRUcmFuc2l0aW9uQ2xhc3MoZWwsIGxlYXZlQ2xhc3MpO1xuICAgICAgYWRkVHJhbnNpdGlvbkNsYXNzKGVsLCBsZWF2ZUFjdGl2ZUNsYXNzKTtcbiAgICAgIG5leHRGcmFtZShmdW5jdGlvbiAoKSB7XG4gICAgICAgIGFkZFRyYW5zaXRpb25DbGFzcyhlbCwgbGVhdmVUb0NsYXNzKTtcbiAgICAgICAgcmVtb3ZlVHJhbnNpdGlvbkNsYXNzKGVsLCBsZWF2ZUNsYXNzKTtcbiAgICAgICAgaWYgKCFjYi5jYW5jZWxsZWQgJiYgIXVzZXJXYW50c0NvbnRyb2wpIHtcbiAgICAgICAgICBpZiAoaXNWYWxpZER1cmF0aW9uKGV4cGxpY2l0TGVhdmVEdXJhdGlvbikpIHtcbiAgICAgICAgICAgIHNldFRpbWVvdXQoY2IsIGV4cGxpY2l0TGVhdmVEdXJhdGlvbik7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHdoZW5UcmFuc2l0aW9uRW5kcyhlbCwgdHlwZSwgY2IpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICAgIGxlYXZlICYmIGxlYXZlKGVsLCBjYik7XG4gICAgaWYgKCFleHBlY3RzQ1NTICYmICF1c2VyV2FudHNDb250cm9sKSB7XG4gICAgICBjYigpO1xuICAgIH1cbiAgfVxufVxuXG4vLyBvbmx5IHVzZWQgaW4gZGV2IG1vZGVcbmZ1bmN0aW9uIGNoZWNrRHVyYXRpb24gKHZhbCwgbmFtZSwgdm5vZGUpIHtcbiAgaWYgKHR5cGVvZiB2YWwgIT09ICdudW1iZXInKSB7XG4gICAgd2FybihcbiAgICAgIFwiPHRyYW5zaXRpb24+IGV4cGxpY2l0IFwiICsgbmFtZSArIFwiIGR1cmF0aW9uIGlzIG5vdCBhIHZhbGlkIG51bWJlciAtIFwiICtcbiAgICAgIFwiZ290IFwiICsgKEpTT04uc3RyaW5naWZ5KHZhbCkpICsgXCIuXCIsXG4gICAgICB2bm9kZS5jb250ZXh0XG4gICAgKTtcbiAgfSBlbHNlIGlmIChpc05hTih2YWwpKSB7XG4gICAgd2FybihcbiAgICAgIFwiPHRyYW5zaXRpb24+IGV4cGxpY2l0IFwiICsgbmFtZSArIFwiIGR1cmF0aW9uIGlzIE5hTiAtIFwiICtcbiAgICAgICd0aGUgZHVyYXRpb24gZXhwcmVzc2lvbiBtaWdodCBiZSBpbmNvcnJlY3QuJyxcbiAgICAgIHZub2RlLmNvbnRleHRcbiAgICApO1xuICB9XG59XG5cbmZ1bmN0aW9uIGlzVmFsaWREdXJhdGlvbiAodmFsKSB7XG4gIHJldHVybiB0eXBlb2YgdmFsID09PSAnbnVtYmVyJyAmJiAhaXNOYU4odmFsKVxufVxuXG4vKipcbiAqIE5vcm1hbGl6ZSBhIHRyYW5zaXRpb24gaG9vaydzIGFyZ3VtZW50IGxlbmd0aC4gVGhlIGhvb2sgbWF5IGJlOlxuICogLSBhIG1lcmdlZCBob29rIChpbnZva2VyKSB3aXRoIHRoZSBvcmlnaW5hbCBpbiAuZm5zXG4gKiAtIGEgd3JhcHBlZCBjb21wb25lbnQgbWV0aG9kIChjaGVjayAuX2xlbmd0aClcbiAqIC0gYSBwbGFpbiBmdW5jdGlvbiAoLmxlbmd0aClcbiAqL1xuZnVuY3Rpb24gZ2V0SG9va0FyZ3VtZW50c0xlbmd0aCAoZm4pIHtcbiAgaWYgKGlzVW5kZWYoZm4pKSB7XG4gICAgcmV0dXJuIGZhbHNlXG4gIH1cbiAgdmFyIGludm9rZXJGbnMgPSBmbi5mbnM7XG4gIGlmIChpc0RlZihpbnZva2VyRm5zKSkge1xuICAgIC8vIGludm9rZXJcbiAgICByZXR1cm4gZ2V0SG9va0FyZ3VtZW50c0xlbmd0aChcbiAgICAgIEFycmF5LmlzQXJyYXkoaW52b2tlckZucylcbiAgICAgICAgPyBpbnZva2VyRm5zWzBdXG4gICAgICAgIDogaW52b2tlckZuc1xuICAgIClcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gKGZuLl9sZW5ndGggfHwgZm4ubGVuZ3RoKSA+IDFcbiAgfVxufVxuXG5mdW5jdGlvbiBfZW50ZXIgKF8sIHZub2RlKSB7XG4gIGlmICh2bm9kZS5kYXRhLnNob3cgIT09IHRydWUpIHtcbiAgICBlbnRlcih2bm9kZSk7XG4gIH1cbn1cblxudmFyIHRyYW5zaXRpb24gPSBpbkJyb3dzZXIgPyB7XG4gIGNyZWF0ZTogX2VudGVyLFxuICBhY3RpdmF0ZTogX2VudGVyLFxuICByZW1vdmU6IGZ1bmN0aW9uIHJlbW92ZSQkMSAodm5vZGUsIHJtKSB7XG4gICAgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cbiAgICBpZiAodm5vZGUuZGF0YS5zaG93ICE9PSB0cnVlKSB7XG4gICAgICBsZWF2ZSh2bm9kZSwgcm0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBybSgpO1xuICAgIH1cbiAgfVxufSA6IHt9O1xuXG52YXIgcGxhdGZvcm1Nb2R1bGVzID0gW1xuICBhdHRycyxcbiAga2xhc3MsXG4gIGV2ZW50cyxcbiAgZG9tUHJvcHMsXG4gIHN0eWxlLFxuICB0cmFuc2l0aW9uXG5dO1xuXG4vKiAgKi9cblxuLy8gdGhlIGRpcmVjdGl2ZSBtb2R1bGUgc2hvdWxkIGJlIGFwcGxpZWQgbGFzdCwgYWZ0ZXIgYWxsXG4vLyBidWlsdC1pbiBtb2R1bGVzIGhhdmUgYmVlbiBhcHBsaWVkLlxudmFyIG1vZHVsZXMgPSBwbGF0Zm9ybU1vZHVsZXMuY29uY2F0KGJhc2VNb2R1bGVzKTtcblxudmFyIHBhdGNoID0gY3JlYXRlUGF0Y2hGdW5jdGlvbih7IG5vZGVPcHM6IG5vZGVPcHMsIG1vZHVsZXM6IG1vZHVsZXMgfSk7XG5cbi8qKlxuICogTm90IHR5cGUgY2hlY2tpbmcgdGhpcyBmaWxlIGJlY2F1c2UgZmxvdyBkb2Vzbid0IGxpa2UgYXR0YWNoaW5nXG4gKiBwcm9wZXJ0aWVzIHRvIEVsZW1lbnRzLlxuICovXG5cbi8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuaWYgKGlzSUU5KSB7XG4gIC8vIGh0dHA6Ly93d3cubWF0dHM0MTEuY29tL3Bvc3QvaW50ZXJuZXQtZXhwbG9yZXItOS1vbmlucHV0L1xuICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdzZWxlY3Rpb25jaGFuZ2UnLCBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGVsID0gZG9jdW1lbnQuYWN0aXZlRWxlbWVudDtcbiAgICBpZiAoZWwgJiYgZWwudm1vZGVsKSB7XG4gICAgICB0cmlnZ2VyKGVsLCAnaW5wdXQnKTtcbiAgICB9XG4gIH0pO1xufVxuXG52YXIgZGlyZWN0aXZlID0ge1xuICBpbnNlcnRlZDogZnVuY3Rpb24gaW5zZXJ0ZWQgKGVsLCBiaW5kaW5nLCB2bm9kZSwgb2xkVm5vZGUpIHtcbiAgICBpZiAodm5vZGUudGFnID09PSAnc2VsZWN0Jykge1xuICAgICAgLy8gIzY5MDNcbiAgICAgIGlmIChvbGRWbm9kZS5lbG0gJiYgIW9sZFZub2RlLmVsbS5fdk9wdGlvbnMpIHtcbiAgICAgICAgbWVyZ2VWTm9kZUhvb2sodm5vZGUsICdwb3N0cGF0Y2gnLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgZGlyZWN0aXZlLmNvbXBvbmVudFVwZGF0ZWQoZWwsIGJpbmRpbmcsIHZub2RlKTtcbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzZXRTZWxlY3RlZChlbCwgYmluZGluZywgdm5vZGUuY29udGV4dCk7XG4gICAgICB9XG4gICAgICBlbC5fdk9wdGlvbnMgPSBbXS5tYXAuY2FsbChlbC5vcHRpb25zLCBnZXRWYWx1ZSk7XG4gICAgfSBlbHNlIGlmICh2bm9kZS50YWcgPT09ICd0ZXh0YXJlYScgfHwgaXNUZXh0SW5wdXRUeXBlKGVsLnR5cGUpKSB7XG4gICAgICBlbC5fdk1vZGlmaWVycyA9IGJpbmRpbmcubW9kaWZpZXJzO1xuICAgICAgaWYgKCFiaW5kaW5nLm1vZGlmaWVycy5sYXp5KSB7XG4gICAgICAgIC8vIFNhZmFyaSA8IDEwLjIgJiBVSVdlYlZpZXcgZG9lc24ndCBmaXJlIGNvbXBvc2l0aW9uZW5kIHdoZW5cbiAgICAgICAgLy8gc3dpdGNoaW5nIGZvY3VzIGJlZm9yZSBjb25maXJtaW5nIGNvbXBvc2l0aW9uIGNob2ljZVxuICAgICAgICAvLyB0aGlzIGFsc28gZml4ZXMgdGhlIGlzc3VlIHdoZXJlIHNvbWUgYnJvd3NlcnMgZS5nLiBpT1MgQ2hyb21lXG4gICAgICAgIC8vIGZpcmVzIFwiY2hhbmdlXCIgaW5zdGVhZCBvZiBcImlucHV0XCIgb24gYXV0b2NvbXBsZXRlLlxuICAgICAgICBlbC5hZGRFdmVudExpc3RlbmVyKCdjaGFuZ2UnLCBvbkNvbXBvc2l0aW9uRW5kKTtcbiAgICAgICAgaWYgKCFpc0FuZHJvaWQpIHtcbiAgICAgICAgICBlbC5hZGRFdmVudExpc3RlbmVyKCdjb21wb3NpdGlvbnN0YXJ0Jywgb25Db21wb3NpdGlvblN0YXJ0KTtcbiAgICAgICAgICBlbC5hZGRFdmVudExpc3RlbmVyKCdjb21wb3NpdGlvbmVuZCcsIG9uQ29tcG9zaXRpb25FbmQpO1xuICAgICAgICB9XG4gICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgICAgICBpZiAoaXNJRTkpIHtcbiAgICAgICAgICBlbC52bW9kZWwgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9LFxuXG4gIGNvbXBvbmVudFVwZGF0ZWQ6IGZ1bmN0aW9uIGNvbXBvbmVudFVwZGF0ZWQgKGVsLCBiaW5kaW5nLCB2bm9kZSkge1xuICAgIGlmICh2bm9kZS50YWcgPT09ICdzZWxlY3QnKSB7XG4gICAgICBzZXRTZWxlY3RlZChlbCwgYmluZGluZywgdm5vZGUuY29udGV4dCk7XG4gICAgICAvLyBpbiBjYXNlIHRoZSBvcHRpb25zIHJlbmRlcmVkIGJ5IHYtZm9yIGhhdmUgY2hhbmdlZCxcbiAgICAgIC8vIGl0J3MgcG9zc2libGUgdGhhdCB0aGUgdmFsdWUgaXMgb3V0LW9mLXN5bmMgd2l0aCB0aGUgcmVuZGVyZWQgb3B0aW9ucy5cbiAgICAgIC8vIGRldGVjdCBzdWNoIGNhc2VzIGFuZCBmaWx0ZXIgb3V0IHZhbHVlcyB0aGF0IG5vIGxvbmdlciBoYXMgYSBtYXRjaGluZ1xuICAgICAgLy8gb3B0aW9uIGluIHRoZSBET00uXG4gICAgICB2YXIgcHJldk9wdGlvbnMgPSBlbC5fdk9wdGlvbnM7XG4gICAgICB2YXIgY3VyT3B0aW9ucyA9IGVsLl92T3B0aW9ucyA9IFtdLm1hcC5jYWxsKGVsLm9wdGlvbnMsIGdldFZhbHVlKTtcbiAgICAgIGlmIChjdXJPcHRpb25zLnNvbWUoZnVuY3Rpb24gKG8sIGkpIHsgcmV0dXJuICFsb29zZUVxdWFsKG8sIHByZXZPcHRpb25zW2ldKTsgfSkpIHtcbiAgICAgICAgLy8gdHJpZ2dlciBjaGFuZ2UgZXZlbnQgaWZcbiAgICAgICAgLy8gbm8gbWF0Y2hpbmcgb3B0aW9uIGZvdW5kIGZvciBhdCBsZWFzdCBvbmUgdmFsdWVcbiAgICAgICAgdmFyIG5lZWRSZXNldCA9IGVsLm11bHRpcGxlXG4gICAgICAgICAgPyBiaW5kaW5nLnZhbHVlLnNvbWUoZnVuY3Rpb24gKHYpIHsgcmV0dXJuIGhhc05vTWF0Y2hpbmdPcHRpb24odiwgY3VyT3B0aW9ucyk7IH0pXG4gICAgICAgICAgOiBiaW5kaW5nLnZhbHVlICE9PSBiaW5kaW5nLm9sZFZhbHVlICYmIGhhc05vTWF0Y2hpbmdPcHRpb24oYmluZGluZy52YWx1ZSwgY3VyT3B0aW9ucyk7XG4gICAgICAgIGlmIChuZWVkUmVzZXQpIHtcbiAgICAgICAgICB0cmlnZ2VyKGVsLCAnY2hhbmdlJyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbn07XG5cbmZ1bmN0aW9uIHNldFNlbGVjdGVkIChlbCwgYmluZGluZywgdm0pIHtcbiAgYWN0dWFsbHlTZXRTZWxlY3RlZChlbCwgYmluZGluZywgdm0pO1xuICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgaWYgKGlzSUUgfHwgaXNFZGdlKSB7XG4gICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICBhY3R1YWxseVNldFNlbGVjdGVkKGVsLCBiaW5kaW5nLCB2bSk7XG4gICAgfSwgMCk7XG4gIH1cbn1cblxuZnVuY3Rpb24gYWN0dWFsbHlTZXRTZWxlY3RlZCAoZWwsIGJpbmRpbmcsIHZtKSB7XG4gIHZhciB2YWx1ZSA9IGJpbmRpbmcudmFsdWU7XG4gIHZhciBpc011bHRpcGxlID0gZWwubXVsdGlwbGU7XG4gIGlmIChpc011bHRpcGxlICYmICFBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgd2FybihcbiAgICAgIFwiPHNlbGVjdCBtdWx0aXBsZSB2LW1vZGVsPVxcXCJcIiArIChiaW5kaW5nLmV4cHJlc3Npb24pICsgXCJcXFwiPiBcIiArXG4gICAgICBcImV4cGVjdHMgYW4gQXJyYXkgdmFsdWUgZm9yIGl0cyBiaW5kaW5nLCBidXQgZ290IFwiICsgKE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh2YWx1ZSkuc2xpY2UoOCwgLTEpKSxcbiAgICAgIHZtXG4gICAgKTtcbiAgICByZXR1cm5cbiAgfVxuICB2YXIgc2VsZWN0ZWQsIG9wdGlvbjtcbiAgZm9yICh2YXIgaSA9IDAsIGwgPSBlbC5vcHRpb25zLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgIG9wdGlvbiA9IGVsLm9wdGlvbnNbaV07XG4gICAgaWYgKGlzTXVsdGlwbGUpIHtcbiAgICAgIHNlbGVjdGVkID0gbG9vc2VJbmRleE9mKHZhbHVlLCBnZXRWYWx1ZShvcHRpb24pKSA+IC0xO1xuICAgICAgaWYgKG9wdGlvbi5zZWxlY3RlZCAhPT0gc2VsZWN0ZWQpIHtcbiAgICAgICAgb3B0aW9uLnNlbGVjdGVkID0gc2VsZWN0ZWQ7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChsb29zZUVxdWFsKGdldFZhbHVlKG9wdGlvbiksIHZhbHVlKSkge1xuICAgICAgICBpZiAoZWwuc2VsZWN0ZWRJbmRleCAhPT0gaSkge1xuICAgICAgICAgIGVsLnNlbGVjdGVkSW5kZXggPSBpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVyblxuICAgICAgfVxuICAgIH1cbiAgfVxuICBpZiAoIWlzTXVsdGlwbGUpIHtcbiAgICBlbC5zZWxlY3RlZEluZGV4ID0gLTE7XG4gIH1cbn1cblxuZnVuY3Rpb24gaGFzTm9NYXRjaGluZ09wdGlvbiAodmFsdWUsIG9wdGlvbnMpIHtcbiAgcmV0dXJuIG9wdGlvbnMuZXZlcnkoZnVuY3Rpb24gKG8pIHsgcmV0dXJuICFsb29zZUVxdWFsKG8sIHZhbHVlKTsgfSlcbn1cblxuZnVuY3Rpb24gZ2V0VmFsdWUgKG9wdGlvbikge1xuICByZXR1cm4gJ192YWx1ZScgaW4gb3B0aW9uXG4gICAgPyBvcHRpb24uX3ZhbHVlXG4gICAgOiBvcHRpb24udmFsdWVcbn1cblxuZnVuY3Rpb24gb25Db21wb3NpdGlvblN0YXJ0IChlKSB7XG4gIGUudGFyZ2V0LmNvbXBvc2luZyA9IHRydWU7XG59XG5cbmZ1bmN0aW9uIG9uQ29tcG9zaXRpb25FbmQgKGUpIHtcbiAgLy8gcHJldmVudCB0cmlnZ2VyaW5nIGFuIGlucHV0IGV2ZW50IGZvciBubyByZWFzb25cbiAgaWYgKCFlLnRhcmdldC5jb21wb3NpbmcpIHsgcmV0dXJuIH1cbiAgZS50YXJnZXQuY29tcG9zaW5nID0gZmFsc2U7XG4gIHRyaWdnZXIoZS50YXJnZXQsICdpbnB1dCcpO1xufVxuXG5mdW5jdGlvbiB0cmlnZ2VyIChlbCwgdHlwZSkge1xuICB2YXIgZSA9IGRvY3VtZW50LmNyZWF0ZUV2ZW50KCdIVE1MRXZlbnRzJyk7XG4gIGUuaW5pdEV2ZW50KHR5cGUsIHRydWUsIHRydWUpO1xuICBlbC5kaXNwYXRjaEV2ZW50KGUpO1xufVxuXG4vKiAgKi9cblxuLy8gcmVjdXJzaXZlbHkgc2VhcmNoIGZvciBwb3NzaWJsZSB0cmFuc2l0aW9uIGRlZmluZWQgaW5zaWRlIHRoZSBjb21wb25lbnQgcm9vdFxuZnVuY3Rpb24gbG9jYXRlTm9kZSAodm5vZGUpIHtcbiAgcmV0dXJuIHZub2RlLmNvbXBvbmVudEluc3RhbmNlICYmICghdm5vZGUuZGF0YSB8fCAhdm5vZGUuZGF0YS50cmFuc2l0aW9uKVxuICAgID8gbG9jYXRlTm9kZSh2bm9kZS5jb21wb25lbnRJbnN0YW5jZS5fdm5vZGUpXG4gICAgOiB2bm9kZVxufVxuXG52YXIgc2hvdyA9IHtcbiAgYmluZDogZnVuY3Rpb24gYmluZCAoZWwsIHJlZiwgdm5vZGUpIHtcbiAgICB2YXIgdmFsdWUgPSByZWYudmFsdWU7XG5cbiAgICB2bm9kZSA9IGxvY2F0ZU5vZGUodm5vZGUpO1xuICAgIHZhciB0cmFuc2l0aW9uJCQxID0gdm5vZGUuZGF0YSAmJiB2bm9kZS5kYXRhLnRyYW5zaXRpb247XG4gICAgdmFyIG9yaWdpbmFsRGlzcGxheSA9IGVsLl9fdk9yaWdpbmFsRGlzcGxheSA9XG4gICAgICBlbC5zdHlsZS5kaXNwbGF5ID09PSAnbm9uZScgPyAnJyA6IGVsLnN0eWxlLmRpc3BsYXk7XG4gICAgaWYgKHZhbHVlICYmIHRyYW5zaXRpb24kJDEpIHtcbiAgICAgIHZub2RlLmRhdGEuc2hvdyA9IHRydWU7XG4gICAgICBlbnRlcih2bm9kZSwgZnVuY3Rpb24gKCkge1xuICAgICAgICBlbC5zdHlsZS5kaXNwbGF5ID0gb3JpZ2luYWxEaXNwbGF5O1xuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGVsLnN0eWxlLmRpc3BsYXkgPSB2YWx1ZSA/IG9yaWdpbmFsRGlzcGxheSA6ICdub25lJztcbiAgICB9XG4gIH0sXG5cbiAgdXBkYXRlOiBmdW5jdGlvbiB1cGRhdGUgKGVsLCByZWYsIHZub2RlKSB7XG4gICAgdmFyIHZhbHVlID0gcmVmLnZhbHVlO1xuICAgIHZhciBvbGRWYWx1ZSA9IHJlZi5vbGRWYWx1ZTtcblxuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgIGlmICh2YWx1ZSA9PT0gb2xkVmFsdWUpIHsgcmV0dXJuIH1cbiAgICB2bm9kZSA9IGxvY2F0ZU5vZGUodm5vZGUpO1xuICAgIHZhciB0cmFuc2l0aW9uJCQxID0gdm5vZGUuZGF0YSAmJiB2bm9kZS5kYXRhLnRyYW5zaXRpb247XG4gICAgaWYgKHRyYW5zaXRpb24kJDEpIHtcbiAgICAgIHZub2RlLmRhdGEuc2hvdyA9IHRydWU7XG4gICAgICBpZiAodmFsdWUpIHtcbiAgICAgICAgZW50ZXIodm5vZGUsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBlbC5zdHlsZS5kaXNwbGF5ID0gZWwuX192T3JpZ2luYWxEaXNwbGF5O1xuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGxlYXZlKHZub2RlLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgZWwuc3R5bGUuZGlzcGxheSA9ICdub25lJztcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGVsLnN0eWxlLmRpc3BsYXkgPSB2YWx1ZSA/IGVsLl9fdk9yaWdpbmFsRGlzcGxheSA6ICdub25lJztcbiAgICB9XG4gIH0sXG5cbiAgdW5iaW5kOiBmdW5jdGlvbiB1bmJpbmQgKFxuICAgIGVsLFxuICAgIGJpbmRpbmcsXG4gICAgdm5vZGUsXG4gICAgb2xkVm5vZGUsXG4gICAgaXNEZXN0cm95XG4gICkge1xuICAgIGlmICghaXNEZXN0cm95KSB7XG4gICAgICBlbC5zdHlsZS5kaXNwbGF5ID0gZWwuX192T3JpZ2luYWxEaXNwbGF5O1xuICAgIH1cbiAgfVxufTtcblxudmFyIHBsYXRmb3JtRGlyZWN0aXZlcyA9IHtcbiAgbW9kZWw6IGRpcmVjdGl2ZSxcbiAgc2hvdzogc2hvd1xufTtcblxuLyogICovXG5cbi8vIFByb3ZpZGVzIHRyYW5zaXRpb24gc3VwcG9ydCBmb3IgYSBzaW5nbGUgZWxlbWVudC9jb21wb25lbnQuXG4vLyBzdXBwb3J0cyB0cmFuc2l0aW9uIG1vZGUgKG91dC1pbiAvIGluLW91dClcblxudmFyIHRyYW5zaXRpb25Qcm9wcyA9IHtcbiAgbmFtZTogU3RyaW5nLFxuICBhcHBlYXI6IEJvb2xlYW4sXG4gIGNzczogQm9vbGVhbixcbiAgbW9kZTogU3RyaW5nLFxuICB0eXBlOiBTdHJpbmcsXG4gIGVudGVyQ2xhc3M6IFN0cmluZyxcbiAgbGVhdmVDbGFzczogU3RyaW5nLFxuICBlbnRlclRvQ2xhc3M6IFN0cmluZyxcbiAgbGVhdmVUb0NsYXNzOiBTdHJpbmcsXG4gIGVudGVyQWN0aXZlQ2xhc3M6IFN0cmluZyxcbiAgbGVhdmVBY3RpdmVDbGFzczogU3RyaW5nLFxuICBhcHBlYXJDbGFzczogU3RyaW5nLFxuICBhcHBlYXJBY3RpdmVDbGFzczogU3RyaW5nLFxuICBhcHBlYXJUb0NsYXNzOiBTdHJpbmcsXG4gIGR1cmF0aW9uOiBbTnVtYmVyLCBTdHJpbmcsIE9iamVjdF1cbn07XG5cbi8vIGluIGNhc2UgdGhlIGNoaWxkIGlzIGFsc28gYW4gYWJzdHJhY3QgY29tcG9uZW50LCBlLmcuIDxrZWVwLWFsaXZlPlxuLy8gd2Ugd2FudCB0byByZWN1cnNpdmVseSByZXRyaWV2ZSB0aGUgcmVhbCBjb21wb25lbnQgdG8gYmUgcmVuZGVyZWRcbmZ1bmN0aW9uIGdldFJlYWxDaGlsZCAodm5vZGUpIHtcbiAgdmFyIGNvbXBPcHRpb25zID0gdm5vZGUgJiYgdm5vZGUuY29tcG9uZW50T3B0aW9ucztcbiAgaWYgKGNvbXBPcHRpb25zICYmIGNvbXBPcHRpb25zLkN0b3Iub3B0aW9ucy5hYnN0cmFjdCkge1xuICAgIHJldHVybiBnZXRSZWFsQ2hpbGQoZ2V0Rmlyc3RDb21wb25lbnRDaGlsZChjb21wT3B0aW9ucy5jaGlsZHJlbikpXG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIHZub2RlXG4gIH1cbn1cblxuZnVuY3Rpb24gZXh0cmFjdFRyYW5zaXRpb25EYXRhIChjb21wKSB7XG4gIHZhciBkYXRhID0ge307XG4gIHZhciBvcHRpb25zID0gY29tcC4kb3B0aW9ucztcbiAgLy8gcHJvcHNcbiAgZm9yICh2YXIga2V5IGluIG9wdGlvbnMucHJvcHNEYXRhKSB7XG4gICAgZGF0YVtrZXldID0gY29tcFtrZXldO1xuICB9XG4gIC8vIGV2ZW50cy5cbiAgLy8gZXh0cmFjdCBsaXN0ZW5lcnMgYW5kIHBhc3MgdGhlbSBkaXJlY3RseSB0byB0aGUgdHJhbnNpdGlvbiBtZXRob2RzXG4gIHZhciBsaXN0ZW5lcnMgPSBvcHRpb25zLl9wYXJlbnRMaXN0ZW5lcnM7XG4gIGZvciAodmFyIGtleSQxIGluIGxpc3RlbmVycykge1xuICAgIGRhdGFbY2FtZWxpemUoa2V5JDEpXSA9IGxpc3RlbmVyc1trZXkkMV07XG4gIH1cbiAgcmV0dXJuIGRhdGFcbn1cblxuZnVuY3Rpb24gcGxhY2Vob2xkZXIgKGgsIHJhd0NoaWxkKSB7XG4gIGlmICgvXFxkLWtlZXAtYWxpdmUkLy50ZXN0KHJhd0NoaWxkLnRhZykpIHtcbiAgICByZXR1cm4gaCgna2VlcC1hbGl2ZScsIHtcbiAgICAgIHByb3BzOiByYXdDaGlsZC5jb21wb25lbnRPcHRpb25zLnByb3BzRGF0YVxuICAgIH0pXG4gIH1cbn1cblxuZnVuY3Rpb24gaGFzUGFyZW50VHJhbnNpdGlvbiAodm5vZGUpIHtcbiAgd2hpbGUgKCh2bm9kZSA9IHZub2RlLnBhcmVudCkpIHtcbiAgICBpZiAodm5vZGUuZGF0YS50cmFuc2l0aW9uKSB7XG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBpc1NhbWVDaGlsZCAoY2hpbGQsIG9sZENoaWxkKSB7XG4gIHJldHVybiBvbGRDaGlsZC5rZXkgPT09IGNoaWxkLmtleSAmJiBvbGRDaGlsZC50YWcgPT09IGNoaWxkLnRhZ1xufVxuXG52YXIgVHJhbnNpdGlvbiA9IHtcbiAgbmFtZTogJ3RyYW5zaXRpb24nLFxuICBwcm9wczogdHJhbnNpdGlvblByb3BzLFxuICBhYnN0cmFjdDogdHJ1ZSxcblxuICByZW5kZXI6IGZ1bmN0aW9uIHJlbmRlciAoaCkge1xuICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gICAgdmFyIGNoaWxkcmVuID0gdGhpcy4kc2xvdHMuZGVmYXVsdDtcbiAgICBpZiAoIWNoaWxkcmVuKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICAvLyBmaWx0ZXIgb3V0IHRleHQgbm9kZXMgKHBvc3NpYmxlIHdoaXRlc3BhY2VzKVxuICAgIGNoaWxkcmVuID0gY2hpbGRyZW4uZmlsdGVyKGZ1bmN0aW9uIChjKSB7IHJldHVybiBjLnRhZyB8fCBpc0FzeW5jUGxhY2Vob2xkZXIoYyk7IH0pO1xuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgIGlmICghY2hpbGRyZW4ubGVuZ3RoKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICAvLyB3YXJuIG11bHRpcGxlIGVsZW1lbnRzXG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgY2hpbGRyZW4ubGVuZ3RoID4gMSkge1xuICAgICAgd2FybihcbiAgICAgICAgJzx0cmFuc2l0aW9uPiBjYW4gb25seSBiZSB1c2VkIG9uIGEgc2luZ2xlIGVsZW1lbnQuIFVzZSAnICtcbiAgICAgICAgJzx0cmFuc2l0aW9uLWdyb3VwPiBmb3IgbGlzdHMuJyxcbiAgICAgICAgdGhpcy4kcGFyZW50XG4gICAgICApO1xuICAgIH1cblxuICAgIHZhciBtb2RlID0gdGhpcy5tb2RlO1xuXG4gICAgLy8gd2FybiBpbnZhbGlkIG1vZGVcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJlxuICAgICAgbW9kZSAmJiBtb2RlICE9PSAnaW4tb3V0JyAmJiBtb2RlICE9PSAnb3V0LWluJ1xuICAgICkge1xuICAgICAgd2FybihcbiAgICAgICAgJ2ludmFsaWQgPHRyYW5zaXRpb24+IG1vZGU6ICcgKyBtb2RlLFxuICAgICAgICB0aGlzLiRwYXJlbnRcbiAgICAgICk7XG4gICAgfVxuXG4gICAgdmFyIHJhd0NoaWxkID0gY2hpbGRyZW5bMF07XG5cbiAgICAvLyBpZiB0aGlzIGlzIGEgY29tcG9uZW50IHJvb3Qgbm9kZSBhbmQgdGhlIGNvbXBvbmVudCdzXG4gICAgLy8gcGFyZW50IGNvbnRhaW5lciBub2RlIGFsc28gaGFzIHRyYW5zaXRpb24sIHNraXAuXG4gICAgaWYgKGhhc1BhcmVudFRyYW5zaXRpb24odGhpcy4kdm5vZGUpKSB7XG4gICAgICByZXR1cm4gcmF3Q2hpbGRcbiAgICB9XG5cbiAgICAvLyBhcHBseSB0cmFuc2l0aW9uIGRhdGEgdG8gY2hpbGRcbiAgICAvLyB1c2UgZ2V0UmVhbENoaWxkKCkgdG8gaWdub3JlIGFic3RyYWN0IGNvbXBvbmVudHMgZS5nLiBrZWVwLWFsaXZlXG4gICAgdmFyIGNoaWxkID0gZ2V0UmVhbENoaWxkKHJhd0NoaWxkKTtcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICBpZiAoIWNoaWxkKSB7XG4gICAgICByZXR1cm4gcmF3Q2hpbGRcbiAgICB9XG5cbiAgICBpZiAodGhpcy5fbGVhdmluZykge1xuICAgICAgcmV0dXJuIHBsYWNlaG9sZGVyKGgsIHJhd0NoaWxkKVxuICAgIH1cblxuICAgIC8vIGVuc3VyZSBhIGtleSB0aGF0IGlzIHVuaXF1ZSB0byB0aGUgdm5vZGUgdHlwZSBhbmQgdG8gdGhpcyB0cmFuc2l0aW9uXG4gICAgLy8gY29tcG9uZW50IGluc3RhbmNlLiBUaGlzIGtleSB3aWxsIGJlIHVzZWQgdG8gcmVtb3ZlIHBlbmRpbmcgbGVhdmluZyBub2Rlc1xuICAgIC8vIGR1cmluZyBlbnRlcmluZy5cbiAgICB2YXIgaWQgPSBcIl9fdHJhbnNpdGlvbi1cIiArICh0aGlzLl91aWQpICsgXCItXCI7XG4gICAgY2hpbGQua2V5ID0gY2hpbGQua2V5ID09IG51bGxcbiAgICAgID8gY2hpbGQuaXNDb21tZW50XG4gICAgICAgID8gaWQgKyAnY29tbWVudCdcbiAgICAgICAgOiBpZCArIGNoaWxkLnRhZ1xuICAgICAgOiBpc1ByaW1pdGl2ZShjaGlsZC5rZXkpXG4gICAgICAgID8gKFN0cmluZyhjaGlsZC5rZXkpLmluZGV4T2YoaWQpID09PSAwID8gY2hpbGQua2V5IDogaWQgKyBjaGlsZC5rZXkpXG4gICAgICAgIDogY2hpbGQua2V5O1xuXG4gICAgdmFyIGRhdGEgPSAoY2hpbGQuZGF0YSB8fCAoY2hpbGQuZGF0YSA9IHt9KSkudHJhbnNpdGlvbiA9IGV4dHJhY3RUcmFuc2l0aW9uRGF0YSh0aGlzKTtcbiAgICB2YXIgb2xkUmF3Q2hpbGQgPSB0aGlzLl92bm9kZTtcbiAgICB2YXIgb2xkQ2hpbGQgPSBnZXRSZWFsQ2hpbGQob2xkUmF3Q2hpbGQpO1xuXG4gICAgLy8gbWFyayB2LXNob3dcbiAgICAvLyBzbyB0aGF0IHRoZSB0cmFuc2l0aW9uIG1vZHVsZSBjYW4gaGFuZCBvdmVyIHRoZSBjb250cm9sIHRvIHRoZSBkaXJlY3RpdmVcbiAgICBpZiAoY2hpbGQuZGF0YS5kaXJlY3RpdmVzICYmIGNoaWxkLmRhdGEuZGlyZWN0aXZlcy5zb21lKGZ1bmN0aW9uIChkKSB7IHJldHVybiBkLm5hbWUgPT09ICdzaG93JzsgfSkpIHtcbiAgICAgIGNoaWxkLmRhdGEuc2hvdyA9IHRydWU7XG4gICAgfVxuXG4gICAgaWYgKFxuICAgICAgb2xkQ2hpbGQgJiZcbiAgICAgIG9sZENoaWxkLmRhdGEgJiZcbiAgICAgICFpc1NhbWVDaGlsZChjaGlsZCwgb2xkQ2hpbGQpICYmXG4gICAgICAhaXNBc3luY1BsYWNlaG9sZGVyKG9sZENoaWxkKSAmJlxuICAgICAgLy8gIzY2ODcgY29tcG9uZW50IHJvb3QgaXMgYSBjb21tZW50IG5vZGVcbiAgICAgICEob2xkQ2hpbGQuY29tcG9uZW50SW5zdGFuY2UgJiYgb2xkQ2hpbGQuY29tcG9uZW50SW5zdGFuY2UuX3Zub2RlLmlzQ29tbWVudClcbiAgICApIHtcbiAgICAgIC8vIHJlcGxhY2Ugb2xkIGNoaWxkIHRyYW5zaXRpb24gZGF0YSB3aXRoIGZyZXNoIG9uZVxuICAgICAgLy8gaW1wb3J0YW50IGZvciBkeW5hbWljIHRyYW5zaXRpb25zIVxuICAgICAgdmFyIG9sZERhdGEgPSBvbGRDaGlsZC5kYXRhLnRyYW5zaXRpb24gPSBleHRlbmQoe30sIGRhdGEpO1xuICAgICAgLy8gaGFuZGxlIHRyYW5zaXRpb24gbW9kZVxuICAgICAgaWYgKG1vZGUgPT09ICdvdXQtaW4nKSB7XG4gICAgICAgIC8vIHJldHVybiBwbGFjZWhvbGRlciBub2RlIGFuZCBxdWV1ZSB1cGRhdGUgd2hlbiBsZWF2ZSBmaW5pc2hlc1xuICAgICAgICB0aGlzLl9sZWF2aW5nID0gdHJ1ZTtcbiAgICAgICAgbWVyZ2VWTm9kZUhvb2sob2xkRGF0YSwgJ2FmdGVyTGVhdmUnLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgdGhpcyQxLl9sZWF2aW5nID0gZmFsc2U7XG4gICAgICAgICAgdGhpcyQxLiRmb3JjZVVwZGF0ZSgpO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHBsYWNlaG9sZGVyKGgsIHJhd0NoaWxkKVxuICAgICAgfSBlbHNlIGlmIChtb2RlID09PSAnaW4tb3V0Jykge1xuICAgICAgICBpZiAoaXNBc3luY1BsYWNlaG9sZGVyKGNoaWxkKSkge1xuICAgICAgICAgIHJldHVybiBvbGRSYXdDaGlsZFxuICAgICAgICB9XG4gICAgICAgIHZhciBkZWxheWVkTGVhdmU7XG4gICAgICAgIHZhciBwZXJmb3JtTGVhdmUgPSBmdW5jdGlvbiAoKSB7IGRlbGF5ZWRMZWF2ZSgpOyB9O1xuICAgICAgICBtZXJnZVZOb2RlSG9vayhkYXRhLCAnYWZ0ZXJFbnRlcicsIHBlcmZvcm1MZWF2ZSk7XG4gICAgICAgIG1lcmdlVk5vZGVIb29rKGRhdGEsICdlbnRlckNhbmNlbGxlZCcsIHBlcmZvcm1MZWF2ZSk7XG4gICAgICAgIG1lcmdlVk5vZGVIb29rKG9sZERhdGEsICdkZWxheUxlYXZlJywgZnVuY3Rpb24gKGxlYXZlKSB7IGRlbGF5ZWRMZWF2ZSA9IGxlYXZlOyB9KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gcmF3Q2hpbGRcbiAgfVxufTtcblxuLyogICovXG5cbi8vIFByb3ZpZGVzIHRyYW5zaXRpb24gc3VwcG9ydCBmb3IgbGlzdCBpdGVtcy5cbi8vIHN1cHBvcnRzIG1vdmUgdHJhbnNpdGlvbnMgdXNpbmcgdGhlIEZMSVAgdGVjaG5pcXVlLlxuXG4vLyBCZWNhdXNlIHRoZSB2ZG9tJ3MgY2hpbGRyZW4gdXBkYXRlIGFsZ29yaXRobSBpcyBcInVuc3RhYmxlXCIgLSBpLmUuXG4vLyBpdCBkb2Vzbid0IGd1YXJhbnRlZSB0aGUgcmVsYXRpdmUgcG9zaXRpb25pbmcgb2YgcmVtb3ZlZCBlbGVtZW50cyxcbi8vIHdlIGZvcmNlIHRyYW5zaXRpb24tZ3JvdXAgdG8gdXBkYXRlIGl0cyBjaGlsZHJlbiBpbnRvIHR3byBwYXNzZXM6XG4vLyBpbiB0aGUgZmlyc3QgcGFzcywgd2UgcmVtb3ZlIGFsbCBub2RlcyB0aGF0IG5lZWQgdG8gYmUgcmVtb3ZlZCxcbi8vIHRyaWdnZXJpbmcgdGhlaXIgbGVhdmluZyB0cmFuc2l0aW9uOyBpbiB0aGUgc2Vjb25kIHBhc3MsIHdlIGluc2VydC9tb3ZlXG4vLyBpbnRvIHRoZSBmaW5hbCBkZXNpcmVkIHN0YXRlLiBUaGlzIHdheSBpbiB0aGUgc2Vjb25kIHBhc3MgcmVtb3ZlZFxuLy8gbm9kZXMgd2lsbCByZW1haW4gd2hlcmUgdGhleSBzaG91bGQgYmUuXG5cbnZhciBwcm9wcyA9IGV4dGVuZCh7XG4gIHRhZzogU3RyaW5nLFxuICBtb3ZlQ2xhc3M6IFN0cmluZ1xufSwgdHJhbnNpdGlvblByb3BzKTtcblxuZGVsZXRlIHByb3BzLm1vZGU7XG5cbnZhciBUcmFuc2l0aW9uR3JvdXAgPSB7XG4gIHByb3BzOiBwcm9wcyxcblxuICByZW5kZXI6IGZ1bmN0aW9uIHJlbmRlciAoaCkge1xuICAgIHZhciB0YWcgPSB0aGlzLnRhZyB8fCB0aGlzLiR2bm9kZS5kYXRhLnRhZyB8fCAnc3Bhbic7XG4gICAgdmFyIG1hcCA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgdmFyIHByZXZDaGlsZHJlbiA9IHRoaXMucHJldkNoaWxkcmVuID0gdGhpcy5jaGlsZHJlbjtcbiAgICB2YXIgcmF3Q2hpbGRyZW4gPSB0aGlzLiRzbG90cy5kZWZhdWx0IHx8IFtdO1xuICAgIHZhciBjaGlsZHJlbiA9IHRoaXMuY2hpbGRyZW4gPSBbXTtcbiAgICB2YXIgdHJhbnNpdGlvbkRhdGEgPSBleHRyYWN0VHJhbnNpdGlvbkRhdGEodGhpcyk7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHJhd0NoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgYyA9IHJhd0NoaWxkcmVuW2ldO1xuICAgICAgaWYgKGMudGFnKSB7XG4gICAgICAgIGlmIChjLmtleSAhPSBudWxsICYmIFN0cmluZyhjLmtleSkuaW5kZXhPZignX192bGlzdCcpICE9PSAwKSB7XG4gICAgICAgICAgY2hpbGRyZW4ucHVzaChjKTtcbiAgICAgICAgICBtYXBbYy5rZXldID0gY1xuICAgICAgICAgIDsoYy5kYXRhIHx8IChjLmRhdGEgPSB7fSkpLnRyYW5zaXRpb24gPSB0cmFuc2l0aW9uRGF0YTtcbiAgICAgICAgfSBlbHNlIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgICAgdmFyIG9wdHMgPSBjLmNvbXBvbmVudE9wdGlvbnM7XG4gICAgICAgICAgdmFyIG5hbWUgPSBvcHRzID8gKG9wdHMuQ3Rvci5vcHRpb25zLm5hbWUgfHwgb3B0cy50YWcgfHwgJycpIDogYy50YWc7XG4gICAgICAgICAgd2FybigoXCI8dHJhbnNpdGlvbi1ncm91cD4gY2hpbGRyZW4gbXVzdCBiZSBrZXllZDogPFwiICsgbmFtZSArIFwiPlwiKSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAocHJldkNoaWxkcmVuKSB7XG4gICAgICB2YXIga2VwdCA9IFtdO1xuICAgICAgdmFyIHJlbW92ZWQgPSBbXTtcbiAgICAgIGZvciAodmFyIGkkMSA9IDA7IGkkMSA8IHByZXZDaGlsZHJlbi5sZW5ndGg7IGkkMSsrKSB7XG4gICAgICAgIHZhciBjJDEgPSBwcmV2Q2hpbGRyZW5baSQxXTtcbiAgICAgICAgYyQxLmRhdGEudHJhbnNpdGlvbiA9IHRyYW5zaXRpb25EYXRhO1xuICAgICAgICBjJDEuZGF0YS5wb3MgPSBjJDEuZWxtLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgICBpZiAobWFwW2MkMS5rZXldKSB7XG4gICAgICAgICAga2VwdC5wdXNoKGMkMSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmVtb3ZlZC5wdXNoKGMkMSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHRoaXMua2VwdCA9IGgodGFnLCBudWxsLCBrZXB0KTtcbiAgICAgIHRoaXMucmVtb3ZlZCA9IHJlbW92ZWQ7XG4gICAgfVxuXG4gICAgcmV0dXJuIGgodGFnLCBudWxsLCBjaGlsZHJlbilcbiAgfSxcblxuICBiZWZvcmVVcGRhdGU6IGZ1bmN0aW9uIGJlZm9yZVVwZGF0ZSAoKSB7XG4gICAgLy8gZm9yY2UgcmVtb3ZpbmcgcGFzc1xuICAgIHRoaXMuX19wYXRjaF9fKFxuICAgICAgdGhpcy5fdm5vZGUsXG4gICAgICB0aGlzLmtlcHQsXG4gICAgICBmYWxzZSwgLy8gaHlkcmF0aW5nXG4gICAgICB0cnVlIC8vIHJlbW92ZU9ubHkgKCFpbXBvcnRhbnQgYXZvaWRzIHVubmVjZXNzYXJ5IG1vdmVzKVxuICAgICk7XG4gICAgdGhpcy5fdm5vZGUgPSB0aGlzLmtlcHQ7XG4gIH0sXG5cbiAgdXBkYXRlZDogZnVuY3Rpb24gdXBkYXRlZCAoKSB7XG4gICAgdmFyIGNoaWxkcmVuID0gdGhpcy5wcmV2Q2hpbGRyZW47XG4gICAgdmFyIG1vdmVDbGFzcyA9IHRoaXMubW92ZUNsYXNzIHx8ICgodGhpcy5uYW1lIHx8ICd2JykgKyAnLW1vdmUnKTtcbiAgICBpZiAoIWNoaWxkcmVuLmxlbmd0aCB8fCAhdGhpcy5oYXNNb3ZlKGNoaWxkcmVuWzBdLmVsbSwgbW92ZUNsYXNzKSkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgLy8gd2UgZGl2aWRlIHRoZSB3b3JrIGludG8gdGhyZWUgbG9vcHMgdG8gYXZvaWQgbWl4aW5nIERPTSByZWFkcyBhbmQgd3JpdGVzXG4gICAgLy8gaW4gZWFjaCBpdGVyYXRpb24gLSB3aGljaCBoZWxwcyBwcmV2ZW50IGxheW91dCB0aHJhc2hpbmcuXG4gICAgY2hpbGRyZW4uZm9yRWFjaChjYWxsUGVuZGluZ0Nicyk7XG4gICAgY2hpbGRyZW4uZm9yRWFjaChyZWNvcmRQb3NpdGlvbik7XG4gICAgY2hpbGRyZW4uZm9yRWFjaChhcHBseVRyYW5zbGF0aW9uKTtcblxuICAgIC8vIGZvcmNlIHJlZmxvdyB0byBwdXQgZXZlcnl0aGluZyBpbiBwb3NpdGlvblxuICAgIC8vIGFzc2lnbiB0byB0aGlzIHRvIGF2b2lkIGJlaW5nIHJlbW92ZWQgaW4gdHJlZS1zaGFraW5nXG4gICAgLy8gJGZsb3ctZGlzYWJsZS1saW5lXG4gICAgdGhpcy5fcmVmbG93ID0gZG9jdW1lbnQuYm9keS5vZmZzZXRIZWlnaHQ7XG5cbiAgICBjaGlsZHJlbi5mb3JFYWNoKGZ1bmN0aW9uIChjKSB7XG4gICAgICBpZiAoYy5kYXRhLm1vdmVkKSB7XG4gICAgICAgIHZhciBlbCA9IGMuZWxtO1xuICAgICAgICB2YXIgcyA9IGVsLnN0eWxlO1xuICAgICAgICBhZGRUcmFuc2l0aW9uQ2xhc3MoZWwsIG1vdmVDbGFzcyk7XG4gICAgICAgIHMudHJhbnNmb3JtID0gcy5XZWJraXRUcmFuc2Zvcm0gPSBzLnRyYW5zaXRpb25EdXJhdGlvbiA9ICcnO1xuICAgICAgICBlbC5hZGRFdmVudExpc3RlbmVyKHRyYW5zaXRpb25FbmRFdmVudCwgZWwuX21vdmVDYiA9IGZ1bmN0aW9uIGNiIChlKSB7XG4gICAgICAgICAgaWYgKCFlIHx8IC90cmFuc2Zvcm0kLy50ZXN0KGUucHJvcGVydHlOYW1lKSkge1xuICAgICAgICAgICAgZWwucmVtb3ZlRXZlbnRMaXN0ZW5lcih0cmFuc2l0aW9uRW5kRXZlbnQsIGNiKTtcbiAgICAgICAgICAgIGVsLl9tb3ZlQ2IgPSBudWxsO1xuICAgICAgICAgICAgcmVtb3ZlVHJhbnNpdGlvbkNsYXNzKGVsLCBtb3ZlQ2xhc3MpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSk7XG4gIH0sXG5cbiAgbWV0aG9kczoge1xuICAgIGhhc01vdmU6IGZ1bmN0aW9uIGhhc01vdmUgKGVsLCBtb3ZlQ2xhc3MpIHtcbiAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgICAgaWYgKCFoYXNUcmFuc2l0aW9uKSB7XG4gICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgfVxuICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgICBpZiAodGhpcy5faGFzTW92ZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5faGFzTW92ZVxuICAgICAgfVxuICAgICAgLy8gRGV0ZWN0IHdoZXRoZXIgYW4gZWxlbWVudCB3aXRoIHRoZSBtb3ZlIGNsYXNzIGFwcGxpZWQgaGFzXG4gICAgICAvLyBDU1MgdHJhbnNpdGlvbnMuIFNpbmNlIHRoZSBlbGVtZW50IG1heSBiZSBpbnNpZGUgYW4gZW50ZXJpbmdcbiAgICAgIC8vIHRyYW5zaXRpb24gYXQgdGhpcyB2ZXJ5IG1vbWVudCwgd2UgbWFrZSBhIGNsb25lIG9mIGl0IGFuZCByZW1vdmVcbiAgICAgIC8vIGFsbCBvdGhlciB0cmFuc2l0aW9uIGNsYXNzZXMgYXBwbGllZCB0byBlbnN1cmUgb25seSB0aGUgbW92ZSBjbGFzc1xuICAgICAgLy8gaXMgYXBwbGllZC5cbiAgICAgIHZhciBjbG9uZSA9IGVsLmNsb25lTm9kZSgpO1xuICAgICAgaWYgKGVsLl90cmFuc2l0aW9uQ2xhc3Nlcykge1xuICAgICAgICBlbC5fdHJhbnNpdGlvbkNsYXNzZXMuZm9yRWFjaChmdW5jdGlvbiAoY2xzKSB7IHJlbW92ZUNsYXNzKGNsb25lLCBjbHMpOyB9KTtcbiAgICAgIH1cbiAgICAgIGFkZENsYXNzKGNsb25lLCBtb3ZlQ2xhc3MpO1xuICAgICAgY2xvbmUuc3R5bGUuZGlzcGxheSA9ICdub25lJztcbiAgICAgIHRoaXMuJGVsLmFwcGVuZENoaWxkKGNsb25lKTtcbiAgICAgIHZhciBpbmZvID0gZ2V0VHJhbnNpdGlvbkluZm8oY2xvbmUpO1xuICAgICAgdGhpcy4kZWwucmVtb3ZlQ2hpbGQoY2xvbmUpO1xuICAgICAgcmV0dXJuICh0aGlzLl9oYXNNb3ZlID0gaW5mby5oYXNUcmFuc2Zvcm0pXG4gICAgfVxuICB9XG59O1xuXG5mdW5jdGlvbiBjYWxsUGVuZGluZ0NicyAoYykge1xuICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgaWYgKGMuZWxtLl9tb3ZlQ2IpIHtcbiAgICBjLmVsbS5fbW92ZUNiKCk7XG4gIH1cbiAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gIGlmIChjLmVsbS5fZW50ZXJDYikge1xuICAgIGMuZWxtLl9lbnRlckNiKCk7XG4gIH1cbn1cblxuZnVuY3Rpb24gcmVjb3JkUG9zaXRpb24gKGMpIHtcbiAgYy5kYXRhLm5ld1BvcyA9IGMuZWxtLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xufVxuXG5mdW5jdGlvbiBhcHBseVRyYW5zbGF0aW9uIChjKSB7XG4gIHZhciBvbGRQb3MgPSBjLmRhdGEucG9zO1xuICB2YXIgbmV3UG9zID0gYy5kYXRhLm5ld1BvcztcbiAgdmFyIGR4ID0gb2xkUG9zLmxlZnQgLSBuZXdQb3MubGVmdDtcbiAgdmFyIGR5ID0gb2xkUG9zLnRvcCAtIG5ld1Bvcy50b3A7XG4gIGlmIChkeCB8fCBkeSkge1xuICAgIGMuZGF0YS5tb3ZlZCA9IHRydWU7XG4gICAgdmFyIHMgPSBjLmVsbS5zdHlsZTtcbiAgICBzLnRyYW5zZm9ybSA9IHMuV2Via2l0VHJhbnNmb3JtID0gXCJ0cmFuc2xhdGUoXCIgKyBkeCArIFwicHgsXCIgKyBkeSArIFwicHgpXCI7XG4gICAgcy50cmFuc2l0aW9uRHVyYXRpb24gPSAnMHMnO1xuICB9XG59XG5cbnZhciBwbGF0Zm9ybUNvbXBvbmVudHMgPSB7XG4gIFRyYW5zaXRpb246IFRyYW5zaXRpb24sXG4gIFRyYW5zaXRpb25Hcm91cDogVHJhbnNpdGlvbkdyb3VwXG59O1xuXG4vKiAgKi9cblxuLy8gaW5zdGFsbCBwbGF0Zm9ybSBzcGVjaWZpYyB1dGlsc1xuVnVlJDMuY29uZmlnLm11c3RVc2VQcm9wID0gbXVzdFVzZVByb3A7XG5WdWUkMy5jb25maWcuaXNSZXNlcnZlZFRhZyA9IGlzUmVzZXJ2ZWRUYWc7XG5WdWUkMy5jb25maWcuaXNSZXNlcnZlZEF0dHIgPSBpc1Jlc2VydmVkQXR0cjtcblZ1ZSQzLmNvbmZpZy5nZXRUYWdOYW1lc3BhY2UgPSBnZXRUYWdOYW1lc3BhY2U7XG5WdWUkMy5jb25maWcuaXNVbmtub3duRWxlbWVudCA9IGlzVW5rbm93bkVsZW1lbnQ7XG5cbi8vIGluc3RhbGwgcGxhdGZvcm0gcnVudGltZSBkaXJlY3RpdmVzICYgY29tcG9uZW50c1xuZXh0ZW5kKFZ1ZSQzLm9wdGlvbnMuZGlyZWN0aXZlcywgcGxhdGZvcm1EaXJlY3RpdmVzKTtcbmV4dGVuZChWdWUkMy5vcHRpb25zLmNvbXBvbmVudHMsIHBsYXRmb3JtQ29tcG9uZW50cyk7XG5cbi8vIGluc3RhbGwgcGxhdGZvcm0gcGF0Y2ggZnVuY3Rpb25cblZ1ZSQzLnByb3RvdHlwZS5fX3BhdGNoX18gPSBpbkJyb3dzZXIgPyBwYXRjaCA6IG5vb3A7XG5cbi8vIHB1YmxpYyBtb3VudCBtZXRob2RcblZ1ZSQzLnByb3RvdHlwZS4kbW91bnQgPSBmdW5jdGlvbiAoXG4gIGVsLFxuICBoeWRyYXRpbmdcbikge1xuICBlbCA9IGVsICYmIGluQnJvd3NlciA/IHF1ZXJ5KGVsKSA6IHVuZGVmaW5lZDtcbiAgcmV0dXJuIG1vdW50Q29tcG9uZW50KHRoaXMsIGVsLCBoeWRyYXRpbmcpXG59O1xuXG4vLyBkZXZ0b29scyBnbG9iYWwgaG9va1xuLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cblZ1ZSQzLm5leHRUaWNrKGZ1bmN0aW9uICgpIHtcbiAgaWYgKGNvbmZpZy5kZXZ0b29scykge1xuICAgIGlmIChkZXZ0b29scykge1xuICAgICAgZGV2dG9vbHMuZW1pdCgnaW5pdCcsIFZ1ZSQzKTtcbiAgICB9IGVsc2UgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgaXNDaHJvbWUpIHtcbiAgICAgIGNvbnNvbGVbY29uc29sZS5pbmZvID8gJ2luZm8nIDogJ2xvZyddKFxuICAgICAgICAnRG93bmxvYWQgdGhlIFZ1ZSBEZXZ0b29scyBleHRlbnNpb24gZm9yIGEgYmV0dGVyIGRldmVsb3BtZW50IGV4cGVyaWVuY2U6XFxuJyArXG4gICAgICAgICdodHRwczovL2dpdGh1Yi5jb20vdnVlanMvdnVlLWRldnRvb2xzJ1xuICAgICAgKTtcbiAgICB9XG4gIH1cbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiZcbiAgICBjb25maWcucHJvZHVjdGlvblRpcCAhPT0gZmFsc2UgJiZcbiAgICBpbkJyb3dzZXIgJiYgdHlwZW9mIGNvbnNvbGUgIT09ICd1bmRlZmluZWQnXG4gICkge1xuICAgIGNvbnNvbGVbY29uc29sZS5pbmZvID8gJ2luZm8nIDogJ2xvZyddKFxuICAgICAgXCJZb3UgYXJlIHJ1bm5pbmcgVnVlIGluIGRldmVsb3BtZW50IG1vZGUuXFxuXCIgK1xuICAgICAgXCJNYWtlIHN1cmUgdG8gdHVybiBvbiBwcm9kdWN0aW9uIG1vZGUgd2hlbiBkZXBsb3lpbmcgZm9yIHByb2R1Y3Rpb24uXFxuXCIgK1xuICAgICAgXCJTZWUgbW9yZSB0aXBzIGF0IGh0dHBzOi8vdnVlanMub3JnL2d1aWRlL2RlcGxveW1lbnQuaHRtbFwiXG4gICAgKTtcbiAgfVxufSwgMCk7XG5cbi8qICAqL1xuXG52YXIgZGVmYXVsdFRhZ1JFID0gL1xce1xceygoPzoufFxcbikrPylcXH1cXH0vZztcbnZhciByZWdleEVzY2FwZVJFID0gL1stLiorP14ke30oKXxbXFxdXFwvXFxcXF0vZztcblxudmFyIGJ1aWxkUmVnZXggPSBjYWNoZWQoZnVuY3Rpb24gKGRlbGltaXRlcnMpIHtcbiAgdmFyIG9wZW4gPSBkZWxpbWl0ZXJzWzBdLnJlcGxhY2UocmVnZXhFc2NhcGVSRSwgJ1xcXFwkJicpO1xuICB2YXIgY2xvc2UgPSBkZWxpbWl0ZXJzWzFdLnJlcGxhY2UocmVnZXhFc2NhcGVSRSwgJ1xcXFwkJicpO1xuICByZXR1cm4gbmV3IFJlZ0V4cChvcGVuICsgJygoPzoufFxcXFxuKSs/KScgKyBjbG9zZSwgJ2cnKVxufSk7XG5cbmZ1bmN0aW9uIHBhcnNlVGV4dCAoXG4gIHRleHQsXG4gIGRlbGltaXRlcnNcbikge1xuICB2YXIgdGFnUkUgPSBkZWxpbWl0ZXJzID8gYnVpbGRSZWdleChkZWxpbWl0ZXJzKSA6IGRlZmF1bHRUYWdSRTtcbiAgaWYgKCF0YWdSRS50ZXN0KHRleHQpKSB7XG4gICAgcmV0dXJuXG4gIH1cbiAgdmFyIHRva2VucyA9IFtdO1xuICB2YXIgbGFzdEluZGV4ID0gdGFnUkUubGFzdEluZGV4ID0gMDtcbiAgdmFyIG1hdGNoLCBpbmRleDtcbiAgd2hpbGUgKChtYXRjaCA9IHRhZ1JFLmV4ZWModGV4dCkpKSB7XG4gICAgaW5kZXggPSBtYXRjaC5pbmRleDtcbiAgICAvLyBwdXNoIHRleHQgdG9rZW5cbiAgICBpZiAoaW5kZXggPiBsYXN0SW5kZXgpIHtcbiAgICAgIHRva2Vucy5wdXNoKEpTT04uc3RyaW5naWZ5KHRleHQuc2xpY2UobGFzdEluZGV4LCBpbmRleCkpKTtcbiAgICB9XG4gICAgLy8gdGFnIHRva2VuXG4gICAgdmFyIGV4cCA9IHBhcnNlRmlsdGVycyhtYXRjaFsxXS50cmltKCkpO1xuICAgIHRva2Vucy5wdXNoKChcIl9zKFwiICsgZXhwICsgXCIpXCIpKTtcbiAgICBsYXN0SW5kZXggPSBpbmRleCArIG1hdGNoWzBdLmxlbmd0aDtcbiAgfVxuICBpZiAobGFzdEluZGV4IDwgdGV4dC5sZW5ndGgpIHtcbiAgICB0b2tlbnMucHVzaChKU09OLnN0cmluZ2lmeSh0ZXh0LnNsaWNlKGxhc3RJbmRleCkpKTtcbiAgfVxuICByZXR1cm4gdG9rZW5zLmpvaW4oJysnKVxufVxuXG4vKiAgKi9cblxuZnVuY3Rpb24gdHJhbnNmb3JtTm9kZSAoZWwsIG9wdGlvbnMpIHtcbiAgdmFyIHdhcm4gPSBvcHRpb25zLndhcm4gfHwgYmFzZVdhcm47XG4gIHZhciBzdGF0aWNDbGFzcyA9IGdldEFuZFJlbW92ZUF0dHIoZWwsICdjbGFzcycpO1xuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiBzdGF0aWNDbGFzcykge1xuICAgIHZhciBleHByZXNzaW9uID0gcGFyc2VUZXh0KHN0YXRpY0NsYXNzLCBvcHRpb25zLmRlbGltaXRlcnMpO1xuICAgIGlmIChleHByZXNzaW9uKSB7XG4gICAgICB3YXJuKFxuICAgICAgICBcImNsYXNzPVxcXCJcIiArIHN0YXRpY0NsYXNzICsgXCJcXFwiOiBcIiArXG4gICAgICAgICdJbnRlcnBvbGF0aW9uIGluc2lkZSBhdHRyaWJ1dGVzIGhhcyBiZWVuIHJlbW92ZWQuICcgK1xuICAgICAgICAnVXNlIHYtYmluZCBvciB0aGUgY29sb24gc2hvcnRoYW5kIGluc3RlYWQuIEZvciBleGFtcGxlLCAnICtcbiAgICAgICAgJ2luc3RlYWQgb2YgPGRpdiBjbGFzcz1cInt7IHZhbCB9fVwiPiwgdXNlIDxkaXYgOmNsYXNzPVwidmFsXCI+LidcbiAgICAgICk7XG4gICAgfVxuICB9XG4gIGlmIChzdGF0aWNDbGFzcykge1xuICAgIGVsLnN0YXRpY0NsYXNzID0gSlNPTi5zdHJpbmdpZnkoc3RhdGljQ2xhc3MpO1xuICB9XG4gIHZhciBjbGFzc0JpbmRpbmcgPSBnZXRCaW5kaW5nQXR0cihlbCwgJ2NsYXNzJywgZmFsc2UgLyogZ2V0U3RhdGljICovKTtcbiAgaWYgKGNsYXNzQmluZGluZykge1xuICAgIGVsLmNsYXNzQmluZGluZyA9IGNsYXNzQmluZGluZztcbiAgfVxufVxuXG5mdW5jdGlvbiBnZW5EYXRhIChlbCkge1xuICB2YXIgZGF0YSA9ICcnO1xuICBpZiAoZWwuc3RhdGljQ2xhc3MpIHtcbiAgICBkYXRhICs9IFwic3RhdGljQ2xhc3M6XCIgKyAoZWwuc3RhdGljQ2xhc3MpICsgXCIsXCI7XG4gIH1cbiAgaWYgKGVsLmNsYXNzQmluZGluZykge1xuICAgIGRhdGEgKz0gXCJjbGFzczpcIiArIChlbC5jbGFzc0JpbmRpbmcpICsgXCIsXCI7XG4gIH1cbiAgcmV0dXJuIGRhdGFcbn1cblxudmFyIGtsYXNzJDEgPSB7XG4gIHN0YXRpY0tleXM6IFsnc3RhdGljQ2xhc3MnXSxcbiAgdHJhbnNmb3JtTm9kZTogdHJhbnNmb3JtTm9kZSxcbiAgZ2VuRGF0YTogZ2VuRGF0YVxufTtcblxuLyogICovXG5cbmZ1bmN0aW9uIHRyYW5zZm9ybU5vZGUkMSAoZWwsIG9wdGlvbnMpIHtcbiAgdmFyIHdhcm4gPSBvcHRpb25zLndhcm4gfHwgYmFzZVdhcm47XG4gIHZhciBzdGF0aWNTdHlsZSA9IGdldEFuZFJlbW92ZUF0dHIoZWwsICdzdHlsZScpO1xuICBpZiAoc3RhdGljU3R5bGUpIHtcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgdmFyIGV4cHJlc3Npb24gPSBwYXJzZVRleHQoc3RhdGljU3R5bGUsIG9wdGlvbnMuZGVsaW1pdGVycyk7XG4gICAgICBpZiAoZXhwcmVzc2lvbikge1xuICAgICAgICB3YXJuKFxuICAgICAgICAgIFwic3R5bGU9XFxcIlwiICsgc3RhdGljU3R5bGUgKyBcIlxcXCI6IFwiICtcbiAgICAgICAgICAnSW50ZXJwb2xhdGlvbiBpbnNpZGUgYXR0cmlidXRlcyBoYXMgYmVlbiByZW1vdmVkLiAnICtcbiAgICAgICAgICAnVXNlIHYtYmluZCBvciB0aGUgY29sb24gc2hvcnRoYW5kIGluc3RlYWQuIEZvciBleGFtcGxlLCAnICtcbiAgICAgICAgICAnaW5zdGVhZCBvZiA8ZGl2IHN0eWxlPVwie3sgdmFsIH19XCI+LCB1c2UgPGRpdiA6c3R5bGU9XCJ2YWxcIj4uJ1xuICAgICAgICApO1xuICAgICAgfVxuICAgIH1cbiAgICBlbC5zdGF0aWNTdHlsZSA9IEpTT04uc3RyaW5naWZ5KHBhcnNlU3R5bGVUZXh0KHN0YXRpY1N0eWxlKSk7XG4gIH1cblxuICB2YXIgc3R5bGVCaW5kaW5nID0gZ2V0QmluZGluZ0F0dHIoZWwsICdzdHlsZScsIGZhbHNlIC8qIGdldFN0YXRpYyAqLyk7XG4gIGlmIChzdHlsZUJpbmRpbmcpIHtcbiAgICBlbC5zdHlsZUJpbmRpbmcgPSBzdHlsZUJpbmRpbmc7XG4gIH1cbn1cblxuZnVuY3Rpb24gZ2VuRGF0YSQxIChlbCkge1xuICB2YXIgZGF0YSA9ICcnO1xuICBpZiAoZWwuc3RhdGljU3R5bGUpIHtcbiAgICBkYXRhICs9IFwic3RhdGljU3R5bGU6XCIgKyAoZWwuc3RhdGljU3R5bGUpICsgXCIsXCI7XG4gIH1cbiAgaWYgKGVsLnN0eWxlQmluZGluZykge1xuICAgIGRhdGEgKz0gXCJzdHlsZTooXCIgKyAoZWwuc3R5bGVCaW5kaW5nKSArIFwiKSxcIjtcbiAgfVxuICByZXR1cm4gZGF0YVxufVxuXG52YXIgc3R5bGUkMSA9IHtcbiAgc3RhdGljS2V5czogWydzdGF0aWNTdHlsZSddLFxuICB0cmFuc2Zvcm1Ob2RlOiB0cmFuc2Zvcm1Ob2RlJDEsXG4gIGdlbkRhdGE6IGdlbkRhdGEkMVxufTtcblxuLyogICovXG5cbnZhciBkZWNvZGVyO1xuXG52YXIgaGUgPSB7XG4gIGRlY29kZTogZnVuY3Rpb24gZGVjb2RlIChodG1sKSB7XG4gICAgZGVjb2RlciA9IGRlY29kZXIgfHwgZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgZGVjb2Rlci5pbm5lckhUTUwgPSBodG1sO1xuICAgIHJldHVybiBkZWNvZGVyLnRleHRDb250ZW50XG4gIH1cbn07XG5cbi8qICAqL1xuXG52YXIgaXNVbmFyeVRhZyA9IG1ha2VNYXAoXG4gICdhcmVhLGJhc2UsYnIsY29sLGVtYmVkLGZyYW1lLGhyLGltZyxpbnB1dCxpc2luZGV4LGtleWdlbiwnICtcbiAgJ2xpbmssbWV0YSxwYXJhbSxzb3VyY2UsdHJhY2ssd2JyJ1xuKTtcblxuLy8gRWxlbWVudHMgdGhhdCB5b3UgY2FuLCBpbnRlbnRpb25hbGx5LCBsZWF2ZSBvcGVuXG4vLyAoYW5kIHdoaWNoIGNsb3NlIHRoZW1zZWx2ZXMpXG52YXIgY2FuQmVMZWZ0T3BlblRhZyA9IG1ha2VNYXAoXG4gICdjb2xncm91cCxkZCxkdCxsaSxvcHRpb25zLHAsdGQsdGZvb3QsdGgsdGhlYWQsdHIsc291cmNlJ1xuKTtcblxuLy8gSFRNTDUgdGFncyBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9pbmRpY2VzLmh0bWwjZWxlbWVudHMtM1xuLy8gUGhyYXNpbmcgQ29udGVudCBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9kb20uaHRtbCNwaHJhc2luZy1jb250ZW50XG52YXIgaXNOb25QaHJhc2luZ1RhZyA9IG1ha2VNYXAoXG4gICdhZGRyZXNzLGFydGljbGUsYXNpZGUsYmFzZSxibG9ja3F1b3RlLGJvZHksY2FwdGlvbixjb2wsY29sZ3JvdXAsZGQsJyArXG4gICdkZXRhaWxzLGRpYWxvZyxkaXYsZGwsZHQsZmllbGRzZXQsZmlnY2FwdGlvbixmaWd1cmUsZm9vdGVyLGZvcm0sJyArXG4gICdoMSxoMixoMyxoNCxoNSxoNixoZWFkLGhlYWRlcixoZ3JvdXAsaHIsaHRtbCxsZWdlbmQsbGksbWVudWl0ZW0sbWV0YSwnICtcbiAgJ29wdGdyb3VwLG9wdGlvbixwYXJhbSxycCxydCxzb3VyY2Usc3R5bGUsc3VtbWFyeSx0Ym9keSx0ZCx0Zm9vdCx0aCx0aGVhZCwnICtcbiAgJ3RpdGxlLHRyLHRyYWNrJ1xuKTtcblxuLyoqXG4gKiBOb3QgdHlwZS1jaGVja2luZyB0aGlzIGZpbGUgYmVjYXVzZSBpdCdzIG1vc3RseSB2ZW5kb3IgY29kZS5cbiAqL1xuXG4vKiFcbiAqIEhUTUwgUGFyc2VyIEJ5IEpvaG4gUmVzaWcgKGVqb2huLm9yZylcbiAqIE1vZGlmaWVkIGJ5IEp1cml5IFwia2FuZ2F4XCIgWmF5dHNldlxuICogT3JpZ2luYWwgY29kZSBieSBFcmlrIEFydmlkc3NvbiwgTW96aWxsYSBQdWJsaWMgTGljZW5zZVxuICogaHR0cDovL2VyaWsuZWFlLm5ldC9zaW1wbGVodG1scGFyc2VyL3NpbXBsZWh0bWxwYXJzZXIuanNcbiAqL1xuXG4vLyBSZWd1bGFyIEV4cHJlc3Npb25zIGZvciBwYXJzaW5nIHRhZ3MgYW5kIGF0dHJpYnV0ZXNcbnZhciBhdHRyaWJ1dGUgPSAvXlxccyooW15cXHNcIic8PlxcLz1dKykoPzpcXHMqKD0pXFxzKig/OlwiKFteXCJdKilcIit8JyhbXiddKiknK3woW15cXHNcIic9PD5gXSspKSk/Lztcbi8vIGNvdWxkIHVzZSBodHRwczovL3d3dy53My5vcmcvVFIvMTk5OS9SRUMteG1sLW5hbWVzLTE5OTkwMTE0LyNOVC1RTmFtZVxuLy8gYnV0IGZvciBWdWUgdGVtcGxhdGVzIHdlIGNhbiBlbmZvcmNlIGEgc2ltcGxlIGNoYXJzZXRcbnZhciBuY25hbWUgPSAnW2EtekEtWl9dW1xcXFx3XFxcXC1cXFxcLl0qJztcbnZhciBxbmFtZUNhcHR1cmUgPSBcIigoPzpcIiArIG5jbmFtZSArIFwiXFxcXDopP1wiICsgbmNuYW1lICsgXCIpXCI7XG52YXIgc3RhcnRUYWdPcGVuID0gbmV3IFJlZ0V4cCgoXCJePFwiICsgcW5hbWVDYXB0dXJlKSk7XG52YXIgc3RhcnRUYWdDbG9zZSA9IC9eXFxzKihcXC8/KT4vO1xudmFyIGVuZFRhZyA9IG5ldyBSZWdFeHAoKFwiXjxcXFxcL1wiICsgcW5hbWVDYXB0dXJlICsgXCJbXj5dKj5cIikpO1xudmFyIGRvY3R5cGUgPSAvXjwhRE9DVFlQRSBbXj5dKz4vaTtcbnZhciBjb21tZW50ID0gL148IS0tLztcbnZhciBjb25kaXRpb25hbENvbW1lbnQgPSAvXjwhXFxbLztcblxudmFyIElTX1JFR0VYX0NBUFRVUklOR19CUk9LRU4gPSBmYWxzZTtcbid4Jy5yZXBsYWNlKC94KC4pPy9nLCBmdW5jdGlvbiAobSwgZykge1xuICBJU19SRUdFWF9DQVBUVVJJTkdfQlJPS0VOID0gZyA9PT0gJyc7XG59KTtcblxuLy8gU3BlY2lhbCBFbGVtZW50cyAoY2FuIGNvbnRhaW4gYW55dGhpbmcpXG52YXIgaXNQbGFpblRleHRFbGVtZW50ID0gbWFrZU1hcCgnc2NyaXB0LHN0eWxlLHRleHRhcmVhJywgdHJ1ZSk7XG52YXIgcmVDYWNoZSA9IHt9O1xuXG52YXIgZGVjb2RpbmdNYXAgPSB7XG4gICcmbHQ7JzogJzwnLFxuICAnJmd0Oyc6ICc+JyxcbiAgJyZxdW90Oyc6ICdcIicsXG4gICcmYW1wOyc6ICcmJyxcbiAgJyYjMTA7JzogJ1xcbicsXG4gICcmIzk7JzogJ1xcdCdcbn07XG52YXIgZW5jb2RlZEF0dHIgPSAvJig/Omx0fGd0fHF1b3R8YW1wKTsvZztcbnZhciBlbmNvZGVkQXR0cldpdGhOZXdMaW5lcyA9IC8mKD86bHR8Z3R8cXVvdHxhbXB8IzEwfCM5KTsvZztcblxuLy8gIzU5OTJcbnZhciBpc0lnbm9yZU5ld2xpbmVUYWcgPSBtYWtlTWFwKCdwcmUsdGV4dGFyZWEnLCB0cnVlKTtcbnZhciBzaG91bGRJZ25vcmVGaXJzdE5ld2xpbmUgPSBmdW5jdGlvbiAodGFnLCBodG1sKSB7IHJldHVybiB0YWcgJiYgaXNJZ25vcmVOZXdsaW5lVGFnKHRhZykgJiYgaHRtbFswXSA9PT0gJ1xcbic7IH07XG5cbmZ1bmN0aW9uIGRlY29kZUF0dHIgKHZhbHVlLCBzaG91bGREZWNvZGVOZXdsaW5lcykge1xuICB2YXIgcmUgPSBzaG91bGREZWNvZGVOZXdsaW5lcyA/IGVuY29kZWRBdHRyV2l0aE5ld0xpbmVzIDogZW5jb2RlZEF0dHI7XG4gIHJldHVybiB2YWx1ZS5yZXBsYWNlKHJlLCBmdW5jdGlvbiAobWF0Y2gpIHsgcmV0dXJuIGRlY29kaW5nTWFwW21hdGNoXTsgfSlcbn1cblxuZnVuY3Rpb24gcGFyc2VIVE1MIChodG1sLCBvcHRpb25zKSB7XG4gIHZhciBzdGFjayA9IFtdO1xuICB2YXIgZXhwZWN0SFRNTCA9IG9wdGlvbnMuZXhwZWN0SFRNTDtcbiAgdmFyIGlzVW5hcnlUYWckJDEgPSBvcHRpb25zLmlzVW5hcnlUYWcgfHwgbm87XG4gIHZhciBjYW5CZUxlZnRPcGVuVGFnJCQxID0gb3B0aW9ucy5jYW5CZUxlZnRPcGVuVGFnIHx8IG5vO1xuICB2YXIgaW5kZXggPSAwO1xuICB2YXIgbGFzdCwgbGFzdFRhZztcbiAgd2hpbGUgKGh0bWwpIHtcbiAgICBsYXN0ID0gaHRtbDtcbiAgICAvLyBNYWtlIHN1cmUgd2UncmUgbm90IGluIGEgcGxhaW50ZXh0IGNvbnRlbnQgZWxlbWVudCBsaWtlIHNjcmlwdC9zdHlsZVxuICAgIGlmICghbGFzdFRhZyB8fCAhaXNQbGFpblRleHRFbGVtZW50KGxhc3RUYWcpKSB7XG4gICAgICB2YXIgdGV4dEVuZCA9IGh0bWwuaW5kZXhPZignPCcpO1xuICAgICAgaWYgKHRleHRFbmQgPT09IDApIHtcbiAgICAgICAgLy8gQ29tbWVudDpcbiAgICAgICAgaWYgKGNvbW1lbnQudGVzdChodG1sKSkge1xuICAgICAgICAgIHZhciBjb21tZW50RW5kID0gaHRtbC5pbmRleE9mKCctLT4nKTtcblxuICAgICAgICAgIGlmIChjb21tZW50RW5kID49IDApIHtcbiAgICAgICAgICAgIGlmIChvcHRpb25zLnNob3VsZEtlZXBDb21tZW50KSB7XG4gICAgICAgICAgICAgIG9wdGlvbnMuY29tbWVudChodG1sLnN1YnN0cmluZyg0LCBjb21tZW50RW5kKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBhZHZhbmNlKGNvbW1lbnRFbmQgKyAzKTtcbiAgICAgICAgICAgIGNvbnRpbnVlXG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gaHR0cDovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9Db25kaXRpb25hbF9jb21tZW50I0Rvd25sZXZlbC1yZXZlYWxlZF9jb25kaXRpb25hbF9jb21tZW50XG4gICAgICAgIGlmIChjb25kaXRpb25hbENvbW1lbnQudGVzdChodG1sKSkge1xuICAgICAgICAgIHZhciBjb25kaXRpb25hbEVuZCA9IGh0bWwuaW5kZXhPZignXT4nKTtcblxuICAgICAgICAgIGlmIChjb25kaXRpb25hbEVuZCA+PSAwKSB7XG4gICAgICAgICAgICBhZHZhbmNlKGNvbmRpdGlvbmFsRW5kICsgMik7XG4gICAgICAgICAgICBjb250aW51ZVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIERvY3R5cGU6XG4gICAgICAgIHZhciBkb2N0eXBlTWF0Y2ggPSBodG1sLm1hdGNoKGRvY3R5cGUpO1xuICAgICAgICBpZiAoZG9jdHlwZU1hdGNoKSB7XG4gICAgICAgICAgYWR2YW5jZShkb2N0eXBlTWF0Y2hbMF0ubGVuZ3RoKTtcbiAgICAgICAgICBjb250aW51ZVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gRW5kIHRhZzpcbiAgICAgICAgdmFyIGVuZFRhZ01hdGNoID0gaHRtbC5tYXRjaChlbmRUYWcpO1xuICAgICAgICBpZiAoZW5kVGFnTWF0Y2gpIHtcbiAgICAgICAgICB2YXIgY3VySW5kZXggPSBpbmRleDtcbiAgICAgICAgICBhZHZhbmNlKGVuZFRhZ01hdGNoWzBdLmxlbmd0aCk7XG4gICAgICAgICAgcGFyc2VFbmRUYWcoZW5kVGFnTWF0Y2hbMV0sIGN1ckluZGV4LCBpbmRleCk7XG4gICAgICAgICAgY29udGludWVcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFN0YXJ0IHRhZzpcbiAgICAgICAgdmFyIHN0YXJ0VGFnTWF0Y2ggPSBwYXJzZVN0YXJ0VGFnKCk7XG4gICAgICAgIGlmIChzdGFydFRhZ01hdGNoKSB7XG4gICAgICAgICAgaGFuZGxlU3RhcnRUYWcoc3RhcnRUYWdNYXRjaCk7XG4gICAgICAgICAgaWYgKHNob3VsZElnbm9yZUZpcnN0TmV3bGluZShsYXN0VGFnLCBodG1sKSkge1xuICAgICAgICAgICAgYWR2YW5jZSgxKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgY29udGludWVcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB2YXIgdGV4dCA9ICh2b2lkIDApLCByZXN0ID0gKHZvaWQgMCksIG5leHQgPSAodm9pZCAwKTtcbiAgICAgIGlmICh0ZXh0RW5kID49IDApIHtcbiAgICAgICAgcmVzdCA9IGh0bWwuc2xpY2UodGV4dEVuZCk7XG4gICAgICAgIHdoaWxlIChcbiAgICAgICAgICAhZW5kVGFnLnRlc3QocmVzdCkgJiZcbiAgICAgICAgICAhc3RhcnRUYWdPcGVuLnRlc3QocmVzdCkgJiZcbiAgICAgICAgICAhY29tbWVudC50ZXN0KHJlc3QpICYmXG4gICAgICAgICAgIWNvbmRpdGlvbmFsQ29tbWVudC50ZXN0KHJlc3QpXG4gICAgICAgICkge1xuICAgICAgICAgIC8vIDwgaW4gcGxhaW4gdGV4dCwgYmUgZm9yZ2l2aW5nIGFuZCB0cmVhdCBpdCBhcyB0ZXh0XG4gICAgICAgICAgbmV4dCA9IHJlc3QuaW5kZXhPZignPCcsIDEpO1xuICAgICAgICAgIGlmIChuZXh0IDwgMCkgeyBicmVhayB9XG4gICAgICAgICAgdGV4dEVuZCArPSBuZXh0O1xuICAgICAgICAgIHJlc3QgPSBodG1sLnNsaWNlKHRleHRFbmQpO1xuICAgICAgICB9XG4gICAgICAgIHRleHQgPSBodG1sLnN1YnN0cmluZygwLCB0ZXh0RW5kKTtcbiAgICAgICAgYWR2YW5jZSh0ZXh0RW5kKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHRleHRFbmQgPCAwKSB7XG4gICAgICAgIHRleHQgPSBodG1sO1xuICAgICAgICBodG1sID0gJyc7XG4gICAgICB9XG5cbiAgICAgIGlmIChvcHRpb25zLmNoYXJzICYmIHRleHQpIHtcbiAgICAgICAgb3B0aW9ucy5jaGFycyh0ZXh0KTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIGVuZFRhZ0xlbmd0aCA9IDA7XG4gICAgICB2YXIgc3RhY2tlZFRhZyA9IGxhc3RUYWcudG9Mb3dlckNhc2UoKTtcbiAgICAgIHZhciByZVN0YWNrZWRUYWcgPSByZUNhY2hlW3N0YWNrZWRUYWddIHx8IChyZUNhY2hlW3N0YWNrZWRUYWddID0gbmV3IFJlZ0V4cCgnKFtcXFxcc1xcXFxTXSo/KSg8LycgKyBzdGFja2VkVGFnICsgJ1tePl0qPiknLCAnaScpKTtcbiAgICAgIHZhciByZXN0JDEgPSBodG1sLnJlcGxhY2UocmVTdGFja2VkVGFnLCBmdW5jdGlvbiAoYWxsLCB0ZXh0LCBlbmRUYWcpIHtcbiAgICAgICAgZW5kVGFnTGVuZ3RoID0gZW5kVGFnLmxlbmd0aDtcbiAgICAgICAgaWYgKCFpc1BsYWluVGV4dEVsZW1lbnQoc3RhY2tlZFRhZykgJiYgc3RhY2tlZFRhZyAhPT0gJ25vc2NyaXB0Jykge1xuICAgICAgICAgIHRleHQgPSB0ZXh0XG4gICAgICAgICAgICAucmVwbGFjZSgvPCEtLShbXFxzXFxTXSo/KS0tPi9nLCAnJDEnKVxuICAgICAgICAgICAgLnJlcGxhY2UoLzwhXFxbQ0RBVEFcXFsoW1xcc1xcU10qPyldXT4vZywgJyQxJyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHNob3VsZElnbm9yZUZpcnN0TmV3bGluZShzdGFja2VkVGFnLCB0ZXh0KSkge1xuICAgICAgICAgIHRleHQgPSB0ZXh0LnNsaWNlKDEpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChvcHRpb25zLmNoYXJzKSB7XG4gICAgICAgICAgb3B0aW9ucy5jaGFycyh0ZXh0KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gJydcbiAgICAgIH0pO1xuICAgICAgaW5kZXggKz0gaHRtbC5sZW5ndGggLSByZXN0JDEubGVuZ3RoO1xuICAgICAgaHRtbCA9IHJlc3QkMTtcbiAgICAgIHBhcnNlRW5kVGFnKHN0YWNrZWRUYWcsIGluZGV4IC0gZW5kVGFnTGVuZ3RoLCBpbmRleCk7XG4gICAgfVxuXG4gICAgaWYgKGh0bWwgPT09IGxhc3QpIHtcbiAgICAgIG9wdGlvbnMuY2hhcnMgJiYgb3B0aW9ucy5jaGFycyhodG1sKTtcbiAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmICFzdGFjay5sZW5ndGggJiYgb3B0aW9ucy53YXJuKSB7XG4gICAgICAgIG9wdGlvbnMud2FybigoXCJNYWwtZm9ybWF0dGVkIHRhZyBhdCBlbmQgb2YgdGVtcGxhdGU6IFxcXCJcIiArIGh0bWwgKyBcIlxcXCJcIikpO1xuICAgICAgfVxuICAgICAgYnJlYWtcbiAgICB9XG4gIH1cblxuICAvLyBDbGVhbiB1cCBhbnkgcmVtYWluaW5nIHRhZ3NcbiAgcGFyc2VFbmRUYWcoKTtcblxuICBmdW5jdGlvbiBhZHZhbmNlIChuKSB7XG4gICAgaW5kZXggKz0gbjtcbiAgICBodG1sID0gaHRtbC5zdWJzdHJpbmcobik7XG4gIH1cblxuICBmdW5jdGlvbiBwYXJzZVN0YXJ0VGFnICgpIHtcbiAgICB2YXIgc3RhcnQgPSBodG1sLm1hdGNoKHN0YXJ0VGFnT3Blbik7XG4gICAgaWYgKHN0YXJ0KSB7XG4gICAgICB2YXIgbWF0Y2ggPSB7XG4gICAgICAgIHRhZ05hbWU6IHN0YXJ0WzFdLFxuICAgICAgICBhdHRyczogW10sXG4gICAgICAgIHN0YXJ0OiBpbmRleFxuICAgICAgfTtcbiAgICAgIGFkdmFuY2Uoc3RhcnRbMF0ubGVuZ3RoKTtcbiAgICAgIHZhciBlbmQsIGF0dHI7XG4gICAgICB3aGlsZSAoIShlbmQgPSBodG1sLm1hdGNoKHN0YXJ0VGFnQ2xvc2UpKSAmJiAoYXR0ciA9IGh0bWwubWF0Y2goYXR0cmlidXRlKSkpIHtcbiAgICAgICAgYWR2YW5jZShhdHRyWzBdLmxlbmd0aCk7XG4gICAgICAgIG1hdGNoLmF0dHJzLnB1c2goYXR0cik7XG4gICAgICB9XG4gICAgICBpZiAoZW5kKSB7XG4gICAgICAgIG1hdGNoLnVuYXJ5U2xhc2ggPSBlbmRbMV07XG4gICAgICAgIGFkdmFuY2UoZW5kWzBdLmxlbmd0aCk7XG4gICAgICAgIG1hdGNoLmVuZCA9IGluZGV4O1xuICAgICAgICByZXR1cm4gbWF0Y2hcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBoYW5kbGVTdGFydFRhZyAobWF0Y2gpIHtcbiAgICB2YXIgdGFnTmFtZSA9IG1hdGNoLnRhZ05hbWU7XG4gICAgdmFyIHVuYXJ5U2xhc2ggPSBtYXRjaC51bmFyeVNsYXNoO1xuXG4gICAgaWYgKGV4cGVjdEhUTUwpIHtcbiAgICAgIGlmIChsYXN0VGFnID09PSAncCcgJiYgaXNOb25QaHJhc2luZ1RhZyh0YWdOYW1lKSkge1xuICAgICAgICBwYXJzZUVuZFRhZyhsYXN0VGFnKTtcbiAgICAgIH1cbiAgICAgIGlmIChjYW5CZUxlZnRPcGVuVGFnJCQxKHRhZ05hbWUpICYmIGxhc3RUYWcgPT09IHRhZ05hbWUpIHtcbiAgICAgICAgcGFyc2VFbmRUYWcodGFnTmFtZSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIHVuYXJ5ID0gaXNVbmFyeVRhZyQkMSh0YWdOYW1lKSB8fCAhIXVuYXJ5U2xhc2g7XG5cbiAgICB2YXIgbCA9IG1hdGNoLmF0dHJzLmxlbmd0aDtcbiAgICB2YXIgYXR0cnMgPSBuZXcgQXJyYXkobCk7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsOyBpKyspIHtcbiAgICAgIHZhciBhcmdzID0gbWF0Y2guYXR0cnNbaV07XG4gICAgICAvLyBoYWNraXNoIHdvcmsgYXJvdW5kIEZGIGJ1ZyBodHRwczovL2J1Z3ppbGxhLm1vemlsbGEub3JnL3Nob3dfYnVnLmNnaT9pZD0zNjk3NzhcbiAgICAgIGlmIChJU19SRUdFWF9DQVBUVVJJTkdfQlJPS0VOICYmIGFyZ3NbMF0uaW5kZXhPZignXCJcIicpID09PSAtMSkge1xuICAgICAgICBpZiAoYXJnc1szXSA9PT0gJycpIHsgZGVsZXRlIGFyZ3NbM107IH1cbiAgICAgICAgaWYgKGFyZ3NbNF0gPT09ICcnKSB7IGRlbGV0ZSBhcmdzWzRdOyB9XG4gICAgICAgIGlmIChhcmdzWzVdID09PSAnJykgeyBkZWxldGUgYXJnc1s1XTsgfVxuICAgICAgfVxuICAgICAgdmFyIHZhbHVlID0gYXJnc1szXSB8fCBhcmdzWzRdIHx8IGFyZ3NbNV0gfHwgJyc7XG4gICAgICB2YXIgc2hvdWxkRGVjb2RlTmV3bGluZXMgPSB0YWdOYW1lID09PSAnYScgJiYgYXJnc1sxXSA9PT0gJ2hyZWYnXG4gICAgICAgID8gb3B0aW9ucy5zaG91bGREZWNvZGVOZXdsaW5lc0ZvckhyZWZcbiAgICAgICAgOiBvcHRpb25zLnNob3VsZERlY29kZU5ld2xpbmVzO1xuICAgICAgYXR0cnNbaV0gPSB7XG4gICAgICAgIG5hbWU6IGFyZ3NbMV0sXG4gICAgICAgIHZhbHVlOiBkZWNvZGVBdHRyKHZhbHVlLCBzaG91bGREZWNvZGVOZXdsaW5lcylcbiAgICAgIH07XG4gICAgfVxuXG4gICAgaWYgKCF1bmFyeSkge1xuICAgICAgc3RhY2sucHVzaCh7IHRhZzogdGFnTmFtZSwgbG93ZXJDYXNlZFRhZzogdGFnTmFtZS50b0xvd2VyQ2FzZSgpLCBhdHRyczogYXR0cnMgfSk7XG4gICAgICBsYXN0VGFnID0gdGFnTmFtZTtcbiAgICB9XG5cbiAgICBpZiAob3B0aW9ucy5zdGFydCkge1xuICAgICAgb3B0aW9ucy5zdGFydCh0YWdOYW1lLCBhdHRycywgdW5hcnksIG1hdGNoLnN0YXJ0LCBtYXRjaC5lbmQpO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHBhcnNlRW5kVGFnICh0YWdOYW1lLCBzdGFydCwgZW5kKSB7XG4gICAgdmFyIHBvcywgbG93ZXJDYXNlZFRhZ05hbWU7XG4gICAgaWYgKHN0YXJ0ID09IG51bGwpIHsgc3RhcnQgPSBpbmRleDsgfVxuICAgIGlmIChlbmQgPT0gbnVsbCkgeyBlbmQgPSBpbmRleDsgfVxuXG4gICAgaWYgKHRhZ05hbWUpIHtcbiAgICAgIGxvd2VyQ2FzZWRUYWdOYW1lID0gdGFnTmFtZS50b0xvd2VyQ2FzZSgpO1xuICAgIH1cblxuICAgIC8vIEZpbmQgdGhlIGNsb3Nlc3Qgb3BlbmVkIHRhZyBvZiB0aGUgc2FtZSB0eXBlXG4gICAgaWYgKHRhZ05hbWUpIHtcbiAgICAgIGZvciAocG9zID0gc3RhY2subGVuZ3RoIC0gMTsgcG9zID49IDA7IHBvcy0tKSB7XG4gICAgICAgIGlmIChzdGFja1twb3NdLmxvd2VyQ2FzZWRUYWcgPT09IGxvd2VyQ2FzZWRUYWdOYW1lKSB7XG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBJZiBubyB0YWcgbmFtZSBpcyBwcm92aWRlZCwgY2xlYW4gc2hvcFxuICAgICAgcG9zID0gMDtcbiAgICB9XG5cbiAgICBpZiAocG9zID49IDApIHtcbiAgICAgIC8vIENsb3NlIGFsbCB0aGUgb3BlbiBlbGVtZW50cywgdXAgdGhlIHN0YWNrXG4gICAgICBmb3IgKHZhciBpID0gc3RhY2subGVuZ3RoIC0gMTsgaSA+PSBwb3M7IGktLSkge1xuICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJlxuICAgICAgICAgIChpID4gcG9zIHx8ICF0YWdOYW1lKSAmJlxuICAgICAgICAgIG9wdGlvbnMud2FyblxuICAgICAgICApIHtcbiAgICAgICAgICBvcHRpb25zLndhcm4oXG4gICAgICAgICAgICAoXCJ0YWcgPFwiICsgKHN0YWNrW2ldLnRhZykgKyBcIj4gaGFzIG5vIG1hdGNoaW5nIGVuZCB0YWcuXCIpXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAob3B0aW9ucy5lbmQpIHtcbiAgICAgICAgICBvcHRpb25zLmVuZChzdGFja1tpXS50YWcsIHN0YXJ0LCBlbmQpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIFJlbW92ZSB0aGUgb3BlbiBlbGVtZW50cyBmcm9tIHRoZSBzdGFja1xuICAgICAgc3RhY2subGVuZ3RoID0gcG9zO1xuICAgICAgbGFzdFRhZyA9IHBvcyAmJiBzdGFja1twb3MgLSAxXS50YWc7XG4gICAgfSBlbHNlIGlmIChsb3dlckNhc2VkVGFnTmFtZSA9PT0gJ2JyJykge1xuICAgICAgaWYgKG9wdGlvbnMuc3RhcnQpIHtcbiAgICAgICAgb3B0aW9ucy5zdGFydCh0YWdOYW1lLCBbXSwgdHJ1ZSwgc3RhcnQsIGVuZCk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChsb3dlckNhc2VkVGFnTmFtZSA9PT0gJ3AnKSB7XG4gICAgICBpZiAob3B0aW9ucy5zdGFydCkge1xuICAgICAgICBvcHRpb25zLnN0YXJ0KHRhZ05hbWUsIFtdLCBmYWxzZSwgc3RhcnQsIGVuZCk7XG4gICAgICB9XG4gICAgICBpZiAob3B0aW9ucy5lbmQpIHtcbiAgICAgICAgb3B0aW9ucy5lbmQodGFnTmFtZSwgc3RhcnQsIGVuZCk7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbi8qICAqL1xuXG52YXIgb25SRSA9IC9eQHxedi1vbjovO1xudmFyIGRpclJFID0gL152LXxeQHxeOi87XG52YXIgZm9yQWxpYXNSRSA9IC8oLio/KVxccysoPzppbnxvZilcXHMrKC4qKS87XG52YXIgZm9ySXRlcmF0b3JSRSA9IC8sKFteLFxcfVxcXV0qKSg/OiwoW14sXFx9XFxdXSopKT8kLztcbnZhciBzdHJpcFBhcmVuc1JFID0gL15cXCh8XFwpJC9nO1xuXG52YXIgYXJnUkUgPSAvOiguKikkLztcbnZhciBiaW5kUkUgPSAvXjp8XnYtYmluZDovO1xudmFyIG1vZGlmaWVyUkUgPSAvXFwuW14uXSsvZztcblxudmFyIGRlY29kZUhUTUxDYWNoZWQgPSBjYWNoZWQoaGUuZGVjb2RlKTtcblxuLy8gY29uZmlndXJhYmxlIHN0YXRlXG52YXIgd2FybiQyO1xudmFyIGRlbGltaXRlcnM7XG52YXIgdHJhbnNmb3JtcztcbnZhciBwcmVUcmFuc2Zvcm1zO1xudmFyIHBvc3RUcmFuc2Zvcm1zO1xudmFyIHBsYXRmb3JtSXNQcmVUYWc7XG52YXIgcGxhdGZvcm1NdXN0VXNlUHJvcDtcbnZhciBwbGF0Zm9ybUdldFRhZ05hbWVzcGFjZTtcblxuXG5cbmZ1bmN0aW9uIGNyZWF0ZUFTVEVsZW1lbnQgKFxuICB0YWcsXG4gIGF0dHJzLFxuICBwYXJlbnRcbikge1xuICByZXR1cm4ge1xuICAgIHR5cGU6IDEsXG4gICAgdGFnOiB0YWcsXG4gICAgYXR0cnNMaXN0OiBhdHRycyxcbiAgICBhdHRyc01hcDogbWFrZUF0dHJzTWFwKGF0dHJzKSxcbiAgICBwYXJlbnQ6IHBhcmVudCxcbiAgICBjaGlsZHJlbjogW11cbiAgfVxufVxuXG4vKipcbiAqIENvbnZlcnQgSFRNTCBzdHJpbmcgdG8gQVNULlxuICovXG5mdW5jdGlvbiBwYXJzZSAoXG4gIHRlbXBsYXRlLFxuICBvcHRpb25zXG4pIHtcbiAgd2FybiQyID0gb3B0aW9ucy53YXJuIHx8IGJhc2VXYXJuO1xuXG4gIHBsYXRmb3JtSXNQcmVUYWcgPSBvcHRpb25zLmlzUHJlVGFnIHx8IG5vO1xuICBwbGF0Zm9ybU11c3RVc2VQcm9wID0gb3B0aW9ucy5tdXN0VXNlUHJvcCB8fCBubztcbiAgcGxhdGZvcm1HZXRUYWdOYW1lc3BhY2UgPSBvcHRpb25zLmdldFRhZ05hbWVzcGFjZSB8fCBubztcblxuICB0cmFuc2Zvcm1zID0gcGx1Y2tNb2R1bGVGdW5jdGlvbihvcHRpb25zLm1vZHVsZXMsICd0cmFuc2Zvcm1Ob2RlJyk7XG4gIHByZVRyYW5zZm9ybXMgPSBwbHVja01vZHVsZUZ1bmN0aW9uKG9wdGlvbnMubW9kdWxlcywgJ3ByZVRyYW5zZm9ybU5vZGUnKTtcbiAgcG9zdFRyYW5zZm9ybXMgPSBwbHVja01vZHVsZUZ1bmN0aW9uKG9wdGlvbnMubW9kdWxlcywgJ3Bvc3RUcmFuc2Zvcm1Ob2RlJyk7XG5cbiAgZGVsaW1pdGVycyA9IG9wdGlvbnMuZGVsaW1pdGVycztcblxuICB2YXIgc3RhY2sgPSBbXTtcbiAgdmFyIHByZXNlcnZlV2hpdGVzcGFjZSA9IG9wdGlvbnMucHJlc2VydmVXaGl0ZXNwYWNlICE9PSBmYWxzZTtcbiAgdmFyIHJvb3Q7XG4gIHZhciBjdXJyZW50UGFyZW50O1xuICB2YXIgaW5WUHJlID0gZmFsc2U7XG4gIHZhciBpblByZSA9IGZhbHNlO1xuICB2YXIgd2FybmVkID0gZmFsc2U7XG5cbiAgZnVuY3Rpb24gd2Fybk9uY2UgKG1zZykge1xuICAgIGlmICghd2FybmVkKSB7XG4gICAgICB3YXJuZWQgPSB0cnVlO1xuICAgICAgd2FybiQyKG1zZyk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gZW5kUHJlIChlbGVtZW50KSB7XG4gICAgLy8gY2hlY2sgcHJlIHN0YXRlXG4gICAgaWYgKGVsZW1lbnQucHJlKSB7XG4gICAgICBpblZQcmUgPSBmYWxzZTtcbiAgICB9XG4gICAgaWYgKHBsYXRmb3JtSXNQcmVUYWcoZWxlbWVudC50YWcpKSB7XG4gICAgICBpblByZSA9IGZhbHNlO1xuICAgIH1cbiAgfVxuXG4gIHBhcnNlSFRNTCh0ZW1wbGF0ZSwge1xuICAgIHdhcm46IHdhcm4kMixcbiAgICBleHBlY3RIVE1MOiBvcHRpb25zLmV4cGVjdEhUTUwsXG4gICAgaXNVbmFyeVRhZzogb3B0aW9ucy5pc1VuYXJ5VGFnLFxuICAgIGNhbkJlTGVmdE9wZW5UYWc6IG9wdGlvbnMuY2FuQmVMZWZ0T3BlblRhZyxcbiAgICBzaG91bGREZWNvZGVOZXdsaW5lczogb3B0aW9ucy5zaG91bGREZWNvZGVOZXdsaW5lcyxcbiAgICBzaG91bGREZWNvZGVOZXdsaW5lc0ZvckhyZWY6IG9wdGlvbnMuc2hvdWxkRGVjb2RlTmV3bGluZXNGb3JIcmVmLFxuICAgIHNob3VsZEtlZXBDb21tZW50OiBvcHRpb25zLmNvbW1lbnRzLFxuICAgIHN0YXJ0OiBmdW5jdGlvbiBzdGFydCAodGFnLCBhdHRycywgdW5hcnkpIHtcbiAgICAgIC8vIGNoZWNrIG5hbWVzcGFjZS5cbiAgICAgIC8vIGluaGVyaXQgcGFyZW50IG5zIGlmIHRoZXJlIGlzIG9uZVxuICAgICAgdmFyIG5zID0gKGN1cnJlbnRQYXJlbnQgJiYgY3VycmVudFBhcmVudC5ucykgfHwgcGxhdGZvcm1HZXRUYWdOYW1lc3BhY2UodGFnKTtcblxuICAgICAgLy8gaGFuZGxlIElFIHN2ZyBidWdcbiAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgICAgaWYgKGlzSUUgJiYgbnMgPT09ICdzdmcnKSB7XG4gICAgICAgIGF0dHJzID0gZ3VhcmRJRVNWR0J1ZyhhdHRycyk7XG4gICAgICB9XG5cbiAgICAgIHZhciBlbGVtZW50ID0gY3JlYXRlQVNURWxlbWVudCh0YWcsIGF0dHJzLCBjdXJyZW50UGFyZW50KTtcbiAgICAgIGlmIChucykge1xuICAgICAgICBlbGVtZW50Lm5zID0gbnM7XG4gICAgICB9XG5cbiAgICAgIGlmIChpc0ZvcmJpZGRlblRhZyhlbGVtZW50KSAmJiAhaXNTZXJ2ZXJSZW5kZXJpbmcoKSkge1xuICAgICAgICBlbGVtZW50LmZvcmJpZGRlbiA9IHRydWU7XG4gICAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgd2FybiQyKFxuICAgICAgICAgICdUZW1wbGF0ZXMgc2hvdWxkIG9ubHkgYmUgcmVzcG9uc2libGUgZm9yIG1hcHBpbmcgdGhlIHN0YXRlIHRvIHRoZSAnICtcbiAgICAgICAgICAnVUkuIEF2b2lkIHBsYWNpbmcgdGFncyB3aXRoIHNpZGUtZWZmZWN0cyBpbiB5b3VyIHRlbXBsYXRlcywgc3VjaCBhcyAnICtcbiAgICAgICAgICBcIjxcIiArIHRhZyArIFwiPlwiICsgJywgYXMgdGhleSB3aWxsIG5vdCBiZSBwYXJzZWQuJ1xuICAgICAgICApO1xuICAgICAgfVxuXG4gICAgICAvLyBhcHBseSBwcmUtdHJhbnNmb3Jtc1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwcmVUcmFuc2Zvcm1zLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGVsZW1lbnQgPSBwcmVUcmFuc2Zvcm1zW2ldKGVsZW1lbnQsIG9wdGlvbnMpIHx8IGVsZW1lbnQ7XG4gICAgICB9XG5cbiAgICAgIGlmICghaW5WUHJlKSB7XG4gICAgICAgIHByb2Nlc3NQcmUoZWxlbWVudCk7XG4gICAgICAgIGlmIChlbGVtZW50LnByZSkge1xuICAgICAgICAgIGluVlByZSA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChwbGF0Zm9ybUlzUHJlVGFnKGVsZW1lbnQudGFnKSkge1xuICAgICAgICBpblByZSA9IHRydWU7XG4gICAgICB9XG4gICAgICBpZiAoaW5WUHJlKSB7XG4gICAgICAgIHByb2Nlc3NSYXdBdHRycyhlbGVtZW50KTtcbiAgICAgIH0gZWxzZSBpZiAoIWVsZW1lbnQucHJvY2Vzc2VkKSB7XG4gICAgICAgIC8vIHN0cnVjdHVyYWwgZGlyZWN0aXZlc1xuICAgICAgICBwcm9jZXNzRm9yKGVsZW1lbnQpO1xuICAgICAgICBwcm9jZXNzSWYoZWxlbWVudCk7XG4gICAgICAgIHByb2Nlc3NPbmNlKGVsZW1lbnQpO1xuICAgICAgICAvLyBlbGVtZW50LXNjb3BlIHN0dWZmXG4gICAgICAgIHByb2Nlc3NFbGVtZW50KGVsZW1lbnQsIG9wdGlvbnMpO1xuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiBjaGVja1Jvb3RDb25zdHJhaW50cyAoZWwpIHtcbiAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgICBpZiAoZWwudGFnID09PSAnc2xvdCcgfHwgZWwudGFnID09PSAndGVtcGxhdGUnKSB7XG4gICAgICAgICAgICB3YXJuT25jZShcbiAgICAgICAgICAgICAgXCJDYW5ub3QgdXNlIDxcIiArIChlbC50YWcpICsgXCI+IGFzIGNvbXBvbmVudCByb290IGVsZW1lbnQgYmVjYXVzZSBpdCBtYXkgXCIgK1xuICAgICAgICAgICAgICAnY29udGFpbiBtdWx0aXBsZSBub2Rlcy4nXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoZWwuYXR0cnNNYXAuaGFzT3duUHJvcGVydHkoJ3YtZm9yJykpIHtcbiAgICAgICAgICAgIHdhcm5PbmNlKFxuICAgICAgICAgICAgICAnQ2Fubm90IHVzZSB2LWZvciBvbiBzdGF0ZWZ1bCBjb21wb25lbnQgcm9vdCBlbGVtZW50IGJlY2F1c2UgJyArXG4gICAgICAgICAgICAgICdpdCByZW5kZXJzIG11bHRpcGxlIGVsZW1lbnRzLidcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIHRyZWUgbWFuYWdlbWVudFxuICAgICAgaWYgKCFyb290KSB7XG4gICAgICAgIHJvb3QgPSBlbGVtZW50O1xuICAgICAgICBjaGVja1Jvb3RDb25zdHJhaW50cyhyb290KTtcbiAgICAgIH0gZWxzZSBpZiAoIXN0YWNrLmxlbmd0aCkge1xuICAgICAgICAvLyBhbGxvdyByb290IGVsZW1lbnRzIHdpdGggdi1pZiwgdi1lbHNlLWlmIGFuZCB2LWVsc2VcbiAgICAgICAgaWYgKHJvb3QuaWYgJiYgKGVsZW1lbnQuZWxzZWlmIHx8IGVsZW1lbnQuZWxzZSkpIHtcbiAgICAgICAgICBjaGVja1Jvb3RDb25zdHJhaW50cyhlbGVtZW50KTtcbiAgICAgICAgICBhZGRJZkNvbmRpdGlvbihyb290LCB7XG4gICAgICAgICAgICBleHA6IGVsZW1lbnQuZWxzZWlmLFxuICAgICAgICAgICAgYmxvY2s6IGVsZW1lbnRcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgICAgd2Fybk9uY2UoXG4gICAgICAgICAgICBcIkNvbXBvbmVudCB0ZW1wbGF0ZSBzaG91bGQgY29udGFpbiBleGFjdGx5IG9uZSByb290IGVsZW1lbnQuIFwiICtcbiAgICAgICAgICAgIFwiSWYgeW91IGFyZSB1c2luZyB2LWlmIG9uIG11bHRpcGxlIGVsZW1lbnRzLCBcIiArXG4gICAgICAgICAgICBcInVzZSB2LWVsc2UtaWYgdG8gY2hhaW4gdGhlbSBpbnN0ZWFkLlwiXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKGN1cnJlbnRQYXJlbnQgJiYgIWVsZW1lbnQuZm9yYmlkZGVuKSB7XG4gICAgICAgIGlmIChlbGVtZW50LmVsc2VpZiB8fCBlbGVtZW50LmVsc2UpIHtcbiAgICAgICAgICBwcm9jZXNzSWZDb25kaXRpb25zKGVsZW1lbnQsIGN1cnJlbnRQYXJlbnQpO1xuICAgICAgICB9IGVsc2UgaWYgKGVsZW1lbnQuc2xvdFNjb3BlKSB7IC8vIHNjb3BlZCBzbG90XG4gICAgICAgICAgY3VycmVudFBhcmVudC5wbGFpbiA9IGZhbHNlO1xuICAgICAgICAgIHZhciBuYW1lID0gZWxlbWVudC5zbG90VGFyZ2V0IHx8ICdcImRlZmF1bHRcIic7KGN1cnJlbnRQYXJlbnQuc2NvcGVkU2xvdHMgfHwgKGN1cnJlbnRQYXJlbnQuc2NvcGVkU2xvdHMgPSB7fSkpW25hbWVdID0gZWxlbWVudDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjdXJyZW50UGFyZW50LmNoaWxkcmVuLnB1c2goZWxlbWVudCk7XG4gICAgICAgICAgZWxlbWVudC5wYXJlbnQgPSBjdXJyZW50UGFyZW50O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoIXVuYXJ5KSB7XG4gICAgICAgIGN1cnJlbnRQYXJlbnQgPSBlbGVtZW50O1xuICAgICAgICBzdGFjay5wdXNoKGVsZW1lbnQpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZW5kUHJlKGVsZW1lbnQpO1xuICAgICAgfVxuICAgICAgLy8gYXBwbHkgcG9zdC10cmFuc2Zvcm1zXG4gICAgICBmb3IgKHZhciBpJDEgPSAwOyBpJDEgPCBwb3N0VHJhbnNmb3Jtcy5sZW5ndGg7IGkkMSsrKSB7XG4gICAgICAgIHBvc3RUcmFuc2Zvcm1zW2kkMV0oZWxlbWVudCwgb3B0aW9ucyk7XG4gICAgICB9XG4gICAgfSxcblxuICAgIGVuZDogZnVuY3Rpb24gZW5kICgpIHtcbiAgICAgIC8vIHJlbW92ZSB0cmFpbGluZyB3aGl0ZXNwYWNlXG4gICAgICB2YXIgZWxlbWVudCA9IHN0YWNrW3N0YWNrLmxlbmd0aCAtIDFdO1xuICAgICAgdmFyIGxhc3ROb2RlID0gZWxlbWVudC5jaGlsZHJlbltlbGVtZW50LmNoaWxkcmVuLmxlbmd0aCAtIDFdO1xuICAgICAgaWYgKGxhc3ROb2RlICYmIGxhc3ROb2RlLnR5cGUgPT09IDMgJiYgbGFzdE5vZGUudGV4dCA9PT0gJyAnICYmICFpblByZSkge1xuICAgICAgICBlbGVtZW50LmNoaWxkcmVuLnBvcCgpO1xuICAgICAgfVxuICAgICAgLy8gcG9wIHN0YWNrXG4gICAgICBzdGFjay5sZW5ndGggLT0gMTtcbiAgICAgIGN1cnJlbnRQYXJlbnQgPSBzdGFja1tzdGFjay5sZW5ndGggLSAxXTtcbiAgICAgIGVuZFByZShlbGVtZW50KTtcbiAgICB9LFxuXG4gICAgY2hhcnM6IGZ1bmN0aW9uIGNoYXJzICh0ZXh0KSB7XG4gICAgICBpZiAoIWN1cnJlbnRQYXJlbnQpIHtcbiAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgICBpZiAodGV4dCA9PT0gdGVtcGxhdGUpIHtcbiAgICAgICAgICAgIHdhcm5PbmNlKFxuICAgICAgICAgICAgICAnQ29tcG9uZW50IHRlbXBsYXRlIHJlcXVpcmVzIGEgcm9vdCBlbGVtZW50LCByYXRoZXIgdGhhbiBqdXN0IHRleHQuJ1xuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9IGVsc2UgaWYgKCh0ZXh0ID0gdGV4dC50cmltKCkpKSB7XG4gICAgICAgICAgICB3YXJuT25jZShcbiAgICAgICAgICAgICAgKFwidGV4dCBcXFwiXCIgKyB0ZXh0ICsgXCJcXFwiIG91dHNpZGUgcm9vdCBlbGVtZW50IHdpbGwgYmUgaWdub3JlZC5cIilcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVyblxuICAgICAgfVxuICAgICAgLy8gSUUgdGV4dGFyZWEgcGxhY2Vob2xkZXIgYnVnXG4gICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICAgIGlmIChpc0lFICYmXG4gICAgICAgIGN1cnJlbnRQYXJlbnQudGFnID09PSAndGV4dGFyZWEnICYmXG4gICAgICAgIGN1cnJlbnRQYXJlbnQuYXR0cnNNYXAucGxhY2Vob2xkZXIgPT09IHRleHRcbiAgICAgICkge1xuICAgICAgICByZXR1cm5cbiAgICAgIH1cbiAgICAgIHZhciBjaGlsZHJlbiA9IGN1cnJlbnRQYXJlbnQuY2hpbGRyZW47XG4gICAgICB0ZXh0ID0gaW5QcmUgfHwgdGV4dC50cmltKClcbiAgICAgICAgPyBpc1RleHRUYWcoY3VycmVudFBhcmVudCkgPyB0ZXh0IDogZGVjb2RlSFRNTENhY2hlZCh0ZXh0KVxuICAgICAgICAvLyBvbmx5IHByZXNlcnZlIHdoaXRlc3BhY2UgaWYgaXRzIG5vdCByaWdodCBhZnRlciBhIHN0YXJ0aW5nIHRhZ1xuICAgICAgICA6IHByZXNlcnZlV2hpdGVzcGFjZSAmJiBjaGlsZHJlbi5sZW5ndGggPyAnICcgOiAnJztcbiAgICAgIGlmICh0ZXh0KSB7XG4gICAgICAgIHZhciBleHByZXNzaW9uO1xuICAgICAgICBpZiAoIWluVlByZSAmJiB0ZXh0ICE9PSAnICcgJiYgKGV4cHJlc3Npb24gPSBwYXJzZVRleHQodGV4dCwgZGVsaW1pdGVycykpKSB7XG4gICAgICAgICAgY2hpbGRyZW4ucHVzaCh7XG4gICAgICAgICAgICB0eXBlOiAyLFxuICAgICAgICAgICAgZXhwcmVzc2lvbjogZXhwcmVzc2lvbixcbiAgICAgICAgICAgIHRleHQ6IHRleHRcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIGlmICh0ZXh0ICE9PSAnICcgfHwgIWNoaWxkcmVuLmxlbmd0aCB8fCBjaGlsZHJlbltjaGlsZHJlbi5sZW5ndGggLSAxXS50ZXh0ICE9PSAnICcpIHtcbiAgICAgICAgICBjaGlsZHJlbi5wdXNoKHtcbiAgICAgICAgICAgIHR5cGU6IDMsXG4gICAgICAgICAgICB0ZXh0OiB0ZXh0XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuICAgIGNvbW1lbnQ6IGZ1bmN0aW9uIGNvbW1lbnQgKHRleHQpIHtcbiAgICAgIGN1cnJlbnRQYXJlbnQuY2hpbGRyZW4ucHVzaCh7XG4gICAgICAgIHR5cGU6IDMsXG4gICAgICAgIHRleHQ6IHRleHQsXG4gICAgICAgIGlzQ29tbWVudDogdHJ1ZVxuICAgICAgfSk7XG4gICAgfVxuICB9KTtcbiAgcmV0dXJuIHJvb3Rcbn1cblxuZnVuY3Rpb24gcHJvY2Vzc1ByZSAoZWwpIHtcbiAgaWYgKGdldEFuZFJlbW92ZUF0dHIoZWwsICd2LXByZScpICE9IG51bGwpIHtcbiAgICBlbC5wcmUgPSB0cnVlO1xuICB9XG59XG5cbmZ1bmN0aW9uIHByb2Nlc3NSYXdBdHRycyAoZWwpIHtcbiAgdmFyIGwgPSBlbC5hdHRyc0xpc3QubGVuZ3RoO1xuICBpZiAobCkge1xuICAgIHZhciBhdHRycyA9IGVsLmF0dHJzID0gbmV3IEFycmF5KGwpO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbDsgaSsrKSB7XG4gICAgICBhdHRyc1tpXSA9IHtcbiAgICAgICAgbmFtZTogZWwuYXR0cnNMaXN0W2ldLm5hbWUsXG4gICAgICAgIHZhbHVlOiBKU09OLnN0cmluZ2lmeShlbC5hdHRyc0xpc3RbaV0udmFsdWUpXG4gICAgICB9O1xuICAgIH1cbiAgfSBlbHNlIGlmICghZWwucHJlKSB7XG4gICAgLy8gbm9uIHJvb3Qgbm9kZSBpbiBwcmUgYmxvY2tzIHdpdGggbm8gYXR0cmlidXRlc1xuICAgIGVsLnBsYWluID0gdHJ1ZTtcbiAgfVxufVxuXG5mdW5jdGlvbiBwcm9jZXNzRWxlbWVudCAoZWxlbWVudCwgb3B0aW9ucykge1xuICBwcm9jZXNzS2V5KGVsZW1lbnQpO1xuXG4gIC8vIGRldGVybWluZSB3aGV0aGVyIHRoaXMgaXMgYSBwbGFpbiBlbGVtZW50IGFmdGVyXG4gIC8vIHJlbW92aW5nIHN0cnVjdHVyYWwgYXR0cmlidXRlc1xuICBlbGVtZW50LnBsYWluID0gIWVsZW1lbnQua2V5ICYmICFlbGVtZW50LmF0dHJzTGlzdC5sZW5ndGg7XG5cbiAgcHJvY2Vzc1JlZihlbGVtZW50KTtcbiAgcHJvY2Vzc1Nsb3QoZWxlbWVudCk7XG4gIHByb2Nlc3NDb21wb25lbnQoZWxlbWVudCk7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgdHJhbnNmb3Jtcy5sZW5ndGg7IGkrKykge1xuICAgIGVsZW1lbnQgPSB0cmFuc2Zvcm1zW2ldKGVsZW1lbnQsIG9wdGlvbnMpIHx8IGVsZW1lbnQ7XG4gIH1cbiAgcHJvY2Vzc0F0dHJzKGVsZW1lbnQpO1xufVxuXG5mdW5jdGlvbiBwcm9jZXNzS2V5IChlbCkge1xuICB2YXIgZXhwID0gZ2V0QmluZGluZ0F0dHIoZWwsICdrZXknKTtcbiAgaWYgKGV4cCkge1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIGVsLnRhZyA9PT0gJ3RlbXBsYXRlJykge1xuICAgICAgd2FybiQyKFwiPHRlbXBsYXRlPiBjYW5ub3QgYmUga2V5ZWQuIFBsYWNlIHRoZSBrZXkgb24gcmVhbCBlbGVtZW50cyBpbnN0ZWFkLlwiKTtcbiAgICB9XG4gICAgZWwua2V5ID0gZXhwO1xuICB9XG59XG5cbmZ1bmN0aW9uIHByb2Nlc3NSZWYgKGVsKSB7XG4gIHZhciByZWYgPSBnZXRCaW5kaW5nQXR0cihlbCwgJ3JlZicpO1xuICBpZiAocmVmKSB7XG4gICAgZWwucmVmID0gcmVmO1xuICAgIGVsLnJlZkluRm9yID0gY2hlY2tJbkZvcihlbCk7XG4gIH1cbn1cblxuZnVuY3Rpb24gcHJvY2Vzc0ZvciAoZWwpIHtcbiAgdmFyIGV4cDtcbiAgaWYgKChleHAgPSBnZXRBbmRSZW1vdmVBdHRyKGVsLCAndi1mb3InKSkpIHtcbiAgICB2YXIgaW5NYXRjaCA9IGV4cC5tYXRjaChmb3JBbGlhc1JFKTtcbiAgICBpZiAoIWluTWF0Y2gpIHtcbiAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgd2FybiQyKFxuICAgICAgICAoXCJJbnZhbGlkIHYtZm9yIGV4cHJlc3Npb246IFwiICsgZXhwKVxuICAgICAgKTtcbiAgICAgIHJldHVyblxuICAgIH1cbiAgICBlbC5mb3IgPSBpbk1hdGNoWzJdLnRyaW0oKTtcbiAgICB2YXIgYWxpYXMgPSBpbk1hdGNoWzFdLnRyaW0oKS5yZXBsYWNlKHN0cmlwUGFyZW5zUkUsICcnKTtcbiAgICB2YXIgaXRlcmF0b3JNYXRjaCA9IGFsaWFzLm1hdGNoKGZvckl0ZXJhdG9yUkUpO1xuICAgIGlmIChpdGVyYXRvck1hdGNoKSB7XG4gICAgICBlbC5hbGlhcyA9IGFsaWFzLnJlcGxhY2UoZm9ySXRlcmF0b3JSRSwgJycpO1xuICAgICAgZWwuaXRlcmF0b3IxID0gaXRlcmF0b3JNYXRjaFsxXS50cmltKCk7XG4gICAgICBpZiAoaXRlcmF0b3JNYXRjaFsyXSkge1xuICAgICAgICBlbC5pdGVyYXRvcjIgPSBpdGVyYXRvck1hdGNoWzJdLnRyaW0oKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgZWwuYWxpYXMgPSBhbGlhcztcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gcHJvY2Vzc0lmIChlbCkge1xuICB2YXIgZXhwID0gZ2V0QW5kUmVtb3ZlQXR0cihlbCwgJ3YtaWYnKTtcbiAgaWYgKGV4cCkge1xuICAgIGVsLmlmID0gZXhwO1xuICAgIGFkZElmQ29uZGl0aW9uKGVsLCB7XG4gICAgICBleHA6IGV4cCxcbiAgICAgIGJsb2NrOiBlbFxuICAgIH0pO1xuICB9IGVsc2Uge1xuICAgIGlmIChnZXRBbmRSZW1vdmVBdHRyKGVsLCAndi1lbHNlJykgIT0gbnVsbCkge1xuICAgICAgZWwuZWxzZSA9IHRydWU7XG4gICAgfVxuICAgIHZhciBlbHNlaWYgPSBnZXRBbmRSZW1vdmVBdHRyKGVsLCAndi1lbHNlLWlmJyk7XG4gICAgaWYgKGVsc2VpZikge1xuICAgICAgZWwuZWxzZWlmID0gZWxzZWlmO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBwcm9jZXNzSWZDb25kaXRpb25zIChlbCwgcGFyZW50KSB7XG4gIHZhciBwcmV2ID0gZmluZFByZXZFbGVtZW50KHBhcmVudC5jaGlsZHJlbik7XG4gIGlmIChwcmV2ICYmIHByZXYuaWYpIHtcbiAgICBhZGRJZkNvbmRpdGlvbihwcmV2LCB7XG4gICAgICBleHA6IGVsLmVsc2VpZixcbiAgICAgIGJsb2NrOiBlbFxuICAgIH0pO1xuICB9IGVsc2UgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICB3YXJuJDIoXG4gICAgICBcInYtXCIgKyAoZWwuZWxzZWlmID8gKCdlbHNlLWlmPVwiJyArIGVsLmVsc2VpZiArICdcIicpIDogJ2Vsc2UnKSArIFwiIFwiICtcbiAgICAgIFwidXNlZCBvbiBlbGVtZW50IDxcIiArIChlbC50YWcpICsgXCI+IHdpdGhvdXQgY29ycmVzcG9uZGluZyB2LWlmLlwiXG4gICAgKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBmaW5kUHJldkVsZW1lbnQgKGNoaWxkcmVuKSB7XG4gIHZhciBpID0gY2hpbGRyZW4ubGVuZ3RoO1xuICB3aGlsZSAoaS0tKSB7XG4gICAgaWYgKGNoaWxkcmVuW2ldLnR5cGUgPT09IDEpIHtcbiAgICAgIHJldHVybiBjaGlsZHJlbltpXVxuICAgIH0gZWxzZSB7XG4gICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiBjaGlsZHJlbltpXS50ZXh0ICE9PSAnICcpIHtcbiAgICAgICAgd2FybiQyKFxuICAgICAgICAgIFwidGV4dCBcXFwiXCIgKyAoY2hpbGRyZW5baV0udGV4dC50cmltKCkpICsgXCJcXFwiIGJldHdlZW4gdi1pZiBhbmQgdi1lbHNlKC1pZikgXCIgK1xuICAgICAgICAgIFwid2lsbCBiZSBpZ25vcmVkLlwiXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICBjaGlsZHJlbi5wb3AoKTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gYWRkSWZDb25kaXRpb24gKGVsLCBjb25kaXRpb24pIHtcbiAgaWYgKCFlbC5pZkNvbmRpdGlvbnMpIHtcbiAgICBlbC5pZkNvbmRpdGlvbnMgPSBbXTtcbiAgfVxuICBlbC5pZkNvbmRpdGlvbnMucHVzaChjb25kaXRpb24pO1xufVxuXG5mdW5jdGlvbiBwcm9jZXNzT25jZSAoZWwpIHtcbiAgdmFyIG9uY2UkJDEgPSBnZXRBbmRSZW1vdmVBdHRyKGVsLCAndi1vbmNlJyk7XG4gIGlmIChvbmNlJCQxICE9IG51bGwpIHtcbiAgICBlbC5vbmNlID0gdHJ1ZTtcbiAgfVxufVxuXG5mdW5jdGlvbiBwcm9jZXNzU2xvdCAoZWwpIHtcbiAgaWYgKGVsLnRhZyA9PT0gJ3Nsb3QnKSB7XG4gICAgZWwuc2xvdE5hbWUgPSBnZXRCaW5kaW5nQXR0cihlbCwgJ25hbWUnKTtcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiBlbC5rZXkpIHtcbiAgICAgIHdhcm4kMihcbiAgICAgICAgXCJga2V5YCBkb2VzIG5vdCB3b3JrIG9uIDxzbG90PiBiZWNhdXNlIHNsb3RzIGFyZSBhYnN0cmFjdCBvdXRsZXRzIFwiICtcbiAgICAgICAgXCJhbmQgY2FuIHBvc3NpYmx5IGV4cGFuZCBpbnRvIG11bHRpcGxlIGVsZW1lbnRzLiBcIiArXG4gICAgICAgIFwiVXNlIHRoZSBrZXkgb24gYSB3cmFwcGluZyBlbGVtZW50IGluc3RlYWQuXCJcbiAgICAgICk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHZhciBzbG90U2NvcGU7XG4gICAgaWYgKGVsLnRhZyA9PT0gJ3RlbXBsYXRlJykge1xuICAgICAgc2xvdFNjb3BlID0gZ2V0QW5kUmVtb3ZlQXR0cihlbCwgJ3Njb3BlJyk7XG4gICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIHNsb3RTY29wZSkge1xuICAgICAgICB3YXJuJDIoXG4gICAgICAgICAgXCJ0aGUgXFxcInNjb3BlXFxcIiBhdHRyaWJ1dGUgZm9yIHNjb3BlZCBzbG90cyBoYXZlIGJlZW4gZGVwcmVjYXRlZCBhbmQgXCIgK1xuICAgICAgICAgIFwicmVwbGFjZWQgYnkgXFxcInNsb3Qtc2NvcGVcXFwiIHNpbmNlIDIuNS4gVGhlIG5ldyBcXFwic2xvdC1zY29wZVxcXCIgYXR0cmlidXRlIFwiICtcbiAgICAgICAgICBcImNhbiBhbHNvIGJlIHVzZWQgb24gcGxhaW4gZWxlbWVudHMgaW4gYWRkaXRpb24gdG8gPHRlbXBsYXRlPiB0byBcIiArXG4gICAgICAgICAgXCJkZW5vdGUgc2NvcGVkIHNsb3RzLlwiLFxuICAgICAgICAgIHRydWVcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIGVsLnNsb3RTY29wZSA9IHNsb3RTY29wZSB8fCBnZXRBbmRSZW1vdmVBdHRyKGVsLCAnc2xvdC1zY29wZScpO1xuICAgIH0gZWxzZSBpZiAoKHNsb3RTY29wZSA9IGdldEFuZFJlbW92ZUF0dHIoZWwsICdzbG90LXNjb3BlJykpKSB7XG4gICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIGVsLmF0dHJzTWFwWyd2LWZvciddKSB7XG4gICAgICAgIHdhcm4kMihcbiAgICAgICAgICBcIkFtYmlndW91cyBjb21iaW5lZCB1c2FnZSBvZiBzbG90LXNjb3BlIGFuZCB2LWZvciBvbiA8XCIgKyAoZWwudGFnKSArIFwiPiBcIiArXG4gICAgICAgICAgXCIodi1mb3IgdGFrZXMgaGlnaGVyIHByaW9yaXR5KS4gVXNlIGEgd3JhcHBlciA8dGVtcGxhdGU+IGZvciB0aGUgXCIgK1xuICAgICAgICAgIFwic2NvcGVkIHNsb3QgdG8gbWFrZSBpdCBjbGVhcmVyLlwiLFxuICAgICAgICAgIHRydWVcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIGVsLnNsb3RTY29wZSA9IHNsb3RTY29wZTtcbiAgICB9XG4gICAgdmFyIHNsb3RUYXJnZXQgPSBnZXRCaW5kaW5nQXR0cihlbCwgJ3Nsb3QnKTtcbiAgICBpZiAoc2xvdFRhcmdldCkge1xuICAgICAgZWwuc2xvdFRhcmdldCA9IHNsb3RUYXJnZXQgPT09ICdcIlwiJyA/ICdcImRlZmF1bHRcIicgOiBzbG90VGFyZ2V0O1xuICAgICAgLy8gcHJlc2VydmUgc2xvdCBhcyBhbiBhdHRyaWJ1dGUgZm9yIG5hdGl2ZSBzaGFkb3cgRE9NIGNvbXBhdFxuICAgICAgLy8gb25seSBmb3Igbm9uLXNjb3BlZCBzbG90cy5cbiAgICAgIGlmIChlbC50YWcgIT09ICd0ZW1wbGF0ZScgJiYgIWVsLnNsb3RTY29wZSkge1xuICAgICAgICBhZGRBdHRyKGVsLCAnc2xvdCcsIHNsb3RUYXJnZXQpO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBwcm9jZXNzQ29tcG9uZW50IChlbCkge1xuICB2YXIgYmluZGluZztcbiAgaWYgKChiaW5kaW5nID0gZ2V0QmluZGluZ0F0dHIoZWwsICdpcycpKSkge1xuICAgIGVsLmNvbXBvbmVudCA9IGJpbmRpbmc7XG4gIH1cbiAgaWYgKGdldEFuZFJlbW92ZUF0dHIoZWwsICdpbmxpbmUtdGVtcGxhdGUnKSAhPSBudWxsKSB7XG4gICAgZWwuaW5saW5lVGVtcGxhdGUgPSB0cnVlO1xuICB9XG59XG5cbmZ1bmN0aW9uIHByb2Nlc3NBdHRycyAoZWwpIHtcbiAgdmFyIGxpc3QgPSBlbC5hdHRyc0xpc3Q7XG4gIHZhciBpLCBsLCBuYW1lLCByYXdOYW1lLCB2YWx1ZSwgbW9kaWZpZXJzLCBpc1Byb3A7XG4gIGZvciAoaSA9IDAsIGwgPSBsaXN0Lmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgIG5hbWUgPSByYXdOYW1lID0gbGlzdFtpXS5uYW1lO1xuICAgIHZhbHVlID0gbGlzdFtpXS52YWx1ZTtcbiAgICBpZiAoZGlyUkUudGVzdChuYW1lKSkge1xuICAgICAgLy8gbWFyayBlbGVtZW50IGFzIGR5bmFtaWNcbiAgICAgIGVsLmhhc0JpbmRpbmdzID0gdHJ1ZTtcbiAgICAgIC8vIG1vZGlmaWVyc1xuICAgICAgbW9kaWZpZXJzID0gcGFyc2VNb2RpZmllcnMobmFtZSk7XG4gICAgICBpZiAobW9kaWZpZXJzKSB7XG4gICAgICAgIG5hbWUgPSBuYW1lLnJlcGxhY2UobW9kaWZpZXJSRSwgJycpO1xuICAgICAgfVxuICAgICAgaWYgKGJpbmRSRS50ZXN0KG5hbWUpKSB7IC8vIHYtYmluZFxuICAgICAgICBuYW1lID0gbmFtZS5yZXBsYWNlKGJpbmRSRSwgJycpO1xuICAgICAgICB2YWx1ZSA9IHBhcnNlRmlsdGVycyh2YWx1ZSk7XG4gICAgICAgIGlzUHJvcCA9IGZhbHNlO1xuICAgICAgICBpZiAobW9kaWZpZXJzKSB7XG4gICAgICAgICAgaWYgKG1vZGlmaWVycy5wcm9wKSB7XG4gICAgICAgICAgICBpc1Byb3AgPSB0cnVlO1xuICAgICAgICAgICAgbmFtZSA9IGNhbWVsaXplKG5hbWUpO1xuICAgICAgICAgICAgaWYgKG5hbWUgPT09ICdpbm5lckh0bWwnKSB7IG5hbWUgPSAnaW5uZXJIVE1MJzsgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAobW9kaWZpZXJzLmNhbWVsKSB7XG4gICAgICAgICAgICBuYW1lID0gY2FtZWxpemUobmFtZSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChtb2RpZmllcnMuc3luYykge1xuICAgICAgICAgICAgYWRkSGFuZGxlcihcbiAgICAgICAgICAgICAgZWwsXG4gICAgICAgICAgICAgIChcInVwZGF0ZTpcIiArIChjYW1lbGl6ZShuYW1lKSkpLFxuICAgICAgICAgICAgICBnZW5Bc3NpZ25tZW50Q29kZSh2YWx1ZSwgXCIkZXZlbnRcIilcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChpc1Byb3AgfHwgKFxuICAgICAgICAgICFlbC5jb21wb25lbnQgJiYgcGxhdGZvcm1NdXN0VXNlUHJvcChlbC50YWcsIGVsLmF0dHJzTWFwLnR5cGUsIG5hbWUpXG4gICAgICAgICkpIHtcbiAgICAgICAgICBhZGRQcm9wKGVsLCBuYW1lLCB2YWx1ZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgYWRkQXR0cihlbCwgbmFtZSwgdmFsdWUpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKG9uUkUudGVzdChuYW1lKSkgeyAvLyB2LW9uXG4gICAgICAgIG5hbWUgPSBuYW1lLnJlcGxhY2Uob25SRSwgJycpO1xuICAgICAgICBhZGRIYW5kbGVyKGVsLCBuYW1lLCB2YWx1ZSwgbW9kaWZpZXJzLCBmYWxzZSwgd2FybiQyKTtcbiAgICAgIH0gZWxzZSB7IC8vIG5vcm1hbCBkaXJlY3RpdmVzXG4gICAgICAgIG5hbWUgPSBuYW1lLnJlcGxhY2UoZGlyUkUsICcnKTtcbiAgICAgICAgLy8gcGFyc2UgYXJnXG4gICAgICAgIHZhciBhcmdNYXRjaCA9IG5hbWUubWF0Y2goYXJnUkUpO1xuICAgICAgICB2YXIgYXJnID0gYXJnTWF0Y2ggJiYgYXJnTWF0Y2hbMV07XG4gICAgICAgIGlmIChhcmcpIHtcbiAgICAgICAgICBuYW1lID0gbmFtZS5zbGljZSgwLCAtKGFyZy5sZW5ndGggKyAxKSk7XG4gICAgICAgIH1cbiAgICAgICAgYWRkRGlyZWN0aXZlKGVsLCBuYW1lLCByYXdOYW1lLCB2YWx1ZSwgYXJnLCBtb2RpZmllcnMpO1xuICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiBuYW1lID09PSAnbW9kZWwnKSB7XG4gICAgICAgICAgY2hlY2tGb3JBbGlhc01vZGVsKGVsLCB2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgLy8gbGl0ZXJhbCBhdHRyaWJ1dGVcbiAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgIHZhciBleHByZXNzaW9uID0gcGFyc2VUZXh0KHZhbHVlLCBkZWxpbWl0ZXJzKTtcbiAgICAgICAgaWYgKGV4cHJlc3Npb24pIHtcbiAgICAgICAgICB3YXJuJDIoXG4gICAgICAgICAgICBuYW1lICsgXCI9XFxcIlwiICsgdmFsdWUgKyBcIlxcXCI6IFwiICtcbiAgICAgICAgICAgICdJbnRlcnBvbGF0aW9uIGluc2lkZSBhdHRyaWJ1dGVzIGhhcyBiZWVuIHJlbW92ZWQuICcgK1xuICAgICAgICAgICAgJ1VzZSB2LWJpbmQgb3IgdGhlIGNvbG9uIHNob3J0aGFuZCBpbnN0ZWFkLiBGb3IgZXhhbXBsZSwgJyArXG4gICAgICAgICAgICAnaW5zdGVhZCBvZiA8ZGl2IGlkPVwie3sgdmFsIH19XCI+LCB1c2UgPGRpdiA6aWQ9XCJ2YWxcIj4uJ1xuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGFkZEF0dHIoZWwsIG5hbWUsIEpTT04uc3RyaW5naWZ5KHZhbHVlKSk7XG4gICAgICAvLyAjNjg4NyBmaXJlZm94IGRvZXNuJ3QgdXBkYXRlIG11dGVkIHN0YXRlIGlmIHNldCB2aWEgYXR0cmlidXRlXG4gICAgICAvLyBldmVuIGltbWVkaWF0ZWx5IGFmdGVyIGVsZW1lbnQgY3JlYXRpb25cbiAgICAgIGlmICghZWwuY29tcG9uZW50ICYmXG4gICAgICAgICAgbmFtZSA9PT0gJ211dGVkJyAmJlxuICAgICAgICAgIHBsYXRmb3JtTXVzdFVzZVByb3AoZWwudGFnLCBlbC5hdHRyc01hcC50eXBlLCBuYW1lKSkge1xuICAgICAgICBhZGRQcm9wKGVsLCBuYW1lLCAndHJ1ZScpO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBjaGVja0luRm9yIChlbCkge1xuICB2YXIgcGFyZW50ID0gZWw7XG4gIHdoaWxlIChwYXJlbnQpIHtcbiAgICBpZiAocGFyZW50LmZvciAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIH1cbiAgICBwYXJlbnQgPSBwYXJlbnQucGFyZW50O1xuICB9XG4gIHJldHVybiBmYWxzZVxufVxuXG5mdW5jdGlvbiBwYXJzZU1vZGlmaWVycyAobmFtZSkge1xuICB2YXIgbWF0Y2ggPSBuYW1lLm1hdGNoKG1vZGlmaWVyUkUpO1xuICBpZiAobWF0Y2gpIHtcbiAgICB2YXIgcmV0ID0ge307XG4gICAgbWF0Y2guZm9yRWFjaChmdW5jdGlvbiAobSkgeyByZXRbbS5zbGljZSgxKV0gPSB0cnVlOyB9KTtcbiAgICByZXR1cm4gcmV0XG4gIH1cbn1cblxuZnVuY3Rpb24gbWFrZUF0dHJzTWFwIChhdHRycykge1xuICB2YXIgbWFwID0ge307XG4gIGZvciAodmFyIGkgPSAwLCBsID0gYXR0cnMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgaWYgKFxuICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJlxuICAgICAgbWFwW2F0dHJzW2ldLm5hbWVdICYmICFpc0lFICYmICFpc0VkZ2VcbiAgICApIHtcbiAgICAgIHdhcm4kMignZHVwbGljYXRlIGF0dHJpYnV0ZTogJyArIGF0dHJzW2ldLm5hbWUpO1xuICAgIH1cbiAgICBtYXBbYXR0cnNbaV0ubmFtZV0gPSBhdHRyc1tpXS52YWx1ZTtcbiAgfVxuICByZXR1cm4gbWFwXG59XG5cbi8vIGZvciBzY3JpcHQgKGUuZy4gdHlwZT1cIngvdGVtcGxhdGVcIikgb3Igc3R5bGUsIGRvIG5vdCBkZWNvZGUgY29udGVudFxuZnVuY3Rpb24gaXNUZXh0VGFnIChlbCkge1xuICByZXR1cm4gZWwudGFnID09PSAnc2NyaXB0JyB8fCBlbC50YWcgPT09ICdzdHlsZSdcbn1cblxuZnVuY3Rpb24gaXNGb3JiaWRkZW5UYWcgKGVsKSB7XG4gIHJldHVybiAoXG4gICAgZWwudGFnID09PSAnc3R5bGUnIHx8XG4gICAgKGVsLnRhZyA9PT0gJ3NjcmlwdCcgJiYgKFxuICAgICAgIWVsLmF0dHJzTWFwLnR5cGUgfHxcbiAgICAgIGVsLmF0dHJzTWFwLnR5cGUgPT09ICd0ZXh0L2phdmFzY3JpcHQnXG4gICAgKSlcbiAgKVxufVxuXG52YXIgaWVOU0J1ZyA9IC9eeG1sbnM6TlNcXGQrLztcbnZhciBpZU5TUHJlZml4ID0gL15OU1xcZCs6LztcblxuLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbmZ1bmN0aW9uIGd1YXJkSUVTVkdCdWcgKGF0dHJzKSB7XG4gIHZhciByZXMgPSBbXTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBhdHRycy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBhdHRyID0gYXR0cnNbaV07XG4gICAgaWYgKCFpZU5TQnVnLnRlc3QoYXR0ci5uYW1lKSkge1xuICAgICAgYXR0ci5uYW1lID0gYXR0ci5uYW1lLnJlcGxhY2UoaWVOU1ByZWZpeCwgJycpO1xuICAgICAgcmVzLnB1c2goYXR0cik7XG4gICAgfVxuICB9XG4gIHJldHVybiByZXNcbn1cblxuZnVuY3Rpb24gY2hlY2tGb3JBbGlhc01vZGVsIChlbCwgdmFsdWUpIHtcbiAgdmFyIF9lbCA9IGVsO1xuICB3aGlsZSAoX2VsKSB7XG4gICAgaWYgKF9lbC5mb3IgJiYgX2VsLmFsaWFzID09PSB2YWx1ZSkge1xuICAgICAgd2FybiQyKFxuICAgICAgICBcIjxcIiArIChlbC50YWcpICsgXCIgdi1tb2RlbD1cXFwiXCIgKyB2YWx1ZSArIFwiXFxcIj46IFwiICtcbiAgICAgICAgXCJZb3UgYXJlIGJpbmRpbmcgdi1tb2RlbCBkaXJlY3RseSB0byBhIHYtZm9yIGl0ZXJhdGlvbiBhbGlhcy4gXCIgK1xuICAgICAgICBcIlRoaXMgd2lsbCBub3QgYmUgYWJsZSB0byBtb2RpZnkgdGhlIHYtZm9yIHNvdXJjZSBhcnJheSBiZWNhdXNlIFwiICtcbiAgICAgICAgXCJ3cml0aW5nIHRvIHRoZSBhbGlhcyBpcyBsaWtlIG1vZGlmeWluZyBhIGZ1bmN0aW9uIGxvY2FsIHZhcmlhYmxlLiBcIiArXG4gICAgICAgIFwiQ29uc2lkZXIgdXNpbmcgYW4gYXJyYXkgb2Ygb2JqZWN0cyBhbmQgdXNlIHYtbW9kZWwgb24gYW4gb2JqZWN0IHByb3BlcnR5IGluc3RlYWQuXCJcbiAgICAgICk7XG4gICAgfVxuICAgIF9lbCA9IF9lbC5wYXJlbnQ7XG4gIH1cbn1cblxuLyogICovXG5cbi8qKlxuICogRXhwYW5kIGlucHV0W3YtbW9kZWxdIHdpdGggZHlhbm1pYyB0eXBlIGJpbmRpbmdzIGludG8gdi1pZi1lbHNlIGNoYWluc1xuICogVHVybiB0aGlzOlxuICogICA8aW5wdXQgdi1tb2RlbD1cImRhdGFbdHlwZV1cIiA6dHlwZT1cInR5cGVcIj5cbiAqIGludG8gdGhpczpcbiAqICAgPGlucHV0IHYtaWY9XCJ0eXBlID09PSAnY2hlY2tib3gnXCIgdHlwZT1cImNoZWNrYm94XCIgdi1tb2RlbD1cImRhdGFbdHlwZV1cIj5cbiAqICAgPGlucHV0IHYtZWxzZS1pZj1cInR5cGUgPT09ICdyYWRpbydcIiB0eXBlPVwicmFkaW9cIiB2LW1vZGVsPVwiZGF0YVt0eXBlXVwiPlxuICogICA8aW5wdXQgdi1lbHNlIDp0eXBlPVwidHlwZVwiIHYtbW9kZWw9XCJkYXRhW3R5cGVdXCI+XG4gKi9cblxuZnVuY3Rpb24gcHJlVHJhbnNmb3JtTm9kZSAoZWwsIG9wdGlvbnMpIHtcbiAgaWYgKGVsLnRhZyA9PT0gJ2lucHV0Jykge1xuICAgIHZhciBtYXAgPSBlbC5hdHRyc01hcDtcbiAgICBpZiAobWFwWyd2LW1vZGVsJ10gJiYgKG1hcFsndi1iaW5kOnR5cGUnXSB8fCBtYXBbJzp0eXBlJ10pKSB7XG4gICAgICB2YXIgdHlwZUJpbmRpbmcgPSBnZXRCaW5kaW5nQXR0cihlbCwgJ3R5cGUnKTtcbiAgICAgIHZhciBpZkNvbmRpdGlvbiA9IGdldEFuZFJlbW92ZUF0dHIoZWwsICd2LWlmJywgdHJ1ZSk7XG4gICAgICB2YXIgaWZDb25kaXRpb25FeHRyYSA9IGlmQ29uZGl0aW9uID8gKFwiJiYoXCIgKyBpZkNvbmRpdGlvbiArIFwiKVwiKSA6IFwiXCI7XG4gICAgICB2YXIgaGFzRWxzZSA9IGdldEFuZFJlbW92ZUF0dHIoZWwsICd2LWVsc2UnLCB0cnVlKSAhPSBudWxsO1xuICAgICAgdmFyIGVsc2VJZkNvbmRpdGlvbiA9IGdldEFuZFJlbW92ZUF0dHIoZWwsICd2LWVsc2UtaWYnLCB0cnVlKTtcbiAgICAgIC8vIDEuIGNoZWNrYm94XG4gICAgICB2YXIgYnJhbmNoMCA9IGNsb25lQVNURWxlbWVudChlbCk7XG4gICAgICAvLyBwcm9jZXNzIGZvciBvbiB0aGUgbWFpbiBub2RlXG4gICAgICBwcm9jZXNzRm9yKGJyYW5jaDApO1xuICAgICAgYWRkUmF3QXR0cihicmFuY2gwLCAndHlwZScsICdjaGVja2JveCcpO1xuICAgICAgcHJvY2Vzc0VsZW1lbnQoYnJhbmNoMCwgb3B0aW9ucyk7XG4gICAgICBicmFuY2gwLnByb2Nlc3NlZCA9IHRydWU7IC8vIHByZXZlbnQgaXQgZnJvbSBkb3VibGUtcHJvY2Vzc2VkXG4gICAgICBicmFuY2gwLmlmID0gXCIoXCIgKyB0eXBlQmluZGluZyArIFwiKT09PSdjaGVja2JveCdcIiArIGlmQ29uZGl0aW9uRXh0cmE7XG4gICAgICBhZGRJZkNvbmRpdGlvbihicmFuY2gwLCB7XG4gICAgICAgIGV4cDogYnJhbmNoMC5pZixcbiAgICAgICAgYmxvY2s6IGJyYW5jaDBcbiAgICAgIH0pO1xuICAgICAgLy8gMi4gYWRkIHJhZGlvIGVsc2UtaWYgY29uZGl0aW9uXG4gICAgICB2YXIgYnJhbmNoMSA9IGNsb25lQVNURWxlbWVudChlbCk7XG4gICAgICBnZXRBbmRSZW1vdmVBdHRyKGJyYW5jaDEsICd2LWZvcicsIHRydWUpO1xuICAgICAgYWRkUmF3QXR0cihicmFuY2gxLCAndHlwZScsICdyYWRpbycpO1xuICAgICAgcHJvY2Vzc0VsZW1lbnQoYnJhbmNoMSwgb3B0aW9ucyk7XG4gICAgICBhZGRJZkNvbmRpdGlvbihicmFuY2gwLCB7XG4gICAgICAgIGV4cDogXCIoXCIgKyB0eXBlQmluZGluZyArIFwiKT09PSdyYWRpbydcIiArIGlmQ29uZGl0aW9uRXh0cmEsXG4gICAgICAgIGJsb2NrOiBicmFuY2gxXG4gICAgICB9KTtcbiAgICAgIC8vIDMuIG90aGVyXG4gICAgICB2YXIgYnJhbmNoMiA9IGNsb25lQVNURWxlbWVudChlbCk7XG4gICAgICBnZXRBbmRSZW1vdmVBdHRyKGJyYW5jaDIsICd2LWZvcicsIHRydWUpO1xuICAgICAgYWRkUmF3QXR0cihicmFuY2gyLCAnOnR5cGUnLCB0eXBlQmluZGluZyk7XG4gICAgICBwcm9jZXNzRWxlbWVudChicmFuY2gyLCBvcHRpb25zKTtcbiAgICAgIGFkZElmQ29uZGl0aW9uKGJyYW5jaDAsIHtcbiAgICAgICAgZXhwOiBpZkNvbmRpdGlvbixcbiAgICAgICAgYmxvY2s6IGJyYW5jaDJcbiAgICAgIH0pO1xuXG4gICAgICBpZiAoaGFzRWxzZSkge1xuICAgICAgICBicmFuY2gwLmVsc2UgPSB0cnVlO1xuICAgICAgfSBlbHNlIGlmIChlbHNlSWZDb25kaXRpb24pIHtcbiAgICAgICAgYnJhbmNoMC5lbHNlaWYgPSBlbHNlSWZDb25kaXRpb247XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBicmFuY2gwXG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGNsb25lQVNURWxlbWVudCAoZWwpIHtcbiAgcmV0dXJuIGNyZWF0ZUFTVEVsZW1lbnQoZWwudGFnLCBlbC5hdHRyc0xpc3Quc2xpY2UoKSwgZWwucGFyZW50KVxufVxuXG5mdW5jdGlvbiBhZGRSYXdBdHRyIChlbCwgbmFtZSwgdmFsdWUpIHtcbiAgZWwuYXR0cnNNYXBbbmFtZV0gPSB2YWx1ZTtcbiAgZWwuYXR0cnNMaXN0LnB1c2goeyBuYW1lOiBuYW1lLCB2YWx1ZTogdmFsdWUgfSk7XG59XG5cbnZhciBtb2RlbCQyID0ge1xuICBwcmVUcmFuc2Zvcm1Ob2RlOiBwcmVUcmFuc2Zvcm1Ob2RlXG59O1xuXG52YXIgbW9kdWxlcyQxID0gW1xuICBrbGFzcyQxLFxuICBzdHlsZSQxLFxuICBtb2RlbCQyXG5dO1xuXG4vKiAgKi9cblxuZnVuY3Rpb24gdGV4dCAoZWwsIGRpcikge1xuICBpZiAoZGlyLnZhbHVlKSB7XG4gICAgYWRkUHJvcChlbCwgJ3RleHRDb250ZW50JywgKFwiX3MoXCIgKyAoZGlyLnZhbHVlKSArIFwiKVwiKSk7XG4gIH1cbn1cblxuLyogICovXG5cbmZ1bmN0aW9uIGh0bWwgKGVsLCBkaXIpIHtcbiAgaWYgKGRpci52YWx1ZSkge1xuICAgIGFkZFByb3AoZWwsICdpbm5lckhUTUwnLCAoXCJfcyhcIiArIChkaXIudmFsdWUpICsgXCIpXCIpKTtcbiAgfVxufVxuXG52YXIgZGlyZWN0aXZlcyQxID0ge1xuICBtb2RlbDogbW9kZWwsXG4gIHRleHQ6IHRleHQsXG4gIGh0bWw6IGh0bWxcbn07XG5cbi8qICAqL1xuXG52YXIgYmFzZU9wdGlvbnMgPSB7XG4gIGV4cGVjdEhUTUw6IHRydWUsXG4gIG1vZHVsZXM6IG1vZHVsZXMkMSxcbiAgZGlyZWN0aXZlczogZGlyZWN0aXZlcyQxLFxuICBpc1ByZVRhZzogaXNQcmVUYWcsXG4gIGlzVW5hcnlUYWc6IGlzVW5hcnlUYWcsXG4gIG11c3RVc2VQcm9wOiBtdXN0VXNlUHJvcCxcbiAgY2FuQmVMZWZ0T3BlblRhZzogY2FuQmVMZWZ0T3BlblRhZyxcbiAgaXNSZXNlcnZlZFRhZzogaXNSZXNlcnZlZFRhZyxcbiAgZ2V0VGFnTmFtZXNwYWNlOiBnZXRUYWdOYW1lc3BhY2UsXG4gIHN0YXRpY0tleXM6IGdlblN0YXRpY0tleXMobW9kdWxlcyQxKVxufTtcblxuLyogICovXG5cbnZhciBpc1N0YXRpY0tleTtcbnZhciBpc1BsYXRmb3JtUmVzZXJ2ZWRUYWc7XG5cbnZhciBnZW5TdGF0aWNLZXlzQ2FjaGVkID0gY2FjaGVkKGdlblN0YXRpY0tleXMkMSk7XG5cbi8qKlxuICogR29hbCBvZiB0aGUgb3B0aW1pemVyOiB3YWxrIHRoZSBnZW5lcmF0ZWQgdGVtcGxhdGUgQVNUIHRyZWVcbiAqIGFuZCBkZXRlY3Qgc3ViLXRyZWVzIHRoYXQgYXJlIHB1cmVseSBzdGF0aWMsIGkuZS4gcGFydHMgb2ZcbiAqIHRoZSBET00gdGhhdCBuZXZlciBuZWVkcyB0byBjaGFuZ2UuXG4gKlxuICogT25jZSB3ZSBkZXRlY3QgdGhlc2Ugc3ViLXRyZWVzLCB3ZSBjYW46XG4gKlxuICogMS4gSG9pc3QgdGhlbSBpbnRvIGNvbnN0YW50cywgc28gdGhhdCB3ZSBubyBsb25nZXIgbmVlZCB0b1xuICogICAgY3JlYXRlIGZyZXNoIG5vZGVzIGZvciB0aGVtIG9uIGVhY2ggcmUtcmVuZGVyO1xuICogMi4gQ29tcGxldGVseSBza2lwIHRoZW0gaW4gdGhlIHBhdGNoaW5nIHByb2Nlc3MuXG4gKi9cbmZ1bmN0aW9uIG9wdGltaXplIChyb290LCBvcHRpb25zKSB7XG4gIGlmICghcm9vdCkgeyByZXR1cm4gfVxuICBpc1N0YXRpY0tleSA9IGdlblN0YXRpY0tleXNDYWNoZWQob3B0aW9ucy5zdGF0aWNLZXlzIHx8ICcnKTtcbiAgaXNQbGF0Zm9ybVJlc2VydmVkVGFnID0gb3B0aW9ucy5pc1Jlc2VydmVkVGFnIHx8IG5vO1xuICAvLyBmaXJzdCBwYXNzOiBtYXJrIGFsbCBub24tc3RhdGljIG5vZGVzLlxuICBtYXJrU3RhdGljJDEocm9vdCk7XG4gIC8vIHNlY29uZCBwYXNzOiBtYXJrIHN0YXRpYyByb290cy5cbiAgbWFya1N0YXRpY1Jvb3RzKHJvb3QsIGZhbHNlKTtcbn1cblxuZnVuY3Rpb24gZ2VuU3RhdGljS2V5cyQxIChrZXlzKSB7XG4gIHJldHVybiBtYWtlTWFwKFxuICAgICd0eXBlLHRhZyxhdHRyc0xpc3QsYXR0cnNNYXAscGxhaW4scGFyZW50LGNoaWxkcmVuLGF0dHJzJyArXG4gICAgKGtleXMgPyAnLCcgKyBrZXlzIDogJycpXG4gIClcbn1cblxuZnVuY3Rpb24gbWFya1N0YXRpYyQxIChub2RlKSB7XG4gIG5vZGUuc3RhdGljID0gaXNTdGF0aWMobm9kZSk7XG4gIGlmIChub2RlLnR5cGUgPT09IDEpIHtcbiAgICAvLyBkbyBub3QgbWFrZSBjb21wb25lbnQgc2xvdCBjb250ZW50IHN0YXRpYy4gdGhpcyBhdm9pZHNcbiAgICAvLyAxLiBjb21wb25lbnRzIG5vdCBhYmxlIHRvIG11dGF0ZSBzbG90IG5vZGVzXG4gICAgLy8gMi4gc3RhdGljIHNsb3QgY29udGVudCBmYWlscyBmb3IgaG90LXJlbG9hZGluZ1xuICAgIGlmIChcbiAgICAgICFpc1BsYXRmb3JtUmVzZXJ2ZWRUYWcobm9kZS50YWcpICYmXG4gICAgICBub2RlLnRhZyAhPT0gJ3Nsb3QnICYmXG4gICAgICBub2RlLmF0dHJzTWFwWydpbmxpbmUtdGVtcGxhdGUnXSA9PSBudWxsXG4gICAgKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG4gICAgZm9yICh2YXIgaSA9IDAsIGwgPSBub2RlLmNoaWxkcmVuLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgdmFyIGNoaWxkID0gbm9kZS5jaGlsZHJlbltpXTtcbiAgICAgIG1hcmtTdGF0aWMkMShjaGlsZCk7XG4gICAgICBpZiAoIWNoaWxkLnN0YXRpYykge1xuICAgICAgICBub2RlLnN0YXRpYyA9IGZhbHNlO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAobm9kZS5pZkNvbmRpdGlvbnMpIHtcbiAgICAgIGZvciAodmFyIGkkMSA9IDEsIGwkMSA9IG5vZGUuaWZDb25kaXRpb25zLmxlbmd0aDsgaSQxIDwgbCQxOyBpJDErKykge1xuICAgICAgICB2YXIgYmxvY2sgPSBub2RlLmlmQ29uZGl0aW9uc1tpJDFdLmJsb2NrO1xuICAgICAgICBtYXJrU3RhdGljJDEoYmxvY2spO1xuICAgICAgICBpZiAoIWJsb2NrLnN0YXRpYykge1xuICAgICAgICAgIG5vZGUuc3RhdGljID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gbWFya1N0YXRpY1Jvb3RzIChub2RlLCBpc0luRm9yKSB7XG4gIGlmIChub2RlLnR5cGUgPT09IDEpIHtcbiAgICBpZiAobm9kZS5zdGF0aWMgfHwgbm9kZS5vbmNlKSB7XG4gICAgICBub2RlLnN0YXRpY0luRm9yID0gaXNJbkZvcjtcbiAgICB9XG4gICAgLy8gRm9yIGEgbm9kZSB0byBxdWFsaWZ5IGFzIGEgc3RhdGljIHJvb3QsIGl0IHNob3VsZCBoYXZlIGNoaWxkcmVuIHRoYXRcbiAgICAvLyBhcmUgbm90IGp1c3Qgc3RhdGljIHRleHQuIE90aGVyd2lzZSB0aGUgY29zdCBvZiBob2lzdGluZyBvdXQgd2lsbFxuICAgIC8vIG91dHdlaWdoIHRoZSBiZW5lZml0cyBhbmQgaXQncyBiZXR0ZXIgb2ZmIHRvIGp1c3QgYWx3YXlzIHJlbmRlciBpdCBmcmVzaC5cbiAgICBpZiAobm9kZS5zdGF0aWMgJiYgbm9kZS5jaGlsZHJlbi5sZW5ndGggJiYgIShcbiAgICAgIG5vZGUuY2hpbGRyZW4ubGVuZ3RoID09PSAxICYmXG4gICAgICBub2RlLmNoaWxkcmVuWzBdLnR5cGUgPT09IDNcbiAgICApKSB7XG4gICAgICBub2RlLnN0YXRpY1Jvb3QgPSB0cnVlO1xuICAgICAgcmV0dXJuXG4gICAgfSBlbHNlIHtcbiAgICAgIG5vZGUuc3RhdGljUm9vdCA9IGZhbHNlO1xuICAgIH1cbiAgICBpZiAobm9kZS5jaGlsZHJlbikge1xuICAgICAgZm9yICh2YXIgaSA9IDAsIGwgPSBub2RlLmNoaWxkcmVuLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICBtYXJrU3RhdGljUm9vdHMobm9kZS5jaGlsZHJlbltpXSwgaXNJbkZvciB8fCAhIW5vZGUuZm9yKTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKG5vZGUuaWZDb25kaXRpb25zKSB7XG4gICAgICBmb3IgKHZhciBpJDEgPSAxLCBsJDEgPSBub2RlLmlmQ29uZGl0aW9ucy5sZW5ndGg7IGkkMSA8IGwkMTsgaSQxKyspIHtcbiAgICAgICAgbWFya1N0YXRpY1Jvb3RzKG5vZGUuaWZDb25kaXRpb25zW2kkMV0uYmxvY2ssIGlzSW5Gb3IpO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBpc1N0YXRpYyAobm9kZSkge1xuICBpZiAobm9kZS50eXBlID09PSAyKSB7IC8vIGV4cHJlc3Npb25cbiAgICByZXR1cm4gZmFsc2VcbiAgfVxuICBpZiAobm9kZS50eXBlID09PSAzKSB7IC8vIHRleHRcbiAgICByZXR1cm4gdHJ1ZVxuICB9XG4gIHJldHVybiAhIShub2RlLnByZSB8fCAoXG4gICAgIW5vZGUuaGFzQmluZGluZ3MgJiYgLy8gbm8gZHluYW1pYyBiaW5kaW5nc1xuICAgICFub2RlLmlmICYmICFub2RlLmZvciAmJiAvLyBub3Qgdi1pZiBvciB2LWZvciBvciB2LWVsc2VcbiAgICAhaXNCdWlsdEluVGFnKG5vZGUudGFnKSAmJiAvLyBub3QgYSBidWlsdC1pblxuICAgIGlzUGxhdGZvcm1SZXNlcnZlZFRhZyhub2RlLnRhZykgJiYgLy8gbm90IGEgY29tcG9uZW50XG4gICAgIWlzRGlyZWN0Q2hpbGRPZlRlbXBsYXRlRm9yKG5vZGUpICYmXG4gICAgT2JqZWN0LmtleXMobm9kZSkuZXZlcnkoaXNTdGF0aWNLZXkpXG4gICkpXG59XG5cbmZ1bmN0aW9uIGlzRGlyZWN0Q2hpbGRPZlRlbXBsYXRlRm9yIChub2RlKSB7XG4gIHdoaWxlIChub2RlLnBhcmVudCkge1xuICAgIG5vZGUgPSBub2RlLnBhcmVudDtcbiAgICBpZiAobm9kZS50YWcgIT09ICd0ZW1wbGF0ZScpIHtcbiAgICAgIHJldHVybiBmYWxzZVxuICAgIH1cbiAgICBpZiAobm9kZS5mb3IpIHtcbiAgICAgIHJldHVybiB0cnVlXG4gICAgfVxuICB9XG4gIHJldHVybiBmYWxzZVxufVxuXG4vKiAgKi9cblxudmFyIGZuRXhwUkUgPSAvXlxccyooW1xcdyRfXSt8XFwoW14pXSo/XFwpKVxccyo9PnxeZnVuY3Rpb25cXHMqXFwoLztcbnZhciBzaW1wbGVQYXRoUkUgPSAvXlxccypbQS1aYS16XyRdW1xcdyRdKig/OlxcLltBLVphLXpfJF1bXFx3JF0qfFxcWycuKj8nXXxcXFtcIi4qP1wiXXxcXFtcXGQrXXxcXFtbQS1aYS16XyRdW1xcdyRdKl0pKlxccyokLztcblxuLy8ga2V5Q29kZSBhbGlhc2VzXG52YXIga2V5Q29kZXMgPSB7XG4gIGVzYzogMjcsXG4gIHRhYjogOSxcbiAgZW50ZXI6IDEzLFxuICBzcGFjZTogMzIsXG4gIHVwOiAzOCxcbiAgbGVmdDogMzcsXG4gIHJpZ2h0OiAzOSxcbiAgZG93bjogNDAsXG4gICdkZWxldGUnOiBbOCwgNDZdXG59O1xuXG4vLyAjNDg2ODogbW9kaWZpZXJzIHRoYXQgcHJldmVudCB0aGUgZXhlY3V0aW9uIG9mIHRoZSBsaXN0ZW5lclxuLy8gbmVlZCB0byBleHBsaWNpdGx5IHJldHVybiBudWxsIHNvIHRoYXQgd2UgY2FuIGRldGVybWluZSB3aGV0aGVyIHRvIHJlbW92ZVxuLy8gdGhlIGxpc3RlbmVyIGZvciAub25jZVxudmFyIGdlbkd1YXJkID0gZnVuY3Rpb24gKGNvbmRpdGlvbikgeyByZXR1cm4gKFwiaWYoXCIgKyBjb25kaXRpb24gKyBcIilyZXR1cm4gbnVsbDtcIik7IH07XG5cbnZhciBtb2RpZmllckNvZGUgPSB7XG4gIHN0b3A6ICckZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7JyxcbiAgcHJldmVudDogJyRldmVudC5wcmV2ZW50RGVmYXVsdCgpOycsXG4gIHNlbGY6IGdlbkd1YXJkKFwiJGV2ZW50LnRhcmdldCAhPT0gJGV2ZW50LmN1cnJlbnRUYXJnZXRcIiksXG4gIGN0cmw6IGdlbkd1YXJkKFwiISRldmVudC5jdHJsS2V5XCIpLFxuICBzaGlmdDogZ2VuR3VhcmQoXCIhJGV2ZW50LnNoaWZ0S2V5XCIpLFxuICBhbHQ6IGdlbkd1YXJkKFwiISRldmVudC5hbHRLZXlcIiksXG4gIG1ldGE6IGdlbkd1YXJkKFwiISRldmVudC5tZXRhS2V5XCIpLFxuICBsZWZ0OiBnZW5HdWFyZChcIididXR0b24nIGluICRldmVudCAmJiAkZXZlbnQuYnV0dG9uICE9PSAwXCIpLFxuICBtaWRkbGU6IGdlbkd1YXJkKFwiJ2J1dHRvbicgaW4gJGV2ZW50ICYmICRldmVudC5idXR0b24gIT09IDFcIiksXG4gIHJpZ2h0OiBnZW5HdWFyZChcIididXR0b24nIGluICRldmVudCAmJiAkZXZlbnQuYnV0dG9uICE9PSAyXCIpXG59O1xuXG5mdW5jdGlvbiBnZW5IYW5kbGVycyAoXG4gIGV2ZW50cyxcbiAgaXNOYXRpdmUsXG4gIHdhcm5cbikge1xuICB2YXIgcmVzID0gaXNOYXRpdmUgPyAnbmF0aXZlT246eycgOiAnb246eyc7XG4gIGZvciAodmFyIG5hbWUgaW4gZXZlbnRzKSB7XG4gICAgcmVzICs9IFwiXFxcIlwiICsgbmFtZSArIFwiXFxcIjpcIiArIChnZW5IYW5kbGVyKG5hbWUsIGV2ZW50c1tuYW1lXSkpICsgXCIsXCI7XG4gIH1cbiAgcmV0dXJuIHJlcy5zbGljZSgwLCAtMSkgKyAnfSdcbn1cblxuZnVuY3Rpb24gZ2VuSGFuZGxlciAoXG4gIG5hbWUsXG4gIGhhbmRsZXJcbikge1xuICBpZiAoIWhhbmRsZXIpIHtcbiAgICByZXR1cm4gJ2Z1bmN0aW9uKCl7fSdcbiAgfVxuXG4gIGlmIChBcnJheS5pc0FycmF5KGhhbmRsZXIpKSB7XG4gICAgcmV0dXJuIChcIltcIiArIChoYW5kbGVyLm1hcChmdW5jdGlvbiAoaGFuZGxlcikgeyByZXR1cm4gZ2VuSGFuZGxlcihuYW1lLCBoYW5kbGVyKTsgfSkuam9pbignLCcpKSArIFwiXVwiKVxuICB9XG5cbiAgdmFyIGlzTWV0aG9kUGF0aCA9IHNpbXBsZVBhdGhSRS50ZXN0KGhhbmRsZXIudmFsdWUpO1xuICB2YXIgaXNGdW5jdGlvbkV4cHJlc3Npb24gPSBmbkV4cFJFLnRlc3QoaGFuZGxlci52YWx1ZSk7XG5cbiAgaWYgKCFoYW5kbGVyLm1vZGlmaWVycykge1xuICAgIHJldHVybiBpc01ldGhvZFBhdGggfHwgaXNGdW5jdGlvbkV4cHJlc3Npb25cbiAgICAgID8gaGFuZGxlci52YWx1ZVxuICAgICAgOiAoXCJmdW5jdGlvbigkZXZlbnQpe1wiICsgKGhhbmRsZXIudmFsdWUpICsgXCJ9XCIpIC8vIGlubGluZSBzdGF0ZW1lbnRcbiAgfSBlbHNlIHtcbiAgICB2YXIgY29kZSA9ICcnO1xuICAgIHZhciBnZW5Nb2RpZmllckNvZGUgPSAnJztcbiAgICB2YXIga2V5cyA9IFtdO1xuICAgIGZvciAodmFyIGtleSBpbiBoYW5kbGVyLm1vZGlmaWVycykge1xuICAgICAgaWYgKG1vZGlmaWVyQ29kZVtrZXldKSB7XG4gICAgICAgIGdlbk1vZGlmaWVyQ29kZSArPSBtb2RpZmllckNvZGVba2V5XTtcbiAgICAgICAgLy8gbGVmdC9yaWdodFxuICAgICAgICBpZiAoa2V5Q29kZXNba2V5XSkge1xuICAgICAgICAgIGtleXMucHVzaChrZXkpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKGtleSA9PT0gJ2V4YWN0Jykge1xuICAgICAgICB2YXIgbW9kaWZpZXJzID0gKGhhbmRsZXIubW9kaWZpZXJzKTtcbiAgICAgICAgZ2VuTW9kaWZpZXJDb2RlICs9IGdlbkd1YXJkKFxuICAgICAgICAgIFsnY3RybCcsICdzaGlmdCcsICdhbHQnLCAnbWV0YSddXG4gICAgICAgICAgICAuZmlsdGVyKGZ1bmN0aW9uIChrZXlNb2RpZmllcikgeyByZXR1cm4gIW1vZGlmaWVyc1trZXlNb2RpZmllcl07IH0pXG4gICAgICAgICAgICAubWFwKGZ1bmN0aW9uIChrZXlNb2RpZmllcikgeyByZXR1cm4gKFwiJGV2ZW50LlwiICsga2V5TW9kaWZpZXIgKyBcIktleVwiKTsgfSlcbiAgICAgICAgICAgIC5qb2luKCd8fCcpXG4gICAgICAgICk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBrZXlzLnB1c2goa2V5KTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGtleXMubGVuZ3RoKSB7XG4gICAgICBjb2RlICs9IGdlbktleUZpbHRlcihrZXlzKTtcbiAgICB9XG4gICAgLy8gTWFrZSBzdXJlIG1vZGlmaWVycyBsaWtlIHByZXZlbnQgYW5kIHN0b3AgZ2V0IGV4ZWN1dGVkIGFmdGVyIGtleSBmaWx0ZXJpbmdcbiAgICBpZiAoZ2VuTW9kaWZpZXJDb2RlKSB7XG4gICAgICBjb2RlICs9IGdlbk1vZGlmaWVyQ29kZTtcbiAgICB9XG4gICAgdmFyIGhhbmRsZXJDb2RlID0gaXNNZXRob2RQYXRoXG4gICAgICA/IGhhbmRsZXIudmFsdWUgKyAnKCRldmVudCknXG4gICAgICA6IGlzRnVuY3Rpb25FeHByZXNzaW9uXG4gICAgICAgID8gKFwiKFwiICsgKGhhbmRsZXIudmFsdWUpICsgXCIpKCRldmVudClcIilcbiAgICAgICAgOiBoYW5kbGVyLnZhbHVlO1xuICAgIHJldHVybiAoXCJmdW5jdGlvbigkZXZlbnQpe1wiICsgY29kZSArIGhhbmRsZXJDb2RlICsgXCJ9XCIpXG4gIH1cbn1cblxuZnVuY3Rpb24gZ2VuS2V5RmlsdGVyIChrZXlzKSB7XG4gIHJldHVybiAoXCJpZighKCdidXR0b24nIGluICRldmVudCkmJlwiICsgKGtleXMubWFwKGdlbkZpbHRlckNvZGUpLmpvaW4oJyYmJykpICsgXCIpcmV0dXJuIG51bGw7XCIpXG59XG5cbmZ1bmN0aW9uIGdlbkZpbHRlckNvZGUgKGtleSkge1xuICB2YXIga2V5VmFsID0gcGFyc2VJbnQoa2V5LCAxMCk7XG4gIGlmIChrZXlWYWwpIHtcbiAgICByZXR1cm4gKFwiJGV2ZW50LmtleUNvZGUhPT1cIiArIGtleVZhbClcbiAgfVxuICB2YXIgY29kZSA9IGtleUNvZGVzW2tleV07XG4gIHJldHVybiAoXG4gICAgXCJfaygkZXZlbnQua2V5Q29kZSxcIiArXG4gICAgKEpTT04uc3RyaW5naWZ5KGtleSkpICsgXCIsXCIgK1xuICAgIChKU09OLnN0cmluZ2lmeShjb2RlKSkgKyBcIixcIiArXG4gICAgXCIkZXZlbnQua2V5KVwiXG4gIClcbn1cblxuLyogICovXG5cbmZ1bmN0aW9uIG9uIChlbCwgZGlyKSB7XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIGRpci5tb2RpZmllcnMpIHtcbiAgICB3YXJuKFwidi1vbiB3aXRob3V0IGFyZ3VtZW50IGRvZXMgbm90IHN1cHBvcnQgbW9kaWZpZXJzLlwiKTtcbiAgfVxuICBlbC53cmFwTGlzdGVuZXJzID0gZnVuY3Rpb24gKGNvZGUpIHsgcmV0dXJuIChcIl9nKFwiICsgY29kZSArIFwiLFwiICsgKGRpci52YWx1ZSkgKyBcIilcIik7IH07XG59XG5cbi8qICAqL1xuXG5mdW5jdGlvbiBiaW5kJDEgKGVsLCBkaXIpIHtcbiAgZWwud3JhcERhdGEgPSBmdW5jdGlvbiAoY29kZSkge1xuICAgIHJldHVybiAoXCJfYihcIiArIGNvZGUgKyBcIiwnXCIgKyAoZWwudGFnKSArIFwiJyxcIiArIChkaXIudmFsdWUpICsgXCIsXCIgKyAoZGlyLm1vZGlmaWVycyAmJiBkaXIubW9kaWZpZXJzLnByb3AgPyAndHJ1ZScgOiAnZmFsc2UnKSArIChkaXIubW9kaWZpZXJzICYmIGRpci5tb2RpZmllcnMuc3luYyA/ICcsdHJ1ZScgOiAnJykgKyBcIilcIilcbiAgfTtcbn1cblxuLyogICovXG5cbnZhciBiYXNlRGlyZWN0aXZlcyA9IHtcbiAgb246IG9uLFxuICBiaW5kOiBiaW5kJDEsXG4gIGNsb2FrOiBub29wXG59O1xuXG4vKiAgKi9cblxudmFyIENvZGVnZW5TdGF0ZSA9IGZ1bmN0aW9uIENvZGVnZW5TdGF0ZSAob3B0aW9ucykge1xuICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zO1xuICB0aGlzLndhcm4gPSBvcHRpb25zLndhcm4gfHwgYmFzZVdhcm47XG4gIHRoaXMudHJhbnNmb3JtcyA9IHBsdWNrTW9kdWxlRnVuY3Rpb24ob3B0aW9ucy5tb2R1bGVzLCAndHJhbnNmb3JtQ29kZScpO1xuICB0aGlzLmRhdGFHZW5GbnMgPSBwbHVja01vZHVsZUZ1bmN0aW9uKG9wdGlvbnMubW9kdWxlcywgJ2dlbkRhdGEnKTtcbiAgdGhpcy5kaXJlY3RpdmVzID0gZXh0ZW5kKGV4dGVuZCh7fSwgYmFzZURpcmVjdGl2ZXMpLCBvcHRpb25zLmRpcmVjdGl2ZXMpO1xuICB2YXIgaXNSZXNlcnZlZFRhZyA9IG9wdGlvbnMuaXNSZXNlcnZlZFRhZyB8fCBubztcbiAgdGhpcy5tYXliZUNvbXBvbmVudCA9IGZ1bmN0aW9uIChlbCkgeyByZXR1cm4gIWlzUmVzZXJ2ZWRUYWcoZWwudGFnKTsgfTtcbiAgdGhpcy5vbmNlSWQgPSAwO1xuICB0aGlzLnN0YXRpY1JlbmRlckZucyA9IFtdO1xufTtcblxuXG5cbmZ1bmN0aW9uIGdlbmVyYXRlIChcbiAgYXN0LFxuICBvcHRpb25zXG4pIHtcbiAgdmFyIHN0YXRlID0gbmV3IENvZGVnZW5TdGF0ZShvcHRpb25zKTtcbiAgdmFyIGNvZGUgPSBhc3QgPyBnZW5FbGVtZW50KGFzdCwgc3RhdGUpIDogJ19jKFwiZGl2XCIpJztcbiAgcmV0dXJuIHtcbiAgICByZW5kZXI6IChcIndpdGgodGhpcyl7cmV0dXJuIFwiICsgY29kZSArIFwifVwiKSxcbiAgICBzdGF0aWNSZW5kZXJGbnM6IHN0YXRlLnN0YXRpY1JlbmRlckZuc1xuICB9XG59XG5cbmZ1bmN0aW9uIGdlbkVsZW1lbnQgKGVsLCBzdGF0ZSkge1xuICBpZiAoZWwuc3RhdGljUm9vdCAmJiAhZWwuc3RhdGljUHJvY2Vzc2VkKSB7XG4gICAgcmV0dXJuIGdlblN0YXRpYyhlbCwgc3RhdGUpXG4gIH0gZWxzZSBpZiAoZWwub25jZSAmJiAhZWwub25jZVByb2Nlc3NlZCkge1xuICAgIHJldHVybiBnZW5PbmNlKGVsLCBzdGF0ZSlcbiAgfSBlbHNlIGlmIChlbC5mb3IgJiYgIWVsLmZvclByb2Nlc3NlZCkge1xuICAgIHJldHVybiBnZW5Gb3IoZWwsIHN0YXRlKVxuICB9IGVsc2UgaWYgKGVsLmlmICYmICFlbC5pZlByb2Nlc3NlZCkge1xuICAgIHJldHVybiBnZW5JZihlbCwgc3RhdGUpXG4gIH0gZWxzZSBpZiAoZWwudGFnID09PSAndGVtcGxhdGUnICYmICFlbC5zbG90VGFyZ2V0KSB7XG4gICAgcmV0dXJuIGdlbkNoaWxkcmVuKGVsLCBzdGF0ZSkgfHwgJ3ZvaWQgMCdcbiAgfSBlbHNlIGlmIChlbC50YWcgPT09ICdzbG90Jykge1xuICAgIHJldHVybiBnZW5TbG90KGVsLCBzdGF0ZSlcbiAgfSBlbHNlIHtcbiAgICAvLyBjb21wb25lbnQgb3IgZWxlbWVudFxuICAgIHZhciBjb2RlO1xuICAgIGlmIChlbC5jb21wb25lbnQpIHtcbiAgICAgIGNvZGUgPSBnZW5Db21wb25lbnQoZWwuY29tcG9uZW50LCBlbCwgc3RhdGUpO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgZGF0YSA9IGVsLnBsYWluID8gdW5kZWZpbmVkIDogZ2VuRGF0YSQyKGVsLCBzdGF0ZSk7XG5cbiAgICAgIHZhciBjaGlsZHJlbiA9IGVsLmlubGluZVRlbXBsYXRlID8gbnVsbCA6IGdlbkNoaWxkcmVuKGVsLCBzdGF0ZSwgdHJ1ZSk7XG4gICAgICBjb2RlID0gXCJfYygnXCIgKyAoZWwudGFnKSArIFwiJ1wiICsgKGRhdGEgPyAoXCIsXCIgKyBkYXRhKSA6ICcnKSArIChjaGlsZHJlbiA/IChcIixcIiArIGNoaWxkcmVuKSA6ICcnKSArIFwiKVwiO1xuICAgIH1cbiAgICAvLyBtb2R1bGUgdHJhbnNmb3Jtc1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc3RhdGUudHJhbnNmb3Jtcy5sZW5ndGg7IGkrKykge1xuICAgICAgY29kZSA9IHN0YXRlLnRyYW5zZm9ybXNbaV0oZWwsIGNvZGUpO1xuICAgIH1cbiAgICByZXR1cm4gY29kZVxuICB9XG59XG5cbi8vIGhvaXN0IHN0YXRpYyBzdWItdHJlZXMgb3V0XG5mdW5jdGlvbiBnZW5TdGF0aWMgKGVsLCBzdGF0ZSkge1xuICBlbC5zdGF0aWNQcm9jZXNzZWQgPSB0cnVlO1xuICBzdGF0ZS5zdGF0aWNSZW5kZXJGbnMucHVzaCgoXCJ3aXRoKHRoaXMpe3JldHVybiBcIiArIChnZW5FbGVtZW50KGVsLCBzdGF0ZSkpICsgXCJ9XCIpKTtcbiAgcmV0dXJuIChcIl9tKFwiICsgKHN0YXRlLnN0YXRpY1JlbmRlckZucy5sZW5ndGggLSAxKSArIChlbC5zdGF0aWNJbkZvciA/ICcsdHJ1ZScgOiAnJykgKyBcIilcIilcbn1cblxuLy8gdi1vbmNlXG5mdW5jdGlvbiBnZW5PbmNlIChlbCwgc3RhdGUpIHtcbiAgZWwub25jZVByb2Nlc3NlZCA9IHRydWU7XG4gIGlmIChlbC5pZiAmJiAhZWwuaWZQcm9jZXNzZWQpIHtcbiAgICByZXR1cm4gZ2VuSWYoZWwsIHN0YXRlKVxuICB9IGVsc2UgaWYgKGVsLnN0YXRpY0luRm9yKSB7XG4gICAgdmFyIGtleSA9ICcnO1xuICAgIHZhciBwYXJlbnQgPSBlbC5wYXJlbnQ7XG4gICAgd2hpbGUgKHBhcmVudCkge1xuICAgICAgaWYgKHBhcmVudC5mb3IpIHtcbiAgICAgICAga2V5ID0gcGFyZW50LmtleTtcbiAgICAgICAgYnJlYWtcbiAgICAgIH1cbiAgICAgIHBhcmVudCA9IHBhcmVudC5wYXJlbnQ7XG4gICAgfVxuICAgIGlmICgha2V5KSB7XG4gICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIHN0YXRlLndhcm4oXG4gICAgICAgIFwidi1vbmNlIGNhbiBvbmx5IGJlIHVzZWQgaW5zaWRlIHYtZm9yIHRoYXQgaXMga2V5ZWQuIFwiXG4gICAgICApO1xuICAgICAgcmV0dXJuIGdlbkVsZW1lbnQoZWwsIHN0YXRlKVxuICAgIH1cbiAgICByZXR1cm4gKFwiX28oXCIgKyAoZ2VuRWxlbWVudChlbCwgc3RhdGUpKSArIFwiLFwiICsgKHN0YXRlLm9uY2VJZCsrKSArIFwiLFwiICsga2V5ICsgXCIpXCIpXG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGdlblN0YXRpYyhlbCwgc3RhdGUpXG4gIH1cbn1cblxuZnVuY3Rpb24gZ2VuSWYgKFxuICBlbCxcbiAgc3RhdGUsXG4gIGFsdEdlbixcbiAgYWx0RW1wdHlcbikge1xuICBlbC5pZlByb2Nlc3NlZCA9IHRydWU7IC8vIGF2b2lkIHJlY3Vyc2lvblxuICByZXR1cm4gZ2VuSWZDb25kaXRpb25zKGVsLmlmQ29uZGl0aW9ucy5zbGljZSgpLCBzdGF0ZSwgYWx0R2VuLCBhbHRFbXB0eSlcbn1cblxuZnVuY3Rpb24gZ2VuSWZDb25kaXRpb25zIChcbiAgY29uZGl0aW9ucyxcbiAgc3RhdGUsXG4gIGFsdEdlbixcbiAgYWx0RW1wdHlcbikge1xuICBpZiAoIWNvbmRpdGlvbnMubGVuZ3RoKSB7XG4gICAgcmV0dXJuIGFsdEVtcHR5IHx8ICdfZSgpJ1xuICB9XG5cbiAgdmFyIGNvbmRpdGlvbiA9IGNvbmRpdGlvbnMuc2hpZnQoKTtcbiAgaWYgKGNvbmRpdGlvbi5leHApIHtcbiAgICByZXR1cm4gKFwiKFwiICsgKGNvbmRpdGlvbi5leHApICsgXCIpP1wiICsgKGdlblRlcm5hcnlFeHAoY29uZGl0aW9uLmJsb2NrKSkgKyBcIjpcIiArIChnZW5JZkNvbmRpdGlvbnMoY29uZGl0aW9ucywgc3RhdGUsIGFsdEdlbiwgYWx0RW1wdHkpKSlcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gKFwiXCIgKyAoZ2VuVGVybmFyeUV4cChjb25kaXRpb24uYmxvY2spKSlcbiAgfVxuXG4gIC8vIHYtaWYgd2l0aCB2LW9uY2Ugc2hvdWxkIGdlbmVyYXRlIGNvZGUgbGlrZSAoYSk/X20oMCk6X20oMSlcbiAgZnVuY3Rpb24gZ2VuVGVybmFyeUV4cCAoZWwpIHtcbiAgICByZXR1cm4gYWx0R2VuXG4gICAgICA/IGFsdEdlbihlbCwgc3RhdGUpXG4gICAgICA6IGVsLm9uY2VcbiAgICAgICAgPyBnZW5PbmNlKGVsLCBzdGF0ZSlcbiAgICAgICAgOiBnZW5FbGVtZW50KGVsLCBzdGF0ZSlcbiAgfVxufVxuXG5mdW5jdGlvbiBnZW5Gb3IgKFxuICBlbCxcbiAgc3RhdGUsXG4gIGFsdEdlbixcbiAgYWx0SGVscGVyXG4pIHtcbiAgdmFyIGV4cCA9IGVsLmZvcjtcbiAgdmFyIGFsaWFzID0gZWwuYWxpYXM7XG4gIHZhciBpdGVyYXRvcjEgPSBlbC5pdGVyYXRvcjEgPyAoXCIsXCIgKyAoZWwuaXRlcmF0b3IxKSkgOiAnJztcbiAgdmFyIGl0ZXJhdG9yMiA9IGVsLml0ZXJhdG9yMiA/IChcIixcIiArIChlbC5pdGVyYXRvcjIpKSA6ICcnO1xuXG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmXG4gICAgc3RhdGUubWF5YmVDb21wb25lbnQoZWwpICYmXG4gICAgZWwudGFnICE9PSAnc2xvdCcgJiZcbiAgICBlbC50YWcgIT09ICd0ZW1wbGF0ZScgJiZcbiAgICAhZWwua2V5XG4gICkge1xuICAgIHN0YXRlLndhcm4oXG4gICAgICBcIjxcIiArIChlbC50YWcpICsgXCIgdi1mb3I9XFxcIlwiICsgYWxpYXMgKyBcIiBpbiBcIiArIGV4cCArIFwiXFxcIj46IGNvbXBvbmVudCBsaXN0cyByZW5kZXJlZCB3aXRoIFwiICtcbiAgICAgIFwidi1mb3Igc2hvdWxkIGhhdmUgZXhwbGljaXQga2V5cy4gXCIgK1xuICAgICAgXCJTZWUgaHR0cHM6Ly92dWVqcy5vcmcvZ3VpZGUvbGlzdC5odG1sI2tleSBmb3IgbW9yZSBpbmZvLlwiLFxuICAgICAgdHJ1ZSAvKiB0aXAgKi9cbiAgICApO1xuICB9XG5cbiAgZWwuZm9yUHJvY2Vzc2VkID0gdHJ1ZTsgLy8gYXZvaWQgcmVjdXJzaW9uXG4gIHJldHVybiAoYWx0SGVscGVyIHx8ICdfbCcpICsgXCIoKFwiICsgZXhwICsgXCIpLFwiICtcbiAgICBcImZ1bmN0aW9uKFwiICsgYWxpYXMgKyBpdGVyYXRvcjEgKyBpdGVyYXRvcjIgKyBcIil7XCIgK1xuICAgICAgXCJyZXR1cm4gXCIgKyAoKGFsdEdlbiB8fCBnZW5FbGVtZW50KShlbCwgc3RhdGUpKSArXG4gICAgJ30pJ1xufVxuXG5mdW5jdGlvbiBnZW5EYXRhJDIgKGVsLCBzdGF0ZSkge1xuICB2YXIgZGF0YSA9ICd7JztcblxuICAvLyBkaXJlY3RpdmVzIGZpcnN0LlxuICAvLyBkaXJlY3RpdmVzIG1heSBtdXRhdGUgdGhlIGVsJ3Mgb3RoZXIgcHJvcGVydGllcyBiZWZvcmUgdGhleSBhcmUgZ2VuZXJhdGVkLlxuICB2YXIgZGlycyA9IGdlbkRpcmVjdGl2ZXMoZWwsIHN0YXRlKTtcbiAgaWYgKGRpcnMpIHsgZGF0YSArPSBkaXJzICsgJywnOyB9XG5cbiAgLy8ga2V5XG4gIGlmIChlbC5rZXkpIHtcbiAgICBkYXRhICs9IFwia2V5OlwiICsgKGVsLmtleSkgKyBcIixcIjtcbiAgfVxuICAvLyByZWZcbiAgaWYgKGVsLnJlZikge1xuICAgIGRhdGEgKz0gXCJyZWY6XCIgKyAoZWwucmVmKSArIFwiLFwiO1xuICB9XG4gIGlmIChlbC5yZWZJbkZvcikge1xuICAgIGRhdGEgKz0gXCJyZWZJbkZvcjp0cnVlLFwiO1xuICB9XG4gIC8vIHByZVxuICBpZiAoZWwucHJlKSB7XG4gICAgZGF0YSArPSBcInByZTp0cnVlLFwiO1xuICB9XG4gIC8vIHJlY29yZCBvcmlnaW5hbCB0YWcgbmFtZSBmb3IgY29tcG9uZW50cyB1c2luZyBcImlzXCIgYXR0cmlidXRlXG4gIGlmIChlbC5jb21wb25lbnQpIHtcbiAgICBkYXRhICs9IFwidGFnOlxcXCJcIiArIChlbC50YWcpICsgXCJcXFwiLFwiO1xuICB9XG4gIC8vIG1vZHVsZSBkYXRhIGdlbmVyYXRpb24gZnVuY3Rpb25zXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgc3RhdGUuZGF0YUdlbkZucy5sZW5ndGg7IGkrKykge1xuICAgIGRhdGEgKz0gc3RhdGUuZGF0YUdlbkZuc1tpXShlbCk7XG4gIH1cbiAgLy8gYXR0cmlidXRlc1xuICBpZiAoZWwuYXR0cnMpIHtcbiAgICBkYXRhICs9IFwiYXR0cnM6e1wiICsgKGdlblByb3BzKGVsLmF0dHJzKSkgKyBcIn0sXCI7XG4gIH1cbiAgLy8gRE9NIHByb3BzXG4gIGlmIChlbC5wcm9wcykge1xuICAgIGRhdGEgKz0gXCJkb21Qcm9wczp7XCIgKyAoZ2VuUHJvcHMoZWwucHJvcHMpKSArIFwifSxcIjtcbiAgfVxuICAvLyBldmVudCBoYW5kbGVyc1xuICBpZiAoZWwuZXZlbnRzKSB7XG4gICAgZGF0YSArPSAoZ2VuSGFuZGxlcnMoZWwuZXZlbnRzLCBmYWxzZSwgc3RhdGUud2FybikpICsgXCIsXCI7XG4gIH1cbiAgaWYgKGVsLm5hdGl2ZUV2ZW50cykge1xuICAgIGRhdGEgKz0gKGdlbkhhbmRsZXJzKGVsLm5hdGl2ZUV2ZW50cywgdHJ1ZSwgc3RhdGUud2FybikpICsgXCIsXCI7XG4gIH1cbiAgLy8gc2xvdCB0YXJnZXRcbiAgLy8gb25seSBmb3Igbm9uLXNjb3BlZCBzbG90c1xuICBpZiAoZWwuc2xvdFRhcmdldCAmJiAhZWwuc2xvdFNjb3BlKSB7XG4gICAgZGF0YSArPSBcInNsb3Q6XCIgKyAoZWwuc2xvdFRhcmdldCkgKyBcIixcIjtcbiAgfVxuICAvLyBzY29wZWQgc2xvdHNcbiAgaWYgKGVsLnNjb3BlZFNsb3RzKSB7XG4gICAgZGF0YSArPSAoZ2VuU2NvcGVkU2xvdHMoZWwuc2NvcGVkU2xvdHMsIHN0YXRlKSkgKyBcIixcIjtcbiAgfVxuICAvLyBjb21wb25lbnQgdi1tb2RlbFxuICBpZiAoZWwubW9kZWwpIHtcbiAgICBkYXRhICs9IFwibW9kZWw6e3ZhbHVlOlwiICsgKGVsLm1vZGVsLnZhbHVlKSArIFwiLGNhbGxiYWNrOlwiICsgKGVsLm1vZGVsLmNhbGxiYWNrKSArIFwiLGV4cHJlc3Npb246XCIgKyAoZWwubW9kZWwuZXhwcmVzc2lvbikgKyBcIn0sXCI7XG4gIH1cbiAgLy8gaW5saW5lLXRlbXBsYXRlXG4gIGlmIChlbC5pbmxpbmVUZW1wbGF0ZSkge1xuICAgIHZhciBpbmxpbmVUZW1wbGF0ZSA9IGdlbklubGluZVRlbXBsYXRlKGVsLCBzdGF0ZSk7XG4gICAgaWYgKGlubGluZVRlbXBsYXRlKSB7XG4gICAgICBkYXRhICs9IGlubGluZVRlbXBsYXRlICsgXCIsXCI7XG4gICAgfVxuICB9XG4gIGRhdGEgPSBkYXRhLnJlcGxhY2UoLywkLywgJycpICsgJ30nO1xuICAvLyB2LWJpbmQgZGF0YSB3cmFwXG4gIGlmIChlbC53cmFwRGF0YSkge1xuICAgIGRhdGEgPSBlbC53cmFwRGF0YShkYXRhKTtcbiAgfVxuICAvLyB2LW9uIGRhdGEgd3JhcFxuICBpZiAoZWwud3JhcExpc3RlbmVycykge1xuICAgIGRhdGEgPSBlbC53cmFwTGlzdGVuZXJzKGRhdGEpO1xuICB9XG4gIHJldHVybiBkYXRhXG59XG5cbmZ1bmN0aW9uIGdlbkRpcmVjdGl2ZXMgKGVsLCBzdGF0ZSkge1xuICB2YXIgZGlycyA9IGVsLmRpcmVjdGl2ZXM7XG4gIGlmICghZGlycykgeyByZXR1cm4gfVxuICB2YXIgcmVzID0gJ2RpcmVjdGl2ZXM6Wyc7XG4gIHZhciBoYXNSdW50aW1lID0gZmFsc2U7XG4gIHZhciBpLCBsLCBkaXIsIG5lZWRSdW50aW1lO1xuICBmb3IgKGkgPSAwLCBsID0gZGlycy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICBkaXIgPSBkaXJzW2ldO1xuICAgIG5lZWRSdW50aW1lID0gdHJ1ZTtcbiAgICB2YXIgZ2VuID0gc3RhdGUuZGlyZWN0aXZlc1tkaXIubmFtZV07XG4gICAgaWYgKGdlbikge1xuICAgICAgLy8gY29tcGlsZS10aW1lIGRpcmVjdGl2ZSB0aGF0IG1hbmlwdWxhdGVzIEFTVC5cbiAgICAgIC8vIHJldHVybnMgdHJ1ZSBpZiBpdCBhbHNvIG5lZWRzIGEgcnVudGltZSBjb3VudGVycGFydC5cbiAgICAgIG5lZWRSdW50aW1lID0gISFnZW4oZWwsIGRpciwgc3RhdGUud2Fybik7XG4gICAgfVxuICAgIGlmIChuZWVkUnVudGltZSkge1xuICAgICAgaGFzUnVudGltZSA9IHRydWU7XG4gICAgICByZXMgKz0gXCJ7bmFtZTpcXFwiXCIgKyAoZGlyLm5hbWUpICsgXCJcXFwiLHJhd05hbWU6XFxcIlwiICsgKGRpci5yYXdOYW1lKSArIFwiXFxcIlwiICsgKGRpci52YWx1ZSA/IChcIix2YWx1ZTooXCIgKyAoZGlyLnZhbHVlKSArIFwiKSxleHByZXNzaW9uOlwiICsgKEpTT04uc3RyaW5naWZ5KGRpci52YWx1ZSkpKSA6ICcnKSArIChkaXIuYXJnID8gKFwiLGFyZzpcXFwiXCIgKyAoZGlyLmFyZykgKyBcIlxcXCJcIikgOiAnJykgKyAoZGlyLm1vZGlmaWVycyA/IChcIixtb2RpZmllcnM6XCIgKyAoSlNPTi5zdHJpbmdpZnkoZGlyLm1vZGlmaWVycykpKSA6ICcnKSArIFwifSxcIjtcbiAgICB9XG4gIH1cbiAgaWYgKGhhc1J1bnRpbWUpIHtcbiAgICByZXR1cm4gcmVzLnNsaWNlKDAsIC0xKSArICddJ1xuICB9XG59XG5cbmZ1bmN0aW9uIGdlbklubGluZVRlbXBsYXRlIChlbCwgc3RhdGUpIHtcbiAgdmFyIGFzdCA9IGVsLmNoaWxkcmVuWzBdO1xuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiAoXG4gICAgZWwuY2hpbGRyZW4ubGVuZ3RoICE9PSAxIHx8IGFzdC50eXBlICE9PSAxXG4gICkpIHtcbiAgICBzdGF0ZS53YXJuKCdJbmxpbmUtdGVtcGxhdGUgY29tcG9uZW50cyBtdXN0IGhhdmUgZXhhY3RseSBvbmUgY2hpbGQgZWxlbWVudC4nKTtcbiAgfVxuICBpZiAoYXN0LnR5cGUgPT09IDEpIHtcbiAgICB2YXIgaW5saW5lUmVuZGVyRm5zID0gZ2VuZXJhdGUoYXN0LCBzdGF0ZS5vcHRpb25zKTtcbiAgICByZXR1cm4gKFwiaW5saW5lVGVtcGxhdGU6e3JlbmRlcjpmdW5jdGlvbigpe1wiICsgKGlubGluZVJlbmRlckZucy5yZW5kZXIpICsgXCJ9LHN0YXRpY1JlbmRlckZuczpbXCIgKyAoaW5saW5lUmVuZGVyRm5zLnN0YXRpY1JlbmRlckZucy5tYXAoZnVuY3Rpb24gKGNvZGUpIHsgcmV0dXJuIChcImZ1bmN0aW9uKCl7XCIgKyBjb2RlICsgXCJ9XCIpOyB9KS5qb2luKCcsJykpICsgXCJdfVwiKVxuICB9XG59XG5cbmZ1bmN0aW9uIGdlblNjb3BlZFNsb3RzIChcbiAgc2xvdHMsXG4gIHN0YXRlXG4pIHtcbiAgcmV0dXJuIChcInNjb3BlZFNsb3RzOl91KFtcIiArIChPYmplY3Qua2V5cyhzbG90cykubWFwKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgIHJldHVybiBnZW5TY29wZWRTbG90KGtleSwgc2xvdHNba2V5XSwgc3RhdGUpXG4gICAgfSkuam9pbignLCcpKSArIFwiXSlcIilcbn1cblxuZnVuY3Rpb24gZ2VuU2NvcGVkU2xvdCAoXG4gIGtleSxcbiAgZWwsXG4gIHN0YXRlXG4pIHtcbiAgaWYgKGVsLmZvciAmJiAhZWwuZm9yUHJvY2Vzc2VkKSB7XG4gICAgcmV0dXJuIGdlbkZvclNjb3BlZFNsb3Qoa2V5LCBlbCwgc3RhdGUpXG4gIH1cbiAgdmFyIGZuID0gXCJmdW5jdGlvbihcIiArIChTdHJpbmcoZWwuc2xvdFNjb3BlKSkgKyBcIil7XCIgK1xuICAgIFwicmV0dXJuIFwiICsgKGVsLnRhZyA9PT0gJ3RlbXBsYXRlJ1xuICAgICAgPyBlbC5pZlxuICAgICAgICA/ICgoZWwuaWYpICsgXCI/XCIgKyAoZ2VuQ2hpbGRyZW4oZWwsIHN0YXRlKSB8fCAndW5kZWZpbmVkJykgKyBcIjp1bmRlZmluZWRcIilcbiAgICAgICAgOiBnZW5DaGlsZHJlbihlbCwgc3RhdGUpIHx8ICd1bmRlZmluZWQnXG4gICAgICA6IGdlbkVsZW1lbnQoZWwsIHN0YXRlKSkgKyBcIn1cIjtcbiAgcmV0dXJuIChcIntrZXk6XCIgKyBrZXkgKyBcIixmbjpcIiArIGZuICsgXCJ9XCIpXG59XG5cbmZ1bmN0aW9uIGdlbkZvclNjb3BlZFNsb3QgKFxuICBrZXksXG4gIGVsLFxuICBzdGF0ZVxuKSB7XG4gIHZhciBleHAgPSBlbC5mb3I7XG4gIHZhciBhbGlhcyA9IGVsLmFsaWFzO1xuICB2YXIgaXRlcmF0b3IxID0gZWwuaXRlcmF0b3IxID8gKFwiLFwiICsgKGVsLml0ZXJhdG9yMSkpIDogJyc7XG4gIHZhciBpdGVyYXRvcjIgPSBlbC5pdGVyYXRvcjIgPyAoXCIsXCIgKyAoZWwuaXRlcmF0b3IyKSkgOiAnJztcbiAgZWwuZm9yUHJvY2Vzc2VkID0gdHJ1ZTsgLy8gYXZvaWQgcmVjdXJzaW9uXG4gIHJldHVybiBcIl9sKChcIiArIGV4cCArIFwiKSxcIiArXG4gICAgXCJmdW5jdGlvbihcIiArIGFsaWFzICsgaXRlcmF0b3IxICsgaXRlcmF0b3IyICsgXCIpe1wiICtcbiAgICAgIFwicmV0dXJuIFwiICsgKGdlblNjb3BlZFNsb3Qoa2V5LCBlbCwgc3RhdGUpKSArXG4gICAgJ30pJ1xufVxuXG5mdW5jdGlvbiBnZW5DaGlsZHJlbiAoXG4gIGVsLFxuICBzdGF0ZSxcbiAgY2hlY2tTa2lwLFxuICBhbHRHZW5FbGVtZW50LFxuICBhbHRHZW5Ob2RlXG4pIHtcbiAgdmFyIGNoaWxkcmVuID0gZWwuY2hpbGRyZW47XG4gIGlmIChjaGlsZHJlbi5sZW5ndGgpIHtcbiAgICB2YXIgZWwkMSA9IGNoaWxkcmVuWzBdO1xuICAgIC8vIG9wdGltaXplIHNpbmdsZSB2LWZvclxuICAgIGlmIChjaGlsZHJlbi5sZW5ndGggPT09IDEgJiZcbiAgICAgIGVsJDEuZm9yICYmXG4gICAgICBlbCQxLnRhZyAhPT0gJ3RlbXBsYXRlJyAmJlxuICAgICAgZWwkMS50YWcgIT09ICdzbG90J1xuICAgICkge1xuICAgICAgcmV0dXJuIChhbHRHZW5FbGVtZW50IHx8IGdlbkVsZW1lbnQpKGVsJDEsIHN0YXRlKVxuICAgIH1cbiAgICB2YXIgbm9ybWFsaXphdGlvblR5cGUgPSBjaGVja1NraXBcbiAgICAgID8gZ2V0Tm9ybWFsaXphdGlvblR5cGUoY2hpbGRyZW4sIHN0YXRlLm1heWJlQ29tcG9uZW50KVxuICAgICAgOiAwO1xuICAgIHZhciBnZW4gPSBhbHRHZW5Ob2RlIHx8IGdlbk5vZGU7XG4gICAgcmV0dXJuIChcIltcIiArIChjaGlsZHJlbi5tYXAoZnVuY3Rpb24gKGMpIHsgcmV0dXJuIGdlbihjLCBzdGF0ZSk7IH0pLmpvaW4oJywnKSkgKyBcIl1cIiArIChub3JtYWxpemF0aW9uVHlwZSA/IChcIixcIiArIG5vcm1hbGl6YXRpb25UeXBlKSA6ICcnKSlcbiAgfVxufVxuXG4vLyBkZXRlcm1pbmUgdGhlIG5vcm1hbGl6YXRpb24gbmVlZGVkIGZvciB0aGUgY2hpbGRyZW4gYXJyYXkuXG4vLyAwOiBubyBub3JtYWxpemF0aW9uIG5lZWRlZFxuLy8gMTogc2ltcGxlIG5vcm1hbGl6YXRpb24gbmVlZGVkIChwb3NzaWJsZSAxLWxldmVsIGRlZXAgbmVzdGVkIGFycmF5KVxuLy8gMjogZnVsbCBub3JtYWxpemF0aW9uIG5lZWRlZFxuZnVuY3Rpb24gZ2V0Tm9ybWFsaXphdGlvblR5cGUgKFxuICBjaGlsZHJlbixcbiAgbWF5YmVDb21wb25lbnRcbikge1xuICB2YXIgcmVzID0gMDtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBjaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgIHZhciBlbCA9IGNoaWxkcmVuW2ldO1xuICAgIGlmIChlbC50eXBlICE9PSAxKSB7XG4gICAgICBjb250aW51ZVxuICAgIH1cbiAgICBpZiAobmVlZHNOb3JtYWxpemF0aW9uKGVsKSB8fFxuICAgICAgICAoZWwuaWZDb25kaXRpb25zICYmIGVsLmlmQ29uZGl0aW9ucy5zb21lKGZ1bmN0aW9uIChjKSB7IHJldHVybiBuZWVkc05vcm1hbGl6YXRpb24oYy5ibG9jayk7IH0pKSkge1xuICAgICAgcmVzID0gMjtcbiAgICAgIGJyZWFrXG4gICAgfVxuICAgIGlmIChtYXliZUNvbXBvbmVudChlbCkgfHxcbiAgICAgICAgKGVsLmlmQ29uZGl0aW9ucyAmJiBlbC5pZkNvbmRpdGlvbnMuc29tZShmdW5jdGlvbiAoYykgeyByZXR1cm4gbWF5YmVDb21wb25lbnQoYy5ibG9jayk7IH0pKSkge1xuICAgICAgcmVzID0gMTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc1xufVxuXG5mdW5jdGlvbiBuZWVkc05vcm1hbGl6YXRpb24gKGVsKSB7XG4gIHJldHVybiBlbC5mb3IgIT09IHVuZGVmaW5lZCB8fCBlbC50YWcgPT09ICd0ZW1wbGF0ZScgfHwgZWwudGFnID09PSAnc2xvdCdcbn1cblxuZnVuY3Rpb24gZ2VuTm9kZSAobm9kZSwgc3RhdGUpIHtcbiAgaWYgKG5vZGUudHlwZSA9PT0gMSkge1xuICAgIHJldHVybiBnZW5FbGVtZW50KG5vZGUsIHN0YXRlKVxuICB9IGlmIChub2RlLnR5cGUgPT09IDMgJiYgbm9kZS5pc0NvbW1lbnQpIHtcbiAgICByZXR1cm4gZ2VuQ29tbWVudChub2RlKVxuICB9IGVsc2Uge1xuICAgIHJldHVybiBnZW5UZXh0KG5vZGUpXG4gIH1cbn1cblxuZnVuY3Rpb24gZ2VuVGV4dCAodGV4dCkge1xuICByZXR1cm4gKFwiX3YoXCIgKyAodGV4dC50eXBlID09PSAyXG4gICAgPyB0ZXh0LmV4cHJlc3Npb24gLy8gbm8gbmVlZCBmb3IgKCkgYmVjYXVzZSBhbHJlYWR5IHdyYXBwZWQgaW4gX3MoKVxuICAgIDogdHJhbnNmb3JtU3BlY2lhbE5ld2xpbmVzKEpTT04uc3RyaW5naWZ5KHRleHQudGV4dCkpKSArIFwiKVwiKVxufVxuXG5mdW5jdGlvbiBnZW5Db21tZW50IChjb21tZW50KSB7XG4gIHJldHVybiAoXCJfZShcIiArIChKU09OLnN0cmluZ2lmeShjb21tZW50LnRleHQpKSArIFwiKVwiKVxufVxuXG5mdW5jdGlvbiBnZW5TbG90IChlbCwgc3RhdGUpIHtcbiAgdmFyIHNsb3ROYW1lID0gZWwuc2xvdE5hbWUgfHwgJ1wiZGVmYXVsdFwiJztcbiAgdmFyIGNoaWxkcmVuID0gZ2VuQ2hpbGRyZW4oZWwsIHN0YXRlKTtcbiAgdmFyIHJlcyA9IFwiX3QoXCIgKyBzbG90TmFtZSArIChjaGlsZHJlbiA/IChcIixcIiArIGNoaWxkcmVuKSA6ICcnKTtcbiAgdmFyIGF0dHJzID0gZWwuYXR0cnMgJiYgKFwie1wiICsgKGVsLmF0dHJzLm1hcChmdW5jdGlvbiAoYSkgeyByZXR1cm4gKChjYW1lbGl6ZShhLm5hbWUpKSArIFwiOlwiICsgKGEudmFsdWUpKTsgfSkuam9pbignLCcpKSArIFwifVwiKTtcbiAgdmFyIGJpbmQkJDEgPSBlbC5hdHRyc01hcFsndi1iaW5kJ107XG4gIGlmICgoYXR0cnMgfHwgYmluZCQkMSkgJiYgIWNoaWxkcmVuKSB7XG4gICAgcmVzICs9IFwiLG51bGxcIjtcbiAgfVxuICBpZiAoYXR0cnMpIHtcbiAgICByZXMgKz0gXCIsXCIgKyBhdHRycztcbiAgfVxuICBpZiAoYmluZCQkMSkge1xuICAgIHJlcyArPSAoYXR0cnMgPyAnJyA6ICcsbnVsbCcpICsgXCIsXCIgKyBiaW5kJCQxO1xuICB9XG4gIHJldHVybiByZXMgKyAnKSdcbn1cblxuLy8gY29tcG9uZW50TmFtZSBpcyBlbC5jb21wb25lbnQsIHRha2UgaXQgYXMgYXJndW1lbnQgdG8gc2h1biBmbG93J3MgcGVzc2ltaXN0aWMgcmVmaW5lbWVudFxuZnVuY3Rpb24gZ2VuQ29tcG9uZW50IChcbiAgY29tcG9uZW50TmFtZSxcbiAgZWwsXG4gIHN0YXRlXG4pIHtcbiAgdmFyIGNoaWxkcmVuID0gZWwuaW5saW5lVGVtcGxhdGUgPyBudWxsIDogZ2VuQ2hpbGRyZW4oZWwsIHN0YXRlLCB0cnVlKTtcbiAgcmV0dXJuIChcIl9jKFwiICsgY29tcG9uZW50TmFtZSArIFwiLFwiICsgKGdlbkRhdGEkMihlbCwgc3RhdGUpKSArIChjaGlsZHJlbiA/IChcIixcIiArIGNoaWxkcmVuKSA6ICcnKSArIFwiKVwiKVxufVxuXG5mdW5jdGlvbiBnZW5Qcm9wcyAocHJvcHMpIHtcbiAgdmFyIHJlcyA9ICcnO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIHByb3AgPSBwcm9wc1tpXTtcbiAgICByZXMgKz0gXCJcXFwiXCIgKyAocHJvcC5uYW1lKSArIFwiXFxcIjpcIiArICh0cmFuc2Zvcm1TcGVjaWFsTmV3bGluZXMocHJvcC52YWx1ZSkpICsgXCIsXCI7XG4gIH1cbiAgcmV0dXJuIHJlcy5zbGljZSgwLCAtMSlcbn1cblxuLy8gIzM4OTUsICM0MjY4XG5mdW5jdGlvbiB0cmFuc2Zvcm1TcGVjaWFsTmV3bGluZXMgKHRleHQpIHtcbiAgcmV0dXJuIHRleHRcbiAgICAucmVwbGFjZSgvXFx1MjAyOC9nLCAnXFxcXHUyMDI4JylcbiAgICAucmVwbGFjZSgvXFx1MjAyOS9nLCAnXFxcXHUyMDI5Jylcbn1cblxuLyogICovXG5cbi8vIHRoZXNlIGtleXdvcmRzIHNob3VsZCBub3QgYXBwZWFyIGluc2lkZSBleHByZXNzaW9ucywgYnV0IG9wZXJhdG9ycyBsaWtlXG4vLyB0eXBlb2YsIGluc3RhbmNlb2YgYW5kIGluIGFyZSBhbGxvd2VkXG52YXIgcHJvaGliaXRlZEtleXdvcmRSRSA9IG5ldyBSZWdFeHAoJ1xcXFxiJyArIChcbiAgJ2RvLGlmLGZvcixsZXQsbmV3LHRyeSx2YXIsY2FzZSxlbHNlLHdpdGgsYXdhaXQsYnJlYWssY2F0Y2gsY2xhc3MsY29uc3QsJyArXG4gICdzdXBlcix0aHJvdyx3aGlsZSx5aWVsZCxkZWxldGUsZXhwb3J0LGltcG9ydCxyZXR1cm4sc3dpdGNoLGRlZmF1bHQsJyArXG4gICdleHRlbmRzLGZpbmFsbHksY29udGludWUsZGVidWdnZXIsZnVuY3Rpb24sYXJndW1lbnRzJ1xuKS5zcGxpdCgnLCcpLmpvaW4oJ1xcXFxifFxcXFxiJykgKyAnXFxcXGInKTtcblxuLy8gdGhlc2UgdW5hcnkgb3BlcmF0b3JzIHNob3VsZCBub3QgYmUgdXNlZCBhcyBwcm9wZXJ0eS9tZXRob2QgbmFtZXNcbnZhciB1bmFyeU9wZXJhdG9yc1JFID0gbmV3IFJlZ0V4cCgnXFxcXGInICsgKFxuICAnZGVsZXRlLHR5cGVvZix2b2lkJ1xuKS5zcGxpdCgnLCcpLmpvaW4oJ1xcXFxzKlxcXFwoW15cXFxcKV0qXFxcXCl8XFxcXGInKSArICdcXFxccypcXFxcKFteXFxcXCldKlxcXFwpJyk7XG5cbi8vIHN0cmlwIHN0cmluZ3MgaW4gZXhwcmVzc2lvbnNcbnZhciBzdHJpcFN0cmluZ1JFID0gLycoPzpbXidcXFxcXXxcXFxcLikqJ3xcIig/OlteXCJcXFxcXXxcXFxcLikqXCJ8YCg/OlteYFxcXFxdfFxcXFwuKSpcXCRcXHt8XFx9KD86W15gXFxcXF18XFxcXC4pKmB8YCg/OlteYFxcXFxdfFxcXFwuKSpgL2c7XG5cbi8vIGRldGVjdCBwcm9ibGVtYXRpYyBleHByZXNzaW9ucyBpbiBhIHRlbXBsYXRlXG5mdW5jdGlvbiBkZXRlY3RFcnJvcnMgKGFzdCkge1xuICB2YXIgZXJyb3JzID0gW107XG4gIGlmIChhc3QpIHtcbiAgICBjaGVja05vZGUoYXN0LCBlcnJvcnMpO1xuICB9XG4gIHJldHVybiBlcnJvcnNcbn1cblxuZnVuY3Rpb24gY2hlY2tOb2RlIChub2RlLCBlcnJvcnMpIHtcbiAgaWYgKG5vZGUudHlwZSA9PT0gMSkge1xuICAgIGZvciAodmFyIG5hbWUgaW4gbm9kZS5hdHRyc01hcCkge1xuICAgICAgaWYgKGRpclJFLnRlc3QobmFtZSkpIHtcbiAgICAgICAgdmFyIHZhbHVlID0gbm9kZS5hdHRyc01hcFtuYW1lXTtcbiAgICAgICAgaWYgKHZhbHVlKSB7XG4gICAgICAgICAgaWYgKG5hbWUgPT09ICd2LWZvcicpIHtcbiAgICAgICAgICAgIGNoZWNrRm9yKG5vZGUsIChcInYtZm9yPVxcXCJcIiArIHZhbHVlICsgXCJcXFwiXCIpLCBlcnJvcnMpO1xuICAgICAgICAgIH0gZWxzZSBpZiAob25SRS50ZXN0KG5hbWUpKSB7XG4gICAgICAgICAgICBjaGVja0V2ZW50KHZhbHVlLCAobmFtZSArIFwiPVxcXCJcIiArIHZhbHVlICsgXCJcXFwiXCIpLCBlcnJvcnMpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjaGVja0V4cHJlc3Npb24odmFsdWUsIChuYW1lICsgXCI9XFxcIlwiICsgdmFsdWUgKyBcIlxcXCJcIiksIGVycm9ycyk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChub2RlLmNoaWxkcmVuKSB7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG5vZGUuY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY2hlY2tOb2RlKG5vZGUuY2hpbGRyZW5baV0sIGVycm9ycyk7XG4gICAgICB9XG4gICAgfVxuICB9IGVsc2UgaWYgKG5vZGUudHlwZSA9PT0gMikge1xuICAgIGNoZWNrRXhwcmVzc2lvbihub2RlLmV4cHJlc3Npb24sIG5vZGUudGV4dCwgZXJyb3JzKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBjaGVja0V2ZW50IChleHAsIHRleHQsIGVycm9ycykge1xuICB2YXIgc3RpcHBlZCA9IGV4cC5yZXBsYWNlKHN0cmlwU3RyaW5nUkUsICcnKTtcbiAgdmFyIGtleXdvcmRNYXRjaCA9IHN0aXBwZWQubWF0Y2godW5hcnlPcGVyYXRvcnNSRSk7XG4gIGlmIChrZXl3b3JkTWF0Y2ggJiYgc3RpcHBlZC5jaGFyQXQoa2V5d29yZE1hdGNoLmluZGV4IC0gMSkgIT09ICckJykge1xuICAgIGVycm9ycy5wdXNoKFxuICAgICAgXCJhdm9pZCB1c2luZyBKYXZhU2NyaXB0IHVuYXJ5IG9wZXJhdG9yIGFzIHByb3BlcnR5IG5hbWU6IFwiICtcbiAgICAgIFwiXFxcIlwiICsgKGtleXdvcmRNYXRjaFswXSkgKyBcIlxcXCIgaW4gZXhwcmVzc2lvbiBcIiArICh0ZXh0LnRyaW0oKSlcbiAgICApO1xuICB9XG4gIGNoZWNrRXhwcmVzc2lvbihleHAsIHRleHQsIGVycm9ycyk7XG59XG5cbmZ1bmN0aW9uIGNoZWNrRm9yIChub2RlLCB0ZXh0LCBlcnJvcnMpIHtcbiAgY2hlY2tFeHByZXNzaW9uKG5vZGUuZm9yIHx8ICcnLCB0ZXh0LCBlcnJvcnMpO1xuICBjaGVja0lkZW50aWZpZXIobm9kZS5hbGlhcywgJ3YtZm9yIGFsaWFzJywgdGV4dCwgZXJyb3JzKTtcbiAgY2hlY2tJZGVudGlmaWVyKG5vZGUuaXRlcmF0b3IxLCAndi1mb3IgaXRlcmF0b3InLCB0ZXh0LCBlcnJvcnMpO1xuICBjaGVja0lkZW50aWZpZXIobm9kZS5pdGVyYXRvcjIsICd2LWZvciBpdGVyYXRvcicsIHRleHQsIGVycm9ycyk7XG59XG5cbmZ1bmN0aW9uIGNoZWNrSWRlbnRpZmllciAoXG4gIGlkZW50LFxuICB0eXBlLFxuICB0ZXh0LFxuICBlcnJvcnNcbikge1xuICBpZiAodHlwZW9mIGlkZW50ID09PSAnc3RyaW5nJykge1xuICAgIHRyeSB7XG4gICAgICBuZXcgRnVuY3Rpb24oKFwidmFyIFwiICsgaWRlbnQgKyBcIj1fXCIpKTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICBlcnJvcnMucHVzaCgoXCJpbnZhbGlkIFwiICsgdHlwZSArIFwiIFxcXCJcIiArIGlkZW50ICsgXCJcXFwiIGluIGV4cHJlc3Npb246IFwiICsgKHRleHQudHJpbSgpKSkpO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBjaGVja0V4cHJlc3Npb24gKGV4cCwgdGV4dCwgZXJyb3JzKSB7XG4gIHRyeSB7XG4gICAgbmV3IEZ1bmN0aW9uKChcInJldHVybiBcIiArIGV4cCkpO1xuICB9IGNhdGNoIChlKSB7XG4gICAgdmFyIGtleXdvcmRNYXRjaCA9IGV4cC5yZXBsYWNlKHN0cmlwU3RyaW5nUkUsICcnKS5tYXRjaChwcm9oaWJpdGVkS2V5d29yZFJFKTtcbiAgICBpZiAoa2V5d29yZE1hdGNoKSB7XG4gICAgICBlcnJvcnMucHVzaChcbiAgICAgICAgXCJhdm9pZCB1c2luZyBKYXZhU2NyaXB0IGtleXdvcmQgYXMgcHJvcGVydHkgbmFtZTogXCIgK1xuICAgICAgICBcIlxcXCJcIiArIChrZXl3b3JkTWF0Y2hbMF0pICsgXCJcXFwiXFxuICBSYXcgZXhwcmVzc2lvbjogXCIgKyAodGV4dC50cmltKCkpXG4gICAgICApO1xuICAgIH0gZWxzZSB7XG4gICAgICBlcnJvcnMucHVzaChcbiAgICAgICAgXCJpbnZhbGlkIGV4cHJlc3Npb246IFwiICsgKGUubWVzc2FnZSkgKyBcIiBpblxcblxcblwiICtcbiAgICAgICAgXCIgICAgXCIgKyBleHAgKyBcIlxcblxcblwiICtcbiAgICAgICAgXCIgIFJhdyBleHByZXNzaW9uOiBcIiArICh0ZXh0LnRyaW0oKSkgKyBcIlxcblwiXG4gICAgICApO1xuICAgIH1cbiAgfVxufVxuXG4vKiAgKi9cblxuZnVuY3Rpb24gY3JlYXRlRnVuY3Rpb24gKGNvZGUsIGVycm9ycykge1xuICB0cnkge1xuICAgIHJldHVybiBuZXcgRnVuY3Rpb24oY29kZSlcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgZXJyb3JzLnB1c2goeyBlcnI6IGVyciwgY29kZTogY29kZSB9KTtcbiAgICByZXR1cm4gbm9vcFxuICB9XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUNvbXBpbGVUb0Z1bmN0aW9uRm4gKGNvbXBpbGUpIHtcbiAgdmFyIGNhY2hlID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcblxuICByZXR1cm4gZnVuY3Rpb24gY29tcGlsZVRvRnVuY3Rpb25zIChcbiAgICB0ZW1wbGF0ZSxcbiAgICBvcHRpb25zLFxuICAgIHZtXG4gICkge1xuICAgIG9wdGlvbnMgPSBleHRlbmQoe30sIG9wdGlvbnMpO1xuICAgIHZhciB3YXJuJCQxID0gb3B0aW9ucy53YXJuIHx8IHdhcm47XG4gICAgZGVsZXRlIG9wdGlvbnMud2FybjtcblxuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAvLyBkZXRlY3QgcG9zc2libGUgQ1NQIHJlc3RyaWN0aW9uXG4gICAgICB0cnkge1xuICAgICAgICBuZXcgRnVuY3Rpb24oJ3JldHVybiAxJyk7XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIGlmIChlLnRvU3RyaW5nKCkubWF0Y2goL3Vuc2FmZS1ldmFsfENTUC8pKSB7XG4gICAgICAgICAgd2FybiQkMShcbiAgICAgICAgICAgICdJdCBzZWVtcyB5b3UgYXJlIHVzaW5nIHRoZSBzdGFuZGFsb25lIGJ1aWxkIG9mIFZ1ZS5qcyBpbiBhbiAnICtcbiAgICAgICAgICAgICdlbnZpcm9ubWVudCB3aXRoIENvbnRlbnQgU2VjdXJpdHkgUG9saWN5IHRoYXQgcHJvaGliaXRzIHVuc2FmZS1ldmFsLiAnICtcbiAgICAgICAgICAgICdUaGUgdGVtcGxhdGUgY29tcGlsZXIgY2Fubm90IHdvcmsgaW4gdGhpcyBlbnZpcm9ubWVudC4gQ29uc2lkZXIgJyArXG4gICAgICAgICAgICAncmVsYXhpbmcgdGhlIHBvbGljeSB0byBhbGxvdyB1bnNhZmUtZXZhbCBvciBwcmUtY29tcGlsaW5nIHlvdXIgJyArXG4gICAgICAgICAgICAndGVtcGxhdGVzIGludG8gcmVuZGVyIGZ1bmN0aW9ucy4nXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIC8vIGNoZWNrIGNhY2hlXG4gICAgdmFyIGtleSA9IG9wdGlvbnMuZGVsaW1pdGVyc1xuICAgICAgPyBTdHJpbmcob3B0aW9ucy5kZWxpbWl0ZXJzKSArIHRlbXBsYXRlXG4gICAgICA6IHRlbXBsYXRlO1xuICAgIGlmIChjYWNoZVtrZXldKSB7XG4gICAgICByZXR1cm4gY2FjaGVba2V5XVxuICAgIH1cblxuICAgIC8vIGNvbXBpbGVcbiAgICB2YXIgY29tcGlsZWQgPSBjb21waWxlKHRlbXBsYXRlLCBvcHRpb25zKTtcblxuICAgIC8vIGNoZWNrIGNvbXBpbGF0aW9uIGVycm9ycy90aXBzXG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIGlmIChjb21waWxlZC5lcnJvcnMgJiYgY29tcGlsZWQuZXJyb3JzLmxlbmd0aCkge1xuICAgICAgICB3YXJuJCQxKFxuICAgICAgICAgIFwiRXJyb3IgY29tcGlsaW5nIHRlbXBsYXRlOlxcblxcblwiICsgdGVtcGxhdGUgKyBcIlxcblxcblwiICtcbiAgICAgICAgICBjb21waWxlZC5lcnJvcnMubWFwKGZ1bmN0aW9uIChlKSB7IHJldHVybiAoXCItIFwiICsgZSk7IH0pLmpvaW4oJ1xcbicpICsgJ1xcbicsXG4gICAgICAgICAgdm1cbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIGlmIChjb21waWxlZC50aXBzICYmIGNvbXBpbGVkLnRpcHMubGVuZ3RoKSB7XG4gICAgICAgIGNvbXBpbGVkLnRpcHMuZm9yRWFjaChmdW5jdGlvbiAobXNnKSB7IHJldHVybiB0aXAobXNnLCB2bSk7IH0pO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIHR1cm4gY29kZSBpbnRvIGZ1bmN0aW9uc1xuICAgIHZhciByZXMgPSB7fTtcbiAgICB2YXIgZm5HZW5FcnJvcnMgPSBbXTtcbiAgICByZXMucmVuZGVyID0gY3JlYXRlRnVuY3Rpb24oY29tcGlsZWQucmVuZGVyLCBmbkdlbkVycm9ycyk7XG4gICAgcmVzLnN0YXRpY1JlbmRlckZucyA9IGNvbXBpbGVkLnN0YXRpY1JlbmRlckZucy5tYXAoZnVuY3Rpb24gKGNvZGUpIHtcbiAgICAgIHJldHVybiBjcmVhdGVGdW5jdGlvbihjb2RlLCBmbkdlbkVycm9ycylcbiAgICB9KTtcblxuICAgIC8vIGNoZWNrIGZ1bmN0aW9uIGdlbmVyYXRpb24gZXJyb3JzLlxuICAgIC8vIHRoaXMgc2hvdWxkIG9ubHkgaGFwcGVuIGlmIHRoZXJlIGlzIGEgYnVnIGluIHRoZSBjb21waWxlciBpdHNlbGYuXG4gICAgLy8gbW9zdGx5IGZvciBjb2RlZ2VuIGRldmVsb3BtZW50IHVzZVxuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICBpZiAoKCFjb21waWxlZC5lcnJvcnMgfHwgIWNvbXBpbGVkLmVycm9ycy5sZW5ndGgpICYmIGZuR2VuRXJyb3JzLmxlbmd0aCkge1xuICAgICAgICB3YXJuJCQxKFxuICAgICAgICAgIFwiRmFpbGVkIHRvIGdlbmVyYXRlIHJlbmRlciBmdW5jdGlvbjpcXG5cXG5cIiArXG4gICAgICAgICAgZm5HZW5FcnJvcnMubWFwKGZ1bmN0aW9uIChyZWYpIHtcbiAgICAgICAgICAgIHZhciBlcnIgPSByZWYuZXJyO1xuICAgICAgICAgICAgdmFyIGNvZGUgPSByZWYuY29kZTtcblxuICAgICAgICAgICAgcmV0dXJuICgoZXJyLnRvU3RyaW5nKCkpICsgXCIgaW5cXG5cXG5cIiArIGNvZGUgKyBcIlxcblwiKTtcbiAgICAgICAgfSkuam9pbignXFxuJyksXG4gICAgICAgICAgdm1cbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gKGNhY2hlW2tleV0gPSByZXMpXG4gIH1cbn1cblxuLyogICovXG5cbmZ1bmN0aW9uIGNyZWF0ZUNvbXBpbGVyQ3JlYXRvciAoYmFzZUNvbXBpbGUpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIGNyZWF0ZUNvbXBpbGVyIChiYXNlT3B0aW9ucykge1xuICAgIGZ1bmN0aW9uIGNvbXBpbGUgKFxuICAgICAgdGVtcGxhdGUsXG4gICAgICBvcHRpb25zXG4gICAgKSB7XG4gICAgICB2YXIgZmluYWxPcHRpb25zID0gT2JqZWN0LmNyZWF0ZShiYXNlT3B0aW9ucyk7XG4gICAgICB2YXIgZXJyb3JzID0gW107XG4gICAgICB2YXIgdGlwcyA9IFtdO1xuICAgICAgZmluYWxPcHRpb25zLndhcm4gPSBmdW5jdGlvbiAobXNnLCB0aXApIHtcbiAgICAgICAgKHRpcCA/IHRpcHMgOiBlcnJvcnMpLnB1c2gobXNnKTtcbiAgICAgIH07XG5cbiAgICAgIGlmIChvcHRpb25zKSB7XG4gICAgICAgIC8vIG1lcmdlIGN1c3RvbSBtb2R1bGVzXG4gICAgICAgIGlmIChvcHRpb25zLm1vZHVsZXMpIHtcbiAgICAgICAgICBmaW5hbE9wdGlvbnMubW9kdWxlcyA9XG4gICAgICAgICAgICAoYmFzZU9wdGlvbnMubW9kdWxlcyB8fCBbXSkuY29uY2F0KG9wdGlvbnMubW9kdWxlcyk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gbWVyZ2UgY3VzdG9tIGRpcmVjdGl2ZXNcbiAgICAgICAgaWYgKG9wdGlvbnMuZGlyZWN0aXZlcykge1xuICAgICAgICAgIGZpbmFsT3B0aW9ucy5kaXJlY3RpdmVzID0gZXh0ZW5kKFxuICAgICAgICAgICAgT2JqZWN0LmNyZWF0ZShiYXNlT3B0aW9ucy5kaXJlY3RpdmVzIHx8IG51bGwpLFxuICAgICAgICAgICAgb3B0aW9ucy5kaXJlY3RpdmVzXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBjb3B5IG90aGVyIG9wdGlvbnNcbiAgICAgICAgZm9yICh2YXIga2V5IGluIG9wdGlvbnMpIHtcbiAgICAgICAgICBpZiAoa2V5ICE9PSAnbW9kdWxlcycgJiYga2V5ICE9PSAnZGlyZWN0aXZlcycpIHtcbiAgICAgICAgICAgIGZpbmFsT3B0aW9uc1trZXldID0gb3B0aW9uc1trZXldO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB2YXIgY29tcGlsZWQgPSBiYXNlQ29tcGlsZSh0ZW1wbGF0ZSwgZmluYWxPcHRpb25zKTtcbiAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgIGVycm9ycy5wdXNoLmFwcGx5KGVycm9ycywgZGV0ZWN0RXJyb3JzKGNvbXBpbGVkLmFzdCkpO1xuICAgICAgfVxuICAgICAgY29tcGlsZWQuZXJyb3JzID0gZXJyb3JzO1xuICAgICAgY29tcGlsZWQudGlwcyA9IHRpcHM7XG4gICAgICByZXR1cm4gY29tcGlsZWRcbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgY29tcGlsZTogY29tcGlsZSxcbiAgICAgIGNvbXBpbGVUb0Z1bmN0aW9uczogY3JlYXRlQ29tcGlsZVRvRnVuY3Rpb25Gbihjb21waWxlKVxuICAgIH1cbiAgfVxufVxuXG4vKiAgKi9cblxuLy8gYGNyZWF0ZUNvbXBpbGVyQ3JlYXRvcmAgYWxsb3dzIGNyZWF0aW5nIGNvbXBpbGVycyB0aGF0IHVzZSBhbHRlcm5hdGl2ZVxuLy8gcGFyc2VyL29wdGltaXplci9jb2RlZ2VuLCBlLmcgdGhlIFNTUiBvcHRpbWl6aW5nIGNvbXBpbGVyLlxuLy8gSGVyZSB3ZSBqdXN0IGV4cG9ydCBhIGRlZmF1bHQgY29tcGlsZXIgdXNpbmcgdGhlIGRlZmF1bHQgcGFydHMuXG52YXIgY3JlYXRlQ29tcGlsZXIgPSBjcmVhdGVDb21waWxlckNyZWF0b3IoZnVuY3Rpb24gYmFzZUNvbXBpbGUgKFxuICB0ZW1wbGF0ZSxcbiAgb3B0aW9uc1xuKSB7XG4gIHZhciBhc3QgPSBwYXJzZSh0ZW1wbGF0ZS50cmltKCksIG9wdGlvbnMpO1xuICBvcHRpbWl6ZShhc3QsIG9wdGlvbnMpO1xuICB2YXIgY29kZSA9IGdlbmVyYXRlKGFzdCwgb3B0aW9ucyk7XG4gIHJldHVybiB7XG4gICAgYXN0OiBhc3QsXG4gICAgcmVuZGVyOiBjb2RlLnJlbmRlcixcbiAgICBzdGF0aWNSZW5kZXJGbnM6IGNvZGUuc3RhdGljUmVuZGVyRm5zXG4gIH1cbn0pO1xuXG4vKiAgKi9cblxudmFyIHJlZiQxID0gY3JlYXRlQ29tcGlsZXIoYmFzZU9wdGlvbnMpO1xudmFyIGNvbXBpbGVUb0Z1bmN0aW9ucyA9IHJlZiQxLmNvbXBpbGVUb0Z1bmN0aW9ucztcblxuLyogICovXG5cbi8vIGNoZWNrIHdoZXRoZXIgY3VycmVudCBicm93c2VyIGVuY29kZXMgYSBjaGFyIGluc2lkZSBhdHRyaWJ1dGUgdmFsdWVzXG52YXIgZGl2O1xuZnVuY3Rpb24gZ2V0U2hvdWxkRGVjb2RlIChocmVmKSB7XG4gIGRpdiA9IGRpdiB8fCBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgZGl2LmlubmVySFRNTCA9IGhyZWYgPyBcIjxhIGhyZWY9XFxcIlxcblxcXCIvPlwiIDogXCI8ZGl2IGE9XFxcIlxcblxcXCIvPlwiO1xuICByZXR1cm4gZGl2LmlubmVySFRNTC5pbmRleE9mKCcmIzEwOycpID4gMFxufVxuXG4vLyAjMzY2MzogSUUgZW5jb2RlcyBuZXdsaW5lcyBpbnNpZGUgYXR0cmlidXRlIHZhbHVlcyB3aGlsZSBvdGhlciBicm93c2VycyBkb24ndFxudmFyIHNob3VsZERlY29kZU5ld2xpbmVzID0gaW5Ccm93c2VyID8gZ2V0U2hvdWxkRGVjb2RlKGZhbHNlKSA6IGZhbHNlO1xuLy8gIzY4Mjg6IGNocm9tZSBlbmNvZGVzIGNvbnRlbnQgaW4gYVtocmVmXVxudmFyIHNob3VsZERlY29kZU5ld2xpbmVzRm9ySHJlZiA9IGluQnJvd3NlciA/IGdldFNob3VsZERlY29kZSh0cnVlKSA6IGZhbHNlO1xuXG4vKiAgKi9cblxudmFyIGlkVG9UZW1wbGF0ZSA9IGNhY2hlZChmdW5jdGlvbiAoaWQpIHtcbiAgdmFyIGVsID0gcXVlcnkoaWQpO1xuICByZXR1cm4gZWwgJiYgZWwuaW5uZXJIVE1MXG59KTtcblxudmFyIG1vdW50ID0gVnVlJDMucHJvdG90eXBlLiRtb3VudDtcblZ1ZSQzLnByb3RvdHlwZS4kbW91bnQgPSBmdW5jdGlvbiAoXG4gIGVsLFxuICBoeWRyYXRpbmdcbikge1xuICBlbCA9IGVsICYmIHF1ZXJ5KGVsKTtcblxuICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgaWYgKGVsID09PSBkb2N1bWVudC5ib2R5IHx8IGVsID09PSBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQpIHtcbiAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIHdhcm4oXG4gICAgICBcIkRvIG5vdCBtb3VudCBWdWUgdG8gPGh0bWw+IG9yIDxib2R5PiAtIG1vdW50IHRvIG5vcm1hbCBlbGVtZW50cyBpbnN0ZWFkLlwiXG4gICAgKTtcbiAgICByZXR1cm4gdGhpc1xuICB9XG5cbiAgdmFyIG9wdGlvbnMgPSB0aGlzLiRvcHRpb25zO1xuICAvLyByZXNvbHZlIHRlbXBsYXRlL2VsIGFuZCBjb252ZXJ0IHRvIHJlbmRlciBmdW5jdGlvblxuICBpZiAoIW9wdGlvbnMucmVuZGVyKSB7XG4gICAgdmFyIHRlbXBsYXRlID0gb3B0aW9ucy50ZW1wbGF0ZTtcbiAgICBpZiAodGVtcGxhdGUpIHtcbiAgICAgIGlmICh0eXBlb2YgdGVtcGxhdGUgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIGlmICh0ZW1wbGF0ZS5jaGFyQXQoMCkgPT09ICcjJykge1xuICAgICAgICAgIHRlbXBsYXRlID0gaWRUb1RlbXBsYXRlKHRlbXBsYXRlKTtcbiAgICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiAhdGVtcGxhdGUpIHtcbiAgICAgICAgICAgIHdhcm4oXG4gICAgICAgICAgICAgIChcIlRlbXBsYXRlIGVsZW1lbnQgbm90IGZvdW5kIG9yIGlzIGVtcHR5OiBcIiArIChvcHRpb25zLnRlbXBsYXRlKSksXG4gICAgICAgICAgICAgIHRoaXNcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKHRlbXBsYXRlLm5vZGVUeXBlKSB7XG4gICAgICAgIHRlbXBsYXRlID0gdGVtcGxhdGUuaW5uZXJIVE1MO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgICB3YXJuKCdpbnZhbGlkIHRlbXBsYXRlIG9wdGlvbjonICsgdGVtcGxhdGUsIHRoaXMpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzXG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChlbCkge1xuICAgICAgdGVtcGxhdGUgPSBnZXRPdXRlckhUTUwoZWwpO1xuICAgIH1cbiAgICBpZiAodGVtcGxhdGUpIHtcbiAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgY29uZmlnLnBlcmZvcm1hbmNlICYmIG1hcmspIHtcbiAgICAgICAgbWFyaygnY29tcGlsZScpO1xuICAgICAgfVxuXG4gICAgICB2YXIgcmVmID0gY29tcGlsZVRvRnVuY3Rpb25zKHRlbXBsYXRlLCB7XG4gICAgICAgIHNob3VsZERlY29kZU5ld2xpbmVzOiBzaG91bGREZWNvZGVOZXdsaW5lcyxcbiAgICAgICAgc2hvdWxkRGVjb2RlTmV3bGluZXNGb3JIcmVmOiBzaG91bGREZWNvZGVOZXdsaW5lc0ZvckhyZWYsXG4gICAgICAgIGRlbGltaXRlcnM6IG9wdGlvbnMuZGVsaW1pdGVycyxcbiAgICAgICAgY29tbWVudHM6IG9wdGlvbnMuY29tbWVudHNcbiAgICAgIH0sIHRoaXMpO1xuICAgICAgdmFyIHJlbmRlciA9IHJlZi5yZW5kZXI7XG4gICAgICB2YXIgc3RhdGljUmVuZGVyRm5zID0gcmVmLnN0YXRpY1JlbmRlckZucztcbiAgICAgIG9wdGlvbnMucmVuZGVyID0gcmVuZGVyO1xuICAgICAgb3B0aW9ucy5zdGF0aWNSZW5kZXJGbnMgPSBzdGF0aWNSZW5kZXJGbnM7XG5cbiAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgY29uZmlnLnBlcmZvcm1hbmNlICYmIG1hcmspIHtcbiAgICAgICAgbWFyaygnY29tcGlsZSBlbmQnKTtcbiAgICAgICAgbWVhc3VyZSgoXCJ2dWUgXCIgKyAodGhpcy5fbmFtZSkgKyBcIiBjb21waWxlXCIpLCAnY29tcGlsZScsICdjb21waWxlIGVuZCcpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gbW91bnQuY2FsbCh0aGlzLCBlbCwgaHlkcmF0aW5nKVxufTtcblxuLyoqXG4gKiBHZXQgb3V0ZXJIVE1MIG9mIGVsZW1lbnRzLCB0YWtpbmcgY2FyZVxuICogb2YgU1ZHIGVsZW1lbnRzIGluIElFIGFzIHdlbGwuXG4gKi9cbmZ1bmN0aW9uIGdldE91dGVySFRNTCAoZWwpIHtcbiAgaWYgKGVsLm91dGVySFRNTCkge1xuICAgIHJldHVybiBlbC5vdXRlckhUTUxcbiAgfSBlbHNlIHtcbiAgICB2YXIgY29udGFpbmVyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgY29udGFpbmVyLmFwcGVuZENoaWxkKGVsLmNsb25lTm9kZSh0cnVlKSk7XG4gICAgcmV0dXJuIGNvbnRhaW5lci5pbm5lckhUTUxcbiAgfVxufVxuXG5WdWUkMy5jb21waWxlID0gY29tcGlsZVRvRnVuY3Rpb25zO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFZ1ZSQzO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9fdnVlQDIuNS4xMUB2dWUvZGlzdC92dWUuY29tbW9uLmpzIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///44\n");

/***/ }),

/***/ 67:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("Object.defineProperty(__webpack_exports__, \"__esModule\", { value: true });\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_tether__ = __webpack_require__(391);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_tether___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_tether__);\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\nfunction omitLinkProps() {\n  for (var t = [], e = arguments.length; e--;) {\n    t[e] = arguments[e];\n  }return Object.keys(props).reduce(function (e, n) {\n    return t.includes(n) || (e[n] = props[n]), e;\n  }, {});\n}function isVisible(t) {\n  return t && (t.offsetWidth > 0 || t.offsetHeight > 0);\n}function findFirstVisible(t, e) {\n  if (!t || !t.querySelectorAll || !e) return null;for (var n = Array.prototype.slice.call(t.querySelectorAll(e)), i = n.find ? n.find(function (t) {\n    return isVisible(t);\n  }) : null, o = 0; !i && o < n.length; o++) {\n    isVisible(n[o]) && (i = n[o]);\n  }return i;\n}function isVisible$1(t) {\n  return t && (t.offsetWidth > 0 || t.offsetHeight > 0);\n}function makePageArray(t, e) {\n  return Array.apply(null, { length: e }).map(function (e, n) {\n    return { number: n + t, className: null };\n  });\n}function observeDOM(t, e, n) {\n  var i = window.MutationObserver || window.WebKitMutationObserver,\n      o = window.addEventListener;i ? new i(function (t) {\n    (t[0].addedNodes.length > 0 || t[0].removedNodes.length > 0) && e();\n  }).observe(t, Object.assign({ childList: !0, subtree: !0 }, n)) : o && (t.addEventListener(\"DOMNodeInserted\", e, !1), t.addEventListener(\"DOMNodeRemoved\", e, !1));\n}function targets(t, e, n, i) {\n  var o = t.__vue__;if (!o) return console.warn(\"__vue__ is not available on element\", t), [];var r = Object.keys(e.modifiers || {}).filter(function (t) {\n    return !all_listen_types[t];\n  });e.value && r.push(e.value);var s = function s() {\n    i({ targets: r, vm: o });\n  };return Object.keys(all_listen_types).forEach(function (i) {\n    (n[i] || e.modifiers[i]) && t.addEventListener(i, s);\n  }), r;\n}function isElement(t) {\n  return t.nodeType;\n}function closest(t, e) {\n  var n = t.closest(e);return n === t ? null : n;\n}function $QSA(t, e) {\n  return e || (e = document), isElement(e) ? Array.prototype.slice.call(e.querySelectorAll(t)) : [];\n}function $QS(t, e) {\n  return e || (e = document), isElement(e) ? e.querySelector(t) || null : null;\n}function getVm(t) {\n  return t ? t.__vue__ : null;\n}function toType(t) {\n  return {}.toString.call(t).match(/\\s([a-zA-Z]+)/)[1].toLowerCase();\n}function typeCheckConfig(t, e, n) {\n  for (var i in n) {\n    if (Object.prototype.hasOwnProperty.call(n, i)) {\n      var o = n[i],\n          r = e[i],\n          s = r && isElement(r) ? \"element\" : toType(r);new RegExp(o).test(s) || console.error(t + ': Option \"' + i + '\" provided type \"' + s + '\" but expected type \"' + o + '\"');\n    }\n  }\n}function ScrollSpy(t, e) {\n  this._$el = t, this._selector = [Selector.NAV_LINKS, Selector.LIST_ITEMS, Selector.DROPDOWN_ITEMS].join(\",\"), this._config = Object.assign({}, Default), this._offsets = [], this._targets = [], this._activeTarget = null, this._scrollHeight = 0, this._$root = null, this._resizeTimeout = null, this.updateConfig(e);\n}var warn = function warn(t) {\n  console.warn(\"[Bootstrap-Vue warn]: \" + t);\n},\n    alert = { render: function render() {\n    var t = this,\n        e = t.$createElement,\n        n = t._self._c || e;return t.localShow ? n(\"div\", { class: t.classObject, attrs: { role: \"alert\", \"aria-live\": \"polite\", \"aria-atomic\": \"true\" } }, [t.dismissible ? n(\"button\", { staticClass: \"close\", attrs: { type: \"button\", \"data-dismiss\": \"alert\", \"aria-label\": \"dismissLabel\" }, on: { click: function click(e) {\n          e.stopPropagation(), e.preventDefault(), t.dismiss(e);\n        } } }, [n(\"span\", { attrs: { \"aria-hidden\": \"true\" } }, [t._v(\"Ã—\")])]) : t._e(), t._t(\"default\")], 2) : t._e();\n  }, staticRenderFns: [], data: function data() {\n    return { countDownTimerId: null, dismissed: !1 };\n  }, created: function created() {\n    this.state && warn('<b-alert> \"state\" property is deprecated, please use \"variant\" property instead.');\n  }, computed: { classObject: function classObject() {\n      return [\"alert\", this.alertVariant, this.dismissible ? \"alert-dismissible\" : \"\"];\n    }, alertVariant: function alertVariant() {\n      return \"alert-\" + (this.state || this.variant || \"info\");\n    }, localShow: function localShow() {\n      return !this.dismissed && (this.countDownTimerId || this.show);\n    } }, props: { variant: { type: String, default: \"info\" }, state: { type: String, default: null }, dismissible: { type: Boolean, default: !1 }, dismissLabel: { type: String, default: \"Close\" }, show: { type: [Boolean, Number], default: !1 } }, watch: { show: function show() {\n      this.showChanged();\n    } }, mounted: function mounted() {\n    this.showChanged();\n  }, methods: { dismiss: function dismiss() {\n      this.dismissed = !0, this.$emit(\"dismissed\"), this.clearCounter();\n    }, clearCounter: function clearCounter() {\n      this.countDownTimerId && clearInterval(this.countDownTimerId);\n    }, showChanged: function showChanged() {\n      var t = this;if (this.dismissed = !1, !0 !== this.show && !1 !== this.show && null !== this.show && 0 !== this.show) {\n        var e = this.show;this.$emit(\"dismiss-count-down\", e), this.clearCounter(), this.countDownTimerId = setInterval(function () {\n          if (e < 2) return t.dismiss();e--, t.$emit(\"dismiss-count-down\", e);\n        }, 1e3);\n      }\n    } } },\n    props = { active: { type: Boolean, default: !1 }, activeClass: { type: String, default: \"active\" }, append: { type: Boolean, default: !1 }, disabled: { type: Boolean, default: !1 }, event: { type: [String, Array], default: \"click\" }, exact: { type: Boolean, default: !1 }, exactActiveClass: { type: String, default: \"active\" }, href: { type: String, default: \"#\" }, rel: { type: String, default: null }, replace: { type: Boolean, default: !1 }, routerTag: { type: String, default: \"a\" }, tag: { type: String, default: null }, target: { type: String, default: \"_self\" }, to: { type: [String, Object], default: null } },\n    computed = { linkProps: function linkProps() {\n    var t = this;return Object.keys(props).reduce(function (e, n) {\n      return e[n] = t[n], e;\n    }, {});\n  }, isRouterLink: function isRouterLink() {\n    return Boolean(this.$router && this.to && !this.disabled);\n  }, _href: function _href() {\n    return this.disabled ? \"#\" : this.href ? this.href : this.to && \"string\" == typeof this.to ? this.to : void 0;\n  }, computedRel: function computedRel() {\n    return \"_blank\" === this.target && null === this.rel ? \"noopener\" : this.rel || null;\n  }, componentTag: function componentTag() {\n    return this.tag ? (warn('<b-link> \"tag\" property is deprecated, please use \"routerTag\" property instead.'), this.tag) : this.routerTag;\n  }, linkClassObject: function linkClassObject() {\n    return [this.active ? this.exact ? this.exactActiveClass : this.activeClass : null, this.disabled ? \"disabled\" : null];\n  } },\n    methods = { linkClick: function linkClick(t) {\n    this.disabled ? t.stopPropagation() : (this.$root.$emit(\"clicked::link\", this), this.$emit(\"click\", t)), this.isRouterLink || \"#\" !== this._href || t.preventDefault();\n  } },\n    linkMixin = { props: props, computed: computed, methods: methods },\n    bLink = { render: function render() {\n    var t = this,\n        e = t.$createElement,\n        n = t._self._c || e;return t.isRouterLink ? n(\"router-link\", { tag: \"a\", class: t.linkClassObject, attrs: { \"active-class\": t.activeClass, \"exact-active-class\": t.exactActiveClass, disabled: t.disabled, \"aria-disabled\": t.disabled ? \"true\" : \"false\", to: t.to, exact: t.exact, append: t.append, replace: t.replace, event: t.event, tag: t.componentTag }, nativeOn: { click: function click(e) {\n          t.linkClick(e);\n        } } }, [t._t(\"default\")], 2) : n(\"a\", { class: t.linkClassObject, attrs: { disabled: t.disabled, \"aria-disabled\": t.disabled ? \"true\" : \"false\", href: t._href, target: t.target || null, rel: t.computedRel }, on: { click: t.linkClick } }, [t._t(\"default\")], 2);\n  }, staticRenderFns: [], mixins: [linkMixin] },\n    bLinkPropKeys = Object.keys(props),\n    breadcrumb = { render: function render() {\n    var t = this,\n        e = t.$createElement,\n        n = t._self._c || e;return n(\"ol\", { staticClass: \"breadcrumb\" }, [t._l(t.normalizedItems, function (e) {\n      return n(\"li\", { class: [\"breadcrumb-item\", e.active ? \"active\" : null], attrs: { role: \"presentation\" }, on: { click: function click(n) {\n            t.onClick(e._originalItem);\n          } } }, [e.active ? n(\"span\", { attrs: { \"aria-current\": t.ariaCurrent }, domProps: { innerHTML: t._s(e.text) } }) : n(\"b-link\", t._b({ domProps: { innerHTML: t._s(e.text) } }, \"b-link\", e._linkProps))], 1);\n    }), t._t(\"default\")], 2);\n  }, staticRenderFns: [], components: { bLink: bLink }, computed: { normalizedItems: function normalizedItems() {\n      var t = !1,\n          e = this.items.length;return this.items.map(function (n, i) {\n        var o = { _originalItem: n },\n            r = i === e - 1;return \"string\" == typeof n ? Object.assign(o, { text: n, link: \"#\", active: r }) : Object.assign(o, n), !0 === o.active || !1 === o.active || t ? o.active && (t = !0) : o.active = r, o.link && (o.href = o.link), o._linkProps = Object.keys(o).reduce(function (t, e) {\n          return bLinkPropKeys.includes(e) && (t[e] = o[e]), t;\n        }, {}), o;\n      });\n    } }, props: { items: { type: Array, default: function _default() {\n        return [];\n      }, required: !0 }, ariaCurrent: { type: String, default: \"location\" } }, methods: { onClick: function onClick(t) {\n      this.$emit(\"click\", t);\n    } } },\n    linkProps = Object.assign(omitLinkProps(\"href\", \"to\"), { href: { type: props.href.type }, to: { type: props.to.type } }),\n    bBtn = { render: function render() {\n    var t = this,\n        e = t.$createElement;return (t._self._c || e)(t.componentType, t._b({ tag: \"button\", class: t.classList, attrs: { type: t.btnType, disabled: t.disabled }, on: { click: t.onClick } }, \"button\", t.conditionalLinkProps), [t._t(\"default\")], 2);\n  }, staticRenderFns: [], components: { bLink: bLink }, computed: { linkProps: computed.linkProps, classList: function classList() {\n      return [\"btn\", this.btnVariant, this.btnSize, this.btnBlock, this.btnDisabled];\n    }, componentType: function componentType() {\n      return this.href || this.to ? \"b-link\" : \"button\";\n    }, btnBlock: function btnBlock() {\n      return this.block ? \"btn-block\" : \"\";\n    }, btnVariant: function btnVariant() {\n      return this.variant ? \"btn-\" + this.variant : \"btn-secondary\";\n    }, btnSize: function btnSize() {\n      return this.size ? \"btn-\" + this.size : \"\";\n    }, btnDisabled: function btnDisabled() {\n      return this.disabled ? \"disabled\" : \"\";\n    }, btnType: function btnType() {\n      return this.href || this.to ? null : this.type;\n    }, conditionalLinkProps: function conditionalLinkProps() {\n      return \"button\" === this.componentType ? {} : this.linkProps;\n    } }, props: Object.assign(linkProps, { block: { type: Boolean, default: !1 }, disabled: { type: Boolean, default: !1 }, size: { type: String, default: null }, variant: { type: String, default: null }, type: { type: String, default: \"button\" } }), methods: { onClick: function onClick(t) {\n      this.disabled ? (t.stopPropagation(), t.preventDefault()) : this.$emit(\"click\", t);\n    } } },\n    ITEM_SELECTOR = ['.btn:not(.disabled):not([disabled]):not([style*=\"display: none\"]):not([style*=\"display:none\"])', '.form-control:not(.disabled):not([disabled]):not([style*=\"display: none\"]):not([style*=\"display:none\"])', 'select:not(.disabled):not([disabled]):not([style*=\"display: none\"]):not([style*=\"display:none\"])', 'input[type=\"checkbox\"]:not(.disabled):not([disabled]):not([style*=\"display: none\"]):not([style*=\"display:none\"])', 'input[type=\"radio\"]:not(.disabled):not([disabled]):not([style*=\"display: none\"]):not([style*=\"display:none\"])'].join(\",\"),\n    buttonToolbar = { render: function render() {\n    var t = this,\n        e = t.$createElement;return (t._self._c || e)(\"div\", { class: t.classObject, attrs: { role: \"toolbar\", tabindex: t.keyNav ? \"0\" : null }, on: { focusin: function focusin(e) {\n          if (e.target !== e.currentTarget) return null;t.focusFirst(e);\n        }, keydown: [function (e) {\n          return \"button\" in e || !t._k(e.keyCode, \"left\", 37) ? \"button\" in e && 0 !== e.button ? null : void t.focusNext(e, !0) : null;\n        }, function (e) {\n          if (!(\"button\" in e) && t._k(e.keyCode, \"up\", 38)) return null;t.focusNext(e, !0);\n        }, function (e) {\n          return \"button\" in e || !t._k(e.keyCode, \"right\", 39) ? \"button\" in e && 2 !== e.button ? null : void t.focusNext(e, !1) : null;\n        }, function (e) {\n          if (!(\"button\" in e) && t._k(e.keyCode, \"down\", 40)) return null;t.focusNext(e, !1);\n        }, function (e) {\n          return (\"button\" in e || !t._k(e.keyCode, \"left\", 37)) && e.shiftKey ? \"button\" in e && 0 !== e.button ? null : void t.focusFirst(e) : null;\n        }, function (e) {\n          return (\"button\" in e || !t._k(e.keyCode, \"up\", 38)) && e.shiftKey ? void t.focusFirst(e) : null;\n        }, function (e) {\n          return (\"button\" in e || !t._k(e.keyCode, \"right\", 39)) && e.shiftKey ? \"button\" in e && 2 !== e.button ? null : void t.focusLast(e) : null;\n        }, function (e) {\n          return (\"button\" in e || !t._k(e.keyCode, \"down\", 40)) && e.shiftKey ? void t.focusLast(e) : null;\n        }] } }, [t._t(\"default\")], 2);\n  }, staticRenderFns: [], computed: { classObject: function classObject() {\n      return [\"btn-toolbar\", this.justify && !this.vertical ? \"justify-content-between\" : \"\"];\n    } }, props: { justify: { type: Boolean, default: !1 }, KeyNav: { type: Boolean, default: !1 } }, methods: { setItemFocus: function setItemFocus(t) {\n      this.$nextTick(function () {\n        t.focus();\n      });\n    }, focusNext: function focusNext(t, e) {\n      if (this.keyNav) {\n        t.preventDefault(), t.stopPropagation();var n = this.getItems();if (!(n.length < 1)) {\n          var i = n.indexOf(t.target);e && i > 0 ? i-- : !e && i < n.length - 1 && i++, i < 0 && (i = 0), this.setItemFocus(n[i]);\n        }\n      }\n    }, focusFirst: function focusFirst(t) {\n      if (this.keyNav) {\n        t.preventDefault(), t.stopPropagation();var e = this.getItems();e.length > 0 && this.setItemFocus(e[0]);\n      }\n    }, focusLast: function focusLast(t) {\n      if (this.keyNav) {\n        t.preventDefault(), t.stopPropagation();var e = this.getItems();e.length > 0 && this.setItemFocus([e.length - 1]);\n      }\n    }, getItems: function getItems() {\n      var t = Array.prototype.slice.call(this.$el.querySelectorAll(ITEM_SELECTOR));return t.forEach(function (t) {\n        t.tabIndex = -1;\n      }), t;\n    } }, mounted: function mounted() {\n    this.keyNav && this.getItems();\n  } },\n    buttonGroup = { render: function render() {\n    var t = this,\n        e = t.$createElement;return (t._self._c || e)(\"div\", { class: t.classObject }, [t._t(\"default\")], 2);\n  }, staticRenderFns: [], computed: { classObject: function classObject() {\n      return [\"btn-group\", this.vertical ? \"btn-group-vertical\" : \"\", this.justify && !this.vertical ? \"justify-content-between\" : \"\", this.size ? \"btn-group-\" + this.size : \"\"];\n    } }, props: { vertical: { type: Boolean, default: !1 }, justify: { type: Boolean, default: !1 }, size: { type: String, default: null } } },\n    clickOut = { mounted: function mounted() {\n    \"undefined\" != typeof document && document.documentElement.addEventListener(\"click\", this._clickOutListener);\n  }, destroyed: function destroyed() {\n    \"undefined\" != typeof document && document.removeEventListener(\"click\", this._clickOutListener);\n  }, methods: { _clickOutListener: function _clickOutListener(t) {\n      this.$el.contains(t.target) || this.clickOutListener && this.clickOutListener();\n    } } },\n    ITEM_SELECTOR$1 = '.dropdown-item:not(.disabled):not([disabled]):not([style*=\"display: none\"]):not([style*=\"display:none\"])',\n    HEADER_SELECTOR = '.dropdown-header:not([style*=\"display: none\"]):not([style*=\"display:none\"])',\n    ALL_SELECTOR = [ITEM_SELECTOR$1, HEADER_SELECTOR].join(\",\"),\n    dropdown = { props: { split: { type: Boolean, default: !1 }, text: { type: String, default: \"\" }, dropup: { type: Boolean, default: !1 }, disabled: { type: Boolean, default: !1 }, right: { type: Boolean, default: !1 } }, created: function created() {\n    var t = this,\n        e = function e(_e) {\n      _e !== t && (t.visible = !1);\n    };this.$root.$on(\"shown::dropdown\", e), this.$root.$on(\"clicked::link\", e);\n  }, watch: { visible: function visible(t, e) {\n      var n = this;t !== e && (t ? (this.$root.$emit(\"shown::dropdown\", this), \"undefined\" != typeof document && \"ontouchstart\" in document.documentElement && Array.prototype.slice.call(document.body.children).forEach(function (t) {\n        t.addEventListener(\"mouseover\", n.noop);\n      })) : (this.$root.$emit(\"hidden::dropdown\", this), \"undefined\" != typeof document && \"ontouchstart\" in document.documentElement && Array.prototype.slice.call(document.body.children).forEach(function (t) {\n        t.removeEventListener(\"mouseover\", n.noop);\n      })));\n    } }, methods: { noop: function noop() {}, toggle: function toggle() {\n      this.disabled ? this.visible = !1 : (this.visible = !this.visible, this.visible && this.$nextTick(function () {\n        var t = this.getFirstItem();t && this.focusItem(0, [t]);\n      }));\n    }, onTab: function onTab() {\n      this.visible && (this.visible = !1);\n    }, onEsc: function onEsc(t) {\n      this.visible && (this.visible = !1, t.preventDefault(), t.stopPropagation(), this.$nextTick(function () {\n        var t;(t = this.split && this.$refs.toggle ? this.$refs.toggle.$el || this.$refs.toggle : this.$refs.button.$el || this.$refs.button) && t.focus && t.focus();\n      }));\n    }, focusNext: function focusNext(t, e) {\n      if (this.visible) {\n        t.preventDefault(), t.stopPropagation();var n = this.getItems();if (!(n.length < 1)) {\n          var i = n.indexOf(t.target);e && i > 0 ? i-- : !e && i < n.length - 1 && i++, i < 0 && (i = 0), this.focusItem(i, n);\n        }\n      }\n    }, focusHovered: function focusHovered(t) {\n      if (this.visible) {\n        var e = this.getItems();if (!(e.length < 1)) {\n          var n = e.indexOf(t.target);n > -1 && (t.preventDefault(), t.stopPropagation(), this.focusItem(n, e));\n        }\n      }\n    }, focusItem: function focusItem(t, e) {\n      e.forEach(function (e, n) {\n        n === t ? (e.classList.add(\"active\"), e.focus()) : e.classList.remove(\"active\");\n      });\n    }, getItems: function getItems() {\n      return Array.prototype.slice.call(this.$refs.menu.querySelectorAll(ALL_SELECTOR));\n    }, getFirstItem: function getFirstItem() {\n      var t = this.$refs.menu.querySelector(ITEM_SELECTOR$1);return t || (t = this.$refs.menu.querySelector(HEADER_SELECTOR)), t || null;\n    } } },\n    buttonGroupDropdown = { render: function render() {\n    var t = this,\n        e = t.$createElement,\n        n = t._self._c || e;return n(\"div\", { class: [\"btn-group\", \"dropdown\", { dropup: t.dropup, show: t.visible }], attrs: { id: t.id || null } }, [n(\"b-button\", { ref: \"button\", class: { \"dropdown-toggle\": !t.split, \"btn-link\": t.link }, attrs: { id: t.id ? t.id + \"__BV_button_\" : null, \"aria-expanded\": t.visible ? \"true\" : \"false\", variant: t.variant, size: t.size, disabled: t.disabled }, on: { click: function click(e) {\n          e.stopPropagation(), e.preventDefault(), t.click(e);\n        }, kedown: [function (e) {\n          if (!(\"button\" in e) && t._k(e.keyCode, \"space\", 32)) return null;e.stopPropagation(), e.preventDefault(), t.click(e);\n        }, function (e) {\n          if (!(\"button\" in e) && t._k(e.keyCode, \"enter\", 13)) return null;e.stopPropagation(), e.preventDefault(), t.click(e);\n        }] } }, [t._t(\"text\", [t._v(t._s(t.text))])], 2), n(\"div\", { ref: \"menu\", class: [\"dropdown-menu\", { \"dropdown-menu-right\": t.right }], attrs: { role: \"menu\", \"aria-labelledby\": t.id ? t.id + \"__BV_button_\" : null }, on: { keyup: function keyup(e) {\n          if (!(\"button\" in e) && t._k(e.keyCode, \"esc\", 27)) return null;t.onEsc(e);\n        }, keydown: [function (e) {\n          if (!(\"button\" in e) && t._k(e.keyCode, \"tab\", 9)) return null;t.onTab(e);\n        }, function (e) {\n          if (!(\"button\" in e) && t._k(e.keyCode, \"up\", 38)) return null;t.focusNext(e, !0);\n        }, function (e) {\n          if (!(\"button\" in e) && t._k(e.keyCode, \"down\", 40)) return null;t.focusNext(e, !1);\n        }], mouseover: function mouseover(e) {\n          t.focusHovered(e);\n        } } }, [t._t(\"default\")], 2)], 1);\n  }, staticRenderFns: [], mixins: [clickOut, dropdown], data: function data() {\n    return { visible: !1 };\n  }, computed: { dropdownToggle: function dropdownToggle() {\n      return this.caret ? \"dropdown-toggle\" : \"\";\n    } }, props: { id: { type: String }, caret: { type: Boolean, default: !0 } }, methods: { clickOutListener: function clickOutListener() {\n      this.visible = !1;\n    } } },\n    inputGroup = { render: function render() {\n    var t = this,\n        e = t.$createElement,\n        n = t._self._c || e;return n(\"div\", { class: t.classObject, attrs: { role: \"group\" } }, [t._t(\"left\", [t.left ? n(\"div\", { staticClass: \"input-group-addon\", domProps: { innerHTML: t._s(t.left) } }) : t._e()]), t._t(\"default\"), t._t(\"right\", [t.right ? n(\"div\", { staticClass: \"input-group-addon\", domProps: { innerHTML: t._s(t.right) } }) : t._e()])], 2);\n  }, staticRenderFns: [], computed: { classObject: function classObject() {\n      return [\"input-group\", this.size ? \"input-group-\" + this.size : \"\", this.state ? \"has-\" + this.state : \"\"];\n    } }, props: { size: { type: String, default: null }, state: { type: String, default: null }, left: { type: String, default: null }, right: { type: String, default: null } } },\n    inputGroupAddon = { render: function render() {\n    var t = this,\n        e = t.$createElement;return (t._self._c || e)(\"div\", { staticClass: \"input-group-addon\", attrs: { id: t.id || null } }, [t._t(\"default\")], 2);\n  }, staticRenderFns: [], props: { id: { type: String, default: null } } },\n    inputGroupButton = { render: function render() {\n    var t = this,\n        e = t.$createElement;return (t._self._c || e)(\"div\", { staticClass: \"input-group-btn\" }, [t._t(\"default\")], 2);\n  }, staticRenderFns: [], props: {} },\n    card = { render: function render() {\n    var t = this,\n        e = t.$createElement,\n        n = t._self._c || e;return n(t.tag, { tag: \"component\", class: [\"card\", t.cardVariant, t.cardAlign, t.cardInverse] }, [t._t(\"img\", [t.img ? n(\"img\", { staticClass: \"card-img\", attrs: { src: t.img, alt: t.imgAlt } }) : t._e()]), t.header || t.$slots.header ? n(t.headerTag, { tag: \"component\", class: [\"card-header\", t.headerVariant ? \"bg-\" + t.headerVariant : \"\", t.headerClass] }, [t._t(\"header\", [n(\"div\", { domProps: { innerHTML: t._s(t.header) } })])], 2) : t._e(), t.noBlock ? [t._t(\"default\")] : n(\"div\", { class: t.blockClass }, [t.title ? n(\"h4\", { staticClass: \"card-title\", domProps: { innerHTML: t._s(t.title) } }) : t._e(), t.subTitle ? n(\"h6\", { staticClass: \"card-subtitle mb-2 text-muted\", domProps: { innerHTML: t._s(t.subTitle) } }) : t._e(), t._t(\"default\")], 2), t.footer || t.$slots.footer ? n(t.footerTag, { tag: \"component\", class: [\"card-footer\", t.footerVariant ? \"bg-\" + t.footerVariant : \"\", t.footerClass] }, [t._t(\"footer\", [n(\"div\", { domProps: { innerHTML: t._s(t.footer) } })])], 2) : t._e()], 2);\n  }, staticRenderFns: [], computed: { blockClass: function blockClass() {\n      return [\"card-block\", this.overlay ? \"card-img-overlay\" : null];\n    }, cardVariant: function cardVariant() {\n      return this.variant ? \"card-\" + this.variant : null;\n    }, cardInverse: function cardInverse() {\n      return this.overlay || this.inverse ? \"card-inverse\" : null === this.inverse && this.variant && this.variant.length > 0 && -1 === this.variant.indexOf(\"outline\") ? \"card-inverse\" : void 0;\n    }, cardAlign: function cardAlign() {\n      return this.align ? \"text-\" + this.align : null;\n    } }, props: { align: { type: String, default: null }, inverse: { type: Boolean, default: null }, variant: { type: String, default: null }, tag: { type: String, default: \"div\" }, header: { type: String, default: null }, headerVariant: { type: String, default: null }, headerClass: { type: [String, Array], default: \"\" }, headerTag: { type: String, default: \"div\" }, footer: { type: String, default: null }, footerVariant: { type: String, default: null }, footerClass: { type: [String, Array], default: \"\" }, footerTag: { type: String, default: \"div\" }, title: { type: String, default: null }, subTitle: { type: String, default: null }, noBlock: { type: Boolean, default: !1 }, img: { type: String, default: null }, imgAlt: { type: String, default: null }, overlay: { type: Boolean, default: !1 } } },\n    cardGroup = { render: function render() {\n    var t = this,\n        e = t.$createElement;return (t._self._c || e)(t.tag, { tag: \"component\", class: [\"card-\" + t.type] }, [t._t(\"default\")], 2);\n  }, staticRenderFns: [], computed: { type: function type() {\n      return this.deck ? \"deck\" : this.columns ? \"columns\" : \"group\";\n    } }, props: { tag: { type: String, default: \"div\" }, deck: { type: Boolean, default: !1 }, columns: { type: Boolean, default: !1 } } },\n    DIRECTION = { next: { current: \"carousel-item-left\", next: \"carousel-item-right\", overlay: \"carousel-item-next\" }, prev: { current: \"carousel-item-right\", next: \"carousel-item-left\", overlay: \"carousel-item-prev\" } },\n    carousel = { render: function render() {\n    var t = this,\n        e = t.$createElement,\n        n = t._self._c || e;return n(\"div\", { staticClass: \"carousel slide\", style: { background: t.background, height: t.height }, attrs: { role: \"region\", id: t.id || null, \"aria-busy\": t.isSliding ? \"true\" : \"false\" }, on: { mouseenter: t.pause, mouseleave: t.start, focusin: t.pause, focusout: function focusout(e) {\n          t.restart(e);\n        }, keydown: [function (e) {\n          return \"button\" in e || !t._k(e.keyCode, \"left\", 37) ? \"button\" in e && 0 !== e.button ? null : (e.stopPropagation(), e.preventDefault(), void t.prev(e)) : null;\n        }, function (e) {\n          return \"button\" in e || !t._k(e.keyCode, \"right\", 39) ? \"button\" in e && 2 !== e.button ? null : (e.stopPropagation(), e.preventDefault(), void t.next(e)) : null;\n        }] } }, [n(\"div\", { staticClass: \"carousel-inner\", attrs: { role: \"list\", id: t.id ? t.id + \"__BV_inner_\" : null } }, [t._t(\"default\")], 2), t.controls ? [n(\"a\", { staticClass: \"carousel-control-prev\", attrs: { href: \"#\", role: \"button\", \"aria-controls\": t.id ? t.id + \"__BV_inner_\" : null }, on: { click: function click(e) {\n          e.stopPropagation(), e.preventDefault(), t.prev(e);\n        }, keydown: [function (e) {\n          if (!(\"button\" in e) && t._k(e.keyCode, \"enter\", 13)) return null;e.stopPropagation(), e.preventDefault(), t.prev(e);\n        }, function (e) {\n          if (!(\"button\" in e) && t._k(e.keyCode, \"space\", 32)) return null;e.stopPropagation(), e.preventDefault(), t.prev(e);\n        }] } }, [n(\"span\", { staticClass: \"carousel-control-prev-icon\", attrs: { \"aria-hidden\": \"true\" } }), t._v(\" \"), n(\"span\", { staticClass: \"sr-only\" }, [t._v(t._s(t.labelPrev))])]), n(\"a\", { staticClass: \"carousel-control-next\", attrs: { href: \"#\", role: \"button\", \"aria-controls\": t.id ? t.id + \"__BV_inner_\" : null }, on: { click: function click(e) {\n          e.stopPropagation(), e.preventDefault(), t.next(e);\n        }, keydown: [function (e) {\n          if (!(\"button\" in e) && t._k(e.keyCode, \"enter\", 13)) return null;e.stopPropagation(), e.preventDefault(), t.next(e);\n        }, function (e) {\n          if (!(\"button\" in e) && t._k(e.keyCode, \"space\", 32)) return null;e.stopPropagation(), e.preventDefault(), t.next(e);\n        }] } }, [n(\"span\", { staticClass: \"carousel-control-next-icon\", attrs: { \"aria-hidden\": \"true\" } }), t._v(\" \"), n(\"span\", { staticClass: \"sr-only\" }, [t._v(t._s(t.labelNext))])])] : t._e(), n(\"ol\", { directives: [{ name: \"show\", rawName: \"v-show\", value: t.indicators, expression: \"indicators\" }], staticClass: \"carousel-indicators\", attrs: { role: \"group\", id: t.id ? t.id + \"__BV_indicators_\" : null, \"aria-hidden\": t.indicators ? \"false\" : \"true\", \"aria-label\": t.indicators && t.labelIndicators ? t.labelIndicators : null, \"aria-owns\": t.indicators && t.id ? t.id + \"__BV_inner_\" : null } }, t._l(t.slides.length, function (e) {\n      return n(\"li\", { class: { active: e - 1 === t.index }, attrs: { role: \"button\", id: t.id ? t.id + \"__BV_indicator_\" + e + \"_\" : null, tabindex: t.indicators ? \"0\" : \"-1\", \"aria-current\": e - 1 === t.index ? \"true\" : \"false\", \"aria-posinset\": e, \"aria-setsize\": t.slides.length, \"aria-label\": t.labelGotoSlide + \" \" + e, \"aria-describedby\": t.slides[e - 1].id || null, \"aria-controls\": t.id ? t.id + \"__BV_inner_\" : null }, on: { click: function click(n) {\n            t.index = e - 1;\n          }, keydown: [function (n) {\n            if (!(\"button\" in n) && t._k(n.keyCode, \"enter\", 13)) return null;n.stopPropagation(), n.preventDefault(), t.index = e - 1;\n          }, function (n) {\n            if (!(\"button\" in n) && t._k(n.keyCode, \"space\", 32)) return null;n.stopPropagation(), n.preventDefault(), t.index = e - 1;\n          }] } });\n    }))], 2);\n  }, staticRenderFns: [], data: function data() {\n    return { index: 0, isSliding: !1, slides: [] };\n  }, props: { id: { type: String }, labelPrev: { type: String, default: \"Previous Slide\" }, labelNext: { type: String, default: \"Next Slide\" }, labelGotoSlide: { type: String, default: \"Goto Slide\" }, labelIndicators: { type: String, default: \"Select a slide to display\" }, interval: { type: Number, default: 5e3 }, indicators: { type: Boolean, default: !1 }, controls: { type: Boolean, default: !1 }, height: { type: String }, background: { type: String } }, methods: { prev: function prev() {\n      this.index <= 0 ? this.index = this.slides.length - 1 : this.index--;\n    }, next: function next() {\n      \"undefined\" != typeof document && document.visibilityState && document.hidden || (this.index >= this.slides.length - 1 ? this.index = 0 : this.index++);\n    }, pause: function pause() {\n      0 !== this.interval && void 0 !== this.interval && (clearInterval(this._intervalId), this._intervalId = null, this.slides[this.index].tabIndex = 0);\n    }, start: function start() {\n      var t = this;0 !== this.interval && void 0 !== this.interval && (this.slides.forEach(function (t) {\n        t.tabIndex = -1;\n      }), this._intervalId = setInterval(function () {\n        t.next();\n      }, this.interval));\n    }, restart: function restart(t) {\n      t.relatedTarget && this.$el.contains(t.relatedTarget) || this.start();\n    } }, mounted: function mounted() {\n    this.slides = Array.prototype.slice.call(this.$el.querySelectorAll(\".carousel-item\")), this.slides[0].classList.add(\"active\");var t = this;this.slides.forEach(function (e, n) {\n      var i = n + 1;e.setAttribute(\"aria-current\", 0 === n ? \"true\" : \"false\"), e.setAttribute(\"aria-posinset\", String(i)), e.setAttribute(\"aria-setsize\", String(t.slides.length)), e.tabIndex = -1, t.id && e.setAttribute(\"aria-controlledby\", t.id + \"__BV_indicator_\" + i + \"_\");\n    }), this._intervalId = null, this.start();\n  }, watch: { index: function index(t, e) {\n      var n = this;if (t !== e) if (this.isSliding) this.index = e;else {\n        var i = t > e ? DIRECTION.next : DIRECTION.prev;0 === e && t === this.slides.length - 1 ? i = DIRECTION.prev : e === this.slides.length - 1 && 0 === t && (i = DIRECTION.next);var o = this.slides[e],\n            r = this.slides[t];o && r && (this.isSliding = !0, r.classList.add(i.next, i.overlay), o.classList.add(i.current), this._carouselAnimation = setTimeout(function () {\n          n.$emit(\"slide\", t), o.classList.remove(\"active\"), o.setAttribute(\"aria-current\", \"false\"), o.setAttribute(\"aria-hidden\", \"true\"), o.tabIndex = -1, o.classList.remove(i.current), r.classList.add(\"active\"), r.setAttribute(\"aria-current\", \"true\"), r.setAttribute(\"aria-hidden\", \"false\"), r.tabIndex = -1, r.classList.remove(i.next, i.overlay), n._intervalId || (o.tabIndex = 0, n.$nextTick(function () {\n            o.focus();\n          })), n.isSliding = !1;\n        }, 500));\n      }\n    } }, destroyed: function destroyed() {\n    clearTimeout(this._carouselAnimation), clearInterval(this._intervalId);\n  } },\n    carouselSlide = { render: function render() {\n    var t = this,\n        e = t.$createElement,\n        n = t._self._c || e;return n(\"div\", { staticClass: \"carousel-item\", style: { background: t.background, height: t.height }, attrs: { role: \"listitem\", id: t.id || null } }, [t.img ? n(\"img\", { staticClass: \"d-block img-fluid\", attrs: { src: t.img, alt: t.imgAlt } }) : t._e(), n(\"div\", { class: t.contentClasses }, [t.caption ? n(\"h3\", { domProps: { innerHTML: t._s(t.caption) } }) : t._e(), t.text ? n(\"p\", { domProps: { innerHTML: t._s(t.text) } }) : t._e(), t._t(\"default\")], 2)]);\n  }, staticRenderFns: [], props: { id: { type: String }, img: { type: String }, imgAlt: { type: String }, contentVisibleUp: { type: String }, caption: { type: String }, text: { type: String }, background: { type: String }, height: { type: String } }, computed: { contentClasses: function contentClasses() {\n      var t = { \"carousel-caption\": Boolean(this.caption) };return this.contentVisibleUp && (t[\"d-none\"] = !0, t[\"d-\" + this.contentVisibleUp + \"-block\"] = !0), t;\n    } } },\n    collapse = { render: function render() {\n    var t = this,\n        e = t.$createElement,\n        n = t._self._c || e;return n(\"transition\", { attrs: { name: \"collapse\" }, on: { enter: t.enter, \"after-enter\": t.clearHeight, leave: t.leave, \"after-leave\": t.clearHeight } }, [n(\"div\", { directives: [{ name: \"show\", rawName: \"v-show\", value: t.show, expression: \"show\" }], class: t.classObject, attrs: { id: t.id || null } }, [t._t(\"default\")], 2)]);\n  }, staticRenderFns: [], _scopeId: \"data-v-67b0a2de\", data: function data() {\n    return { show: this.visible };\n  }, computed: { classObject: function classObject() {\n      return { \"navbar-collapse\": this.isNav, show: this.show };\n    } }, model: { prop: \"visible\", event: \"input\" }, watch: { visible: function visible(t) {\n      t !== this.show && (this.show = t, this.emitState());\n    } }, props: { isNav: { type: Boolean, default: !1 }, id: { type: String, required: !0 }, accordion: { type: String, default: null }, visible: { type: Boolean, default: !1 } }, methods: { toggle: function toggle() {\n      this.show = !this.show, this.emitState();\n    }, enter: function enter(t) {\n      t.style.height = \"auto\";var e = getComputedStyle(t).height;t.style.height = \"0px\", t.offsetHeight, t.style.height = e;\n    }, leave: function leave(t) {\n      t.style.height = \"auto\";var e = getComputedStyle(t).height;t.style.height = e, t.offsetHeight, t.style.height = \"0px\";\n    }, clearHeight: function clearHeight(t) {\n      t.style.height = null;\n    }, emitState: function emitState() {\n      this.$emit(\"input\", this.show), this.$root.$emit(\"collapse::toggle::state\", this.id, this.show), this.accordion && this.show && this.$root.$emit(\"accordion::toggle\", this.id, this.accordion);\n    } }, created: function created() {\n    var t = this;this.$root.$on(\"collapse::toggle\", function (e) {\n      e === t.id && t.toggle();\n    }), this.$root.$on(\"accordion::toggle\", function (e, n) {\n      t.accordion && n === t.accordion && (e === t.id ? t.show || t.toggle() : t.show && t.toggle());\n    });\n  }, mounted: function mounted() {\n    this.emitState();\n  } },\n    dropdown$1 = { render: function render() {\n    var t = this,\n        e = t.$createElement,\n        n = t._self._c || e;return n(\"div\", { class: [\"dropdown\", \"btn-group\", { dropup: t.dropup, show: t.visible }], attrs: { id: t.id || null } }, [n(\"b-button\", { ref: \"button\", class: { \"dropdown-toggle\": !t.split, \"btn-link\": t.link }, attrs: { id: t.id ? t.id + \"__BV_button_\" : null, \"aria-haspopup\": t.split ? null : \"true\", \"aria-expanded\": t.split ? null : t.visible ? \"true\" : \"false\", variant: t.variant, size: t.size, disabled: t.disabled }, on: { click: function click(e) {\n          e.stopPropagation(), e.preventDefault(), t.click(e);\n        } } }, [t._t(\"text\", [t._v(t._s(t.text))])], 2), t.split ? n(\"b-button\", { ref: \"toggle\", class: [\"dropdown-toggle\", \"dropdown-toggle-split\", { \"btn-link\": t.link }], attrs: { id: t.id ? t.id + \"__BV_toggle_\" : null, \"aria-haspopup\": t.split ? \"true\" : null, \"aria-expanded\": t.split ? t.visible ? \"true\" : \"false\" : null, variant: t.variant, size: t.size, disabled: t.disabled }, on: { click: function click(e) {\n          e.stopPropagation(), e.preventDefault(), t.toggle(e);\n        } } }, [n(\"span\", { staticClass: \"sr-only\" }, [t._v(t._s(t.toggleText))])]) : t._e(), n(\"div\", { ref: \"menu\", class: [\"dropdown-menu\", { \"dropdown-menu-right\": t.right }], attrs: { role: \"menu\", \"aria-labelledby\": t.id ? t.id + (t.split ? \"__BV_toggle_\" : \"__BV_button_\") : null }, on: { keyup: function keyup(e) {\n          if (!(\"button\" in e) && t._k(e.keyCode, \"esc\", 27)) return null;t.onEsc(e);\n        }, keydown: [function (e) {\n          if (!(\"button\" in e) && t._k(e.keyCode, \"tab\", 9)) return null;t.onTab(e);\n        }, function (e) {\n          if (!(\"button\" in e) && t._k(e.keyCode, \"up\", 38)) return null;t.focusNext(e, !0);\n        }, function (e) {\n          if (!(\"button\" in e) && t._k(e.keyCode, \"down\", 40)) return null;t.focusNext(e, !1);\n        }], mouseover: function mouseover(e) {\n          t.focusHovered(e);\n        } } }, [t._t(\"default\")], 2)], 1);\n  }, staticRenderFns: [], mixins: [clickOut, dropdown], components: { bButton: bBtn }, data: function data() {\n    return { visible: !1 };\n  }, props: { id: { type: String }, toggleText: { type: String, default: \"Toggle Dropdown\" }, size: { type: String, default: null }, variant: { type: String, default: null }, link: { type: Boolean, default: !1 } }, methods: { clickOutListener: function clickOutListener() {\n      this.visible = !1;\n    }, click: function click(t) {\n      this.disabled ? this.visible = !1 : this.split ? (this.$emit(\"click\", t), this.$root.$emit(\"shown::dropdown\", this)) : this.toggle();\n    } } },\n    dropdownItem = { render: function render() {\n    var t = this,\n        e = t.$createElement;return (t._self._c || e)(\"b-link\", t._b({ staticClass: \"dropdown-item\", attrs: { role: \"menuitem\" }, on: { click: function click(e) {\n          t.$emit(\"click\", e);\n        } } }, \"b-link\", t.linkProps), [t._t(\"default\")], 2);\n  }, staticRenderFns: [], components: { bLink: bLink }, props: props, computed: { linkProps: computed.linkProps } },\n    dropdownItemButton = { render: function render() {\n    var t = this,\n        e = t.$createElement;return (t._self._c || e)(\"button\", { staticClass: \"dropdown-item\", attrs: { type: \"button\", role: \"menuitem\", disabled: t.disabled }, on: { click: t.onClick } }, [t._t(\"default\")], 2);\n  }, staticRenderFns: [], props: { disabled: { type: Boolean, default: !1 } }, methods: { onClick: function onClick(t) {\n      this.$root.$emit(\"clicked::link\", this), this.$emit(\"click\", t);\n    } } },\n    dropdownDivider = { render: function render() {\n    var t = this,\n        e = t.$createElement;return (t._self._c || e)(\"div\", { staticClass: \"dropdown-divider\", attrs: { role: \"separator\" } });\n  }, staticRenderFns: [], props: {} },\n    dropdownHeader = { render: function render() {\n    var t = this,\n        e = t.$createElement;return (t._self._c || e)(t.tag, { tag: \"component\", staticClass: \"dropdown-header\", attrs: { tabindex: \"-1\" } }, [t._t(\"default\")], 2);\n  }, staticRenderFns: [], props: { tag: { type: String, default: \"h6\" } } },\n    dropdownSelect = { render: function render() {\n    var t = this,\n        e = t.$createElement,\n        n = t._self._c || e;return n(\"div\", { staticClass: \"dropdown-select\", class: { open: t.show, dropdown: !t.dropup, dropup: t.dropup } }, [n(\"button\", { class: [\"btn\", \"dropdown\", t.dropdownToggle, t.btnVariant, t.btnSize], attrs: { id: t.id, role: \"button\", \"aria-haspopup\": \"true\", \"aria-expanded\": \"show\", disabled: t.disabled }, on: { click: function click(e) {\n          e.preventDefault(), t.toggle(e);\n        } } }, [n(\"span\", { staticClass: \"checked-items\", domProps: { innerHTML: t._s(t.displayItem) } })]), n(\"ul\", { staticClass: \"dropdown-menu\", class: { \"dropdown-menu-right\": \"right\" == t.position }, attrs: { \"aria-labelledby\": \"dLabel\" } }, t._l(t.list, function (e) {\n      return n(\"li\", [n(\"button\", { staticClass: \"dropdown-item\", attrs: { click: t.select(e) } }, [t._v(t._s(e.text))])]);\n    }))]);\n  }, staticRenderFns: [], data: function data() {\n    return { show: !1, selected: !1 };\n  }, computed: { btnVariant: function btnVariant() {\n      return this.variant && \"default\" !== this.variant ? \"btn-\" + this.variant : \"btn-secondary\";\n    }, btnSize: function btnSize() {\n      return this.size && \"default\" !== this.size ? \"btn-\" + this.size : \"\";\n    }, dropdownToggle: function dropdownToggle() {\n      return this.caret ? \"dropdown-toggle\" : \"\";\n    }, displayItem: function displayItem() {\n      if (this.returnObject && this.model && !this.model.text || !this.returnObject && this.model && 0 === this.model.length || this.forceDefault) return this.defaultText;if (this.returnObject && this.model && this.model.text) return this.model.text;if (!this.returnObject && this.model) {\n        var t = this.model || \"\";return this.list.forEach(function (e) {\n          e.value === this.model && (t = e.text);\n        }), t;\n      }return \"\";\n    } }, props: { id: { type: String }, model: { required: !1 }, list: { type: Array, default: [], required: !0 }, caret: { type: Boolean, default: !0 }, position: { type: String, default: \"left\" }, size: { type: String, default: \"\" }, variant: { type: String, default: \"default\" }, defaultText: { type: String, default: \"Plase select one\" }, forceDefault: { type: Boolean, default: !1 }, returnObject: { type: Boolean, default: !1 }, dropup: { type: Boolean, default: !1 }, disabled: { type: Boolean, default: !1 } }, methods: { toggle: function toggle(t) {\n      this.show = !this.show, this.show ? (this.$root.$emit(\"shown:dropdown\", this.id), t.stopPropagation()) : this.$root.$emit(\"hidden::dropdown\", this.id);\n    }, select: function select(t) {\n      this.returnObject ? this.model = t : this.model = t.value, this.show = !1, this.$root.$emit(\"selected::dropdown\", this.id, this.model);\n    } }, created: function created() {\n    this.$root.$on(\"hide::dropdown\", function () {\n      this.show = !1;\n    });\n  } },\n    bForm = { render: function render() {\n    var t = this,\n        e = t.$createElement;return (t._self._c || e)(\"form\", { class: t.classObject }, [t._t(\"default\")], 2);\n  }, staticRenderFns: [], computed: { classObject: function classObject() {\n      return [this.inline ? \"form-inline\" : \"\"];\n    } }, props: { inline: { type: Boolean, default: !1 } } },\n    formFieldset = { render: function render() {\n    var t = this,\n        e = t.$createElement,\n        n = t._self._c || e;return n(\"div\", { class: [\"form-group\", \"row\", t.inputState], attrs: { id: t.id || null, role: \"group\", \"aria-describedby\": t.describedBy } }, [t.label ? n(\"label\", { class: [t.labelSrOnly ? \"sr-only\" : \"col-form-label\", t.labelLayout, t.labelAlignClass], attrs: { for: t.target, id: t.labelId }, domProps: { innerHTML: t._s(t.label) } }) : t._e(), n(\"div\", { ref: \"content\", class: t.inputLayout }, [t._t(\"default\"), t.feedback ? n(\"div\", { staticClass: \"form-text form-control-feedback\", attrs: { id: t.feedbackId, role: \"alert\", \"aria-live\": \"assertive\", \"aria-atomic\": \"true\" }, domProps: { innerHTML: t._s(t.feedback) } }) : t._e(), t.description ? n(\"small\", { staticClass: \"form-text text-muted\", attrs: { id: t.descriptionId }, domProps: { innerHTML: t._s(t.description) } }) : t._e()], 2)]);\n  }, staticRenderFns: [], data: function data() {\n    return { target: null };\n  }, computed: { labelId: function labelId() {\n      return this.id && this.label ? this.id + \"__BV_label_\" : null;\n    }, descriptionId: function descriptionId() {\n      return this.id && this.description ? this.id + \"__BV_description_\" : null;\n    }, feedbackId: function feedbackId() {\n      return this.id && this.feedback ? this.id + \"__BV_feedback_\" : null;\n    }, describedBy: function describedBy() {\n      return this.id && (this.label || this.feedback || this.description) ? [this.labelId, this.descriptionId, this.feedbackId].filter(function (t) {\n        return t;\n      }).join(\" \") : null;\n    }, inputState: function inputState() {\n      return this.state ? \"has-\" + this.state : \"\";\n    }, labelLayout: function labelLayout() {\n      return this.labelSrOnly ? null : this.horizontal ? \"col-sm-\" + this.labelSize : \"col-12\";\n    }, labelAlignClass: function labelAlignClass() {\n      return this.labelSrOnly ? null : this.labelTextAlign ? \"text-\" + this.labelTextAlign : null;\n    }, inputLayout: function inputLayout() {\n      return this.horizontal ? \"col-sm-\" + (12 - this.labelSize) : \"col-12\";\n    } }, methods: { updateTarget: function updateTarget() {\n      if (this.for && this.$el && this.$el.querySelector(\"#\" + this.for)) return this.for;var t = this.$refs.content;if (!t) return null;var e = t.querySelector(this.inputSelector);this.target = e && e.id ? e.id : null;\n    } }, mounted: function mounted() {\n    this.updateTarget();\n  }, updated: function updated() {\n    this.updateTarget();\n  }, props: { id: { type: String, default: null }, for: { type: String, default: null }, state: { type: String, default: null }, horizontal: { type: Boolean, default: !1 }, labelSize: { type: Number, default: 3 }, labelTextAlign: { type: String, default: null }, label: { type: String, default: null }, labelSrOnly: { type: Boolean, default: !1 }, description: { type: String, default: null }, feedback: { type: String, default: null }, inputSelector: { type: String, default: '[role=\"radiogroup\"],input,select,textarea,.form-control,.form-control-static,.dropdown,.dropup' } } },\n    formMixin = { computed: { inputClass: function inputClass() {\n      return [this.size ? \"form-control-\" + this.size : null, this.state ? \"form-control-\" + this.state : null];\n    }, custom: function custom() {\n      return !this.plain;\n    } }, props: { name: { type: String }, disabled: { type: Boolean }, plain: { type: Boolean, default: !1 }, state: { type: String }, size: { type: String }, id: { type: String } } },\n    formCheckBoxMixin = { computed: { checkboxClass: function checkboxClass() {\n      return { \"custom-control\": this.custom, \"form-check-inline\": this.inline };\n    } } },\n    formCheckbox = { render: function render() {\n    var t = this,\n        e = t.$createElement,\n        n = t._self._c || e;return n(\"label\", { class: [t.inputClass, t.checkboxClass, t.custom ? \"custom-checkbox\" : null] }, [n(\"input\", { class: [t.custom ? \"custom-control-input\" : null], attrs: { type: \"checkbox\", id: t.id || null, name: t.name, disabled: t.disabled }, domProps: { value: t.value, checked: t.isChecked }, on: { change: t.handleChange } }), t._v(\" \"), t.custom ? n(\"span\", { staticClass: \"custom-control-indicator\", attrs: { \"aria-hidden\": \"true\" } }) : t._e(), t._v(\" \"), n(\"span\", { class: [t.custom ? \"custom-control-description\" : null] }, [t._t(\"default\")], 2)]);\n  }, staticRenderFns: [], mixins: [formMixin, formCheckBoxMixin], model: { prop: \"checked\", event: \"change\" }, props: { value: { default: !0 }, uncheckedValue: { default: !1 }, checked: { default: !0 } }, computed: { isChecked: function isChecked() {\n      return this.checked.includes(this.value);\n    } }, methods: { handleChange: function handleChange(t) {\n      var e = this,\n          n = t.target.checked;Array.isArray(this.checked) ? this.isChecked ? this.$emit(\"change\", this.checked.filter(function (t) {\n        return t !== e.value;\n      })) : this.$emit(\"change\", this.checked.concat([this.value])) : this.$emit(\"change\", n ? this.value : this.uncheckedValue);\n    } } },\n    formOptions = { computed: { formOptions: function formOptions() {\n      var t = this,\n          e = this.options || {};return e = Array.isArray(e) ? e.map(function (e) {\n        return \"object\" == (typeof e === \"undefined\" ? \"undefined\" : _typeof(e)) ? { value: e[t.valueField], text: e[t.textField], disabled: e.disabled || !1 } : { text: String(e), value: e || {} };\n      }) : Object.keys(e).map(function (n) {\n        var i = e[n] || {};return \"object\" != (typeof i === \"undefined\" ? \"undefined\" : _typeof(i)) && (i = { text: String(i) }), i.value = i[t.valueField] || n, i;\n      });\n    }, selectedValue: function selectedValue() {\n      for (var t = this, e = this.formOptions, n = 0; n < e.length; n++) {\n        if (e[n].value === t.localValue) return t.returnObject ? e[n] : e[n].value;\n      }\n    } }, props: { valueField: { type: [String], default: \"value\" }, textField: { type: [String], default: \"text\" } }, watch: { localValue: function localValue(t, e) {\n      t !== e && this.$emit(\"input\", this.selectedValue);\n    }, value: function value(t, e) {\n      t !== e && (this.localValue = t);\n    } } },\n    formRadio = { render: function render() {\n    var t = this,\n        e = t.$createElement,\n        n = t._self._c || e;return n(\"div\", { class: [t.inputClass, t.inputState, this.stacked ? \"custom-controls-stacked\" : \"\"], attrs: { id: t.id || null, role: \"radiogroup\" } }, t._l(t.formOptions, function (e) {\n      return n(\"label\", { class: [t.checkboxClass, t.custom ? \"custom-radio\" : null] }, [n(\"input\", { directives: [{ name: \"model\", rawName: \"v-model\", value: t.localValue, expression: \"localValue\" }], ref: \"inputs\", refInFor: !0, class: t.custom ? \"custom-control-input\" : null, attrs: { id: e.id || null, type: \"radio\", name: e.name, disabled: e.disabled }, domProps: { value: e.value, checked: t._q(t.localValue, e.value) }, on: { change: function change(n) {\n            t.$emit(\"change\", t.returnObject ? e : e.value);\n          }, __c: function __c(n) {\n            t.localValue = e.value;\n          } } }), t._v(\" \"), t.custom ? n(\"span\", { staticClass: \"custom-control-indicator\", attrs: { \"aria-hidden\": \"true\" } }) : t._e(), t._v(\" \"), n(\"span\", { class: t.custom ? \"custom-control-description\" : null, domProps: { innerHTML: t._s(e.text) } })]);\n    }));\n  }, staticRenderFns: [], mixins: [formMixin, formCheckBoxMixin, formOptions], data: function data() {\n    return { localValue: this.value };\n  }, computed: { inputState: function inputState() {\n      return this.state ? \"has-\" + this.state : \"\";\n    } }, props: { value: {}, options: { type: [Array, Object], default: null, required: !0 }, stacked: { type: Boolean, default: !1 }, returnObject: { type: Boolean, default: !1 } } },\n    bFormInputStatic = { render: function render() {\n    var t = this,\n        e = t.$createElement;return (t._self._c || e)(\"p\", { class: [\"form-control-static\", t.inputClass], attrs: { id: t.id || null }, domProps: { innerHTML: t._s(t.staticValue) } }, [t._t(\"default\")], 2);\n  }, staticRenderFns: [], mixins: [formMixin], computed: { staticValue: function staticValue() {\n      return this.formatter ? this.formatter(this.value) : this.value;\n    } }, props: { value: { default: null }, formatter: { type: Function } } },\n    formInput = { render: function render() {\n    var t = this,\n        e = t.$createElement,\n        n = t._self._c || e;return t.static ? n(\"b-form-input-static\", { attrs: { id: t.id || null, value: t.value, formatter: t.formatter } }) : n(t.textarea ? \"textarea\" : \"input\", { ref: \"input\", tag: \"input\", class: [\"form-control\", t.inputClass], attrs: { type: t.type, name: t.name, id: t.id || null, disabled: t.disabled, readonly: t.readonly, rows: t.rows || t.rowsCount, placeholder: t.placeholder }, domProps: { value: t.value }, on: { input: function input(e) {\n          t.onInput(e.target.value);\n        }, change: function change(e) {\n          t.onChange(e.target.value);\n        }, keyup: function keyup(e) {\n          t.onKeyUp(e);\n        }, focus: function focus(e) {\n          t.$emit(\"focus\");\n        }, blur: function blur(e) {\n          t.$emit(\"blur\");\n        } } });\n  }, staticRenderFns: [], mixins: [formMixin], components: { bFormInputStatic: bFormInputStatic }, computed: { rowsCount: function rowsCount() {\n      return (this.value || \"\").toString().split(\"\\n\").length;\n    } }, methods: { format: function format(t) {\n      if (this.formatter) {\n        var e = this.formatter(t);e !== t && (t = e, this.$refs.input.value = e);\n      }return t;\n    }, onInput: function onInput(t) {\n      this.lazyFormatter || (t = this.format(t)), this.$emit(\"input\", t);\n    }, onChange: function onChange(t) {\n      t = this.format(t), this.$emit(\"input\", t), this.$emit(\"change\", t);\n    }, onKeyUp: function onKeyUp(t) {\n      this.$emit(\"keyup\", t);\n    }, focus: function focus() {\n      this.$refs.input.focus();\n    } }, props: { value: { default: null }, type: { type: String, default: \"text\" }, readonly: { type: Boolean, default: !1 }, static: { type: Boolean, default: !1 }, placeholder: { type: String, default: null }, rows: { type: Number, default: null }, textarea: { type: Boolean, default: !1 }, formatter: { type: Function }, lazyFormatter: { type: Boolean, default: !1 } } },\n    formFile = { render: function render() {\n    var t = this,\n        e = t.$createElement,\n        n = t._self._c || e;return n(\"div\", { class: [\"form-control\", t.custom ? \"custom-file\" : null, t.inputClass], attrs: { id: t.id ? t.id + \"__BV_file_outer_\" : null }, on: { dragover: function dragover(e) {\n          e.stopPropagation(), e.preventDefault(), t.dragover(e);\n        } } }, [t.dragging && t.custom ? n(\"span\", { staticClass: \"drop-here\", attrs: { \"data-drop\": t.dropLabel }, on: { dragover: function dragover(e) {\n          e.stopPropagation(), e.preventDefault(), t.dragover(e);\n        }, drop: function drop(e) {\n          e.stopPropagation(), e.preventDefault(), t.drop(e);\n        }, dragleave: function dragleave(e) {\n          e.stopPropagation(), e.preventDefault(), t.dragging = !1;\n        } } }) : t._e(), n(\"input\", { ref: \"input\", class: t.custom ? \"custom-file-input\" : \"\", attrs: { type: \"file\", name: t.name, id: t.id || null, disabled: t.disabled, accept: t.accept || null, multiple: t.multiple, webkitdirectory: t.directory, \"aria-describedby\": t.custom && t.id ? t.id + \"__BV_file_control_\" : null }, on: { change: t.onFileChange } }), t._v(\" \"), t.custom ? n(\"span\", { class: [\"custom-file-control\", t.dragging ? \"dragging\" : null, t.inputClass], attrs: { id: t.id ? t.id + \"__BV_file_control_\" : null, \"data-choose\": t.computedChooseLabel, \"data-selected\": t.selectedLabel } }) : t._e()]);\n  }, staticRenderFns: [], _scopeId: \"data-v-c68bd5f8\", mixins: [formMixin], data: function data() {\n    return { selectedFile: null, dragging: !1 };\n  }, computed: { selectedLabel: function selectedLabel() {\n      return this.selectedFile && 0 !== this.selectedFile.length ? this.multiple ? 1 === this.selectedFile.length ? this.selectedFile[0].name : this.selectedFormat.replace(\":names\", this.selectedFile.map(function (t) {\n        return t.name;\n      }).join(\",\")).replace(\":count\", this.selectedFile.length) : this.selectedFile.name : this.placeholder || \"No file chosen\";\n    }, computedChooseLabel: function computedChooseLabel() {\n      return this.chooseLabel || (this.multiple ? \"Choose Files\" : \"Choose File\");\n    } }, watch: { selectedFile: function selectedFile(t, e) {\n      t !== e && (!t && this.multiple ? this.$emit(\"input\", []) : this.$emit(\"input\", t));\n    } }, methods: { reset: function reset() {\n      try {\n        this.$refs.input.value = \"\";\n      } catch (t) {}this.$refs.input.type = \"\", this.$refs.input.type = \"file\", this.selectedFile = this.multiple ? [] : null;\n    }, onFileChange: function onFileChange(t) {\n      var e = this;this.$emit(\"change\", t);var n = t.dataTransfer && t.dataTransfer.items;if (!n || this.noTraverse) this.setFiles(t.target.files || t.dataTransfer.files);else {\n        for (var i = [], o = 0; o < n.length; o++) {\n          var r = n[o].webkitGetAsEntry();r && i.push(e.traverseFileTree(r));\n        }Promise.all(i).then(function (t) {\n          e.setFiles(Array.prototype.concat.apply([], t));\n        });\n      }\n    }, setFiles: function setFiles(t) {\n      var e = this;if (t) {\n        if (this.multiple) {\n          for (var n = [], i = 0; i < t.length; i++) {\n            t[i].type.match(e.accept) && n.push(t[i]);\n          }this.selectedFile = n;\n        } else this.selectedFile = t[0];\n      } else this.selectedFile = null;\n    }, dragover: function dragover(t) {\n      !this.noDrop && this.custom && (this.dragging = !0, t.dataTransfer.dropEffect = \"copy\");\n    }, drop: function drop(t) {\n      this.noDrop || (this.dragging = !1, t.dataTransfer.files && t.dataTransfer.files.length > 0 && this.onFileChange(t));\n    }, traverseFileTree: function traverseFileTree(t, e) {\n      var n = this;return new Promise(function (i) {\n        e = e || \"\", t.isFile ? t.file(function (t) {\n          t.$path = e, i(t);\n        }) : t.isDirectory && t.createReader().readEntries(function (o) {\n          for (var r = [], s = 0; s < o.length; s++) {\n            r.push(n.traverseFileTree(o[s], e + t.name + \"/\"));\n          }Promise.all(r).then(function (t) {\n            i(Array.prototype.concat.apply([], t));\n          });\n        });\n      });\n    } }, props: { accept: { type: String, default: \"\" }, placeholder: { type: String, default: null }, chooseLabel: { type: String, default: null }, multiple: { type: Boolean, default: !1 }, directory: { type: Boolean, default: !1 }, noTraverse: { type: Boolean, default: !1 }, selectedFormat: { type: String, default: \":count Files\" }, noDrop: { type: Boolean, default: !1 }, dropLabel: { type: String, default: \"Drop files here\" } } },\n    formSelect = { render: function render() {\n    var t = this,\n        e = t.$createElement,\n        n = t._self._c || e;return n(\"select\", { directives: [{ name: \"model\", rawName: \"v-model\", value: t.localValue, expression: \"localValue\" }], ref: \"input\", class: [\"form-control\", t.inputClass, t.custom ? \"custom-select\" : null], attrs: { name: t.name, id: t.id || null, disabled: t.disabled }, on: { change: function change(e) {\n          var n = Array.prototype.filter.call(e.target.options, function (t) {\n            return t.selected;\n          }).map(function (t) {\n            return \"_value\" in t ? t._value : t.value;\n          });t.localValue = e.target.multiple ? n : n[0];\n        } } }, t._l(t.formOptions, function (e) {\n      return n(\"option\", { attrs: { disabled: e.disabled }, domProps: { value: e.value, innerHTML: t._s(e.text) } });\n    }));\n  }, staticRenderFns: [], mixins: [formMixin, formOptions], data: function data() {\n    return { localValue: this.value };\n  }, props: { value: {}, options: { type: [Array, Object], required: !0 }, returnObject: { type: Boolean, default: !1 } } },\n    jumbotron = { render: function render() {\n    var t = this,\n        e = t.$createElement,\n        n = t._self._c || e;return n(\"div\", { class: [\"jumbotron\", t.fluid ? \"jumbotron-fluid\" : null] }, [n(\"div\", { class: t.containerFluid ? \"container-fluid\" : \"container\" }, [t.header ? n(\"h1\", { staticClass: \"display-3\", domProps: { innerHTML: t._s(t.header) } }) : t._e(), t.lead ? n(\"p\", { staticClass: \"lead\", domProps: { innerHTML: t._s(t.lead) } }) : t._e(), t._t(\"default\")], 2)]);\n  }, staticRenderFns: [], computed: {}, props: { fluid: { type: Boolean, default: !1 }, containerFluid: { type: Boolean, default: !1 }, header: { type: String, default: null }, lead: { type: String, default: null } } },\n    badge = { render: function render() {\n    var t = this,\n        e = t.$createElement;return (t._self._c || e)(\"span\", { class: [\"badge\", t.badgeVariant, t.badgePill] }, [t._t(\"default\")], 2);\n  }, staticRenderFns: [], computed: { badgeVariant: function badgeVariant() {\n      return this.variant && \"default\" !== this.variant ? \"badge-\" + this.variant : \"badge-default\";\n    }, badgePill: function badgePill() {\n      return this.pill ? \"badge-pill\" : \"\";\n    } }, props: { variant: { type: String, default: \"default\" }, pill: { type: Boolean, default: !1 } } },\n    listGroup = { render: function render() {\n    var t = this,\n        e = t.$createElement;return (t._self._c || e)(t.tag, { tag: \"component\", class: [\"list-group\", t.flush ? \"list-group-flush\" : null] }, [t._t(\"default\")], 2);\n  }, staticRenderFns: [], props: { tag: { type: String, default: \"div\" }, flush: { type: Boolean, default: !1 } } },\n    linkProps$1 = Object.assign(omitLinkProps(\"href\", \"to\"), { href: { type: props.href.type }, to: { type: props.to.type }, tag: { type: props.tag.type } }),\n    actionTags = [\"a\", \"router-link\", \"button\", \"b-link\"],\n    listGroupItem = { render: function render() {\n    var t = this,\n        e = t.$createElement;return (t._self._c || e)(t.myTag, t._b({ ref: \"item\", tag: \"component\", class: t.classObject }, \"component\", t.conditionalLinkProps), [t._t(\"default\")], 2);\n  }, staticRenderFns: [], components: { bLink: bLink }, computed: { linkProps: computed.linkProps, classObject: function classObject() {\n      return [\"list-group-item\", this.listState, this.active ? \"active\" : null, this.disabled ? \"disabled\" : null, this.isAction ? \"list-group-item-action\" : null];\n    }, isAction: function isAction() {\n      return !1 !== this.action && !!(this.action || this.to || this.href || actionTags.includes(this.tag));\n    }, listState: function listState() {\n      return this.variant ? \"list-group-item-\" + this.variant : null;\n    }, myTag: function myTag() {\n      return this.tag ? this.tag : this.to || this.href ? \"b-link\" : \"div\";\n    }, conditionalLinkProps: function conditionalLinkProps() {\n      return \"b-link\" !== this.myTag ? {} : this.linkProps;\n    } }, props: Object.assign(linkProps$1, { action: { type: Boolean, default: null }, variant: { type: String, default: null } }) },\n    media = { render: function render() {\n    var t = this,\n        e = t.$createElement,\n        n = t._self._c || e;return n(\"div\", { staticClass: \"media\" }, [t.rightAlign ? t._e() : n(\"div\", { class: [\"d-flex\", \"mr-3\", t.verticalAlignClass] }, [t._t(\"aside\")], 2), n(\"div\", { staticClass: \"media-body\" }, [t._t(\"default\")], 2), t.rightAlign ? n(\"div\", { class: [\"d-flex\", \"ml-3\", t.verticalAlignClass] }, [t._t(\"aside\")], 2) : t._e()]);\n  }, staticRenderFns: [], computed: { verticalAlignClass: function verticalAlignClass() {\n      return \"align-self-\" + this.verticalAlign;\n    } }, props: { rightAlign: { type: Boolean, default: !1 }, verticalAlign: { type: String, default: \"top\" } } },\n    FOCUS_SELECTOR = [\"button:not([disabled])\", \"input:not([disabled])\", \"select:not([disabled])\", \"textarea:not([disabled])\", \"a:not([disabled]):not(.disabled)\", \"[tabindex]:not([disabled]):not(.disabled)\"].join(\",\"),\n    modal = { render: function render() {\n    var t = this,\n        e = t.$createElement,\n        n = t._self._c || e;return n(\"div\", [n(\"transition-group\", { attrs: { \"enter-class\": \"hidden\", \"enter-to-class\": \"\", \"enter-active-class\": \"\", \"leave-class\": \"show\", \"leave-active-class\": \"\", \"leave-to-class\": \"hidden\" }, on: { \"after-enter\": t.focusFirst } }, [n(\"div\", { directives: [{ name: \"show\", rawName: \"v-show\", value: t.is_visible, expression: \"is_visible\" }], key: \"modal\", ref: \"modal\", class: [\"modal\", { fade: !t.noFade, show: t.is_visible }], attrs: { id: t.id || null, role: \"dialog\" }, on: { click: function click(e) {\n          t.onClickOut();\n        }, keyup: function keyup(e) {\n          if (!(\"button\" in e) && t._k(e.keyCode, \"esc\", 27)) return null;t.onEsc();\n        } } }, [n(\"div\", { class: [\"modal-dialog\", \"modal-\" + t.size] }, [n(\"div\", { ref: \"content\", staticClass: \"modal-content\", attrs: { tabindex: \"-1\", role: \"document\", \"aria-labelledby\": t.hideHeader || !t.id ? null : t.id + \"__BV_title_\", \"aria-describedby\": t.id ? t.id + \"__BV_body_\" : null }, on: { click: function click(t) {\n          t.stopPropagation();\n        } } }, [t.hideHeader ? t._e() : n(\"header\", { ref: \"header\", staticClass: \"modal-header\" }, [t._t(\"modal-header\", [n(\"h5\", { staticClass: \"modal-title\", attrs: { id: t.id ? t.id + \"__BV_title_\" : null } }, [t._t(\"modal-title\", [t._v(t._s(t.title))])], 2), t.hideHeaderClose ? t._e() : n(\"button\", { staticClass: \"close\", attrs: { type: \"button\", \"aria-label\": t.headerCloseLabel }, on: { click: t.hide } }, [n(\"span\", { attrs: { \"aria-hidden\": \"true\" } }, [t._v(\"Ã—\")])])])], 2), n(\"div\", { ref: \"body\", staticClass: \"modal-body\", attrs: { id: t.id ? t.id + \"__BV_body_\" : null } }, [t._t(\"default\")], 2), t.hideFooter ? t._e() : n(\"footer\", { ref: \"footer\", staticClass: \"modal-footer\" }, [t._t(\"modal-footer\", [t.okOnly ? t._e() : n(\"b-btn\", { attrs: { variant: \"secondary\", size: t.buttonSize }, on: { click: function click(e) {\n          t.hide(!1);\n        } } }, [t._t(\"modal-cancel\", [t._v(t._s(t.closeTitle))])], 2), n(\"b-btn\", { attrs: { variant: \"primary\", size: t.buttonSize, disabled: t.okDisabled }, on: { click: function click(e) {\n          t.hide(!0);\n        } } }, [t._t(\"modal-ok\", [t._v(t._s(t.okTitle))])], 2)])], 2)])])]), t.is_visible ? n(\"div\", { key: \"modal-backdrop\", class: [\"modal-backdrop\", { fade: !t.noFade, show: t.is_visible }] }) : t._e()])], 1);\n  }, staticRenderFns: [], _scopeId: \"data-v-1b4cbb68\", components: { bBtn: bBtn }, data: function data() {\n    return { is_visible: !1, return_focus: this.returnFocus || null };\n  }, model: { prop: \"visible\", event: \"change\" }, computed: { body: function body() {\n      if (\"undefined\" != typeof document) return document.querySelector(\"body\");\n    } }, watch: { visible: function visible(t, e) {\n      t !== e && (t ? this.show() : this.hide());\n    } }, props: { id: { type: String, default: null }, title: { type: String, default: \"\" }, size: { type: String, default: \"md\" }, buttonSize: { type: String, default: \"md\" }, noFade: { type: Boolean, default: !1 }, noCloseOnBackdrop: { type: Boolean, default: !1 }, noCloseOnEsc: { type: Boolean, default: !1 }, noAutoFocus: { type: Boolean, default: !1 }, hideHeader: { type: Boolean, default: !1 }, hideFooter: { type: Boolean, default: !1 }, okOnly: { type: Boolean, default: !1 }, okDisabled: { type: Boolean, default: !1 }, hideHeaderClose: { type: Boolean, default: !1 }, visible: { type: Boolean, default: !1 }, returnFocus: { default: null }, headerCloseLabel: { type: String, default: \"Close\" }, closeTitle: { type: String, default: \"Close\" }, okTitle: { type: String, default: \"OK\" } }, methods: { show: function show() {\n      this.is_visible || (this.$emit(\"show\"), this.is_visible = !0, this.$root.$emit(\"shown::modal\", this.id), this.body.classList.add(\"modal-open\"), this.$emit(\"shown\"), this.$emit(\"change\", !0), \"undefined\" != typeof document && (document.removeEventListener(\"focusin\", this.enforceFocus, !1), document.addEventListener(\"focusin\", this.enforceFocus, !1)));\n    }, hide: function hide(t) {\n      if (this.is_visible) {\n        var e = !1,\n            n = { isOK: t, cancel: function cancel() {\n            e = !0;\n          } };this.$emit(\"change\", !1), this.$emit(\"hide\", n), !0 === t ? this.$emit(\"ok\", n) : !1 === t && this.$emit(\"cancel\", n), e || (\"undefined\" != typeof document && (document.removeEventListener(\"focusin\", this.enforceFocus, !1), this.returnFocusTo()), this.is_visible = !1, this.$root.$emit(\"hidden::modal\", this.id), this.$emit(\"hidden\", n), this.body.classList.remove(\"modal-open\"));\n      }\n    }, onClickOut: function onClickOut() {\n      this.is_visible && !this.noCloseOnBackdrop && this.hide();\n    }, onEsc: function onEsc() {\n      this.is_visible && !this.noCloseOnEsc && this.hide();\n    }, focusFirst: function focusFirst() {\n      var t = this;\"undefined\" != typeof document && this.$nextTick(function () {\n        if (!document.activeElement || !t.$refs.content.contains(document.activeElement)) {\n          var e;t.noAutoFocus || (t.$refs.body && (e = findFirstVisible(t.$refs.body, FOCUS_SELECTOR)), !e && t.$refs.footer && (e = findFirstVisible(t.$refs.footer, FOCUS_SELECTOR)), !e && t.$refs.header && (e = findFirstVisible(t.$refs.header, FOCUS_SELECTOR))), e || (e = t.$refs.content), e && e.focus && e.focus();\n        }\n      });\n    }, returnFocusTo: function returnFocusTo() {\n      var t = this.returnFocus || this.return_focus || null;t && (\"string\" == typeof t && (t = document.querySelector(t)), t && t.$el && \"function\" == typeof t.$el.focus ? t.$el.focus() : t && \"function\" == typeof t.focus && t.focus());\n    }, enforceFocus: function enforceFocus(t) {\n      this.is_visible && document !== t.target && this.$refs.content && this.$refs.content !== t.target && !this.$refs.content.contains(t.target) && this.$refs.content.focus();\n    } }, created: function created() {\n    var t = this;this.$root.$on(\"show::modal\", function (e, n) {\n      e === t.id && (t.return_focus = n || null, t.show());\n    }), this.$root.$on(\"hide::modal\", function (e) {\n      e === t.id && t.hide();\n    });\n  }, mounted: function mounted() {\n    !0 === this.visible && this.show();\n  }, destroyed: function destroyed() {\n    \"undefined\" != typeof document && document.removeEventListener(\"focusin\", this.enforceFocus, !1);\n  } },\n    nav = { render: function render() {\n    var t = this,\n        e = t.$createElement;return (t._self._c || e)(t.type, { tag: \"component\", class: t.classObject }, [t._t(\"default\")], 2);\n  }, staticRenderFns: [], computed: { classObject: function classObject() {\n      return { nav: !0, \"navbar-nav\": this.isNavBar, \"nav-tabs\": this.tabs, \"nav-pills\": this.pills, \"flex-column\": this.vertical, \"nav-fill\": this.fill, \"nav-justified\": this.justified };\n    } }, props: { type: { type: String, default: \"ul\" }, fill: { type: Boolean, default: !1 }, justified: { type: Boolean, default: !1 }, tabs: { type: Boolean, default: !1 }, pills: { type: Boolean, default: !1 }, vertical: { type: Boolean, default: !1 }, isNavBar: { type: Boolean, default: !1 } } },\n    navItem = { render: function render() {\n    var t = this,\n        e = t.$createElement,\n        n = t._self._c || e;return n(\"li\", { staticClass: \"nav-item\" }, [n(\"b-link\", t._b({ staticClass: \"nav-link\", on: { click: function click(e) {\n          t.$emit(\"click\", e);\n        } } }, \"b-link\", t.linkProps), [t._t(\"default\")], 2)], 1);\n  }, staticRenderFns: [], components: { bLink: bLink }, props: props, computed: { linkProps: computed.linkProps } },\n    navItemDropdown = { render: function render() {\n    var t = this,\n        e = t.$createElement,\n        n = t._self._c || e;return n(\"li\", { class: [\"nav-item\", \"dropdown\", { dropup: t.dropup, show: t.visible }], attrs: { id: t.id || null } }, [n(\"a\", { ref: \"button\", class: [\"nav-link\", t.dropdownToggle, { disabled: t.disabled }], attrs: { href: \"#\", id: t.id ? t.id + \"__BV_button_\" : null, \"aria-haspopup\": \"true\", \"aria-expanded\": t.visible ? \"true\" : \"false\", disabled: t.disabled }, on: { click: function click(e) {\n          e.stopPropagation(), e.preventDefault(), t.toggle(e);\n        }, keydown: [function (e) {\n          if (!(\"button\" in e) && t._k(e.keyCode, \"enter\", 13)) return null;e.stopPropagation(), e.preventDefault(), t.toggle(e);\n        }, function (e) {\n          if (!(\"button\" in e) && t._k(e.keyCode, \"space\", 32)) return null;e.stopPropagation(), e.preventDefault(), t.toggle(e);\n        }] } }, [t._t(\"text\", [n(\"span\", { domProps: { innerHTML: t._s(t.text) } })])], 2), n(\"div\", { ref: \"menu\", class: [\"dropdown-menu\", { \"dropdown-menu-right\": t.right }], attrs: { role: \"menu\", \"aria-labelledby\": t.id ? t.id + \"__BV_button_\" : null }, on: { keyup: function keyup(e) {\n          if (!(\"button\" in e) && t._k(e.keyCode, \"esc\", 27)) return null;t.onEsc(e);\n        }, keydown: [function (e) {\n          if (!(\"button\" in e) && t._k(e.keyCode, \"tab\", 9)) return null;t.onTab(e);\n        }, function (e) {\n          if (!(\"button\" in e) && t._k(e.keyCode, \"up\", 38)) return null;t.focusNext(e, !0);\n        }, function (e) {\n          if (!(\"button\" in e) && t._k(e.keyCode, \"down\", 40)) return null;t.focusNext(e, !1);\n        }], mouseover: function mouseover(e) {\n          t.focusHovered(e);\n        } } }, [t._t(\"default\")], 2)]);\n  }, staticRenderFns: [], mixins: [clickOut, dropdown], data: function data() {\n    return { visible: !1 };\n  }, computed: { dropdownToggle: function dropdownToggle() {\n      return this.caret ? \"dropdown-toggle\" : \"\";\n    } }, props: { id: { type: String }, caret: { type: Boolean, default: !0 } }, methods: { clickOutListener: function clickOutListener() {\n      this.visible = !1;\n    } } },\n    navToggle = { render: function render() {\n    var t = this,\n        e = t.$createElement,\n        n = t._self._c || e;return n(\"button\", { class: t.classObject, attrs: { type: \"button\", \"aria-label\": t.label, \"aria-controls\": t.target.id ? t.target.id : t.target, \"aria-expanded\": t.toggleState ? \"true\" : \"false\" }, on: { click: t.onclick } }, [n(\"span\", { staticClass: \"navbar-toggler-icon\" })]);\n  }, staticRenderFns: [], computed: { classObject: function classObject() {\n      return [\"navbar-toggler\", \"navbar-toggler-\" + this.position];\n    } }, data: function data() {\n    return { toggleState: !1 };\n  }, props: { label: { type: String, default: \"Toggle navigation\" }, position: { type: String, default: \"right\" }, target: { required: !0 } }, methods: { onclick: function onclick() {\n      var t = this.target;t.toggle && t.toggle(), this.$root.$emit(\"collapse::toggle\", this.target);\n    } }, created: function created() {\n    var t = this;this.$root.$on(\"collapse::toggle::state\", function (e, n) {\n      e !== t.target && e !== t.target.id || (t.toggleState = n);\n    });\n  } },\n    navbar = { render: function render() {\n    var t = this,\n        e = t.$createElement;return (t._self._c || e)(\"nav\", { class: t.classObject }, [t._t(\"default\")], 2);\n  }, staticRenderFns: [], computed: { classObject: function classObject() {\n      return [\"navbar\", this.type ? \"navbar-\" + this.type : null, this.variant ? \"bg-\" + this.variant : null, this.fixed ? \"fixed-\" + this.fixed : null, this.sticky ? \"sticky-top\" : null, this.toggleable ? this.toggleableClass : null];\n    }, toggleableClass: function toggleableClass() {\n      var t = \"navbar-toggleable\";return this.toggleBreakpoint && (t += \"-\" + this.toggleBreakpoint), t;\n    } }, props: { type: { type: String, default: \"light\" }, variant: { type: String }, toggleable: { type: Boolean, default: !1 }, toggleBreakpoint: { type: String, default: null }, fixed: { type: String }, sticky: { type: Boolean, default: !1 } } },\n    navText = { render: function render() {\n    var t = this,\n        e = t.$createElement;return (t._self._c || e)(\"span\", { staticClass: \"navbar-text\" }, [t._t(\"default\")], 2);\n  }, staticRenderFns: [], props: {} },\n    navForm = { render: function render() {\n    var t = this,\n        e = t.$createElement;return (t._self._c || e)(\"b-form\", { attrs: { id: t.id || null, inline: \"\" } }, [t._t(\"default\")], 2);\n  }, staticRenderFns: [], components: [bForm], props: { id: { type: String } } },\n    ELLIPSIS_THRESHOLD = 3,\n    pagination = { render: function render() {\n    var t = this,\n        e = t.$createElement,\n        n = t._self._c || e;return n(\"ul\", { class: [\"pagination\", t.btnSize], attrs: { role: t.role, \"aria-disabled\": t.disabled ? \"true\" : \"false\", \"aria-label\": t.ariaLabel ? t.ariaLabel : null }, on: { focusin: function focusin(e) {\n          if (e.target !== e.currentTarget) return null;t.focusCurrent(e);\n        }, keydown: [function (e) {\n          return \"button\" in e || !t._k(e.keyCode, \"left\", 37) ? \"button\" in e && 0 !== e.button ? null : (e.preventDefault(), void t.focusPrev(e)) : null;\n        }, function (e) {\n          return \"button\" in e || !t._k(e.keyCode, \"right\", 39) ? \"button\" in e && 2 !== e.button ? null : (e.preventDefault(), void t.focusNext(e)) : null;\n        }, function (e) {\n          return (\"button\" in e || !t._k(e.keyCode, \"left\", 37)) && e.shiftKey ? \"button\" in e && 0 !== e.button ? null : (e.preventDefault(), void t.focusFirst(e)) : null;\n        }, function (e) {\n          return (\"button\" in e || !t._k(e.keyCode, \"right\", 39)) && e.shiftKey ? \"button\" in e && 2 !== e.button ? null : (e.preventDefault(), void t.focusLast(e)) : null;\n        }] } }, [t.hideGotoEndButtons ? t._e() : [t.isActive(1) || t.disabled ? n(\"li\", { staticClass: \"page-item disabled\", attrs: { \"aria-hidden\": \"true\" } }, [n(\"span\", { staticClass: \"page-link\", domProps: { innerHTML: t._s(t.firstText) } })]) : n(\"li\", { staticClass: \"page-item\" }, [n(\"a\", { staticClass: \"page-link\", attrs: { role: t.buttonRole, \"aria-label\": t.labelFirstPage, tabindex: \"-1\", href: \"#\" }, on: { click: function click(e) {\n          e.preventDefault(), t.setPage(e, 1);\n        }, keydown: [function (e) {\n          if (!(\"button\" in e) && t._k(e.keyCode, \"enter\", 13)) return null;e.preventDefault(), t.setPage(e, 1);\n        }, function (e) {\n          if (!(\"button\" in e) && t._k(e.keyCode, \"space\", 32)) return null;e.preventDefault(), t.setPage(e, 1);\n        }] } }, [n(\"span\", { attrs: { \"aria-hidden\": \"true\" }, domProps: { innerHTML: t._s(t.firstText) } })])])], t.isActive(1) || t.disabled ? n(\"li\", { staticClass: \"page-item disabled\", attrs: { \"aria-hidden\": \"true\" } }, [n(\"span\", { staticClass: \"page-link\", domProps: { innerHTML: t._s(t.prevText) } })]) : n(\"li\", { staticClass: \"page-item\" }, [n(\"a\", { staticClass: \"page-link\", attrs: { role: t.buttonRole, \"aria-label\": t.labelPrevPage, tabindex: \"-1\", href: \"#\" }, on: { click: function click(e) {\n          e.preventDefault(), t.setPage(e, t.currentPage - 1);\n        }, keydown: [function (e) {\n          if (!(\"button\" in e) && t._k(e.keyCode, \"enter\", 13)) return null;e.preventDefault(), t.setPage(e, t.currentPage - 1);\n        }, function (e) {\n          if (!(\"button\" in e) && t._k(e.keyCode, \"space\", 32)) return null;e.preventDefault(), t.setPage(e, t.currentPage - 1);\n        }] } }, [n(\"span\", { attrs: { \"aria-hidden\": \"true\" }, domProps: { innerHTML: t._s(t.prevText) } })])]), t.showFirstDots ? n(\"li\", { staticClass: \"page-item disabled hidden-xs-down\", attrs: { role: \"seperator\" } }, [n(\"span\", { staticClass: \"page-link\", domProps: { innerHTML: t._s(t.ellipsisText) } })]) : t._e(), t._l(t.pageList, function (e) {\n      return n(\"li\", { key: e.number, class: t.pageItemClasses(e) }, [n(\"a\", { class: t.pageLinkClasses(e), attrs: { role: t.buttonRole, disabled: t.disabled, \"aria-disabled\": t.disabled ? \"true\" : \"false\", \"aria-label\": t.labelPage + \" \" + e.number, \"aria-current\": t.isActive(e) ? \"true\" : \"false\", \"aria-posinset\": e.number, \"aria-setsize\": t.numberOfPages, tabindex: \"-1\" }, on: { click: function click(n) {\n            n.preventDefault(), t.setPage(n, e.number);\n          }, keydown: [function (n) {\n            if (!(\"button\" in n) && t._k(n.keyCode, \"enter\", 13)) return null;n.preventDefault(), t.setPage(n, e.number);\n          }, function (n) {\n            if (!(\"button\" in n) && t._k(n.keyCode, \"space\", 32)) return null;n.preventDefault(), t.setPage(n, e.number);\n          }] } }, [t._v(t._s(e.number))])]);\n    }), t.showLastDots ? n(\"li\", { staticClass: \"page-item disabled hidden-xs-down\", attrs: { role: \"seperator\" } }, [n(\"span\", { staticClass: \"page-link\", domProps: { innerHTML: t._s(t.ellipsisText) } })]) : t._e(), t.isActive(t.numberOfPages) || t.disabled ? n(\"li\", { staticClass: \"page-item disabled\", attrs: { \"aria-hidden\": \"true\" } }, [n(\"span\", { staticClass: \"page-link\", domProps: { innerHTML: t._s(t.nextText) } })]) : n(\"li\", { staticClass: \"page-item\" }, [n(\"a\", { staticClass: \"page-link\", attrs: { role: t.buttonRole, \"aria-label\": t.labelNextPage, tabindex: \"-1\" }, on: { click: function click(e) {\n          e.preventDefault(), t.setPage(e, t.currentPage + 1);\n        }, keydown: [function (e) {\n          if (!(\"button\" in e) && t._k(e.keyCode, \"enter\", 13)) return null;e.preventDefault(), t.setPage(e, t.currentPage + 1);\n        }, function (e) {\n          if (!(\"button\" in e) && t._k(e.keyCode, \"space\", 32)) return null;e.preventDefault(), t.setPage(e, t.currentPage + 1);\n        }] } }, [n(\"span\", { attrs: { \"aria-hidden\": \"true\" }, domProps: { innerHTML: t._s(t.nextText) } })])]), t.hideGotoEndButtons ? t._e() : [t.isActive(t.numberOfPages) || t.disabled ? n(\"li\", { staticClass: \"page-item disabled\", attrs: { \"aria-hidden\": \"true\" } }, [n(\"span\", { staticClass: \"page-link\", domProps: { innerHTML: t._s(t.lastText) } })]) : n(\"li\", { staticClass: \"page-item\" }, [n(\"a\", { staticClass: \"page-link\", attrs: { role: t.buttonRole, \"aria-label\": t.labelLastPage, tabindex: \"-1\" }, on: { click: function click(e) {\n          e.preventDefault(), t.setPage(e, t.numberOfPages);\n        }, keydown: [function (e) {\n          if (!(\"button\" in e) && t._k(e.keyCode, \"enter\", 13)) return null;e.preventDefault(), t.setPage(e, t.numberOfPages);\n        }, function (e) {\n          if (!(\"button\" in e) && t._k(e.keyCode, \"space\", 32)) return null;e.preventDefault(), t.setPage(e, t.numberOfPages);\n        }] } }, [n(\"span\", { attrs: { \"aria-hidden\": \"true\" }, domProps: { innerHTML: t._s(t.lastText) } })])])]], 2);\n  }, staticRenderFns: [], _scopeId: \"data-v-2792960b\", data: function data() {\n    return { showFirstDots: !1, showLastDots: !1, currentPage: this.value };\n  }, computed: { numberOfPages: function numberOfPages() {\n      var t = Math.ceil(this.totalRows / this.perPage);return t < 1 ? 1 : t;\n    }, btnSize: function btnSize() {\n      return this.size ? \"pagination-\" + this.size : \"\";\n    }, pageList: function pageList() {\n      this.currentPage > this.numberOfPages ? this.currentPage = this.numberOfPages : this.currentPage < 1 && (this.currentPage = 1), this.showFirstDots = !1, this.showLastDots = !1;var t = this.limit,\n          e = 1;this.numberOfPages <= this.limit ? t = this.numberOfPages : this.currentPage < this.limit - 1 && this.limit > ELLIPSIS_THRESHOLD ? this.hideEllipsis || (t = this.limit - 1, this.showLastDots = !0) : this.numberOfPages - this.currentPage + 2 < this.limit && this.limit > ELLIPSIS_THRESHOLD ? (this.hideEllipsis || (this.showFirstDots = !0, t = this.limit - 1), e = this.numberOfPages - t + 1) : (this.limit > ELLIPSIS_THRESHOLD && !this.hideEllipsis && (this.showFirstDots = !0, this.showLastDots = !0, t = this.limit - 2), e = this.currentPage - Math.floor(t / 2)), e < 1 ? e = 1 : e > this.numberOfPages - t && (e = this.numberOfPages - t + 1);var n = makePageArray(e, t);if (n.length > 3) {\n        var i = this.currentPage - e;if (0 === i) for (var o = 3; o < n.length; o++) {\n          n[o].className = \"hidden-xs-down\";\n        } else if (i === n.length - 1) for (var r = 0; r < n.length - 3; r++) {\n          n[r].className = \"hidden-xs-down\";\n        } else {\n          for (var s = 0; s < i - 1; s++) {\n            n[s].className = \"hidden-xs-down\";\n          }for (var a = n.length - 1; a > i + 1; a--) {\n            n[a].className = \"hidden-xs-down\";\n          }\n        }\n      }return n;\n    } }, methods: { isActive: function isActive(t) {\n      return t === this.currentPage;\n    }, pageItemClasses: function pageItemClasses(t) {\n      var e = this.isActive(t.number);return [\"page-item\", this.disabled ? \"disabled\" : \"\", e ? \"active\" : \"\", t.className];\n    }, pageLinkClasses: function pageLinkClasses(t) {\n      var e = this.isActive(t.number);return [\"page-link\", this.disabled ? \"disabled\" : \"\", e ? \"active\" : \"\"];\n    }, setPage: function setPage(t, e) {\n      var n = this;if (this.disabled) return t.preventDefault(), void t.stopPropagation();e > this.numberOfPages ? this.currentPage = this.numberOfPages : e < 1 ? this.currentpage = 1 : this.currentPage = e, this.$nextTick(function () {\n        isVisible$1(t.target) && t.target.focus ? t.target.focus() : n.focusCurrent();\n      }), this.$emit(\"change\", this.currentPage);\n    }, getButtons: function getButtons() {\n      return Array.prototype.slice.call(this.$el.querySelectorAll(\"a.page-link\")).filter(function (t) {\n        return isVisible$1(t);\n      });\n    }, setBtnFocus: function setBtnFocus(t) {\n      this.$nextTick(function () {\n        t.focus();\n      });\n    }, focusFirst: function focusFirst() {\n      var t = this.getButtons().find(function (t) {\n        return !t.disabled;\n      });t && t.focus && t !== document.activeElement && this.setBtnFocus(t);\n    }, focusLast: function focusLast() {\n      var t = this.getButtons().reverse().find(function (t) {\n        return !t.disabled;\n      });t && t.focus && t !== document.activeElement && this.setBtnFocus(t);\n    }, focusCurrent: function focusCurrent() {\n      var t = this,\n          e = this.getButtons().find(function (e) {\n        return parseInt(e.getAttribute(\"aria-posinset\"), 10) === t.currentPage;\n      });e && e.focus ? this.setBtnFocus(e) : this.focusFirst();\n    }, focusPrev: function focusPrev() {\n      var t = this.getButtons(),\n          e = t.indexOf(document.activeElement);e > 0 && !t[e - 1].disabled && t[e - 1].focus && this.setBtnFocus(t[e - 1]);\n    }, focusNext: function focusNext() {\n      var t = this.getButtons(),\n          e = t.indexOf(document.activeElement);e < t.length - 1 && !t[e + 1].disabled && t[e + 1].focus && this.setBtnFocus(t[e + 1]);\n    } }, watch: { currentPage: function currentPage(t, e) {\n      t !== e && this.$emit(\"input\", t);\n    }, value: function value(t, e) {\n      t !== e && (this.currentPage = t);\n    } }, props: { disabled: { type: Boolean, default: !1 }, value: { type: Number, default: 1 }, limit: { type: Number, default: 5 }, perPage: { type: Number, default: 20 }, totalRows: { type: Number, default: 20 }, size: { type: String, default: \"md\" }, hideGotoEndButtons: { type: Boolean, default: !1 }, ariaLabel: { type: String, default: \"Pagination\" }, labelFirstPage: { type: String, default: \"Goto first page\" }, firstText: { type: String, default: \"&laquo\" }, labelPrevPage: { type: String, default: \"Goto previous page\" }, prevText: { type: String, default: \"&lsaquo;\" }, labelNextPage: { type: String, default: \"Goto next page\" }, nextText: { type: String, default: \"&rsaquo;\" }, labelLastPage: { type: String, default: \"Goto last page\" }, lastText: { type: String, default: \"&raquo;\" }, labelPage: { type: String, default: \"Goto page\" }, hideEllipsis: { type: Boolean, default: !1 }, ellipsisText: { type: String, default: \"&hellip;\" }, role: { type: String, default: \"group\" }, buttonRole: { type: String, default: \"button\" } } },\n    TRIGGER_LISTENERS = { click: { click: \"toggle\" }, hover: { mouseenter: \"show\", mouseleave: \"hide\" }, focus: { focus: \"show\", blur: \"hide\" } },\n    PLACEMENT_PARAMS = { top: \"bottom center\", bottom: \"top center\", left: \"middle right\", right: \"middle left\" },\n    TETHER_CLASS_PREFIX = \"bs-tether\",\n    TETHER_CLASSES = { element: !1, enabled: !1 },\n    TRANSITION_DURATION = 150,\n    popover$1 = { props: { constraints: { type: Array, default: function _default() {\n        return [];\n      } }, debounce: { type: [Number], default: 300, validator: function validator(t) {\n        return t >= 0;\n      } }, delay: { type: [Number, Object], default: 0, validator: function validator(t) {\n        return \"number\" == typeof t ? t >= 0 : null !== t && \"object\" == (typeof t === \"undefined\" ? \"undefined\" : _typeof(t)) && \"number\" == typeof t.show && \"number\" == typeof t.hide && t.show >= 0 && t.hide >= 0;\n      } }, offset: { type: String, default: \"0 0\", validator: function validator(t) {\n        return (/^((0\\s?)|([+-]?[0-9]+(px|%)\\s?)){2}$/.test(t)\n        );\n      } }, placement: { type: String, default: \"top\", validator: function validator(t) {\n        return -1 !== Object.keys(PLACEMENT_PARAMS).indexOf(t);\n      } }, popoverStyle: { type: Object, default: null }, show: { type: Boolean, default: null }, targetOffset: { type: String, default: \"0 0\", validator: function validator(t) {\n        return (/^((0\\s?)|([+-]?[0-9]+(px|%)\\s?)){2}$/.test(t)\n        );\n      } }, triggers: { type: [Boolean, String, Array], default: function _default() {\n        return [\"click\", \"focus\"];\n      }, validator: function validator(t) {\n        if (!1 === t || \"\" === t) return !0;if (\"string\" == typeof t) return -1 !== Object.keys(TRIGGER_LISTENERS).indexOf(t);if (Array.isArray(t)) {\n          var e = Object.keys(TRIGGER_LISTENERS);return t.forEach(function (t) {\n            if (-1 === e.indexOf(t)) return !1;\n          }), !0;\n        }return !1;\n      } } }, data: function data() {\n    return { triggerState: this.show, classState: this.show, lastEvent: null };\n  }, computed: { normalizedTriggers: function normalizedTriggers() {\n      return !1 === this.triggers ? [] : \"string\" == typeof this.triggers ? [this.triggers] : this.triggers;\n    }, popoverAlignment: function popoverAlignment() {\n      return this.placement && \"default\" !== this.placement ? \"popover-\" + this.placement : \"popover-top\";\n    }, showState: function showState() {\n      return !1 !== this.show && (this.triggerState || this.show);\n    } }, watch: { constraints: function constraints() {\n      this.setOptions();\n    }, normalizedTriggers: function normalizedTriggers(t, e) {\n      this.updateListeners(t, e);\n    }, offset: function offset() {\n      this.setOptions();\n    }, placement: function placement() {\n      this.setOptions();\n    }, showState: function showState(t) {\n      var e = this,\n          n = this.getDelay(t);clearTimeout(this.$data._timeout), n ? this.$data._timeout = setTimeout(function () {\n        return e.togglePopover(t);\n      }, n) : this.togglePopover(t);\n    } }, methods: { addListener: function addListener(t) {\n      var e = this;for (var n in TRIGGER_LISTENERS[t]) {\n        e.$data._trigger.addEventListener(n, function (t) {\n          return e.eventHandler(t);\n        });\n      }\n    }, destroyTether: function destroyTether() {\n      if (this.$data._tether && !this.showState) {\n        this.$data._tether.destroy(), this.$data._tether = null;var t = new RegExp(\"(^|[^-]\\\\b)(\" + TETHER_CLASS_PREFIX + \"\\\\S*)\", \"g\");this.$data._trigger.className = this.$data._trigger.className.replace(t, \"\");\n      }\n    }, eventHandler: function eventHandler(t) {\n      var e = this;if (!(this.normalizedTriggers.length > 1 && this.debounce > 0 && null !== this.lastEvent && t.timeStamp <= this.lastEvent + this.debounce)) for (var n in TRIGGER_LISTENERS) {\n        for (var i in TRIGGER_LISTENERS[n]) {\n          if (i === t.type) {\n            var o = TRIGGER_LISTENERS[n][i];return void ((\"toggle\" === o || e.triggerState && \"hide\" === o || !e.triggerState && \"show\" === o) && (e.triggerState = !e.triggerState, e.lastEvent = t.timeStamp));\n          }\n        }\n      }\n    }, getDelay: function getDelay(t) {\n      return \"object\" == _typeof(this.delay) ? t ? this.delay.show : this.delay.hide : this.delay;\n    }, getTetherOptions: function getTetherOptions() {\n      return { attachment: PLACEMENT_PARAMS[this.placement], element: this.$data._popover, target: this.$data._trigger, classes: TETHER_CLASSES, classPrefix: TETHER_CLASS_PREFIX, offset: this.offset, constraints: this.constraints, targetOffset: this.targetOffset };\n    }, hidePopover: function hidePopover() {\n      var t = this;this.classState = !1, clearTimeout(this.$data._timeout), this.$data._timeout = setTimeout(function () {\n        t.$data._popover.style.display = \"none\", t.destroyTether();\n      }, TRANSITION_DURATION);\n    }, refreshPosition: function refreshPosition() {\n      var t = this;this.$data._tether && this.$nextTick(function () {\n        t.$data._tether.position();\n      });\n    }, removeListener: function removeListener(t) {\n      var e = this;for (var n in TRIGGER_LISTENERS[t]) {\n        e.$data._trigger.removeEventListener(n, function (t) {\n          return e.eventHandler(t);\n        });\n      }\n    }, setOptions: function setOptions() {\n      this.$data._tether && this.$data._tether.setOptions(this.getTetherOptions());\n    }, showPopover: function showPopover() {\n      var t = this;clearTimeout(this.$data._timeout), this.$data._tether || (this.$data._tether = new __WEBPACK_IMPORTED_MODULE_0_tether___default.a(this.getTetherOptions())), this.$data._popover.style.display = \"block\", this.refreshPosition(), this.$nextTick(function () {\n        t.classState = !0;\n      });\n    }, togglePopover: function togglePopover(t) {\n      this.$emit(\"showChange\", t), t ? (this.showPopover(), this.$root.$emit(\"shown::popover\")) : (this.hidePopover(), this.$root.$emit(\"hidden::popover\"));\n    }, updateListeners: function updateListeners(t, e) {\n      var n = this;void 0 === e && (e = []);var i = [],\n          o = [];t.forEach(function (t) {\n        -1 === e.indexOf(t) && i.push(t);\n      }), e.forEach(function (e) {\n        -1 === t.indexOf(e) && o.push(e);\n      }), i.forEach(function (t) {\n        return n.addListener(t);\n      }), o.forEach(function (t) {\n        return n.removeListener(t);\n      });\n    } }, created: function created() {\n    var t = this;this.$root.$on(\"hide::popover\", function () {\n      t.triggerState = !1;\n    });\n  }, mounted: function mounted() {\n    this.$data._trigger = this.$refs.trigger.children[0] || this.$refs.trigger, this.$data._popover = this.$refs.popover, this.$data._popover.style.display = \"none\", this.$data._tether = new __WEBPACK_IMPORTED_MODULE_0_tether___default.a(this.getTetherOptions()), this.$data._timeout = 0, this.updateListeners(this.normalizedTriggers), this.showState && this.showPopover();\n  }, updated: function updated() {\n    this.refreshPosition();\n  }, beforeDestroy: function beforeDestroy() {\n    var t = this;this.normalizedTriggers.forEach(function (e) {\n      return t.removeListener(e);\n    }), clearTimeout(this.$data._timeout), this.destroyTether();\n  }, destroyed: function destroyed() {\n    this.$data._popover.parentElement === document.body && document.body.removeChild(this.$data._popover);\n  } },\n    popover = { render: function render() {\n    var t = this,\n        e = t.$createElement,\n        n = t._self._c || e;return n(\"div\", [n(\"span\", { ref: \"trigger\" }, [t._t(\"default\")], 2), n(\"div\", { ref: \"popover\", class: [\"popover\", \"fade\", t.classState ? \"show\" : \"\", t.popoverAlignment], style: t.popoverStyle, attrs: { tabindex: \"-1\" }, on: { focus: function focus(e) {\n          t.$emit(\"focus\");\n        }, blur: function blur(e) {\n          t.$emit(\"blur\");\n        } } }, [n(\"div\", { staticClass: \"popover-arrow\" }), t.title ? n(\"h3\", { staticClass: \"popover-title\", domProps: { innerHTML: t._s(t.title) } }) : t._e(), n(\"div\", { staticClass: \"popover-content\" }, [n(\"div\", { staticClass: \"popover-content-wrapper\" }, [t._t(\"content\", [n(\"span\", { domProps: { innerHTML: t._s(t.content) } })])], 2)])])]);\n  }, staticRenderFns: [], mixins: [popover$1], props: { title: { type: String, default: \"\" }, content: { type: String, default: \"\" }, popoverStyle: { type: Object, default: null } } },\n    progress = { render: function render() {\n    var t = this,\n        e = t.$createElement,\n        n = t._self._c || e;return n(\"div\", { staticClass: \"progress\" }, [n(\"transition\", [n(\"div\", { class: t.classObject, style: t.styleObject, attrs: { role: \"progressbar\", \"aria-valuenow\": t.value, \"aria-valuemin\": 0, \"aria-valuemax\": t.max } }, [t._t(\"default\", [t.showProgress ? [t._v(t._s(t.progress) + \"%\")] : t.showValue ? [t._v(t._s(t.value))] : t._e()])], 2)])], 1);\n  }, staticRenderFns: [], computed: { classObject: function classObject() {\n      return [\"progress-bar\", this.progressVariant, this.striped || this.animated ? \"progress-bar-striped\" : \"\", this.animated ? \"progress-bar-animated\" : \"\"];\n    }, styleObject: function styleObject() {\n      return { width: this.progress + \"%\" };\n    }, progressVariant: function progressVariant() {\n      return this.variant ? \"bg-\" + this.variant : null;\n    }, progress: function progress() {\n      var t = Math.pow(10, this.precision);return Math.round(100 * t * this.value / this.max) / t;\n    } }, props: { striped: { type: Boolean, default: !1 }, animated: { type: Boolean, default: !1 }, precision: { type: Number, default: 0 }, value: { type: Number, default: 0 }, max: { type: Number, default: 100 }, variant: { type: String, default: null }, showProgress: { type: Boolean, default: !1 }, showValue: { type: Boolean, default: !1 } } },\n    toString = function toString(t) {\n  return t ? t instanceof Object ? Object.keys(t).map(function (e) {\n    return toString(t[e]);\n  }).join(\" \") : String(t) : \"\";\n},\n    recToString = function recToString(t) {\n  if (!(t instanceof Object)) return \"\";var e = { state: !0, _rowVariant: !0 };return toString(Object.keys(t).reduce(function (n, i) {\n    return e[i] || (n[i] = t[i]), n;\n  }, {}));\n},\n    defaultSortCompare = function defaultSortCompare(t, e, n) {\n  return \"number\" == typeof t[n] && \"number\" == typeof e[n] ? t[n] < e[n] ? -1 : t[n] > e[n] ? 1 : 0 : toString(t[n]).localeCompare(toString(e[n]), void 0, { numeric: !0 });\n},\n    table = { render: function render() {\n    var t = this,\n        e = t.$createElement,\n        n = t._self._c || e;return n(\"table\", { class: t.tableClass, attrs: { id: t.id || null, role: \"grid\", \"aria-busy\": t.busy ? \"true\" : \"false\" } }, [n(\"thead\", { class: t.headClass }, [n(\"tr\", { attrs: { role: \"row\" } }, t._l(t.fields, function (e, i) {\n      return n(\"th\", { key: i, class: t.fieldClass(e, i), style: e.thStyle || {}, attrs: { \"aria-label\": e.sortable ? t.sortDesc && t.sortBy === i ? t.labelSortAsc : t.labelSortDesc : null, \"aria-sort\": e.sortable && t.sortBy === i ? t.sortDesc ? \"descending\" : \"ascending\" : null, tabindex: e.sortable ? \"0\" : null }, on: { click: function click(n) {\n            n.stopPropagation(), n.preventDefault(), t.headClicked(n, e, i);\n          }, keydown: [function (n) {\n            if (!(\"button\" in n) && t._k(n.keyCode, \"enter\", 13)) return null;n.stopPropagation(), n.preventDefault(), t.headClicked(n, e, i);\n          }, function (n) {\n            if (!(\"button\" in n) && t._k(n.keyCode, \"space\", 32)) return null;n.stopPropagation(), n.preventDefault(), t.headClicked(n, e, i);\n          }] } }, [t._t(\"HEAD_\" + i, [n(\"div\", { domProps: { innerHTML: t._s(e.label) } })], { label: e.label, column: i, field: e })], 2);\n    }))]), t.footClone ? n(\"tfoot\", { class: t.footClass }, [n(\"tr\", { attrs: { role: \"row\" } }, t._l(t.fields, function (e, i) {\n      return n(\"th\", { key: i, class: t.fieldClass(e, i), style: e.thStyle || {}, attrs: { \"aria-label\": e.sortable ? t.sortDesc && t.sortBy === i ? t.labelSortAsc : t.labelSortDesc : null, \"aria-sort\": e.sortable && t.sortBy === i ? t.sortDesc ? \"descending\" : \"ascending\" : null, tabindex: e.sortable ? \"0\" : null }, on: { click: function click(n) {\n            n.stopPropagation(), n.preventDefault(), t.headClicked(n, e, i);\n          }, keydown: [function (n) {\n            if (!(\"button\" in n) && t._k(n.keyCode, \"enter\", 13)) return null;n.stopPropagation(), n.preventDefault(), t.headClicked(n, e, i);\n          }, function (n) {\n            if (!(\"button\" in n) && t._k(n.keyCode, \"space\", 32)) return null;n.stopPropagation(), n.preventDefault(), t.headClicked(n, e, i);\n          }] } }, [t.$scopedSlots[\"FOOT_\" + i] ? t._t(\"FOOT_\" + i, [n(\"div\", { domProps: { innerHTML: t._s(e.label) } })], { label: e.label, column: i, field: e }) : t._t(\"HEAD_\" + i, [n(\"div\", { domProps: { innerHTML: t._s(e.label) } })], { label: e.label, column: i, field: e })], 2);\n    }))]) : t._e(), n(\"tbody\", [t._l(t._items, function (e, i) {\n      return n(\"tr\", { key: i, class: t.rowClass(e), attrs: { role: \"row\" }, on: { click: function click(n) {\n            t.rowClicked(n, e, i);\n          }, hover: function hover(n) {\n            t.rowHovered(n, e, i);\n          } } }, t._l(t.fields, function (o, r) {\n        return n(\"td\", { key: r, class: t.tdClass(o, e, r) }, [t._t(r, [t._v(t._s(e[r]))], { value: e[r], item: e, index: i })], 2);\n      }));\n    }), !t.showEmpty || t._items && 0 !== t._items.length ? t._e() : n(\"tr\", { attrs: { role: \"row\" } }, [n(\"td\", { attrs: { colspan: Object.keys(t.fields).length } }, [t.filter ? n(\"div\", { attrs: { role: \"alert\", \"aria-live\": \"polite\" } }, [t._t(\"emptyfiltered\", [n(\"div\", { staticClass: \"text-center my-2\", domProps: { innerHTML: t._s(t.emptyFilteredText) } })])], 2) : n(\"div\", { attrs: { role: \"alert\", \"aria-live\": \"polite\" } }, [t._t(\"empty\", [n(\"div\", { staticClass: \"text-center my-2\", domProps: { innerHTML: t._s(t.emptyText) } })])], 2)])])], 2)], 1);\n  }, staticRenderFns: [], data: function data() {\n    return { sortBy: null, sortDesc: !0, localItems: [] };\n  }, props: { id: { type: String, default: \"\" }, items: { type: [Array, Function], default: function _default() {\n        return this && this.itemsProvider ? (warn(\"b-table: prop items-provider has been deprecated. Pass a function to items instead\"), this.itemsProvider) : [];\n      } }, fields: { type: Object, default: {} }, striped: { type: Boolean, default: !1 }, bordered: { type: Boolean, default: !1 }, inverse: { type: Boolean, default: !1 }, hover: { type: Boolean, default: !1 }, small: { type: Boolean, default: !1 }, responsive: { type: Boolean, default: !1 }, headVariant: { type: String, default: \"\" }, footVariant: { type: String, default: \"\" }, perPage: { type: Number, default: null }, currentPage: { type: Number, default: 1 }, filter: { type: [String, RegExp, Function], default: null }, sortCompare: { type: Function, default: null }, itemsProvider: { type: Function, default: null }, noProviderPaging: { type: Boolean, default: !1 }, noProviderSorting: { type: Boolean, default: !1 }, noProviderFiltering: { type: Boolean, default: !1 }, busy: { type: Boolean, default: !1 }, value: { type: Array, default: function _default() {\n        return [];\n      } }, footClone: { type: Boolean, default: !1 }, labelSortAsc: { type: String, default: \"Click to sort Ascending\" }, labelSortDesc: { type: String, default: \"Click to sort Descending\" }, showEmpty: { type: Boolean, default: !1 }, emptyText: { type: String, default: \"There are no records to show\" }, emptyFilteredText: { type: String, default: \"There are no records matching your request\" } }, watch: { items: function items(t, e) {\n      e !== t && this._providerUpdate();\n    }, sortDesc: function sortDesc(t, e) {\n      e === t || this.noProviderSorting || this._providerUpdate();\n    }, sortBy: function sortBy(t, e) {\n      e === t || this.noProviderSorting || this._providerUpdate();\n    }, perPage: function perPage(t, e) {\n      e === t || this.noProviderPaging || this._providerUpdate();\n    }, currentPage: function currentPage(t, e) {\n      e === t || this.noProviderPaging || this._providerUpdate();\n    }, filter: function filter(t, e) {\n      e === t || this.noProviderFiltering || this._providerUpdate();\n    } }, mounted: function mounted() {\n    var t = this;this.hasProvider && this._providerUpdate(), this.$root.$on(\"table::refresh\", function (e) {\n      e === t.id && t._providerUpdate();\n    });\n  }, computed: { tableClass: function tableClass() {\n      return [\"table\", \"b-table\", this.striped ? \"table-striped\" : \"\", this.hover ? \"table-hover\" : \"\", this.inverse ? \"table-inverse\" : \"\", this.bordered ? \"table-bordered\" : \"\", this.responsive ? \"table-responsive\" : \"\", this.small ? \"table-sm\" : \"\"];\n    }, headClass: function headClass() {\n      return this.headVariant ? \"thead-\" + this.headVariant : \"\";\n    }, footClass: function footClass() {\n      var t = this.footVariant || this.headVariant || null;return t ? \"thead-\" + t : \"\";\n    }, hasProvider: function hasProvider() {\n      return this.items instanceof Function;\n    }, providerFiltering: function providerFiltering() {\n      return Boolean(this.hasProvider && !this.noProviderFiltering);\n    }, providerSorting: function providerSorting() {\n      return Boolean(this.hasProvider && !this.noProviderSorting);\n    }, providerPaging: function providerPaging() {\n      return Boolean(this.hasProvider && !this.noProviderPaging);\n    }, context: function context() {\n      return { perPage: this.perPage, currentPage: this.currentPage, filter: this.filter, sortBy: this.sortBy, sortDesc: this.sortDesc };\n    }, _items: function _items() {\n      var t = this,\n          e = this.perPage,\n          n = this.currentPage,\n          i = this.filter,\n          o = (this.sortBy, this.sortDesc, this.sortCompare || defaultSortCompare),\n          r = this.hasProvider ? this.localItems : this.items;if (!r) return this.$nextTick(this._providerUpdate), [];if (r = r.slice(), i && !this.providerFiltering) if (i instanceof Function) r = r.filter(i);else {\n        var s;s = i instanceof RegExp ? i : new RegExp(\".*\" + i + \".*\", \"ig\"), r = r.filter(function (t) {\n          var e = s.test(recToString(t));return s.lastIndex = 0, e;\n        });\n      }return this.sortBy && !this.providerSorting && (r = r.sort(function (e, n) {\n        var i = o(e, n, t.sortBy);return t.sortDesc ? i : -1 * i;\n      })), e && !this.providerPaging && (r = r.slice((n - 1) * e, n * e)), this.$emit(\"input\", r), r;\n    } }, methods: { fieldClass: function fieldClass(t, e) {\n      return [t.sortable ? \"sorting\" : \"\", t.sortable && this.sortBy === e ? \"sorting_\" + (this.sortDesc ? \"desc\" : \"asc\") : \"\", t.variant ? \"table-\" + t.variant : \"\", t.class ? t.class : \"\", t.thClass ? t.thClass : \"\"];\n    }, tdClass: function tdClass(t, e, n) {\n      var i = \"\";return e._cellVariants && e._cellVariants[n] && (i = (this.inverse ? \"bg-\" : \"table-\") + e._cellVariants[n]), [t.variant && !i ? (this.inverse ? \"bg-\" : \"table-\") + t.variant : \"\", i, t.class ? t.class : \"\", t.tdClass ? t.tdClass : \"\"];\n    }, rowClass: function rowClass(t) {\n      var e = t._rowVariant || t.state || null;return [e ? (this.inverse ? \"bg-\" : \"table-\") + e : \"\"];\n    }, rowClicked: function rowClicked(t, e, n) {\n      if (this.busy) return t.preventDefault(), void t.stopPropagation();this.$emit(\"row-clicked\", e, n);\n    }, rowHovered: function rowHovered(t, e, n) {\n      if (this.busy) return t.preventDefault(), void t.stopPropagation();this.$emit(\"row-hovered\", e, n);\n    }, headClicked: function headClicked(t, e, n) {\n      if (this.busy) return t.preventDefault(), void t.stopPropagation();var i = !1;e.sortable ? (n === this.sortBy ? this.sortDesc = !this.sortDesc : (this.sortBy = n, this.sortDesc = !0), i = !0) : this.sortBy && (this.sortBy = null, i = !0), this.$emit(\"head-clicked\", n, e), i && this.$emit(\"sort-changed\", this.context);\n    }, refresh: function refresh() {\n      this.hasProvider && this._providerUpdate();\n    }, _providerSetLocal: function _providerSetLocal(t) {\n      this.localItems = t && t.length > 0 ? t.slice() : [], this.$emit(\"refreshed\"), this.$root.$emit(\"table::refreshed\", this.id);\n    }, _providerUpdate: function _providerUpdate() {\n      var t = this;if (!this.busy && this.hasProvider) {\n        var e = this.items(this.context, this._providerSetLocal);e && (e.then && \"function\" == typeof e.then ? e.then(function (e) {\n          t._providerSetLocal(e);\n        }) : this._providerSetLocal(e));\n      }\n    } } },\n    tabs = { render: function render() {\n    var t = this,\n        e = t.$createElement,\n        n = t._self._c || e;return n(t.tag, { tag: \"component\", staticClass: \"tabs\", attrs: { id: t.id || null } }, [t.bottom ? n(\"div\", { ref: \"tabsContainer\", class: [\"tab-content\", { \"card-block\": t.card }] }, [t._t(\"default\"), t.tabs && t.tabs.length ? t._e() : t._t(\"empty\")], 2) : t._e(), n(\"div\", { class: { \"card-header\": t.card } }, [n(\"ul\", { class: [\"nav\", \"nav-\" + t.navStyle, t.card ? \"card-header-\" + t.navStyle : null], attrs: { role: \"tablist\", tabindex: \"0\", \"aria-setsize\": t.tabs.length, \"aria-posinset\": t.currentTab + 1 }, on: { keydown: [function (e) {\n          return \"button\" in e || !t._k(e.keyCode, \"left\", 37) ? \"button\" in e && 0 !== e.button ? null : void t.previousTab(e) : null;\n        }, function (e) {\n          if (!(\"button\" in e) && t._k(e.keyCode, \"up\", 38)) return null;t.previousTab(e);\n        }, function (e) {\n          return \"button\" in e || !t._k(e.keyCode, \"right\", 39) ? \"button\" in e && 2 !== e.button ? null : void t.nextTab(e) : null;\n        }, function (e) {\n          if (!(\"button\" in e) && t._k(e.keyCode, \"down\", 40)) return null;t.nextTab(e);\n        }, function (e) {\n          return (\"button\" in e || !t._k(e.keyCode, \"left\", 37)) && e.shiftKey ? \"button\" in e && 0 !== e.button ? null : void t.setTab(-1, !1, 1) : null;\n        }, function (e) {\n          return (\"button\" in e || !t._k(e.keyCode, \"up\", 38)) && e.shiftKey ? void t.setTab(-1, !1, 1) : null;\n        }, function (e) {\n          return (\"button\" in e || !t._k(e.keyCode, \"right\", 39)) && e.shiftKey ? \"button\" in e && 2 !== e.button ? null : void t.setTab(t.tabs.length, !1, -1) : null;\n        }, function (e) {\n          return (\"button\" in e || !t._k(e.keyCode, \"down\", 40)) && e.shiftKey ? void t.setTab(t.tabs.length, !1, -1) : null;\n        }] } }, [t._l(t.tabs, function (e, i) {\n      return n(\"li\", { staticClass: \"nav-item\", attrs: { role: \"presentation\" } }, [e.headHtml ? n(\"div\", { class: [\"tab-head\", { small: t.small, active: e.localActive, disabled: e.disabled }], attrs: { role: \"heading\", tabindex: \"-1\" }, domProps: { innerHTML: t._s(e.headHtml) } }) : n(\"a\", { class: [\"nav-link\", { small: t.small, active: e.localActive, disabled: e.disabled }], attrs: { href: e.href, role: \"tab\", \"aria-selected\": e.localActive ? \"true\" : \"false\", \"aria-controls\": e.id || null, id: e.controlledBy || null, tabindex: \"-1\" }, domProps: { innerHTML: t._s(e.title) }, on: { click: function click(e) {\n            e.preventDefault(), e.stopPropagation(), t.setTab(i);\n          }, keydown: [function (e) {\n            if (!(\"button\" in e) && t._k(e.keyCode, \"space\", 32)) return null;e.preventDefault(), e.stopPropagation(), t.setTab(i);\n          }, function (e) {\n            if (!(\"button\" in e) && t._k(e.keyCode, \"enter\", 13)) return null;e.preventDefault(), e.stopPropagation(), t.setTab(i);\n          }] } })]);\n    }), t._t(\"tabs\")], 2)]), t.bottom ? t._e() : n(\"div\", { ref: \"tabsContainer\", class: [\"tab-content\", { \"card-block\": t.card }] }, [t._t(\"default\"), t.tabs && t.tabs.length ? t._e() : t._t(\"empty\")], 2)]);\n  }, staticRenderFns: [], data: function data() {\n    return { currentTab: this.value, tabs: [] };\n  }, props: { id: { type: String, default: \"\" }, tag: { type: String, default: \"div\" }, noFade: { type: Boolean, default: !1 }, card: { type: Boolean, default: !1 }, small: { type: Boolean, default: !1 }, value: { type: Number, default: 0 }, pills: { type: Boolean, default: !1 }, lazy: { type: Boolean, default: !1 }, bottom: { type: Boolean, default: !1 } }, watch: { currentTab: function currentTab(t, e) {\n      t !== e && (this.$root.$emit(\"changed::tab\", this, t, this.tabs[t]), this.$emit(\"input\", t), this.tabs[t].$emit(\"click\"));\n    }, value: function value(t, e) {\n      t !== e && this.setTab(t);\n    }, fade: function fade(t, e) {\n      var n = this;t !== e && this.tabs.forEach(function (e) {\n        n.$set(e, \"fade\", t);\n      });\n    } }, computed: { fade: function fade() {\n      return !this.noFade;\n    }, navStyle: function navStyle() {\n      return this.pills ? \"pills\" : \"tabs\";\n    } }, methods: { sign: function sign(t) {\n      return 0 === t ? 0 : t > 0 ? 1 : -1;\n    }, nextTab: function nextTab() {\n      this.setTab(this.currentTab, !1, 1);\n    }, previousTab: function previousTab() {\n      this.setTab(this.currentTab, !1, -1);\n    }, setTab: function setTab(t, e, n) {\n      var i = this;if (n = n || 0, e || t + n !== this.currentTab) {\n        var o = this.tabs[t + n];o && (o.disabled ? n && this.setTab(t, e, n + this.sign(n)) : (this.tabs.forEach(function (t) {\n          t !== o && t.localActive && i.$set(t, \"localActive\", !1);\n        }), this.$set(o, \"localActive\", !0), this.currentTab = t + n));\n      }\n    }, updateTabs: function updateTabs() {\n      var t = this;this.$slots.default ? this.tabs = this.$slots.default.filter(function (t) {\n        return t.componentInstance || !1;\n      }).map(function (t) {\n        return t.componentInstance;\n      }) : this.tabs = [], this.tabs.forEach(function (e) {\n        t.$set(e, \"fade\", t.fade), t.$set(e, \"lazy\", t.lazy);\n      });var e = this.currentTab;null !== e && void 0 !== e || this.tabs.forEach(function (t, n) {\n        t.active && (e = n);\n      });var n = 0;e > this.tabs.length - 1 && (n = -1), this.setTab(e || 0, !0, n);\n    } }, mounted: function mounted() {\n    this.updateTabs(), observeDOM(this.$refs.tabsContainer, this.updateTabs.bind(this), { subtree: !1 });\n  } },\n    tab = { render: function render() {\n    var t = this,\n        e = t.$createElement,\n        n = t._self._c || e;return n(\"transition\", { attrs: { mode: \"out-in\" }, on: { enter: t.enter, \"before-leave\": t.beforeLeave } }, [t.localActive || !t.lazy ? n(t.tag, { directives: [{ name: \"show\", rawName: \"v-show\", value: t.localActive || t.lazy, expression: \"localActive || lazy\" }], ref: \"panel\", tag: \"component\", class: [\"tab-pane\", { show: t.show, fade: t.fade, disabled: t.disabled, active: t.localActive }], attrs: { id: t.id || null, role: \"tabpanel\", \"aria-hidden\": t.localActive ? \"false\" : \"true\", \"aria-expanded\": t.localActive ? \"true\" : \"false\", \"aria-lablelledby\": t.controlledBy || null } }, [t._t(\"default\")], 2) : t._e()], 1);\n  }, staticRenderFns: [], methods: { enter: function enter() {\n      this.show = !0;\n    }, beforeLeave: function beforeLeave() {\n      this.show = !1;\n    } }, data: function data() {\n    return { fade: !1, localActive: !1, lazy: !0, show: !1 };\n  }, computed: { controlledBy: function controlledBy() {\n      return this.buttonId || (this.id ? this.id + \"__BV_tab_button__\" : null);\n    } }, props: { id: { type: String, default: \"\" }, tag: { type: String, default: \"div\" }, buttonId: { type: String, default: \"\" }, title: { type: String, default: \"\" }, headHtml: { type: String, default: null }, disabled: { type: Boolean, default: !1 }, active: { type: Boolean, default: !1 }, href: { type: String, default: \"#\" } } },\n    tooltip = { render: function render() {\n    var t = this,\n        e = t.$createElement,\n        n = t._self._c || e;return n(\"div\", { staticClass: \"d-inline-block\" }, [n(\"span\", { ref: \"trigger\", staticClass: \"d-inline-block\" }, [t._t(\"default\")], 2), n(\"div\", { ref: \"popover\", class: [\"tooltip\", \"tooltip-\" + this.placement], style: { opacity: t.showState ? 1 : 0 }, attrs: { tabindex: \"-1\" }, on: { focus: function focus(e) {\n          t.$emit(\"focus\");\n        }, blur: function blur(e) {\n          t.$emit(\"blur\");\n        } } }, [n(\"div\", { staticClass: \"tooltip-inner\" }, [t._t(\"content\", [n(\"span\", { domProps: { innerHTML: t._s(t.content) } })])], 2)])]);\n  }, staticRenderFns: [], mixins: [popover$1], props: { content: { type: String, default: \"\" }, triggers: { type: [Boolean, String, Array], default: \"hover\" } } },\n    components = Object.freeze({ bAlert: alert, bBreadcrumb: breadcrumb, bButton: bBtn, bBtn: bBtn, bButtonToolbar: buttonToolbar, bBtnToolbar: buttonToolbar, bButtonGroup: buttonGroup, bBtnGroup: buttonGroup, bButtonGroupDropdown: buttonGroupDropdown, bBtnGroupDropdown: buttonGroupDropdown, bInputGroup: inputGroup, bInputGroupAddon: inputGroupAddon, bInputGroupButton: inputGroupButton, bInputGroupBtn: inputGroupButton, bCard: card, bCardGroup: cardGroup, bDropdown: dropdown$1, bDropdownItem: dropdownItem, bDropdownItemButton: dropdownItemButton, bDropdownItemBtn: dropdownItemButton, bDropdownDivider: dropdownDivider, bDropdownHeader: dropdownHeader, bDropdownSelect: dropdownSelect, bForm: bForm, bFormCheckbox: formCheckbox, bFormFieldset: formFieldset, bFormFile: formFile, bFormRadio: formRadio, bFormInput: formInput, bFormInputStatic: bFormInputStatic, bFormSelect: formSelect, bJumbotron: jumbotron, bBadge: badge, bMedia: media, bModal: modal, bNavbar: navbar, bNavText: navText, bNavForm: navForm, bPagination: pagination, bPopover: popover, bProgress: progress, bTable: table, bTooltip: tooltip, bTab: tab, bTabs: tabs, bNav: nav, bNavItem: navItem, bNavItemDropdown: navItemDropdown, bNavToggle: navToggle, bListGroupItem: listGroupItem, bListGroup: listGroup, bCarouselSlide: carouselSlide, bCarousel: carousel, bCollapse: collapse, bLink: bLink }),\n    all_listen_types = { hover: !0, click: !0, focus: !0 },\n    inBrowser = \"undefined\" != typeof window,\n    listen_types = { click: !0 },\n    toggle = { bind: function bind(t, e) {\n    var n = targets(t, e, listen_types, function (t) {\n      var e = t.targets,\n          n = t.vm;e.forEach(function (t) {\n        n.$root.$emit(\"collapse::toggle\", t);\n      });\n    });inBrowser && t.__vue__ && n.length > 0 && (t.setAttribute(\"aria-controls\", n.join(\" \")), t.setAttribute(\"aria-expanded\", \"false\"), t.__vue__.$root.$on(\"collapse::toggle::state\", function (e, i) {\n      -1 !== n.indexOf(e) && t.setAttribute(\"aria-expanded\", i ? \"true\" : \"false\");\n    }));\n  } },\n    listen_types$1 = { click: !0 },\n    modal$1 = { bind: function bind(t, e) {\n    targets(t, e, listen_types$1, function (e) {\n      var n = e.targets,\n          i = e.vm;n.forEach(function (e) {\n        i.$root.$emit(\"show::modal\", e, t);\n      });\n    });\n  } },\n    inBrowser$1 = \"undefined\" != typeof window,\n    isServer = !inBrowser$1;inBrowser$1 && window.Element && !Element.prototype.closest && (Element.prototype.closest = function (t) {\n  var e,\n      n = (this.document || this.ownerDocument).querySelectorAll(t),\n      i = this;do {\n    for (e = n.length; --e >= 0 && n.item(e) !== i;) {}\n  } while (e < 0 && (i = i.parentElement));return i;\n});var NAME = \"v-b-scrollspy\",\n    EVENT = \"scrollspy::activate\",\n    BVSS = \"__BV_ScrollSpy__\",\n    Default = { element: \"body\", offset: 10, method: \"auto\", throttle: 200 },\n    DefaultType = { element: \"(string|element)\", offset: \"number\", method: \"string\", throttle: \"number\" },\n    ClassName = { DROPDOWN_ITEM: \"dropdown-item\", DROPDOWN_MENU: \"dropdown-menu\", DROPDOWN_TOGGLE: \"dropdown-toggle\", NAV_LINK: \"nav-link\", LIST_ITEM: \"list-group-item\", ACTIVE: \"active\" },\n    Selector = { ACTIVE: \".active\", NAV_LIST_GROUP: \".nav, .list-group\", NAV: \".nav\", LIST_GROUP: \".list-group\", NAV_LINKS: \".nav-link\", LIST_ITEMS: \".list-group-item\", DROPDOWN: \".dropdown\", DROPDOWN_ITEMS: \".dropdown-item\", DROPDOWN_TOGGLE: \".dropdown-toggle\" },\n    OffsetMethod = { OFFSET: \"offset\", POSITION: \"position\" };ScrollSpy.prototype.updateConfig = function (t) {\n  var e = this;t.arg && (this._config.element = \"#\" + t.arg), Object.keys(t.modifiers).forEach(function (t) {\n    /^\\d+$/.test(t) ? e._config.offset = parseInt(t, 10) : /^(auto|position|offset)$/.test(t) && (e._config.method = t);\n  }), \"string\" == typeof t.value ? this._config.element = t.value : \"number\" == typeof t.value ? this._config.offset = Math.round(t.value) : \"object\" == _typeof(t.value) && Object.keys(t.value).filter(function (t) {\n    return Boolean(DefaultType[t]);\n  }).forEach(function (n) {\n    e._config[n] = t.value[n];\n  }), typeCheckConfig(NAME, this._config, DefaultType);var n = getVm(this._$el);return n && n.$root && (this._$root = n.$root), this;\n}, ScrollSpy.prototype.listen = function () {\n  var t = this._getScroller();return t && (\"BODY\" !== t.tagName && t.addEventListener(\"scroll\", this, !1), window.addEventListener(\"scroll\", this, !1), window.addEventListener(\"orientationchange\", this, !1), window.addEventListener(\"resize\", this, !1)), this;\n}, ScrollSpy.prototype.unListen = function () {\n  var t = this._getScroller();return t && (\"BODY\" !== t.tagName && t.removeEventListener(\"scroll\", this, !1), window.removeEventListener(\"scroll\", this, !1), window.removeEventListener(\"orientationchange\", this, !1), window.removeEventListener(\"resize\", this, !1)), this;\n}, ScrollSpy.prototype.refresh = function () {\n  var t = this,\n      e = this._getScroller();if (!e) return this;var n = \"BODY\" === e.tagName ? OffsetMethod.OFFSET : OffsetMethod.POSITION,\n      i = \"auto\" === this._config.method ? n : this._config.method,\n      o = i === OffsetMethod.OFFSET ? 0 : this._getScrollTop();return this._offsets = [], this._targets = [], this._scrollHeight = this._getScrollHeight(), $QSA(this._selector, this._$el).map(function (t) {\n    var n = t.getAttribute(\"href\");if (n && \"#\" === n.charAt(0) && \"#\" !== n && -1 === n.indexOf(\"#/\")) {\n      var r = $QS(n, e);if (!r) return null;var s = r.getBoundingClientRect();if (s.width || s.height) return { offset: (i === OffsetMethod.OFFSET ? s.top : r.offsetTop) + o, href: n };\n    }return null;\n  }).filter(function (t) {\n    return t;\n  }).sort(function (t, e) {\n    return t.offset - e.offset;\n  }).forEach(function (e) {\n    t._offsets.push(e.offset), t._targets.push(e.href);\n  }), this;\n}, ScrollSpy.prototype.process = function () {\n  var t = this;if (!this._getScroller) return this;var e = this._getScrollTop() + this._config.offset,\n      n = this._getScrollHeight(),\n      i = this._config.offset + n - this._getOffsetHeight();if (this._scrollHeight !== n && this.refresh(), e >= i) {\n    var o = this._targets[this._targets.length - 1];return this._activeTarget !== o && this._activate(o), this;\n  }if (this._activeTarget && e < this._offsets[0] && this._offsets[0] > 0) return this._activeTarget = null, this._clear(), this;for (var r = this._offsets.length; r--;) {\n    t._activeTarget !== t._targets[r] && e >= t._offsets[r] && (void 0 === t._offsets[r + 1] || e < t._offsets[r + 1]) && t._activate(t._targets[r]);\n  }return this;\n}, ScrollSpy.prototype.dispose = function () {\n  this.unListen(), clearTimeout(this._resizeTimeout), this._resizeTimeout = null, this._$el = null, this._config = null, this._selector = null, this._offsets = null, this._targets = null, this._activeTarget = null, this._scrollHeight = null, this._$root = null;\n}, ScrollSpy.prototype.handleEvent = function (t) {\n  var e = this;\"scroll\" === t.type ? this.process() : \"orientationchange\" === t.type ? this.refresh().process() : \"resize\" === t.type && function () {\n    clearTimeout(this._resizeTimeout), this._resizeTimeout = setTimeout(function () {\n      e.refresh().process();\n    }, e._config.throttle || Default.throttle);\n  }();\n}, ScrollSpy.prototype._getScroller = function () {\n  if (isServer) return null;var t = this._config.element;return t ? t && isElement(t) ? t : \"string\" == typeof t ? \"body\" === t ? document.body : $QS(t) : null : null;\n}, ScrollSpy.prototype._getScrollTop = function () {\n  var t = this._getScroller();return t ? \"BODY\" === t.tagName ? window.pageYOffset : t.scrollTop : 0;\n}, ScrollSpy.prototype._getScrollHeight = function () {\n  var t = this._getScroller();return t ? \"BODY\" === t.tagName ? Math.max(document.body.scrollHeight, document.documentElement.scrollHeight) : t.scrollHeight : 0;\n}, ScrollSpy.prototype._getOffsetHeight = function () {\n  var t = this._getScroller();return t ? \"BODY\" === t.tagName ? window.innerHeight : t.getBoundingClientRect().height : 0;\n}, ScrollSpy.prototype._activate = function (t) {\n  var e = this;this._activeTarget = t, this._clear();var n = this._selector.split(\",\"),\n      i = $QSA((n = n.map(function (e) {\n    return e + '[href=\"' + t + '\"]';\n  })).join(\",\"), this._$el);i.forEach(function (t) {\n    if (t.classList.contains(ClassName.DROPDOWN_ITEM)) {\n      var n = closest(t, Selector.DROPDOWN);if (n) {\n        var i = $QS(Selector.DROPDOWN_TOGGLE, n);i && e._setActiveState(i, !0);\n      }e._setActiveState(t, !0);\n    } else e._setActiveState(t, !0), e._setParentsSiblingActiveState(t, Selector.NAV_LIST_GROUP, [ClassName.NAV_LINK, ClassName.LIST_ITEM], !0);\n  }), i && i.length > 0 && this._$root && this._$root.$emit && this._$root.$emit(EVENT, t);\n}, ScrollSpy.prototype._clear = function () {\n  var t = this;$QSA(this._selector, this._$el).filter(function (t) {\n    if (t.classList.contains(ClassName.ACTIVE)) {\n      var e = t.getAttribute(\"href\");return \"#\" === e.charAt(0) && 0 !== e.indexOf(\"#/\");\n    }return !1;\n  }).forEach(function (e) {\n    t._setActiveState(e, !1);\n  });\n}, ScrollSpy.prototype._setActiveState = function (t, e) {\n  if (t) {\n    t.classList.contains(ClassName.NAV_LINK) && !t.classList.contains(ClassName.DROPDOWN_TOGGLE) && (t = t.parentElement);var n = getVm(t);n && Object.prototype.hasOwnProperty.call(n.$props, \"active\") ? n.$props.active = e : t.classList[e ? \"add\" : \"remove\"](ClassName.ACTIVE);\n  }\n}, ScrollSpy.prototype._setParentsSiblingActiveState = function (t, e, n, i) {\n  var o = this;if (n) {\n    Array.isArray(n) || (n = [n]);for (var r = t; r;) {\n      if ((r = closest(r, e)) && r.previousElementSibling) for (var s = 0; s < n.length - 1; s++) {\n        r.previousElementSibling.classList.contains(n[s]) && o._setActiveState(r, i);\n      }\n    }\n  }\n};var scrollspy = { bind: function bind(t, e) {\n    isServer || t[BVSS] || (t[BVSS] = new ScrollSpy(t, e));\n  }, inserted: function inserted(t, e) {\n    !isServer && t[BVSS] && t[BVSS].updateConfig(e).listen().refresh().process();\n  }, update: function update(t, e) {\n    !isServer && t[BVSS] && t[BVSS].updateConfig(e).refresh().process();\n  }, componentUpdated: function componentUpdated(t, e) {\n    !isServer && t[BVSS] && t[BVSS].updateConfig(e).refresh().process();\n  }, unbind: function unbind(t) {\n    !isServer && t[BVSS] && (t[BVSS].unListen().dispose(), t[BVSS] = null);\n  } },\n    directives = Object.freeze({ bToggle: toggle, bModal: modal$1, bScrollspy: scrollspy }),\n    VuePlugin = { install: function install(t) {\n    if (!t._bootstrap_vue_installed) {\n      t._bootstrap_vue_installed = !0;for (var e in components) {\n        t.component(e, components[e]);\n      }for (var n in directives) {\n        t.directive(n, directives[n]);\n      }\n    }\n  } };\"undefined\" != typeof window && window.Vue && window.Vue.use(VuePlugin);/* harmony default export */ __webpack_exports__[\"default\"] = (VuePlugin);\n//# sourceMappingURL=bootstrap-vue.esm.js.map\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L19ib290c3RyYXAtdnVlQDAuMTcuMUBib290c3RyYXAtdnVlL2Rpc3QvYm9vdHN0cmFwLXZ1ZS5lc20uanM/OTNmNiJdLCJuYW1lcyI6WyJvbWl0TGlua1Byb3BzIiwidCIsImUiLCJhcmd1bWVudHMiLCJsZW5ndGgiLCJPYmplY3QiLCJrZXlzIiwicHJvcHMiLCJyZWR1Y2UiLCJuIiwiaW5jbHVkZXMiLCJpc1Zpc2libGUiLCJvZmZzZXRXaWR0aCIsIm9mZnNldEhlaWdodCIsImZpbmRGaXJzdFZpc2libGUiLCJxdWVyeVNlbGVjdG9yQWxsIiwiQXJyYXkiLCJwcm90b3R5cGUiLCJzbGljZSIsImNhbGwiLCJpIiwiZmluZCIsIm8iLCJpc1Zpc2libGUkMSIsIm1ha2VQYWdlQXJyYXkiLCJhcHBseSIsIm1hcCIsIm51bWJlciIsImNsYXNzTmFtZSIsIm9ic2VydmVET00iLCJ3aW5kb3ciLCJNdXRhdGlvbk9ic2VydmVyIiwiV2ViS2l0TXV0YXRpb25PYnNlcnZlciIsImFkZEV2ZW50TGlzdGVuZXIiLCJhZGRlZE5vZGVzIiwicmVtb3ZlZE5vZGVzIiwib2JzZXJ2ZSIsImFzc2lnbiIsImNoaWxkTGlzdCIsInN1YnRyZWUiLCJ0YXJnZXRzIiwiX192dWVfXyIsImNvbnNvbGUiLCJ3YXJuIiwiciIsIm1vZGlmaWVycyIsImZpbHRlciIsImFsbF9saXN0ZW5fdHlwZXMiLCJ2YWx1ZSIsInB1c2giLCJzIiwidm0iLCJmb3JFYWNoIiwiaXNFbGVtZW50Iiwibm9kZVR5cGUiLCJjbG9zZXN0IiwiJFFTQSIsImRvY3VtZW50IiwiJFFTIiwicXVlcnlTZWxlY3RvciIsImdldFZtIiwidG9UeXBlIiwidG9TdHJpbmciLCJtYXRjaCIsInRvTG93ZXJDYXNlIiwidHlwZUNoZWNrQ29uZmlnIiwiaGFzT3duUHJvcGVydHkiLCJSZWdFeHAiLCJ0ZXN0IiwiZXJyb3IiLCJTY3JvbGxTcHkiLCJfJGVsIiwiX3NlbGVjdG9yIiwiU2VsZWN0b3IiLCJOQVZfTElOS1MiLCJMSVNUX0lURU1TIiwiRFJPUERPV05fSVRFTVMiLCJqb2luIiwiX2NvbmZpZyIsIkRlZmF1bHQiLCJfb2Zmc2V0cyIsIl90YXJnZXRzIiwiX2FjdGl2ZVRhcmdldCIsIl9zY3JvbGxIZWlnaHQiLCJfJHJvb3QiLCJfcmVzaXplVGltZW91dCIsInVwZGF0ZUNvbmZpZyIsImFsZXJ0IiwicmVuZGVyIiwiJGNyZWF0ZUVsZW1lbnQiLCJfc2VsZiIsIl9jIiwibG9jYWxTaG93IiwiY2xhc3MiLCJjbGFzc09iamVjdCIsImF0dHJzIiwicm9sZSIsImRpc21pc3NpYmxlIiwic3RhdGljQ2xhc3MiLCJ0eXBlIiwib24iLCJjbGljayIsInN0b3BQcm9wYWdhdGlvbiIsInByZXZlbnREZWZhdWx0IiwiZGlzbWlzcyIsIl92IiwiX2UiLCJfdCIsInN0YXRpY1JlbmRlckZucyIsImRhdGEiLCJjb3VudERvd25UaW1lcklkIiwiZGlzbWlzc2VkIiwiY3JlYXRlZCIsInN0YXRlIiwiY29tcHV0ZWQiLCJhbGVydFZhcmlhbnQiLCJ2YXJpYW50Iiwic2hvdyIsIlN0cmluZyIsImRlZmF1bHQiLCJCb29sZWFuIiwiZGlzbWlzc0xhYmVsIiwiTnVtYmVyIiwid2F0Y2giLCJzaG93Q2hhbmdlZCIsIm1vdW50ZWQiLCJtZXRob2RzIiwiJGVtaXQiLCJjbGVhckNvdW50ZXIiLCJjbGVhckludGVydmFsIiwic2V0SW50ZXJ2YWwiLCJhY3RpdmUiLCJhY3RpdmVDbGFzcyIsImFwcGVuZCIsImRpc2FibGVkIiwiZXZlbnQiLCJleGFjdCIsImV4YWN0QWN0aXZlQ2xhc3MiLCJocmVmIiwicmVsIiwicmVwbGFjZSIsInJvdXRlclRhZyIsInRhZyIsInRhcmdldCIsInRvIiwibGlua1Byb3BzIiwiaXNSb3V0ZXJMaW5rIiwiJHJvdXRlciIsIl9ocmVmIiwiY29tcHV0ZWRSZWwiLCJjb21wb25lbnRUYWciLCJsaW5rQ2xhc3NPYmplY3QiLCJsaW5rQ2xpY2siLCIkcm9vdCIsImxpbmtNaXhpbiIsImJMaW5rIiwibmF0aXZlT24iLCJtaXhpbnMiLCJiTGlua1Byb3BLZXlzIiwiYnJlYWRjcnVtYiIsIl9sIiwibm9ybWFsaXplZEl0ZW1zIiwib25DbGljayIsIl9vcmlnaW5hbEl0ZW0iLCJhcmlhQ3VycmVudCIsImRvbVByb3BzIiwiaW5uZXJIVE1MIiwiX3MiLCJ0ZXh0IiwiX2IiLCJfbGlua1Byb3BzIiwiY29tcG9uZW50cyIsIml0ZW1zIiwibGluayIsInJlcXVpcmVkIiwiYkJ0biIsImNvbXBvbmVudFR5cGUiLCJjbGFzc0xpc3QiLCJidG5UeXBlIiwiY29uZGl0aW9uYWxMaW5rUHJvcHMiLCJidG5WYXJpYW50IiwiYnRuU2l6ZSIsImJ0bkJsb2NrIiwiYnRuRGlzYWJsZWQiLCJibG9jayIsInNpemUiLCJJVEVNX1NFTEVDVE9SIiwiYnV0dG9uVG9vbGJhciIsInRhYmluZGV4Iiwia2V5TmF2IiwiZm9jdXNpbiIsImN1cnJlbnRUYXJnZXQiLCJmb2N1c0ZpcnN0Iiwia2V5ZG93biIsIl9rIiwia2V5Q29kZSIsImJ1dHRvbiIsImZvY3VzTmV4dCIsInNoaWZ0S2V5IiwiZm9jdXNMYXN0IiwianVzdGlmeSIsInZlcnRpY2FsIiwiS2V5TmF2Iiwic2V0SXRlbUZvY3VzIiwiJG5leHRUaWNrIiwiZm9jdXMiLCJnZXRJdGVtcyIsImluZGV4T2YiLCIkZWwiLCJ0YWJJbmRleCIsImJ1dHRvbkdyb3VwIiwiY2xpY2tPdXQiLCJkb2N1bWVudEVsZW1lbnQiLCJfY2xpY2tPdXRMaXN0ZW5lciIsImRlc3Ryb3llZCIsInJlbW92ZUV2ZW50TGlzdGVuZXIiLCJjb250YWlucyIsImNsaWNrT3V0TGlzdGVuZXIiLCJJVEVNX1NFTEVDVE9SJDEiLCJIRUFERVJfU0VMRUNUT1IiLCJBTExfU0VMRUNUT1IiLCJkcm9wZG93biIsInNwbGl0IiwiZHJvcHVwIiwicmlnaHQiLCJ2aXNpYmxlIiwiJG9uIiwiYm9keSIsImNoaWxkcmVuIiwibm9vcCIsInRvZ2dsZSIsImdldEZpcnN0SXRlbSIsImZvY3VzSXRlbSIsIm9uVGFiIiwib25Fc2MiLCIkcmVmcyIsImZvY3VzSG92ZXJlZCIsImFkZCIsInJlbW92ZSIsIm1lbnUiLCJidXR0b25Hcm91cERyb3Bkb3duIiwiaWQiLCJyZWYiLCJrZWRvd24iLCJrZXl1cCIsIm1vdXNlb3ZlciIsImRyb3Bkb3duVG9nZ2xlIiwiY2FyZXQiLCJpbnB1dEdyb3VwIiwibGVmdCIsImlucHV0R3JvdXBBZGRvbiIsImlucHV0R3JvdXBCdXR0b24iLCJjYXJkIiwiY2FyZFZhcmlhbnQiLCJjYXJkQWxpZ24iLCJjYXJkSW52ZXJzZSIsImltZyIsInNyYyIsImFsdCIsImltZ0FsdCIsImhlYWRlciIsIiRzbG90cyIsImhlYWRlclRhZyIsImhlYWRlclZhcmlhbnQiLCJoZWFkZXJDbGFzcyIsIm5vQmxvY2siLCJibG9ja0NsYXNzIiwidGl0bGUiLCJzdWJUaXRsZSIsImZvb3RlciIsImZvb3RlclRhZyIsImZvb3RlclZhcmlhbnQiLCJmb290ZXJDbGFzcyIsIm92ZXJsYXkiLCJpbnZlcnNlIiwiYWxpZ24iLCJjYXJkR3JvdXAiLCJkZWNrIiwiY29sdW1ucyIsIkRJUkVDVElPTiIsIm5leHQiLCJjdXJyZW50IiwicHJldiIsImNhcm91c2VsIiwic3R5bGUiLCJiYWNrZ3JvdW5kIiwiaGVpZ2h0IiwiaXNTbGlkaW5nIiwibW91c2VlbnRlciIsInBhdXNlIiwibW91c2VsZWF2ZSIsInN0YXJ0IiwiZm9jdXNvdXQiLCJyZXN0YXJ0IiwiY29udHJvbHMiLCJsYWJlbFByZXYiLCJsYWJlbE5leHQiLCJkaXJlY3RpdmVzIiwibmFtZSIsInJhd05hbWUiLCJpbmRpY2F0b3JzIiwiZXhwcmVzc2lvbiIsImxhYmVsSW5kaWNhdG9ycyIsInNsaWRlcyIsImluZGV4IiwibGFiZWxHb3RvU2xpZGUiLCJpbnRlcnZhbCIsInZpc2liaWxpdHlTdGF0ZSIsImhpZGRlbiIsIl9pbnRlcnZhbElkIiwicmVsYXRlZFRhcmdldCIsInNldEF0dHJpYnV0ZSIsIl9jYXJvdXNlbEFuaW1hdGlvbiIsInNldFRpbWVvdXQiLCJjbGVhclRpbWVvdXQiLCJjYXJvdXNlbFNsaWRlIiwiY29udGVudENsYXNzZXMiLCJjYXB0aW9uIiwiY29udGVudFZpc2libGVVcCIsImNvbGxhcHNlIiwiZW50ZXIiLCJjbGVhckhlaWdodCIsImxlYXZlIiwiX3Njb3BlSWQiLCJpc05hdiIsIm1vZGVsIiwicHJvcCIsImVtaXRTdGF0ZSIsImFjY29yZGlvbiIsImdldENvbXB1dGVkU3R5bGUiLCJkcm9wZG93biQxIiwidG9nZ2xlVGV4dCIsImJCdXR0b24iLCJkcm9wZG93bkl0ZW0iLCJkcm9wZG93bkl0ZW1CdXR0b24iLCJkcm9wZG93bkRpdmlkZXIiLCJkcm9wZG93bkhlYWRlciIsImRyb3Bkb3duU2VsZWN0Iiwib3BlbiIsImRpc3BsYXlJdGVtIiwicG9zaXRpb24iLCJsaXN0Iiwic2VsZWN0Iiwic2VsZWN0ZWQiLCJyZXR1cm5PYmplY3QiLCJmb3JjZURlZmF1bHQiLCJkZWZhdWx0VGV4dCIsImJGb3JtIiwiaW5saW5lIiwiZm9ybUZpZWxkc2V0IiwiaW5wdXRTdGF0ZSIsImRlc2NyaWJlZEJ5IiwibGFiZWwiLCJsYWJlbFNyT25seSIsImxhYmVsTGF5b3V0IiwibGFiZWxBbGlnbkNsYXNzIiwiZm9yIiwibGFiZWxJZCIsImlucHV0TGF5b3V0IiwiZmVlZGJhY2siLCJmZWVkYmFja0lkIiwiZGVzY3JpcHRpb24iLCJkZXNjcmlwdGlvbklkIiwiaG9yaXpvbnRhbCIsImxhYmVsU2l6ZSIsImxhYmVsVGV4dEFsaWduIiwidXBkYXRlVGFyZ2V0IiwiY29udGVudCIsImlucHV0U2VsZWN0b3IiLCJ1cGRhdGVkIiwiZm9ybU1peGluIiwiaW5wdXRDbGFzcyIsImN1c3RvbSIsInBsYWluIiwiZm9ybUNoZWNrQm94TWl4aW4iLCJjaGVja2JveENsYXNzIiwiZm9ybUNoZWNrYm94IiwiY2hlY2tlZCIsImlzQ2hlY2tlZCIsImNoYW5nZSIsImhhbmRsZUNoYW5nZSIsInVuY2hlY2tlZFZhbHVlIiwiaXNBcnJheSIsImNvbmNhdCIsImZvcm1PcHRpb25zIiwib3B0aW9ucyIsInZhbHVlRmllbGQiLCJ0ZXh0RmllbGQiLCJzZWxlY3RlZFZhbHVlIiwibG9jYWxWYWx1ZSIsImZvcm1SYWRpbyIsInN0YWNrZWQiLCJyZWZJbkZvciIsIl9xIiwiX19jIiwiYkZvcm1JbnB1dFN0YXRpYyIsInN0YXRpY1ZhbHVlIiwiZm9ybWF0dGVyIiwiRnVuY3Rpb24iLCJmb3JtSW5wdXQiLCJzdGF0aWMiLCJ0ZXh0YXJlYSIsInJlYWRvbmx5Iiwicm93cyIsInJvd3NDb3VudCIsInBsYWNlaG9sZGVyIiwiaW5wdXQiLCJvbklucHV0Iiwib25DaGFuZ2UiLCJvbktleVVwIiwiYmx1ciIsImZvcm1hdCIsImxhenlGb3JtYXR0ZXIiLCJmb3JtRmlsZSIsImRyYWdvdmVyIiwiZHJhZ2dpbmciLCJkcm9wTGFiZWwiLCJkcm9wIiwiZHJhZ2xlYXZlIiwiYWNjZXB0IiwibXVsdGlwbGUiLCJ3ZWJraXRkaXJlY3RvcnkiLCJkaXJlY3RvcnkiLCJvbkZpbGVDaGFuZ2UiLCJjb21wdXRlZENob29zZUxhYmVsIiwic2VsZWN0ZWRMYWJlbCIsInNlbGVjdGVkRmlsZSIsInNlbGVjdGVkRm9ybWF0IiwiY2hvb3NlTGFiZWwiLCJyZXNldCIsImRhdGFUcmFuc2ZlciIsIm5vVHJhdmVyc2UiLCJzZXRGaWxlcyIsImZpbGVzIiwid2Via2l0R2V0QXNFbnRyeSIsInRyYXZlcnNlRmlsZVRyZWUiLCJhbGwiLCJ0aGVuIiwibm9Ecm9wIiwiZHJvcEVmZmVjdCIsIlByb21pc2UiLCJpc0ZpbGUiLCJmaWxlIiwiJHBhdGgiLCJpc0RpcmVjdG9yeSIsImNyZWF0ZVJlYWRlciIsInJlYWRFbnRyaWVzIiwiZm9ybVNlbGVjdCIsIl92YWx1ZSIsImp1bWJvdHJvbiIsImZsdWlkIiwiY29udGFpbmVyRmx1aWQiLCJsZWFkIiwiYmFkZ2UiLCJiYWRnZVZhcmlhbnQiLCJiYWRnZVBpbGwiLCJwaWxsIiwibGlzdEdyb3VwIiwiZmx1c2giLCJsaW5rUHJvcHMkMSIsImFjdGlvblRhZ3MiLCJsaXN0R3JvdXBJdGVtIiwibXlUYWciLCJsaXN0U3RhdGUiLCJpc0FjdGlvbiIsImFjdGlvbiIsIm1lZGlhIiwicmlnaHRBbGlnbiIsInZlcnRpY2FsQWxpZ25DbGFzcyIsInZlcnRpY2FsQWxpZ24iLCJGT0NVU19TRUxFQ1RPUiIsIm1vZGFsIiwiaXNfdmlzaWJsZSIsImtleSIsImZhZGUiLCJub0ZhZGUiLCJvbkNsaWNrT3V0IiwiaGlkZUhlYWRlciIsImhpZGVIZWFkZXJDbG9zZSIsImhlYWRlckNsb3NlTGFiZWwiLCJoaWRlIiwiaGlkZUZvb3RlciIsIm9rT25seSIsImJ1dHRvblNpemUiLCJjbG9zZVRpdGxlIiwib2tEaXNhYmxlZCIsIm9rVGl0bGUiLCJyZXR1cm5fZm9jdXMiLCJyZXR1cm5Gb2N1cyIsIm5vQ2xvc2VPbkJhY2tkcm9wIiwibm9DbG9zZU9uRXNjIiwibm9BdXRvRm9jdXMiLCJlbmZvcmNlRm9jdXMiLCJpc09LIiwiY2FuY2VsIiwicmV0dXJuRm9jdXNUbyIsImFjdGl2ZUVsZW1lbnQiLCJuYXYiLCJpc05hdkJhciIsInRhYnMiLCJwaWxscyIsImZpbGwiLCJqdXN0aWZpZWQiLCJuYXZJdGVtIiwibmF2SXRlbURyb3Bkb3duIiwibmF2VG9nZ2xlIiwidG9nZ2xlU3RhdGUiLCJvbmNsaWNrIiwibmF2YmFyIiwiZml4ZWQiLCJzdGlja3kiLCJ0b2dnbGVhYmxlIiwidG9nZ2xlYWJsZUNsYXNzIiwidG9nZ2xlQnJlYWtwb2ludCIsIm5hdlRleHQiLCJuYXZGb3JtIiwiRUxMSVBTSVNfVEhSRVNIT0xEIiwicGFnaW5hdGlvbiIsImFyaWFMYWJlbCIsImZvY3VzQ3VycmVudCIsImZvY3VzUHJldiIsImhpZGVHb3RvRW5kQnV0dG9ucyIsImlzQWN0aXZlIiwiZmlyc3RUZXh0IiwiYnV0dG9uUm9sZSIsImxhYmVsRmlyc3RQYWdlIiwic2V0UGFnZSIsInByZXZUZXh0IiwibGFiZWxQcmV2UGFnZSIsImN1cnJlbnRQYWdlIiwic2hvd0ZpcnN0RG90cyIsImVsbGlwc2lzVGV4dCIsInBhZ2VMaXN0IiwicGFnZUl0ZW1DbGFzc2VzIiwicGFnZUxpbmtDbGFzc2VzIiwibGFiZWxQYWdlIiwibnVtYmVyT2ZQYWdlcyIsInNob3dMYXN0RG90cyIsIm5leHRUZXh0IiwibGFiZWxOZXh0UGFnZSIsImxhc3RUZXh0IiwibGFiZWxMYXN0UGFnZSIsIk1hdGgiLCJjZWlsIiwidG90YWxSb3dzIiwicGVyUGFnZSIsImxpbWl0IiwiaGlkZUVsbGlwc2lzIiwiZmxvb3IiLCJhIiwiY3VycmVudHBhZ2UiLCJnZXRCdXR0b25zIiwic2V0QnRuRm9jdXMiLCJyZXZlcnNlIiwicGFyc2VJbnQiLCJnZXRBdHRyaWJ1dGUiLCJUUklHR0VSX0xJU1RFTkVSUyIsImhvdmVyIiwiUExBQ0VNRU5UX1BBUkFNUyIsInRvcCIsImJvdHRvbSIsIlRFVEhFUl9DTEFTU19QUkVGSVgiLCJURVRIRVJfQ0xBU1NFUyIsImVsZW1lbnQiLCJlbmFibGVkIiwiVFJBTlNJVElPTl9EVVJBVElPTiIsInBvcG92ZXIkMSIsImNvbnN0cmFpbnRzIiwiZGVib3VuY2UiLCJ2YWxpZGF0b3IiLCJkZWxheSIsIm9mZnNldCIsInBsYWNlbWVudCIsInBvcG92ZXJTdHlsZSIsInRhcmdldE9mZnNldCIsInRyaWdnZXJzIiwidHJpZ2dlclN0YXRlIiwiY2xhc3NTdGF0ZSIsImxhc3RFdmVudCIsIm5vcm1hbGl6ZWRUcmlnZ2VycyIsInBvcG92ZXJBbGlnbm1lbnQiLCJzaG93U3RhdGUiLCJzZXRPcHRpb25zIiwidXBkYXRlTGlzdGVuZXJzIiwiZ2V0RGVsYXkiLCIkZGF0YSIsIl90aW1lb3V0IiwidG9nZ2xlUG9wb3ZlciIsImFkZExpc3RlbmVyIiwiX3RyaWdnZXIiLCJldmVudEhhbmRsZXIiLCJkZXN0cm95VGV0aGVyIiwiX3RldGhlciIsImRlc3Ryb3kiLCJ0aW1lU3RhbXAiLCJnZXRUZXRoZXJPcHRpb25zIiwiYXR0YWNobWVudCIsIl9wb3BvdmVyIiwiY2xhc3NlcyIsImNsYXNzUHJlZml4IiwiaGlkZVBvcG92ZXIiLCJkaXNwbGF5IiwicmVmcmVzaFBvc2l0aW9uIiwicmVtb3ZlTGlzdGVuZXIiLCJzaG93UG9wb3ZlciIsInRyaWdnZXIiLCJwb3BvdmVyIiwiYmVmb3JlRGVzdHJveSIsInBhcmVudEVsZW1lbnQiLCJyZW1vdmVDaGlsZCIsInByb2dyZXNzIiwic3R5bGVPYmplY3QiLCJtYXgiLCJzaG93UHJvZ3Jlc3MiLCJzaG93VmFsdWUiLCJwcm9ncmVzc1ZhcmlhbnQiLCJzdHJpcGVkIiwiYW5pbWF0ZWQiLCJ3aWR0aCIsInBvdyIsInByZWNpc2lvbiIsInJvdW5kIiwicmVjVG9TdHJpbmciLCJfcm93VmFyaWFudCIsImRlZmF1bHRTb3J0Q29tcGFyZSIsImxvY2FsZUNvbXBhcmUiLCJudW1lcmljIiwidGFibGUiLCJ0YWJsZUNsYXNzIiwiYnVzeSIsImhlYWRDbGFzcyIsImZpZWxkcyIsImZpZWxkQ2xhc3MiLCJ0aFN0eWxlIiwic29ydGFibGUiLCJzb3J0RGVzYyIsInNvcnRCeSIsImxhYmVsU29ydEFzYyIsImxhYmVsU29ydERlc2MiLCJoZWFkQ2xpY2tlZCIsImNvbHVtbiIsImZpZWxkIiwiZm9vdENsb25lIiwiZm9vdENsYXNzIiwiJHNjb3BlZFNsb3RzIiwiX2l0ZW1zIiwicm93Q2xhc3MiLCJyb3dDbGlja2VkIiwicm93SG92ZXJlZCIsInRkQ2xhc3MiLCJpdGVtIiwic2hvd0VtcHR5IiwiY29sc3BhbiIsImVtcHR5RmlsdGVyZWRUZXh0IiwiZW1wdHlUZXh0IiwibG9jYWxJdGVtcyIsIml0ZW1zUHJvdmlkZXIiLCJib3JkZXJlZCIsInNtYWxsIiwicmVzcG9uc2l2ZSIsImhlYWRWYXJpYW50IiwiZm9vdFZhcmlhbnQiLCJzb3J0Q29tcGFyZSIsIm5vUHJvdmlkZXJQYWdpbmciLCJub1Byb3ZpZGVyU29ydGluZyIsIm5vUHJvdmlkZXJGaWx0ZXJpbmciLCJfcHJvdmlkZXJVcGRhdGUiLCJoYXNQcm92aWRlciIsInByb3ZpZGVyRmlsdGVyaW5nIiwicHJvdmlkZXJTb3J0aW5nIiwicHJvdmlkZXJQYWdpbmciLCJjb250ZXh0IiwibGFzdEluZGV4Iiwic29ydCIsInRoQ2xhc3MiLCJfY2VsbFZhcmlhbnRzIiwicmVmcmVzaCIsIl9wcm92aWRlclNldExvY2FsIiwibmF2U3R5bGUiLCJjdXJyZW50VGFiIiwicHJldmlvdXNUYWIiLCJuZXh0VGFiIiwic2V0VGFiIiwiaGVhZEh0bWwiLCJsb2NhbEFjdGl2ZSIsImNvbnRyb2xsZWRCeSIsImxhenkiLCIkc2V0Iiwic2lnbiIsInVwZGF0ZVRhYnMiLCJjb21wb25lbnRJbnN0YW5jZSIsInRhYnNDb250YWluZXIiLCJiaW5kIiwidGFiIiwibW9kZSIsImJlZm9yZUxlYXZlIiwiYnV0dG9uSWQiLCJ0b29sdGlwIiwib3BhY2l0eSIsImZyZWV6ZSIsImJBbGVydCIsImJCcmVhZGNydW1iIiwiYkJ1dHRvblRvb2xiYXIiLCJiQnRuVG9vbGJhciIsImJCdXR0b25Hcm91cCIsImJCdG5Hcm91cCIsImJCdXR0b25Hcm91cERyb3Bkb3duIiwiYkJ0bkdyb3VwRHJvcGRvd24iLCJiSW5wdXRHcm91cCIsImJJbnB1dEdyb3VwQWRkb24iLCJiSW5wdXRHcm91cEJ1dHRvbiIsImJJbnB1dEdyb3VwQnRuIiwiYkNhcmQiLCJiQ2FyZEdyb3VwIiwiYkRyb3Bkb3duIiwiYkRyb3Bkb3duSXRlbSIsImJEcm9wZG93bkl0ZW1CdXR0b24iLCJiRHJvcGRvd25JdGVtQnRuIiwiYkRyb3Bkb3duRGl2aWRlciIsImJEcm9wZG93bkhlYWRlciIsImJEcm9wZG93blNlbGVjdCIsImJGb3JtQ2hlY2tib3giLCJiRm9ybUZpZWxkc2V0IiwiYkZvcm1GaWxlIiwiYkZvcm1SYWRpbyIsImJGb3JtSW5wdXQiLCJiRm9ybVNlbGVjdCIsImJKdW1ib3Ryb24iLCJiQmFkZ2UiLCJiTWVkaWEiLCJiTW9kYWwiLCJiTmF2YmFyIiwiYk5hdlRleHQiLCJiTmF2Rm9ybSIsImJQYWdpbmF0aW9uIiwiYlBvcG92ZXIiLCJiUHJvZ3Jlc3MiLCJiVGFibGUiLCJiVG9vbHRpcCIsImJUYWIiLCJiVGFicyIsImJOYXYiLCJiTmF2SXRlbSIsImJOYXZJdGVtRHJvcGRvd24iLCJiTmF2VG9nZ2xlIiwiYkxpc3RHcm91cEl0ZW0iLCJiTGlzdEdyb3VwIiwiYkNhcm91c2VsU2xpZGUiLCJiQ2Fyb3VzZWwiLCJiQ29sbGFwc2UiLCJpbkJyb3dzZXIiLCJsaXN0ZW5fdHlwZXMiLCJsaXN0ZW5fdHlwZXMkMSIsIm1vZGFsJDEiLCJpbkJyb3dzZXIkMSIsImlzU2VydmVyIiwiRWxlbWVudCIsIm93bmVyRG9jdW1lbnQiLCJOQU1FIiwiRVZFTlQiLCJCVlNTIiwibWV0aG9kIiwidGhyb3R0bGUiLCJEZWZhdWx0VHlwZSIsIkNsYXNzTmFtZSIsIkRST1BET1dOX0lURU0iLCJEUk9QRE9XTl9NRU5VIiwiRFJPUERPV05fVE9HR0xFIiwiTkFWX0xJTksiLCJMSVNUX0lURU0iLCJBQ1RJVkUiLCJOQVZfTElTVF9HUk9VUCIsIk5BViIsIkxJU1RfR1JPVVAiLCJEUk9QRE9XTiIsIk9mZnNldE1ldGhvZCIsIk9GRlNFVCIsIlBPU0lUSU9OIiwiYXJnIiwibGlzdGVuIiwiX2dldFNjcm9sbGVyIiwidGFnTmFtZSIsInVuTGlzdGVuIiwiX2dldFNjcm9sbFRvcCIsIl9nZXRTY3JvbGxIZWlnaHQiLCJjaGFyQXQiLCJnZXRCb3VuZGluZ0NsaWVudFJlY3QiLCJvZmZzZXRUb3AiLCJwcm9jZXNzIiwiX2dldE9mZnNldEhlaWdodCIsIl9hY3RpdmF0ZSIsIl9jbGVhciIsImRpc3Bvc2UiLCJoYW5kbGVFdmVudCIsInBhZ2VZT2Zmc2V0Iiwic2Nyb2xsVG9wIiwic2Nyb2xsSGVpZ2h0IiwiaW5uZXJIZWlnaHQiLCJfc2V0QWN0aXZlU3RhdGUiLCJfc2V0UGFyZW50c1NpYmxpbmdBY3RpdmVTdGF0ZSIsIiRwcm9wcyIsInByZXZpb3VzRWxlbWVudFNpYmxpbmciLCJzY3JvbGxzcHkiLCJpbnNlcnRlZCIsInVwZGF0ZSIsImNvbXBvbmVudFVwZGF0ZWQiLCJ1bmJpbmQiLCJiVG9nZ2xlIiwiYlNjcm9sbHNweSIsIlZ1ZVBsdWdpbiIsImluc3RhbGwiLCJfYm9vdHN0cmFwX3Z1ZV9pbnN0YWxsZWQiLCJjb21wb25lbnQi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SUFBYXlLLFVBQWI7QUFBd0IxSyxVQUFFMnlCLFNBQUYsQ0FBWTF5QixDQUFaLEVBQWN5SyxXQUFXekssQ0FBWCxDQUFkO0FBQXhCLE9BQXFELEtBQUksSUFBSU8sQ0FBUixJQUFhZ1MsVUFBYjtBQUF3QnhTLFVBQUU0eUIsU0FBRixDQUFZcHlCLENBQVosRUFBY2dTLFdBQVdoUyxDQUFYLENBQWQ7QUFBeEI7QUFBcUQ7QUFBQyxHQUE5TCxFQUF4aEIsQ0FBd3RCLGVBQWEsT0FBT3FCLE1BQXBCLElBQTRCQSxPQUFPZ3hCLEdBQW5DLElBQXdDaHhCLE9BQU9neEIsR0FBUCxDQUFXQyxHQUFYLENBQWVOLFNBQWYsQ0FBeEMsQ0FBa0UsK0RBQWVBLFNBQWY7QUFDcjQvRiIsImZpbGUiOiI2Ny5qcyIsInNvdXJjZXNDb250ZW50IjpbImZ1bmN0aW9uIG9taXRMaW5rUHJvcHMoKXtmb3IodmFyIHQ9W10sZT1hcmd1bWVudHMubGVuZ3RoO2UtLTspdFtlXT1hcmd1bWVudHNbZV07cmV0dXJuIE9iamVjdC5rZXlzKHByb3BzKS5yZWR1Y2UoZnVuY3Rpb24oZSxuKXtyZXR1cm4gdC5pbmNsdWRlcyhuKXx8KGVbbl09cHJvcHNbbl0pLGV9LHt9KX1mdW5jdGlvbiBpc1Zpc2libGUodCl7cmV0dXJuIHQmJih0Lm9mZnNldFdpZHRoPjB8fHQub2Zmc2V0SGVpZ2h0PjApfWZ1bmN0aW9uIGZpbmRGaXJzdFZpc2libGUodCxlKXtpZighdHx8IXQucXVlcnlTZWxlY3RvckFsbHx8IWUpcmV0dXJuIG51bGw7Zm9yKHZhciBuPUFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKHQucXVlcnlTZWxlY3RvckFsbChlKSksaT1uLmZpbmQ/bi5maW5kKGZ1bmN0aW9uKHQpe3JldHVybiBpc1Zpc2libGUodCl9KTpudWxsLG89MDshaSYmbzxuLmxlbmd0aDtvKyspaXNWaXNpYmxlKG5bb10pJiYoaT1uW29dKTtyZXR1cm4gaX1mdW5jdGlvbiBpc1Zpc2libGUkMSh0KXtyZXR1cm4gdCYmKHQub2Zmc2V0V2lkdGg+MHx8dC5vZmZzZXRIZWlnaHQ+MCl9ZnVuY3Rpb24gbWFrZVBhZ2VBcnJheSh0LGUpe3JldHVybiBBcnJheS5hcHBseShudWxsLHtsZW5ndGg6ZX0pLm1hcChmdW5jdGlvbihlLG4pe3JldHVybntudW1iZXI6bit0LGNsYXNzTmFtZTpudWxsfX0pfWZ1bmN0aW9uIG9ic2VydmVET00odCxlLG4pe3ZhciBpPXdpbmRvdy5NdXRhdGlvbk9ic2VydmVyfHx3aW5kb3cuV2ViS2l0TXV0YXRpb25PYnNlcnZlcixvPXdpbmRvdy5hZGRFdmVudExpc3RlbmVyO2k/bmV3IGkoZnVuY3Rpb24odCl7KHRbMF0uYWRkZWROb2Rlcy5sZW5ndGg+MHx8dFswXS5yZW1vdmVkTm9kZXMubGVuZ3RoPjApJiZlKCl9KS5vYnNlcnZlKHQsT2JqZWN0LmFzc2lnbih7Y2hpbGRMaXN0OiEwLHN1YnRyZWU6ITB9LG4pKTpvJiYodC5hZGRFdmVudExpc3RlbmVyKFwiRE9NTm9kZUluc2VydGVkXCIsZSwhMSksdC5hZGRFdmVudExpc3RlbmVyKFwiRE9NTm9kZVJlbW92ZWRcIixlLCExKSl9ZnVuY3Rpb24gdGFyZ2V0cyh0LGUsbixpKXt2YXIgbz10Ll9fdnVlX187aWYoIW8pcmV0dXJuIGNvbnNvbGUud2FybihcIl9fdnVlX18gaXMgbm90IGF2YWlsYWJsZSBvbiBlbGVtZW50XCIsdCksW107dmFyIHI9T2JqZWN0LmtleXMoZS5tb2RpZmllcnN8fHt9KS5maWx0ZXIoZnVuY3Rpb24odCl7cmV0dXJuIWFsbF9saXN0ZW5fdHlwZXNbdF19KTtlLnZhbHVlJiZyLnB1c2goZS52YWx1ZSk7dmFyIHM9ZnVuY3Rpb24oKXtpKHt0YXJnZXRzOnIsdm06b30pfTtyZXR1cm4gT2JqZWN0LmtleXMoYWxsX2xpc3Rlbl90eXBlcykuZm9yRWFjaChmdW5jdGlvbihpKXsobltpXXx8ZS5tb2RpZmllcnNbaV0pJiZ0LmFkZEV2ZW50TGlzdGVuZXIoaSxzKX0pLHJ9ZnVuY3Rpb24gaXNFbGVtZW50KHQpe3JldHVybiB0Lm5vZGVUeXBlfWZ1bmN0aW9uIGNsb3Nlc3QodCxlKXt2YXIgbj10LmNsb3Nlc3QoZSk7cmV0dXJuIG49PT10P251bGw6bn1mdW5jdGlvbiAkUVNBKHQsZSl7cmV0dXJuIGV8fChlPWRvY3VtZW50KSxpc0VsZW1lbnQoZSk/QXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoZS5xdWVyeVNlbGVjdG9yQWxsKHQpKTpbXX1mdW5jdGlvbiAkUVModCxlKXtyZXR1cm4gZXx8KGU9ZG9jdW1lbnQpLGlzRWxlbWVudChlKT9lLnF1ZXJ5U2VsZWN0b3IodCl8fG51bGw6bnVsbH1mdW5jdGlvbiBnZXRWbSh0KXtyZXR1cm4gdD90Ll9fdnVlX186bnVsbH1mdW5jdGlvbiB0b1R5cGUodCl7cmV0dXJue30udG9TdHJpbmcuY2FsbCh0KS5tYXRjaCgvXFxzKFthLXpBLVpdKykvKVsxXS50b0xvd2VyQ2FzZSgpfWZ1bmN0aW9uIHR5cGVDaGVja0NvbmZpZyh0LGUsbil7Zm9yKHZhciBpIGluIG4paWYoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG4saSkpe3ZhciBvPW5baV0scj1lW2ldLHM9ciYmaXNFbGVtZW50KHIpP1wiZWxlbWVudFwiOnRvVHlwZShyKTtuZXcgUmVnRXhwKG8pLnRlc3Qocyl8fGNvbnNvbGUuZXJyb3IodCsnOiBPcHRpb24gXCInK2krJ1wiIHByb3ZpZGVkIHR5cGUgXCInK3MrJ1wiIGJ1dCBleHBlY3RlZCB0eXBlIFwiJytvKydcIicpfX1mdW5jdGlvbiBTY3JvbGxTcHkodCxlKXt0aGlzLl8kZWw9dCx0aGlzLl9zZWxlY3Rvcj1bU2VsZWN0b3IuTkFWX0xJTktTLFNlbGVjdG9yLkxJU1RfSVRFTVMsU2VsZWN0b3IuRFJPUERPV05fSVRFTVNdLmpvaW4oXCIsXCIpLHRoaXMuX2NvbmZpZz1PYmplY3QuYXNzaWduKHt9LERlZmF1bHQpLHRoaXMuX29mZnNldHM9W10sdGhpcy5fdGFyZ2V0cz1bXSx0aGlzLl9hY3RpdmVUYXJnZXQ9bnVsbCx0aGlzLl9zY3JvbGxIZWlnaHQ9MCx0aGlzLl8kcm9vdD1udWxsLHRoaXMuX3Jlc2l6ZVRpbWVvdXQ9bnVsbCx0aGlzLnVwZGF0ZUNvbmZpZyhlKX1pbXBvcnQgVGV0aGVyIGZyb21cInRldGhlclwiO3ZhciB3YXJuPWZ1bmN0aW9uKHQpe2NvbnNvbGUud2FybihcIltCb290c3RyYXAtVnVlIHdhcm5dOiBcIit0KX0sYWxlcnQ9e3JlbmRlcjpmdW5jdGlvbigpe3ZhciB0PXRoaXMsZT10LiRjcmVhdGVFbGVtZW50LG49dC5fc2VsZi5fY3x8ZTtyZXR1cm4gdC5sb2NhbFNob3c/bihcImRpdlwiLHtjbGFzczp0LmNsYXNzT2JqZWN0LGF0dHJzOntyb2xlOlwiYWxlcnRcIixcImFyaWEtbGl2ZVwiOlwicG9saXRlXCIsXCJhcmlhLWF0b21pY1wiOlwidHJ1ZVwifX0sW3QuZGlzbWlzc2libGU/bihcImJ1dHRvblwiLHtzdGF0aWNDbGFzczpcImNsb3NlXCIsYXR0cnM6e3R5cGU6XCJidXR0b25cIixcImRhdGEtZGlzbWlzc1wiOlwiYWxlcnRcIixcImFyaWEtbGFiZWxcIjpcImRpc21pc3NMYWJlbFwifSxvbjp7Y2xpY2s6ZnVuY3Rpb24oZSl7ZS5zdG9wUHJvcGFnYXRpb24oKSxlLnByZXZlbnREZWZhdWx0KCksdC5kaXNtaXNzKGUpfX19LFtuKFwic3BhblwiLHthdHRyczp7XCJhcmlhLWhpZGRlblwiOlwidHJ1ZVwifX0sW3QuX3YoXCLDl1wiKV0pXSk6dC5fZSgpLHQuX3QoXCJkZWZhdWx0XCIpXSwyKTp0Ll9lKCl9LHN0YXRpY1JlbmRlckZuczpbXSxkYXRhOmZ1bmN0aW9uKCl7cmV0dXJue2NvdW50RG93blRpbWVySWQ6bnVsbCxkaXNtaXNzZWQ6ITF9fSxjcmVhdGVkOmZ1bmN0aW9uKCl7dGhpcy5zdGF0ZSYmd2FybignPGItYWxlcnQ+IFwic3RhdGVcIiBwcm9wZXJ0eSBpcyBkZXByZWNhdGVkLCBwbGVhc2UgdXNlIFwidmFyaWFudFwiIHByb3BlcnR5IGluc3RlYWQuJyl9LGNvbXB1dGVkOntjbGFzc09iamVjdDpmdW5jdGlvbigpe3JldHVybltcImFsZXJ0XCIsdGhpcy5hbGVydFZhcmlhbnQsdGhpcy5kaXNtaXNzaWJsZT9cImFsZXJ0LWRpc21pc3NpYmxlXCI6XCJcIl19LGFsZXJ0VmFyaWFudDpmdW5jdGlvbigpe3JldHVyblwiYWxlcnQtXCIrKHRoaXMuc3RhdGV8fHRoaXMudmFyaWFudHx8XCJpbmZvXCIpfSxsb2NhbFNob3c6ZnVuY3Rpb24oKXtyZXR1cm4hdGhpcy5kaXNtaXNzZWQmJih0aGlzLmNvdW50RG93blRpbWVySWR8fHRoaXMuc2hvdyl9fSxwcm9wczp7dmFyaWFudDp7dHlwZTpTdHJpbmcsZGVmYXVsdDpcImluZm9cIn0sc3RhdGU6e3R5cGU6U3RyaW5nLGRlZmF1bHQ6bnVsbH0sZGlzbWlzc2libGU6e3R5cGU6Qm9vbGVhbixkZWZhdWx0OiExfSxkaXNtaXNzTGFiZWw6e3R5cGU6U3RyaW5nLGRlZmF1bHQ6XCJDbG9zZVwifSxzaG93Ont0eXBlOltCb29sZWFuLE51bWJlcl0sZGVmYXVsdDohMX19LHdhdGNoOntzaG93OmZ1bmN0aW9uKCl7dGhpcy5zaG93Q2hhbmdlZCgpfX0sbW91bnRlZDpmdW5jdGlvbigpe3RoaXMuc2hvd0NoYW5nZWQoKX0sbWV0aG9kczp7ZGlzbWlzczpmdW5jdGlvbigpe3RoaXMuZGlzbWlzc2VkPSEwLHRoaXMuJGVtaXQoXCJkaXNtaXNzZWRcIiksdGhpcy5jbGVhckNvdW50ZXIoKX0sY2xlYXJDb3VudGVyOmZ1bmN0aW9uKCl7dGhpcy5jb3VudERvd25UaW1lcklkJiZjbGVhckludGVydmFsKHRoaXMuY291bnREb3duVGltZXJJZCl9LHNob3dDaGFuZ2VkOmZ1bmN0aW9uKCl7dmFyIHQ9dGhpcztpZih0aGlzLmRpc21pc3NlZD0hMSwhMCE9PXRoaXMuc2hvdyYmITEhPT10aGlzLnNob3cmJm51bGwhPT10aGlzLnNob3cmJjAhPT10aGlzLnNob3cpe3ZhciBlPXRoaXMuc2hvdzt0aGlzLiRlbWl0KFwiZGlzbWlzcy1jb3VudC1kb3duXCIsZSksdGhpcy5jbGVhckNvdW50ZXIoKSx0aGlzLmNvdW50RG93blRpbWVySWQ9c2V0SW50ZXJ2YWwoZnVuY3Rpb24oKXtpZihlPDIpcmV0dXJuIHQuZGlzbWlzcygpO2UtLSx0LiRlbWl0KFwiZGlzbWlzcy1jb3VudC1kb3duXCIsZSl9LDFlMyl9fX19LHByb3BzPXthY3RpdmU6e3R5cGU6Qm9vbGVhbixkZWZhdWx0OiExfSxhY3RpdmVDbGFzczp7dHlwZTpTdHJpbmcsZGVmYXVsdDpcImFjdGl2ZVwifSxhcHBlbmQ6e3R5cGU6Qm9vbGVhbixkZWZhdWx0OiExfSxkaXNhYmxlZDp7dHlwZTpCb29sZWFuLGRlZmF1bHQ6ITF9LGV2ZW50Ont0eXBlOltTdHJpbmcsQXJyYXldLGRlZmF1bHQ6XCJjbGlja1wifSxleGFjdDp7dHlwZTpCb29sZWFuLGRlZmF1bHQ6ITF9LGV4YWN0QWN0aXZlQ2xhc3M6e3R5cGU6U3RyaW5nLGRlZmF1bHQ6XCJhY3RpdmVcIn0saHJlZjp7dHlwZTpTdHJpbmcsZGVmYXVsdDpcIiNcIn0scmVsOnt0eXBlOlN0cmluZyxkZWZhdWx0Om51bGx9LHJlcGxhY2U6e3R5cGU6Qm9vbGVhbixkZWZhdWx0OiExfSxyb3V0ZXJUYWc6e3R5cGU6U3RyaW5nLGRlZmF1bHQ6XCJhXCJ9LHRhZzp7dHlwZTpTdHJpbmcsZGVmYXVsdDpudWxsfSx0YXJnZXQ6e3R5cGU6U3RyaW5nLGRlZmF1bHQ6XCJfc2VsZlwifSx0bzp7dHlwZTpbU3RyaW5nLE9iamVjdF0sZGVmYXVsdDpudWxsfX0sY29tcHV0ZWQ9e2xpbmtQcm9wczpmdW5jdGlvbigpe3ZhciB0PXRoaXM7cmV0dXJuIE9iamVjdC5rZXlzKHByb3BzKS5yZWR1Y2UoZnVuY3Rpb24oZSxuKXtyZXR1cm4gZVtuXT10W25dLGV9LHt9KX0saXNSb3V0ZXJMaW5rOmZ1bmN0aW9uKCl7cmV0dXJuIEJvb2xlYW4odGhpcy4kcm91dGVyJiZ0aGlzLnRvJiYhdGhpcy5kaXNhYmxlZCl9LF9ocmVmOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuZGlzYWJsZWQ/XCIjXCI6dGhpcy5ocmVmP3RoaXMuaHJlZjp0aGlzLnRvJiZcInN0cmluZ1wiPT10eXBlb2YgdGhpcy50bz90aGlzLnRvOnZvaWQgMH0sY29tcHV0ZWRSZWw6ZnVuY3Rpb24oKXtyZXR1cm5cIl9ibGFua1wiPT09dGhpcy50YXJnZXQmJm51bGw9PT10aGlzLnJlbD9cIm5vb3BlbmVyXCI6dGhpcy5yZWx8fG51bGx9LGNvbXBvbmVudFRhZzpmdW5jdGlvbigpe3JldHVybiB0aGlzLnRhZz8od2FybignPGItbGluaz4gXCJ0YWdcIiBwcm9wZXJ0eSBpcyBkZXByZWNhdGVkLCBwbGVhc2UgdXNlIFwicm91dGVyVGFnXCIgcHJvcGVydHkgaW5zdGVhZC4nKSx0aGlzLnRhZyk6dGhpcy5yb3V0ZXJUYWd9LGxpbmtDbGFzc09iamVjdDpmdW5jdGlvbigpe3JldHVyblt0aGlzLmFjdGl2ZT90aGlzLmV4YWN0P3RoaXMuZXhhY3RBY3RpdmVDbGFzczp0aGlzLmFjdGl2ZUNsYXNzOm51bGwsdGhpcy5kaXNhYmxlZD9cImRpc2FibGVkXCI6bnVsbF19fSxtZXRob2RzPXtsaW5rQ2xpY2s6ZnVuY3Rpb24odCl7dGhpcy5kaXNhYmxlZD90LnN0b3BQcm9wYWdhdGlvbigpOih0aGlzLiRyb290LiRlbWl0KFwiY2xpY2tlZDo6bGlua1wiLHRoaXMpLHRoaXMuJGVtaXQoXCJjbGlja1wiLHQpKSx0aGlzLmlzUm91dGVyTGlua3x8XCIjXCIhPT10aGlzLl9ocmVmfHx0LnByZXZlbnREZWZhdWx0KCl9fSxsaW5rTWl4aW49e3Byb3BzOnByb3BzLGNvbXB1dGVkOmNvbXB1dGVkLG1ldGhvZHM6bWV0aG9kc30sYkxpbms9e3JlbmRlcjpmdW5jdGlvbigpe3ZhciB0PXRoaXMsZT10LiRjcmVhdGVFbGVtZW50LG49dC5fc2VsZi5fY3x8ZTtyZXR1cm4gdC5pc1JvdXRlckxpbms/bihcInJvdXRlci1saW5rXCIse3RhZzpcImFcIixjbGFzczp0LmxpbmtDbGFzc09iamVjdCxhdHRyczp7XCJhY3RpdmUtY2xhc3NcIjp0LmFjdGl2ZUNsYXNzLFwiZXhhY3QtYWN0aXZlLWNsYXNzXCI6dC5leGFjdEFjdGl2ZUNsYXNzLGRpc2FibGVkOnQuZGlzYWJsZWQsXCJhcmlhLWRpc2FibGVkXCI6dC5kaXNhYmxlZD9cInRydWVcIjpcImZhbHNlXCIsdG86dC50byxleGFjdDp0LmV4YWN0LGFwcGVuZDp0LmFwcGVuZCxyZXBsYWNlOnQucmVwbGFjZSxldmVudDp0LmV2ZW50LHRhZzp0LmNvbXBvbmVudFRhZ30sbmF0aXZlT246e2NsaWNrOmZ1bmN0aW9uKGUpe3QubGlua0NsaWNrKGUpfX19LFt0Ll90KFwiZGVmYXVsdFwiKV0sMik6bihcImFcIix7Y2xhc3M6dC5saW5rQ2xhc3NPYmplY3QsYXR0cnM6e2Rpc2FibGVkOnQuZGlzYWJsZWQsXCJhcmlhLWRpc2FibGVkXCI6dC5kaXNhYmxlZD9cInRydWVcIjpcImZhbHNlXCIsaHJlZjp0Ll9ocmVmLHRhcmdldDp0LnRhcmdldHx8bnVsbCxyZWw6dC5jb21wdXRlZFJlbH0sb246e2NsaWNrOnQubGlua0NsaWNrfX0sW3QuX3QoXCJkZWZhdWx0XCIpXSwyKX0sc3RhdGljUmVuZGVyRm5zOltdLG1peGluczpbbGlua01peGluXX0sYkxpbmtQcm9wS2V5cz1PYmplY3Qua2V5cyhwcm9wcyksYnJlYWRjcnVtYj17cmVuZGVyOmZ1bmN0aW9uKCl7dmFyIHQ9dGhpcyxlPXQuJGNyZWF0ZUVsZW1lbnQsbj10Ll9zZWxmLl9jfHxlO3JldHVybiBuKFwib2xcIix7c3RhdGljQ2xhc3M6XCJicmVhZGNydW1iXCJ9LFt0Ll9sKHQubm9ybWFsaXplZEl0ZW1zLGZ1bmN0aW9uKGUpe3JldHVybiBuKFwibGlcIix7Y2xhc3M6W1wiYnJlYWRjcnVtYi1pdGVtXCIsZS5hY3RpdmU/XCJhY3RpdmVcIjpudWxsXSxhdHRyczp7cm9sZTpcInByZXNlbnRhdGlvblwifSxvbjp7Y2xpY2s6ZnVuY3Rpb24obil7dC5vbkNsaWNrKGUuX29yaWdpbmFsSXRlbSl9fX0sW2UuYWN0aXZlP24oXCJzcGFuXCIse2F0dHJzOntcImFyaWEtY3VycmVudFwiOnQuYXJpYUN1cnJlbnR9LGRvbVByb3BzOntpbm5lckhUTUw6dC5fcyhlLnRleHQpfX0pOm4oXCJiLWxpbmtcIix0Ll9iKHtkb21Qcm9wczp7aW5uZXJIVE1MOnQuX3MoZS50ZXh0KX19LFwiYi1saW5rXCIsZS5fbGlua1Byb3BzKSldLDEpfSksdC5fdChcImRlZmF1bHRcIildLDIpfSxzdGF0aWNSZW5kZXJGbnM6W10sY29tcG9uZW50czp7Ykxpbms6Ykxpbmt9LGNvbXB1dGVkOntub3JtYWxpemVkSXRlbXM6ZnVuY3Rpb24oKXt2YXIgdD0hMSxlPXRoaXMuaXRlbXMubGVuZ3RoO3JldHVybiB0aGlzLml0ZW1zLm1hcChmdW5jdGlvbihuLGkpe3ZhciBvPXtfb3JpZ2luYWxJdGVtOm59LHI9aT09PWUtMTtyZXR1cm5cInN0cmluZ1wiPT10eXBlb2Ygbj9PYmplY3QuYXNzaWduKG8se3RleHQ6bixsaW5rOlwiI1wiLGFjdGl2ZTpyfSk6T2JqZWN0LmFzc2lnbihvLG4pLCEwPT09by5hY3RpdmV8fCExPT09by5hY3RpdmV8fHQ/by5hY3RpdmUmJih0PSEwKTpvLmFjdGl2ZT1yLG8ubGluayYmKG8uaHJlZj1vLmxpbmspLG8uX2xpbmtQcm9wcz1PYmplY3Qua2V5cyhvKS5yZWR1Y2UoZnVuY3Rpb24odCxlKXtyZXR1cm4gYkxpbmtQcm9wS2V5cy5pbmNsdWRlcyhlKSYmKHRbZV09b1tlXSksdH0se30pLG99KX19LHByb3BzOntpdGVtczp7dHlwZTpBcnJheSxkZWZhdWx0OmZ1bmN0aW9uKCl7cmV0dXJuW119LHJlcXVpcmVkOiEwfSxhcmlhQ3VycmVudDp7dHlwZTpTdHJpbmcsZGVmYXVsdDpcImxvY2F0aW9uXCJ9fSxtZXRob2RzOntvbkNsaWNrOmZ1bmN0aW9uKHQpe3RoaXMuJGVtaXQoXCJjbGlja1wiLHQpfX19LGxpbmtQcm9wcz1PYmplY3QuYXNzaWduKG9taXRMaW5rUHJvcHMoXCJocmVmXCIsXCJ0b1wiKSx7aHJlZjp7dHlwZTpwcm9wcy5ocmVmLnR5cGV9LHRvOnt0eXBlOnByb3BzLnRvLnR5cGV9fSksYkJ0bj17cmVuZGVyOmZ1bmN0aW9uKCl7dmFyIHQ9dGhpcyxlPXQuJGNyZWF0ZUVsZW1lbnQ7cmV0dXJuKHQuX3NlbGYuX2N8fGUpKHQuY29tcG9uZW50VHlwZSx0Ll9iKHt0YWc6XCJidXR0b25cIixjbGFzczp0LmNsYXNzTGlzdCxhdHRyczp7dHlwZTp0LmJ0blR5cGUsZGlzYWJsZWQ6dC5kaXNhYmxlZH0sb246e2NsaWNrOnQub25DbGlja319LFwiYnV0dG9uXCIsdC5jb25kaXRpb25hbExpbmtQcm9wcyksW3QuX3QoXCJkZWZhdWx0XCIpXSwyKX0sc3RhdGljUmVuZGVyRm5zOltdLGNvbXBvbmVudHM6e2JMaW5rOmJMaW5rfSxjb21wdXRlZDp7bGlua1Byb3BzOmNvbXB1dGVkLmxpbmtQcm9wcyxjbGFzc0xpc3Q6ZnVuY3Rpb24oKXtyZXR1cm5bXCJidG5cIix0aGlzLmJ0blZhcmlhbnQsdGhpcy5idG5TaXplLHRoaXMuYnRuQmxvY2ssdGhpcy5idG5EaXNhYmxlZF19LGNvbXBvbmVudFR5cGU6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5ocmVmfHx0aGlzLnRvP1wiYi1saW5rXCI6XCJidXR0b25cIn0sYnRuQmxvY2s6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5ibG9jaz9cImJ0bi1ibG9ja1wiOlwiXCJ9LGJ0blZhcmlhbnQ6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy52YXJpYW50P1wiYnRuLVwiK3RoaXMudmFyaWFudDpcImJ0bi1zZWNvbmRhcnlcIn0sYnRuU2l6ZTpmdW5jdGlvbigpe3JldHVybiB0aGlzLnNpemU/XCJidG4tXCIrdGhpcy5zaXplOlwiXCJ9LGJ0bkRpc2FibGVkOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuZGlzYWJsZWQ/XCJkaXNhYmxlZFwiOlwiXCJ9LGJ0blR5cGU6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5ocmVmfHx0aGlzLnRvP251bGw6dGhpcy50eXBlfSxjb25kaXRpb25hbExpbmtQcm9wczpmdW5jdGlvbigpe3JldHVyblwiYnV0dG9uXCI9PT10aGlzLmNvbXBvbmVudFR5cGU/e306dGhpcy5saW5rUHJvcHN9fSxwcm9wczpPYmplY3QuYXNzaWduKGxpbmtQcm9wcyx7YmxvY2s6e3R5cGU6Qm9vbGVhbixkZWZhdWx0OiExfSxkaXNhYmxlZDp7dHlwZTpCb29sZWFuLGRlZmF1bHQ6ITF9LHNpemU6e3R5cGU6U3RyaW5nLGRlZmF1bHQ6bnVsbH0sdmFyaWFudDp7dHlwZTpTdHJpbmcsZGVmYXVsdDpudWxsfSx0eXBlOnt0eXBlOlN0cmluZyxkZWZhdWx0OlwiYnV0dG9uXCJ9fSksbWV0aG9kczp7b25DbGljazpmdW5jdGlvbih0KXt0aGlzLmRpc2FibGVkPyh0LnN0b3BQcm9wYWdhdGlvbigpLHQucHJldmVudERlZmF1bHQoKSk6dGhpcy4kZW1pdChcImNsaWNrXCIsdCl9fX0sSVRFTV9TRUxFQ1RPUj1bJy5idG46bm90KC5kaXNhYmxlZCk6bm90KFtkaXNhYmxlZF0pOm5vdChbc3R5bGUqPVwiZGlzcGxheTogbm9uZVwiXSk6bm90KFtzdHlsZSo9XCJkaXNwbGF5Om5vbmVcIl0pJywnLmZvcm0tY29udHJvbDpub3QoLmRpc2FibGVkKTpub3QoW2Rpc2FibGVkXSk6bm90KFtzdHlsZSo9XCJkaXNwbGF5OiBub25lXCJdKTpub3QoW3N0eWxlKj1cImRpc3BsYXk6bm9uZVwiXSknLCdzZWxlY3Q6bm90KC5kaXNhYmxlZCk6bm90KFtkaXNhYmxlZF0pOm5vdChbc3R5bGUqPVwiZGlzcGxheTogbm9uZVwiXSk6bm90KFtzdHlsZSo9XCJkaXNwbGF5Om5vbmVcIl0pJywnaW5wdXRbdHlwZT1cImNoZWNrYm94XCJdOm5vdCguZGlzYWJsZWQpOm5vdChbZGlzYWJsZWRdKTpub3QoW3N0eWxlKj1cImRpc3BsYXk6IG5vbmVcIl0pOm5vdChbc3R5bGUqPVwiZGlzcGxheTpub25lXCJdKScsJ2lucHV0W3R5cGU9XCJyYWRpb1wiXTpub3QoLmRpc2FibGVkKTpub3QoW2Rpc2FibGVkXSk6bm90KFtzdHlsZSo9XCJkaXNwbGF5OiBub25lXCJdKTpub3QoW3N0eWxlKj1cImRpc3BsYXk6bm9uZVwiXSknXS5qb2luKFwiLFwiKSxidXR0b25Ub29sYmFyPXtyZW5kZXI6ZnVuY3Rpb24oKXt2YXIgdD10aGlzLGU9dC4kY3JlYXRlRWxlbWVudDtyZXR1cm4odC5fc2VsZi5fY3x8ZSkoXCJkaXZcIix7Y2xhc3M6dC5jbGFzc09iamVjdCxhdHRyczp7cm9sZTpcInRvb2xiYXJcIix0YWJpbmRleDp0LmtleU5hdj9cIjBcIjpudWxsfSxvbjp7Zm9jdXNpbjpmdW5jdGlvbihlKXtpZihlLnRhcmdldCE9PWUuY3VycmVudFRhcmdldClyZXR1cm4gbnVsbDt0LmZvY3VzRmlyc3QoZSl9LGtleWRvd246W2Z1bmN0aW9uKGUpe3JldHVyblwiYnV0dG9uXCJpbiBlfHwhdC5fayhlLmtleUNvZGUsXCJsZWZ0XCIsMzcpP1wiYnV0dG9uXCJpbiBlJiYwIT09ZS5idXR0b24/bnVsbDp2b2lkIHQuZm9jdXNOZXh0KGUsITApOm51bGx9LGZ1bmN0aW9uKGUpe2lmKCEoXCJidXR0b25cImluIGUpJiZ0Ll9rKGUua2V5Q29kZSxcInVwXCIsMzgpKXJldHVybiBudWxsO3QuZm9jdXNOZXh0KGUsITApfSxmdW5jdGlvbihlKXtyZXR1cm5cImJ1dHRvblwiaW4gZXx8IXQuX2soZS5rZXlDb2RlLFwicmlnaHRcIiwzOSk/XCJidXR0b25cImluIGUmJjIhPT1lLmJ1dHRvbj9udWxsOnZvaWQgdC5mb2N1c05leHQoZSwhMSk6bnVsbH0sZnVuY3Rpb24oZSl7aWYoIShcImJ1dHRvblwiaW4gZSkmJnQuX2soZS5rZXlDb2RlLFwiZG93blwiLDQwKSlyZXR1cm4gbnVsbDt0LmZvY3VzTmV4dChlLCExKX0sZnVuY3Rpb24oZSl7cmV0dXJuKFwiYnV0dG9uXCJpbiBlfHwhdC5fayhlLmtleUNvZGUsXCJsZWZ0XCIsMzcpKSYmZS5zaGlmdEtleT9cImJ1dHRvblwiaW4gZSYmMCE9PWUuYnV0dG9uP251bGw6dm9pZCB0LmZvY3VzRmlyc3QoZSk6bnVsbH0sZnVuY3Rpb24oZSl7cmV0dXJuKFwiYnV0dG9uXCJpbiBlfHwhdC5fayhlLmtleUNvZGUsXCJ1cFwiLDM4KSkmJmUuc2hpZnRLZXk/dm9pZCB0LmZvY3VzRmlyc3QoZSk6bnVsbH0sZnVuY3Rpb24oZSl7cmV0dXJuKFwiYnV0dG9uXCJpbiBlfHwhdC5fayhlLmtleUNvZGUsXCJyaWdodFwiLDM5KSkmJmUuc2hpZnRLZXk/XCJidXR0b25cImluIGUmJjIhPT1lLmJ1dHRvbj9udWxsOnZvaWQgdC5mb2N1c0xhc3QoZSk6bnVsbH0sZnVuY3Rpb24oZSl7cmV0dXJuKFwiYnV0dG9uXCJpbiBlfHwhdC5fayhlLmtleUNvZGUsXCJkb3duXCIsNDApKSYmZS5zaGlmdEtleT92b2lkIHQuZm9jdXNMYXN0KGUpOm51bGx9XX19LFt0Ll90KFwiZGVmYXVsdFwiKV0sMil9LHN0YXRpY1JlbmRlckZuczpbXSxjb21wdXRlZDp7Y2xhc3NPYmplY3Q6ZnVuY3Rpb24oKXtyZXR1cm5bXCJidG4tdG9vbGJhclwiLHRoaXMuanVzdGlmeSYmIXRoaXMudmVydGljYWw/XCJqdXN0aWZ5LWNvbnRlbnQtYmV0d2VlblwiOlwiXCJdfX0scHJvcHM6e2p1c3RpZnk6e3R5cGU6Qm9vbGVhbixkZWZhdWx0OiExfSxLZXlOYXY6e3R5cGU6Qm9vbGVhbixkZWZhdWx0OiExfX0sbWV0aG9kczp7c2V0SXRlbUZvY3VzOmZ1bmN0aW9uKHQpe3RoaXMuJG5leHRUaWNrKGZ1bmN0aW9uKCl7dC5mb2N1cygpfSl9LGZvY3VzTmV4dDpmdW5jdGlvbih0LGUpe2lmKHRoaXMua2V5TmF2KXt0LnByZXZlbnREZWZhdWx0KCksdC5zdG9wUHJvcGFnYXRpb24oKTt2YXIgbj10aGlzLmdldEl0ZW1zKCk7aWYoIShuLmxlbmd0aDwxKSl7dmFyIGk9bi5pbmRleE9mKHQudGFyZ2V0KTtlJiZpPjA/aS0tOiFlJiZpPG4ubGVuZ3RoLTEmJmkrKyxpPDAmJihpPTApLHRoaXMuc2V0SXRlbUZvY3VzKG5baV0pfX19LGZvY3VzRmlyc3Q6ZnVuY3Rpb24odCl7aWYodGhpcy5rZXlOYXYpe3QucHJldmVudERlZmF1bHQoKSx0LnN0b3BQcm9wYWdhdGlvbigpO3ZhciBlPXRoaXMuZ2V0SXRlbXMoKTtlLmxlbmd0aD4wJiZ0aGlzLnNldEl0ZW1Gb2N1cyhlWzBdKX19LGZvY3VzTGFzdDpmdW5jdGlvbih0KXtpZih0aGlzLmtleU5hdil7dC5wcmV2ZW50RGVmYXVsdCgpLHQuc3RvcFByb3BhZ2F0aW9uKCk7dmFyIGU9dGhpcy5nZXRJdGVtcygpO2UubGVuZ3RoPjAmJnRoaXMuc2V0SXRlbUZvY3VzKFtlLmxlbmd0aC0xXSl9fSxnZXRJdGVtczpmdW5jdGlvbigpe3ZhciB0PUFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKHRoaXMuJGVsLnF1ZXJ5U2VsZWN0b3JBbGwoSVRFTV9TRUxFQ1RPUikpO3JldHVybiB0LmZvckVhY2goZnVuY3Rpb24odCl7dC50YWJJbmRleD0tMX0pLHR9fSxtb3VudGVkOmZ1bmN0aW9uKCl7dGhpcy5rZXlOYXYmJnRoaXMuZ2V0SXRlbXMoKX19LGJ1dHRvbkdyb3VwPXtyZW5kZXI6ZnVuY3Rpb24oKXt2YXIgdD10aGlzLGU9dC4kY3JlYXRlRWxlbWVudDtyZXR1cm4odC5fc2VsZi5fY3x8ZSkoXCJkaXZcIix7Y2xhc3M6dC5jbGFzc09iamVjdH0sW3QuX3QoXCJkZWZhdWx0XCIpXSwyKX0sc3RhdGljUmVuZGVyRm5zOltdLGNvbXB1dGVkOntjbGFzc09iamVjdDpmdW5jdGlvbigpe3JldHVybltcImJ0bi1ncm91cFwiLHRoaXMudmVydGljYWw/XCJidG4tZ3JvdXAtdmVydGljYWxcIjpcIlwiLHRoaXMuanVzdGlmeSYmIXRoaXMudmVydGljYWw/XCJqdXN0aWZ5LWNvbnRlbnQtYmV0d2VlblwiOlwiXCIsdGhpcy5zaXplP1wiYnRuLWdyb3VwLVwiK3RoaXMuc2l6ZTpcIlwiXX19LHByb3BzOnt2ZXJ0aWNhbDp7dHlwZTpCb29sZWFuLGRlZmF1bHQ6ITF9LGp1c3RpZnk6e3R5cGU6Qm9vbGVhbixkZWZhdWx0OiExfSxzaXplOnt0eXBlOlN0cmluZyxkZWZhdWx0Om51bGx9fX0sY2xpY2tPdXQ9e21vdW50ZWQ6ZnVuY3Rpb24oKXtcInVuZGVmaW5lZFwiIT10eXBlb2YgZG9jdW1lbnQmJmRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5hZGRFdmVudExpc3RlbmVyKFwiY2xpY2tcIix0aGlzLl9jbGlja091dExpc3RlbmVyKX0sZGVzdHJveWVkOmZ1bmN0aW9uKCl7XCJ1bmRlZmluZWRcIiE9dHlwZW9mIGRvY3VtZW50JiZkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKFwiY2xpY2tcIix0aGlzLl9jbGlja091dExpc3RlbmVyKX0sbWV0aG9kczp7X2NsaWNrT3V0TGlzdGVuZXI6ZnVuY3Rpb24odCl7dGhpcy4kZWwuY29udGFpbnModC50YXJnZXQpfHx0aGlzLmNsaWNrT3V0TGlzdGVuZXImJnRoaXMuY2xpY2tPdXRMaXN0ZW5lcigpfX19LElURU1fU0VMRUNUT1IkMT0nLmRyb3Bkb3duLWl0ZW06bm90KC5kaXNhYmxlZCk6bm90KFtkaXNhYmxlZF0pOm5vdChbc3R5bGUqPVwiZGlzcGxheTogbm9uZVwiXSk6bm90KFtzdHlsZSo9XCJkaXNwbGF5Om5vbmVcIl0pJyxIRUFERVJfU0VMRUNUT1I9Jy5kcm9wZG93bi1oZWFkZXI6bm90KFtzdHlsZSo9XCJkaXNwbGF5OiBub25lXCJdKTpub3QoW3N0eWxlKj1cImRpc3BsYXk6bm9uZVwiXSknLEFMTF9TRUxFQ1RPUj1bSVRFTV9TRUxFQ1RPUiQxLEhFQURFUl9TRUxFQ1RPUl0uam9pbihcIixcIiksZHJvcGRvd249e3Byb3BzOntzcGxpdDp7dHlwZTpCb29sZWFuLGRlZmF1bHQ6ITF9LHRleHQ6e3R5cGU6U3RyaW5nLGRlZmF1bHQ6XCJcIn0sZHJvcHVwOnt0eXBlOkJvb2xlYW4sZGVmYXVsdDohMX0sZGlzYWJsZWQ6e3R5cGU6Qm9vbGVhbixkZWZhdWx0OiExfSxyaWdodDp7dHlwZTpCb29sZWFuLGRlZmF1bHQ6ITF9fSxjcmVhdGVkOmZ1bmN0aW9uKCl7dmFyIHQ9dGhpcyxlPWZ1bmN0aW9uKGUpe2UhPT10JiYodC52aXNpYmxlPSExKX07dGhpcy4kcm9vdC4kb24oXCJzaG93bjo6ZHJvcGRvd25cIixlKSx0aGlzLiRyb290LiRvbihcImNsaWNrZWQ6OmxpbmtcIixlKX0sd2F0Y2g6e3Zpc2libGU6ZnVuY3Rpb24odCxlKXt2YXIgbj10aGlzO3QhPT1lJiYodD8odGhpcy4kcm9vdC4kZW1pdChcInNob3duOjpkcm9wZG93blwiLHRoaXMpLFwidW5kZWZpbmVkXCIhPXR5cGVvZiBkb2N1bWVudCYmXCJvbnRvdWNoc3RhcnRcImluIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudCYmQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoZG9jdW1lbnQuYm9keS5jaGlsZHJlbikuZm9yRWFjaChmdW5jdGlvbih0KXt0LmFkZEV2ZW50TGlzdGVuZXIoXCJtb3VzZW92ZXJcIixuLm5vb3ApfSkpOih0aGlzLiRyb290LiRlbWl0KFwiaGlkZGVuOjpkcm9wZG93blwiLHRoaXMpLFwidW5kZWZpbmVkXCIhPXR5cGVvZiBkb2N1bWVudCYmXCJvbnRvdWNoc3RhcnRcImluIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudCYmQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoZG9jdW1lbnQuYm9keS5jaGlsZHJlbikuZm9yRWFjaChmdW5jdGlvbih0KXt0LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJtb3VzZW92ZXJcIixuLm5vb3ApfSkpKX19LG1ldGhvZHM6e25vb3A6ZnVuY3Rpb24oKXt9LHRvZ2dsZTpmdW5jdGlvbigpe3RoaXMuZGlzYWJsZWQ/dGhpcy52aXNpYmxlPSExOih0aGlzLnZpc2libGU9IXRoaXMudmlzaWJsZSx0aGlzLnZpc2libGUmJnRoaXMuJG5leHRUaWNrKGZ1bmN0aW9uKCl7dmFyIHQ9dGhpcy5nZXRGaXJzdEl0ZW0oKTt0JiZ0aGlzLmZvY3VzSXRlbSgwLFt0XSl9KSl9LG9uVGFiOmZ1bmN0aW9uKCl7dGhpcy52aXNpYmxlJiYodGhpcy52aXNpYmxlPSExKX0sb25Fc2M6ZnVuY3Rpb24odCl7dGhpcy52aXNpYmxlJiYodGhpcy52aXNpYmxlPSExLHQucHJldmVudERlZmF1bHQoKSx0LnN0b3BQcm9wYWdhdGlvbigpLHRoaXMuJG5leHRUaWNrKGZ1bmN0aW9uKCl7dmFyIHQ7KHQ9dGhpcy5zcGxpdCYmdGhpcy4kcmVmcy50b2dnbGU/dGhpcy4kcmVmcy50b2dnbGUuJGVsfHx0aGlzLiRyZWZzLnRvZ2dsZTp0aGlzLiRyZWZzLmJ1dHRvbi4kZWx8fHRoaXMuJHJlZnMuYnV0dG9uKSYmdC5mb2N1cyYmdC5mb2N1cygpfSkpfSxmb2N1c05leHQ6ZnVuY3Rpb24odCxlKXtpZih0aGlzLnZpc2libGUpe3QucHJldmVudERlZmF1bHQoKSx0LnN0b3BQcm9wYWdhdGlvbigpO3ZhciBuPXRoaXMuZ2V0SXRlbXMoKTtpZighKG4ubGVuZ3RoPDEpKXt2YXIgaT1uLmluZGV4T2YodC50YXJnZXQpO2UmJmk+MD9pLS06IWUmJmk8bi5sZW5ndGgtMSYmaSsrLGk8MCYmKGk9MCksdGhpcy5mb2N1c0l0ZW0oaSxuKX19fSxmb2N1c0hvdmVyZWQ6ZnVuY3Rpb24odCl7aWYodGhpcy52aXNpYmxlKXt2YXIgZT10aGlzLmdldEl0ZW1zKCk7aWYoIShlLmxlbmd0aDwxKSl7dmFyIG49ZS5pbmRleE9mKHQudGFyZ2V0KTtuPi0xJiYodC5wcmV2ZW50RGVmYXVsdCgpLHQuc3RvcFByb3BhZ2F0aW9uKCksdGhpcy5mb2N1c0l0ZW0obixlKSl9fX0sZm9jdXNJdGVtOmZ1bmN0aW9uKHQsZSl7ZS5mb3JFYWNoKGZ1bmN0aW9uKGUsbil7bj09PXQ/KGUuY2xhc3NMaXN0LmFkZChcImFjdGl2ZVwiKSxlLmZvY3VzKCkpOmUuY2xhc3NMaXN0LnJlbW92ZShcImFjdGl2ZVwiKX0pfSxnZXRJdGVtczpmdW5jdGlvbigpe3JldHVybiBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbCh0aGlzLiRyZWZzLm1lbnUucXVlcnlTZWxlY3RvckFsbChBTExfU0VMRUNUT1IpKX0sZ2V0Rmlyc3RJdGVtOmZ1bmN0aW9uKCl7dmFyIHQ9dGhpcy4kcmVmcy5tZW51LnF1ZXJ5U2VsZWN0b3IoSVRFTV9TRUxFQ1RPUiQxKTtyZXR1cm4gdHx8KHQ9dGhpcy4kcmVmcy5tZW51LnF1ZXJ5U2VsZWN0b3IoSEVBREVSX1NFTEVDVE9SKSksdHx8bnVsbH19fSxidXR0b25Hcm91cERyb3Bkb3duPXtyZW5kZXI6ZnVuY3Rpb24oKXt2YXIgdD10aGlzLGU9dC4kY3JlYXRlRWxlbWVudCxuPXQuX3NlbGYuX2N8fGU7cmV0dXJuIG4oXCJkaXZcIix7Y2xhc3M6W1wiYnRuLWdyb3VwXCIsXCJkcm9wZG93blwiLHtkcm9wdXA6dC5kcm9wdXAsc2hvdzp0LnZpc2libGV9XSxhdHRyczp7aWQ6dC5pZHx8bnVsbH19LFtuKFwiYi1idXR0b25cIix7cmVmOlwiYnV0dG9uXCIsY2xhc3M6e1wiZHJvcGRvd24tdG9nZ2xlXCI6IXQuc3BsaXQsXCJidG4tbGlua1wiOnQubGlua30sYXR0cnM6e2lkOnQuaWQ/dC5pZCtcIl9fQlZfYnV0dG9uX1wiOm51bGwsXCJhcmlhLWV4cGFuZGVkXCI6dC52aXNpYmxlP1widHJ1ZVwiOlwiZmFsc2VcIix2YXJpYW50OnQudmFyaWFudCxzaXplOnQuc2l6ZSxkaXNhYmxlZDp0LmRpc2FibGVkfSxvbjp7Y2xpY2s6ZnVuY3Rpb24oZSl7ZS5zdG9wUHJvcGFnYXRpb24oKSxlLnByZXZlbnREZWZhdWx0KCksdC5jbGljayhlKX0sa2Vkb3duOltmdW5jdGlvbihlKXtpZighKFwiYnV0dG9uXCJpbiBlKSYmdC5fayhlLmtleUNvZGUsXCJzcGFjZVwiLDMyKSlyZXR1cm4gbnVsbDtlLnN0b3BQcm9wYWdhdGlvbigpLGUucHJldmVudERlZmF1bHQoKSx0LmNsaWNrKGUpfSxmdW5jdGlvbihlKXtpZighKFwiYnV0dG9uXCJpbiBlKSYmdC5fayhlLmtleUNvZGUsXCJlbnRlclwiLDEzKSlyZXR1cm4gbnVsbDtlLnN0b3BQcm9wYWdhdGlvbigpLGUucHJldmVudERlZmF1bHQoKSx0LmNsaWNrKGUpfV19fSxbdC5fdChcInRleHRcIixbdC5fdih0Ll9zKHQudGV4dCkpXSldLDIpLG4oXCJkaXZcIix7cmVmOlwibWVudVwiLGNsYXNzOltcImRyb3Bkb3duLW1lbnVcIix7XCJkcm9wZG93bi1tZW51LXJpZ2h0XCI6dC5yaWdodH1dLGF0dHJzOntyb2xlOlwibWVudVwiLFwiYXJpYS1sYWJlbGxlZGJ5XCI6dC5pZD90LmlkK1wiX19CVl9idXR0b25fXCI6bnVsbH0sb246e2tleXVwOmZ1bmN0aW9uKGUpe2lmKCEoXCJidXR0b25cImluIGUpJiZ0Ll9rKGUua2V5Q29kZSxcImVzY1wiLDI3KSlyZXR1cm4gbnVsbDt0Lm9uRXNjKGUpfSxrZXlkb3duOltmdW5jdGlvbihlKXtpZighKFwiYnV0dG9uXCJpbiBlKSYmdC5fayhlLmtleUNvZGUsXCJ0YWJcIiw5KSlyZXR1cm4gbnVsbDt0Lm9uVGFiKGUpfSxmdW5jdGlvbihlKXtpZighKFwiYnV0dG9uXCJpbiBlKSYmdC5fayhlLmtleUNvZGUsXCJ1cFwiLDM4KSlyZXR1cm4gbnVsbDt0LmZvY3VzTmV4dChlLCEwKX0sZnVuY3Rpb24oZSl7aWYoIShcImJ1dHRvblwiaW4gZSkmJnQuX2soZS5rZXlDb2RlLFwiZG93blwiLDQwKSlyZXR1cm4gbnVsbDt0LmZvY3VzTmV4dChlLCExKX1dLG1vdXNlb3ZlcjpmdW5jdGlvbihlKXt0LmZvY3VzSG92ZXJlZChlKX19fSxbdC5fdChcImRlZmF1bHRcIildLDIpXSwxKX0sc3RhdGljUmVuZGVyRm5zOltdLG1peGluczpbY2xpY2tPdXQsZHJvcGRvd25dLGRhdGE6ZnVuY3Rpb24oKXtyZXR1cm57dmlzaWJsZTohMX19LGNvbXB1dGVkOntkcm9wZG93blRvZ2dsZTpmdW5jdGlvbigpe3JldHVybiB0aGlzLmNhcmV0P1wiZHJvcGRvd24tdG9nZ2xlXCI6XCJcIn19LHByb3BzOntpZDp7dHlwZTpTdHJpbmd9LGNhcmV0Ont0eXBlOkJvb2xlYW4sZGVmYXVsdDohMH19LG1ldGhvZHM6e2NsaWNrT3V0TGlzdGVuZXI6ZnVuY3Rpb24oKXt0aGlzLnZpc2libGU9ITF9fX0saW5wdXRHcm91cD17cmVuZGVyOmZ1bmN0aW9uKCl7dmFyIHQ9dGhpcyxlPXQuJGNyZWF0ZUVsZW1lbnQsbj10Ll9zZWxmLl9jfHxlO3JldHVybiBuKFwiZGl2XCIse2NsYXNzOnQuY2xhc3NPYmplY3QsYXR0cnM6e3JvbGU6XCJncm91cFwifX0sW3QuX3QoXCJsZWZ0XCIsW3QubGVmdD9uKFwiZGl2XCIse3N0YXRpY0NsYXNzOlwiaW5wdXQtZ3JvdXAtYWRkb25cIixkb21Qcm9wczp7aW5uZXJIVE1MOnQuX3ModC5sZWZ0KX19KTp0Ll9lKCldKSx0Ll90KFwiZGVmYXVsdFwiKSx0Ll90KFwicmlnaHRcIixbdC5yaWdodD9uKFwiZGl2XCIse3N0YXRpY0NsYXNzOlwiaW5wdXQtZ3JvdXAtYWRkb25cIixkb21Qcm9wczp7aW5uZXJIVE1MOnQuX3ModC5yaWdodCl9fSk6dC5fZSgpXSldLDIpfSxzdGF0aWNSZW5kZXJGbnM6W10sY29tcHV0ZWQ6e2NsYXNzT2JqZWN0OmZ1bmN0aW9uKCl7cmV0dXJuW1wiaW5wdXQtZ3JvdXBcIix0aGlzLnNpemU/XCJpbnB1dC1ncm91cC1cIit0aGlzLnNpemU6XCJcIix0aGlzLnN0YXRlP1wiaGFzLVwiK3RoaXMuc3RhdGU6XCJcIl19fSxwcm9wczp7c2l6ZTp7dHlwZTpTdHJpbmcsZGVmYXVsdDpudWxsfSxzdGF0ZTp7dHlwZTpTdHJpbmcsZGVmYXVsdDpudWxsfSxsZWZ0Ont0eXBlOlN0cmluZyxkZWZhdWx0Om51bGx9LHJpZ2h0Ont0eXBlOlN0cmluZyxkZWZhdWx0Om51bGx9fX0saW5wdXRHcm91cEFkZG9uPXtyZW5kZXI6ZnVuY3Rpb24oKXt2YXIgdD10aGlzLGU9dC4kY3JlYXRlRWxlbWVudDtyZXR1cm4odC5fc2VsZi5fY3x8ZSkoXCJkaXZcIix7c3RhdGljQ2xhc3M6XCJpbnB1dC1ncm91cC1hZGRvblwiLGF0dHJzOntpZDp0LmlkfHxudWxsfX0sW3QuX3QoXCJkZWZhdWx0XCIpXSwyKX0sc3RhdGljUmVuZGVyRm5zOltdLHByb3BzOntpZDp7dHlwZTpTdHJpbmcsZGVmYXVsdDpudWxsfX19LGlucHV0R3JvdXBCdXR0b249e3JlbmRlcjpmdW5jdGlvbigpe3ZhciB0PXRoaXMsZT10LiRjcmVhdGVFbGVtZW50O3JldHVybih0Ll9zZWxmLl9jfHxlKShcImRpdlwiLHtzdGF0aWNDbGFzczpcImlucHV0LWdyb3VwLWJ0blwifSxbdC5fdChcImRlZmF1bHRcIildLDIpfSxzdGF0aWNSZW5kZXJGbnM6W10scHJvcHM6e319LGNhcmQ9e3JlbmRlcjpmdW5jdGlvbigpe3ZhciB0PXRoaXMsZT10LiRjcmVhdGVFbGVtZW50LG49dC5fc2VsZi5fY3x8ZTtyZXR1cm4gbih0LnRhZyx7dGFnOlwiY29tcG9uZW50XCIsY2xhc3M6W1wiY2FyZFwiLHQuY2FyZFZhcmlhbnQsdC5jYXJkQWxpZ24sdC5jYXJkSW52ZXJzZV19LFt0Ll90KFwiaW1nXCIsW3QuaW1nP24oXCJpbWdcIix7c3RhdGljQ2xhc3M6XCJjYXJkLWltZ1wiLGF0dHJzOntzcmM6dC5pbWcsYWx0OnQuaW1nQWx0fX0pOnQuX2UoKV0pLHQuaGVhZGVyfHx0LiRzbG90cy5oZWFkZXI/bih0LmhlYWRlclRhZyx7dGFnOlwiY29tcG9uZW50XCIsY2xhc3M6W1wiY2FyZC1oZWFkZXJcIix0LmhlYWRlclZhcmlhbnQ/XCJiZy1cIit0LmhlYWRlclZhcmlhbnQ6XCJcIix0LmhlYWRlckNsYXNzXX0sW3QuX3QoXCJoZWFkZXJcIixbbihcImRpdlwiLHtkb21Qcm9wczp7aW5uZXJIVE1MOnQuX3ModC5oZWFkZXIpfX0pXSldLDIpOnQuX2UoKSx0Lm5vQmxvY2s/W3QuX3QoXCJkZWZhdWx0XCIpXTpuKFwiZGl2XCIse2NsYXNzOnQuYmxvY2tDbGFzc30sW3QudGl0bGU/bihcImg0XCIse3N0YXRpY0NsYXNzOlwiY2FyZC10aXRsZVwiLGRvbVByb3BzOntpbm5lckhUTUw6dC5fcyh0LnRpdGxlKX19KTp0Ll9lKCksdC5zdWJUaXRsZT9uKFwiaDZcIix7c3RhdGljQ2xhc3M6XCJjYXJkLXN1YnRpdGxlIG1iLTIgdGV4dC1tdXRlZFwiLGRvbVByb3BzOntpbm5lckhUTUw6dC5fcyh0LnN1YlRpdGxlKX19KTp0Ll9lKCksdC5fdChcImRlZmF1bHRcIildLDIpLHQuZm9vdGVyfHx0LiRzbG90cy5mb290ZXI/bih0LmZvb3RlclRhZyx7dGFnOlwiY29tcG9uZW50XCIsY2xhc3M6W1wiY2FyZC1mb290ZXJcIix0LmZvb3RlclZhcmlhbnQ/XCJiZy1cIit0LmZvb3RlclZhcmlhbnQ6XCJcIix0LmZvb3RlckNsYXNzXX0sW3QuX3QoXCJmb290ZXJcIixbbihcImRpdlwiLHtkb21Qcm9wczp7aW5uZXJIVE1MOnQuX3ModC5mb290ZXIpfX0pXSldLDIpOnQuX2UoKV0sMil9LHN0YXRpY1JlbmRlckZuczpbXSxjb21wdXRlZDp7YmxvY2tDbGFzczpmdW5jdGlvbigpe3JldHVybltcImNhcmQtYmxvY2tcIix0aGlzLm92ZXJsYXk/XCJjYXJkLWltZy1vdmVybGF5XCI6bnVsbF19LGNhcmRWYXJpYW50OmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMudmFyaWFudD9cImNhcmQtXCIrdGhpcy52YXJpYW50Om51bGx9LGNhcmRJbnZlcnNlOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMub3ZlcmxheXx8dGhpcy5pbnZlcnNlP1wiY2FyZC1pbnZlcnNlXCI6bnVsbD09PXRoaXMuaW52ZXJzZSYmdGhpcy52YXJpYW50JiZ0aGlzLnZhcmlhbnQubGVuZ3RoPjAmJi0xPT09dGhpcy52YXJpYW50LmluZGV4T2YoXCJvdXRsaW5lXCIpP1wiY2FyZC1pbnZlcnNlXCI6dm9pZCAwfSxjYXJkQWxpZ246ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5hbGlnbj9cInRleHQtXCIrdGhpcy5hbGlnbjpudWxsfX0scHJvcHM6e2FsaWduOnt0eXBlOlN0cmluZyxkZWZhdWx0Om51bGx9LGludmVyc2U6e3R5cGU6Qm9vbGVhbixkZWZhdWx0Om51bGx9LHZhcmlhbnQ6e3R5cGU6U3RyaW5nLGRlZmF1bHQ6bnVsbH0sdGFnOnt0eXBlOlN0cmluZyxkZWZhdWx0OlwiZGl2XCJ9LGhlYWRlcjp7dHlwZTpTdHJpbmcsZGVmYXVsdDpudWxsfSxoZWFkZXJWYXJpYW50Ont0eXBlOlN0cmluZyxkZWZhdWx0Om51bGx9LGhlYWRlckNsYXNzOnt0eXBlOltTdHJpbmcsQXJyYXldLGRlZmF1bHQ6XCJcIn0saGVhZGVyVGFnOnt0eXBlOlN0cmluZyxkZWZhdWx0OlwiZGl2XCJ9LGZvb3Rlcjp7dHlwZTpTdHJpbmcsZGVmYXVsdDpudWxsfSxmb290ZXJWYXJpYW50Ont0eXBlOlN0cmluZyxkZWZhdWx0Om51bGx9LGZvb3RlckNsYXNzOnt0eXBlOltTdHJpbmcsQXJyYXldLGRlZmF1bHQ6XCJcIn0sZm9vdGVyVGFnOnt0eXBlOlN0cmluZyxkZWZhdWx0OlwiZGl2XCJ9LHRpdGxlOnt0eXBlOlN0cmluZyxkZWZhdWx0Om51bGx9LHN1YlRpdGxlOnt0eXBlOlN0cmluZyxkZWZhdWx0Om51bGx9LG5vQmxvY2s6e3R5cGU6Qm9vbGVhbixkZWZhdWx0OiExfSxpbWc6e3R5cGU6U3RyaW5nLGRlZmF1bHQ6bnVsbH0saW1nQWx0Ont0eXBlOlN0cmluZyxkZWZhdWx0Om51bGx9LG92ZXJsYXk6e3R5cGU6Qm9vbGVhbixkZWZhdWx0OiExfX19LGNhcmRHcm91cD17cmVuZGVyOmZ1bmN0aW9uKCl7dmFyIHQ9dGhpcyxlPXQuJGNyZWF0ZUVsZW1lbnQ7cmV0dXJuKHQuX3NlbGYuX2N8fGUpKHQudGFnLHt0YWc6XCJjb21wb25lbnRcIixjbGFzczpbXCJjYXJkLVwiK3QudHlwZV19LFt0Ll90KFwiZGVmYXVsdFwiKV0sMil9LHN0YXRpY1JlbmRlckZuczpbXSxjb21wdXRlZDp7dHlwZTpmdW5jdGlvbigpe3JldHVybiB0aGlzLmRlY2s/XCJkZWNrXCI6dGhpcy5jb2x1bW5zP1wiY29sdW1uc1wiOlwiZ3JvdXBcIn19LHByb3BzOnt0YWc6e3R5cGU6U3RyaW5nLGRlZmF1bHQ6XCJkaXZcIn0sZGVjazp7dHlwZTpCb29sZWFuLGRlZmF1bHQ6ITF9LGNvbHVtbnM6e3R5cGU6Qm9vbGVhbixkZWZhdWx0OiExfX19LERJUkVDVElPTj17bmV4dDp7Y3VycmVudDpcImNhcm91c2VsLWl0ZW0tbGVmdFwiLG5leHQ6XCJjYXJvdXNlbC1pdGVtLXJpZ2h0XCIsb3ZlcmxheTpcImNhcm91c2VsLWl0ZW0tbmV4dFwifSxwcmV2OntjdXJyZW50OlwiY2Fyb3VzZWwtaXRlbS1yaWdodFwiLG5leHQ6XCJjYXJvdXNlbC1pdGVtLWxlZnRcIixvdmVybGF5OlwiY2Fyb3VzZWwtaXRlbS1wcmV2XCJ9fSxjYXJvdXNlbD17cmVuZGVyOmZ1bmN0aW9uKCl7dmFyIHQ9dGhpcyxlPXQuJGNyZWF0ZUVsZW1lbnQsbj10Ll9zZWxmLl9jfHxlO3JldHVybiBuKFwiZGl2XCIse3N0YXRpY0NsYXNzOlwiY2Fyb3VzZWwgc2xpZGVcIixzdHlsZTp7YmFja2dyb3VuZDp0LmJhY2tncm91bmQsaGVpZ2h0OnQuaGVpZ2h0fSxhdHRyczp7cm9sZTpcInJlZ2lvblwiLGlkOnQuaWR8fG51bGwsXCJhcmlhLWJ1c3lcIjp0LmlzU2xpZGluZz9cInRydWVcIjpcImZhbHNlXCJ9LG9uOnttb3VzZWVudGVyOnQucGF1c2UsbW91c2VsZWF2ZTp0LnN0YXJ0LGZvY3VzaW46dC5wYXVzZSxmb2N1c291dDpmdW5jdGlvbihlKXt0LnJlc3RhcnQoZSl9LGtleWRvd246W2Z1bmN0aW9uKGUpe3JldHVyblwiYnV0dG9uXCJpbiBlfHwhdC5fayhlLmtleUNvZGUsXCJsZWZ0XCIsMzcpP1wiYnV0dG9uXCJpbiBlJiYwIT09ZS5idXR0b24/bnVsbDooZS5zdG9wUHJvcGFnYXRpb24oKSxlLnByZXZlbnREZWZhdWx0KCksdm9pZCB0LnByZXYoZSkpOm51bGx9LGZ1bmN0aW9uKGUpe3JldHVyblwiYnV0dG9uXCJpbiBlfHwhdC5fayhlLmtleUNvZGUsXCJyaWdodFwiLDM5KT9cImJ1dHRvblwiaW4gZSYmMiE9PWUuYnV0dG9uP251bGw6KGUuc3RvcFByb3BhZ2F0aW9uKCksZS5wcmV2ZW50RGVmYXVsdCgpLHZvaWQgdC5uZXh0KGUpKTpudWxsfV19fSxbbihcImRpdlwiLHtzdGF0aWNDbGFzczpcImNhcm91c2VsLWlubmVyXCIsYXR0cnM6e3JvbGU6XCJsaXN0XCIsaWQ6dC5pZD90LmlkK1wiX19CVl9pbm5lcl9cIjpudWxsfX0sW3QuX3QoXCJkZWZhdWx0XCIpXSwyKSx0LmNvbnRyb2xzP1tuKFwiYVwiLHtzdGF0aWNDbGFzczpcImNhcm91c2VsLWNvbnRyb2wtcHJldlwiLGF0dHJzOntocmVmOlwiI1wiLHJvbGU6XCJidXR0b25cIixcImFyaWEtY29udHJvbHNcIjp0LmlkP3QuaWQrXCJfX0JWX2lubmVyX1wiOm51bGx9LG9uOntjbGljazpmdW5jdGlvbihlKXtlLnN0b3BQcm9wYWdhdGlvbigpLGUucHJldmVudERlZmF1bHQoKSx0LnByZXYoZSl9LGtleWRvd246W2Z1bmN0aW9uKGUpe2lmKCEoXCJidXR0b25cImluIGUpJiZ0Ll9rKGUua2V5Q29kZSxcImVudGVyXCIsMTMpKXJldHVybiBudWxsO2Uuc3RvcFByb3BhZ2F0aW9uKCksZS5wcmV2ZW50RGVmYXVsdCgpLHQucHJldihlKX0sZnVuY3Rpb24oZSl7aWYoIShcImJ1dHRvblwiaW4gZSkmJnQuX2soZS5rZXlDb2RlLFwic3BhY2VcIiwzMikpcmV0dXJuIG51bGw7ZS5zdG9wUHJvcGFnYXRpb24oKSxlLnByZXZlbnREZWZhdWx0KCksdC5wcmV2KGUpfV19fSxbbihcInNwYW5cIix7c3RhdGljQ2xhc3M6XCJjYXJvdXNlbC1jb250cm9sLXByZXYtaWNvblwiLGF0dHJzOntcImFyaWEtaGlkZGVuXCI6XCJ0cnVlXCJ9fSksdC5fdihcIiBcIiksbihcInNwYW5cIix7c3RhdGljQ2xhc3M6XCJzci1vbmx5XCJ9LFt0Ll92KHQuX3ModC5sYWJlbFByZXYpKV0pXSksbihcImFcIix7c3RhdGljQ2xhc3M6XCJjYXJvdXNlbC1jb250cm9sLW5leHRcIixhdHRyczp7aHJlZjpcIiNcIixyb2xlOlwiYnV0dG9uXCIsXCJhcmlhLWNvbnRyb2xzXCI6dC5pZD90LmlkK1wiX19CVl9pbm5lcl9cIjpudWxsfSxvbjp7Y2xpY2s6ZnVuY3Rpb24oZSl7ZS5zdG9wUHJvcGFnYXRpb24oKSxlLnByZXZlbnREZWZhdWx0KCksdC5uZXh0KGUpfSxrZXlkb3duOltmdW5jdGlvbihlKXtpZighKFwiYnV0dG9uXCJpbiBlKSYmdC5fayhlLmtleUNvZGUsXCJlbnRlclwiLDEzKSlyZXR1cm4gbnVsbDtlLnN0b3BQcm9wYWdhdGlvbigpLGUucHJldmVudERlZmF1bHQoKSx0Lm5leHQoZSl9LGZ1bmN0aW9uKGUpe2lmKCEoXCJidXR0b25cImluIGUpJiZ0Ll9rKGUua2V5Q29kZSxcInNwYWNlXCIsMzIpKXJldHVybiBudWxsO2Uuc3RvcFByb3BhZ2F0aW9uKCksZS5wcmV2ZW50RGVmYXVsdCgpLHQubmV4dChlKX1dfX0sW24oXCJzcGFuXCIse3N0YXRpY0NsYXNzOlwiY2Fyb3VzZWwtY29udHJvbC1uZXh0LWljb25cIixhdHRyczp7XCJhcmlhLWhpZGRlblwiOlwidHJ1ZVwifX0pLHQuX3YoXCIgXCIpLG4oXCJzcGFuXCIse3N0YXRpY0NsYXNzOlwic3Itb25seVwifSxbdC5fdih0Ll9zKHQubGFiZWxOZXh0KSldKV0pXTp0Ll9lKCksbihcIm9sXCIse2RpcmVjdGl2ZXM6W3tuYW1lOlwic2hvd1wiLHJhd05hbWU6XCJ2LXNob3dcIix2YWx1ZTp0LmluZGljYXRvcnMsZXhwcmVzc2lvbjpcImluZGljYXRvcnNcIn1dLHN0YXRpY0NsYXNzOlwiY2Fyb3VzZWwtaW5kaWNhdG9yc1wiLGF0dHJzOntyb2xlOlwiZ3JvdXBcIixpZDp0LmlkP3QuaWQrXCJfX0JWX2luZGljYXRvcnNfXCI6bnVsbCxcImFyaWEtaGlkZGVuXCI6dC5pbmRpY2F0b3JzP1wiZmFsc2VcIjpcInRydWVcIixcImFyaWEtbGFiZWxcIjp0LmluZGljYXRvcnMmJnQubGFiZWxJbmRpY2F0b3JzP3QubGFiZWxJbmRpY2F0b3JzOm51bGwsXCJhcmlhLW93bnNcIjp0LmluZGljYXRvcnMmJnQuaWQ/dC5pZCtcIl9fQlZfaW5uZXJfXCI6bnVsbH19LHQuX2wodC5zbGlkZXMubGVuZ3RoLGZ1bmN0aW9uKGUpe3JldHVybiBuKFwibGlcIix7Y2xhc3M6e2FjdGl2ZTplLTE9PT10LmluZGV4fSxhdHRyczp7cm9sZTpcImJ1dHRvblwiLGlkOnQuaWQ/dC5pZCtcIl9fQlZfaW5kaWNhdG9yX1wiK2UrXCJfXCI6bnVsbCx0YWJpbmRleDp0LmluZGljYXRvcnM/XCIwXCI6XCItMVwiLFwiYXJpYS1jdXJyZW50XCI6ZS0xPT09dC5pbmRleD9cInRydWVcIjpcImZhbHNlXCIsXCJhcmlhLXBvc2luc2V0XCI6ZSxcImFyaWEtc2V0c2l6ZVwiOnQuc2xpZGVzLmxlbmd0aCxcImFyaWEtbGFiZWxcIjp0LmxhYmVsR290b1NsaWRlK1wiIFwiK2UsXCJhcmlhLWRlc2NyaWJlZGJ5XCI6dC5zbGlkZXNbZS0xXS5pZHx8bnVsbCxcImFyaWEtY29udHJvbHNcIjp0LmlkP3QuaWQrXCJfX0JWX2lubmVyX1wiOm51bGx9LG9uOntjbGljazpmdW5jdGlvbihuKXt0LmluZGV4PWUtMX0sa2V5ZG93bjpbZnVuY3Rpb24obil7aWYoIShcImJ1dHRvblwiaW4gbikmJnQuX2sobi5rZXlDb2RlLFwiZW50ZXJcIiwxMykpcmV0dXJuIG51bGw7bi5zdG9wUHJvcGFnYXRpb24oKSxuLnByZXZlbnREZWZhdWx0KCksdC5pbmRleD1lLTF9LGZ1bmN0aW9uKG4pe2lmKCEoXCJidXR0b25cImluIG4pJiZ0Ll9rKG4ua2V5Q29kZSxcInNwYWNlXCIsMzIpKXJldHVybiBudWxsO24uc3RvcFByb3BhZ2F0aW9uKCksbi5wcmV2ZW50RGVmYXVsdCgpLHQuaW5kZXg9ZS0xfV19fSl9KSldLDIpfSxzdGF0aWNSZW5kZXJGbnM6W10sZGF0YTpmdW5jdGlvbigpe3JldHVybntpbmRleDowLGlzU2xpZGluZzohMSxzbGlkZXM6W119fSxwcm9wczp7aWQ6e3R5cGU6U3RyaW5nfSxsYWJlbFByZXY6e3R5cGU6U3RyaW5nLGRlZmF1bHQ6XCJQcmV2aW91cyBTbGlkZVwifSxsYWJlbE5leHQ6e3R5cGU6U3RyaW5nLGRlZmF1bHQ6XCJOZXh0IFNsaWRlXCJ9LGxhYmVsR290b1NsaWRlOnt0eXBlOlN0cmluZyxkZWZhdWx0OlwiR290byBTbGlkZVwifSxsYWJlbEluZGljYXRvcnM6e3R5cGU6U3RyaW5nLGRlZmF1bHQ6XCJTZWxlY3QgYSBzbGlkZSB0byBkaXNwbGF5XCJ9LGludGVydmFsOnt0eXBlOk51bWJlcixkZWZhdWx0OjVlM30saW5kaWNhdG9yczp7dHlwZTpCb29sZWFuLGRlZmF1bHQ6ITF9LGNvbnRyb2xzOnt0eXBlOkJvb2xlYW4sZGVmYXVsdDohMX0saGVpZ2h0Ont0eXBlOlN0cmluZ30sYmFja2dyb3VuZDp7dHlwZTpTdHJpbmd9fSxtZXRob2RzOntwcmV2OmZ1bmN0aW9uKCl7dGhpcy5pbmRleDw9MD90aGlzLmluZGV4PXRoaXMuc2xpZGVzLmxlbmd0aC0xOnRoaXMuaW5kZXgtLX0sbmV4dDpmdW5jdGlvbigpe1widW5kZWZpbmVkXCIhPXR5cGVvZiBkb2N1bWVudCYmZG9jdW1lbnQudmlzaWJpbGl0eVN0YXRlJiZkb2N1bWVudC5oaWRkZW58fCh0aGlzLmluZGV4Pj10aGlzLnNsaWRlcy5sZW5ndGgtMT90aGlzLmluZGV4PTA6dGhpcy5pbmRleCsrKX0scGF1c2U6ZnVuY3Rpb24oKXswIT09dGhpcy5pbnRlcnZhbCYmdm9pZCAwIT09dGhpcy5pbnRlcnZhbCYmKGNsZWFySW50ZXJ2YWwodGhpcy5faW50ZXJ2YWxJZCksdGhpcy5faW50ZXJ2YWxJZD1udWxsLHRoaXMuc2xpZGVzW3RoaXMuaW5kZXhdLnRhYkluZGV4PTApfSxzdGFydDpmdW5jdGlvbigpe3ZhciB0PXRoaXM7MCE9PXRoaXMuaW50ZXJ2YWwmJnZvaWQgMCE9PXRoaXMuaW50ZXJ2YWwmJih0aGlzLnNsaWRlcy5mb3JFYWNoKGZ1bmN0aW9uKHQpe3QudGFiSW5kZXg9LTF9KSx0aGlzLl9pbnRlcnZhbElkPXNldEludGVydmFsKGZ1bmN0aW9uKCl7dC5uZXh0KCl9LHRoaXMuaW50ZXJ2YWwpKX0scmVzdGFydDpmdW5jdGlvbih0KXt0LnJlbGF0ZWRUYXJnZXQmJnRoaXMuJGVsLmNvbnRhaW5zKHQucmVsYXRlZFRhcmdldCl8fHRoaXMuc3RhcnQoKX19LG1vdW50ZWQ6ZnVuY3Rpb24oKXt0aGlzLnNsaWRlcz1BcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbCh0aGlzLiRlbC5xdWVyeVNlbGVjdG9yQWxsKFwiLmNhcm91c2VsLWl0ZW1cIikpLHRoaXMuc2xpZGVzWzBdLmNsYXNzTGlzdC5hZGQoXCJhY3RpdmVcIik7dmFyIHQ9dGhpczt0aGlzLnNsaWRlcy5mb3JFYWNoKGZ1bmN0aW9uKGUsbil7dmFyIGk9bisxO2Uuc2V0QXR0cmlidXRlKFwiYXJpYS1jdXJyZW50XCIsMD09PW4/XCJ0cnVlXCI6XCJmYWxzZVwiKSxlLnNldEF0dHJpYnV0ZShcImFyaWEtcG9zaW5zZXRcIixTdHJpbmcoaSkpLGUuc2V0QXR0cmlidXRlKFwiYXJpYS1zZXRzaXplXCIsU3RyaW5nKHQuc2xpZGVzLmxlbmd0aCkpLGUudGFiSW5kZXg9LTEsdC5pZCYmZS5zZXRBdHRyaWJ1dGUoXCJhcmlhLWNvbnRyb2xsZWRieVwiLHQuaWQrXCJfX0JWX2luZGljYXRvcl9cIitpK1wiX1wiKX0pLHRoaXMuX2ludGVydmFsSWQ9bnVsbCx0aGlzLnN0YXJ0KCl9LHdhdGNoOntpbmRleDpmdW5jdGlvbih0LGUpe3ZhciBuPXRoaXM7aWYodCE9PWUpaWYodGhpcy5pc1NsaWRpbmcpdGhpcy5pbmRleD1lO2Vsc2V7dmFyIGk9dD5lP0RJUkVDVElPTi5uZXh0OkRJUkVDVElPTi5wcmV2OzA9PT1lJiZ0PT09dGhpcy5zbGlkZXMubGVuZ3RoLTE/aT1ESVJFQ1RJT04ucHJldjplPT09dGhpcy5zbGlkZXMubGVuZ3RoLTEmJjA9PT10JiYoaT1ESVJFQ1RJT04ubmV4dCk7dmFyIG89dGhpcy5zbGlkZXNbZV0scj10aGlzLnNsaWRlc1t0XTtvJiZyJiYodGhpcy5pc1NsaWRpbmc9ITAsci5jbGFzc0xpc3QuYWRkKGkubmV4dCxpLm92ZXJsYXkpLG8uY2xhc3NMaXN0LmFkZChpLmN1cnJlbnQpLHRoaXMuX2Nhcm91c2VsQW5pbWF0aW9uPXNldFRpbWVvdXQoZnVuY3Rpb24oKXtuLiRlbWl0KFwic2xpZGVcIix0KSxvLmNsYXNzTGlzdC5yZW1vdmUoXCJhY3RpdmVcIiksby5zZXRBdHRyaWJ1dGUoXCJhcmlhLWN1cnJlbnRcIixcImZhbHNlXCIpLG8uc2V0QXR0cmlidXRlKFwiYXJpYS1oaWRkZW5cIixcInRydWVcIiksby50YWJJbmRleD0tMSxvLmNsYXNzTGlzdC5yZW1vdmUoaS5jdXJyZW50KSxyLmNsYXNzTGlzdC5hZGQoXCJhY3RpdmVcIiksci5zZXRBdHRyaWJ1dGUoXCJhcmlhLWN1cnJlbnRcIixcInRydWVcIiksci5zZXRBdHRyaWJ1dGUoXCJhcmlhLWhpZGRlblwiLFwiZmFsc2VcIiksci50YWJJbmRleD0tMSxyLmNsYXNzTGlzdC5yZW1vdmUoaS5uZXh0LGkub3ZlcmxheSksbi5faW50ZXJ2YWxJZHx8KG8udGFiSW5kZXg9MCxuLiRuZXh0VGljayhmdW5jdGlvbigpe28uZm9jdXMoKX0pKSxuLmlzU2xpZGluZz0hMX0sNTAwKSl9fX0sZGVzdHJveWVkOmZ1bmN0aW9uKCl7Y2xlYXJUaW1lb3V0KHRoaXMuX2Nhcm91c2VsQW5pbWF0aW9uKSxjbGVhckludGVydmFsKHRoaXMuX2ludGVydmFsSWQpfX0sY2Fyb3VzZWxTbGlkZT17cmVuZGVyOmZ1bmN0aW9uKCl7dmFyIHQ9dGhpcyxlPXQuJGNyZWF0ZUVsZW1lbnQsbj10Ll9zZWxmLl9jfHxlO3JldHVybiBuKFwiZGl2XCIse3N0YXRpY0NsYXNzOlwiY2Fyb3VzZWwtaXRlbVwiLHN0eWxlOntiYWNrZ3JvdW5kOnQuYmFja2dyb3VuZCxoZWlnaHQ6dC5oZWlnaHR9LGF0dHJzOntyb2xlOlwibGlzdGl0ZW1cIixpZDp0LmlkfHxudWxsfX0sW3QuaW1nP24oXCJpbWdcIix7c3RhdGljQ2xhc3M6XCJkLWJsb2NrIGltZy1mbHVpZFwiLGF0dHJzOntzcmM6dC5pbWcsYWx0OnQuaW1nQWx0fX0pOnQuX2UoKSxuKFwiZGl2XCIse2NsYXNzOnQuY29udGVudENsYXNzZXN9LFt0LmNhcHRpb24/bihcImgzXCIse2RvbVByb3BzOntpbm5lckhUTUw6dC5fcyh0LmNhcHRpb24pfX0pOnQuX2UoKSx0LnRleHQ/bihcInBcIix7ZG9tUHJvcHM6e2lubmVySFRNTDp0Ll9zKHQudGV4dCl9fSk6dC5fZSgpLHQuX3QoXCJkZWZhdWx0XCIpXSwyKV0pfSxzdGF0aWNSZW5kZXJGbnM6W10scHJvcHM6e2lkOnt0eXBlOlN0cmluZ30saW1nOnt0eXBlOlN0cmluZ30saW1nQWx0Ont0eXBlOlN0cmluZ30sY29udGVudFZpc2libGVVcDp7dHlwZTpTdHJpbmd9LGNhcHRpb246e3R5cGU6U3RyaW5nfSx0ZXh0Ont0eXBlOlN0cmluZ30sYmFja2dyb3VuZDp7dHlwZTpTdHJpbmd9LGhlaWdodDp7dHlwZTpTdHJpbmd9fSxjb21wdXRlZDp7Y29udGVudENsYXNzZXM6ZnVuY3Rpb24oKXt2YXIgdD17XCJjYXJvdXNlbC1jYXB0aW9uXCI6Qm9vbGVhbih0aGlzLmNhcHRpb24pfTtyZXR1cm4gdGhpcy5jb250ZW50VmlzaWJsZVVwJiYodFtcImQtbm9uZVwiXT0hMCx0W1wiZC1cIit0aGlzLmNvbnRlbnRWaXNpYmxlVXArXCItYmxvY2tcIl09ITApLHR9fX0sY29sbGFwc2U9e3JlbmRlcjpmdW5jdGlvbigpe3ZhciB0PXRoaXMsZT10LiRjcmVhdGVFbGVtZW50LG49dC5fc2VsZi5fY3x8ZTtyZXR1cm4gbihcInRyYW5zaXRpb25cIix7YXR0cnM6e25hbWU6XCJjb2xsYXBzZVwifSxvbjp7ZW50ZXI6dC5lbnRlcixcImFmdGVyLWVudGVyXCI6dC5jbGVhckhlaWdodCxsZWF2ZTp0LmxlYXZlLFwiYWZ0ZXItbGVhdmVcIjp0LmNsZWFySGVpZ2h0fX0sW24oXCJkaXZcIix7ZGlyZWN0aXZlczpbe25hbWU6XCJzaG93XCIscmF3TmFtZTpcInYtc2hvd1wiLHZhbHVlOnQuc2hvdyxleHByZXNzaW9uOlwic2hvd1wifV0sY2xhc3M6dC5jbGFzc09iamVjdCxhdHRyczp7aWQ6dC5pZHx8bnVsbH19LFt0Ll90KFwiZGVmYXVsdFwiKV0sMildKX0sc3RhdGljUmVuZGVyRm5zOltdLF9zY29wZUlkOlwiZGF0YS12LTY3YjBhMmRlXCIsZGF0YTpmdW5jdGlvbigpe3JldHVybntzaG93OnRoaXMudmlzaWJsZX19LGNvbXB1dGVkOntjbGFzc09iamVjdDpmdW5jdGlvbigpe3JldHVybntcIm5hdmJhci1jb2xsYXBzZVwiOnRoaXMuaXNOYXYsc2hvdzp0aGlzLnNob3d9fX0sbW9kZWw6e3Byb3A6XCJ2aXNpYmxlXCIsZXZlbnQ6XCJpbnB1dFwifSx3YXRjaDp7dmlzaWJsZTpmdW5jdGlvbih0KXt0IT09dGhpcy5zaG93JiYodGhpcy5zaG93PXQsdGhpcy5lbWl0U3RhdGUoKSl9fSxwcm9wczp7aXNOYXY6e3R5cGU6Qm9vbGVhbixkZWZhdWx0OiExfSxpZDp7dHlwZTpTdHJpbmcscmVxdWlyZWQ6ITB9LGFjY29yZGlvbjp7dHlwZTpTdHJpbmcsZGVmYXVsdDpudWxsfSx2aXNpYmxlOnt0eXBlOkJvb2xlYW4sZGVmYXVsdDohMX19LG1ldGhvZHM6e3RvZ2dsZTpmdW5jdGlvbigpe3RoaXMuc2hvdz0hdGhpcy5zaG93LHRoaXMuZW1pdFN0YXRlKCl9LGVudGVyOmZ1bmN0aW9uKHQpe3Quc3R5bGUuaGVpZ2h0PVwiYXV0b1wiO3ZhciBlPWdldENvbXB1dGVkU3R5bGUodCkuaGVpZ2h0O3Quc3R5bGUuaGVpZ2h0PVwiMHB4XCIsdC5vZmZzZXRIZWlnaHQsdC5zdHlsZS5oZWlnaHQ9ZX0sbGVhdmU6ZnVuY3Rpb24odCl7dC5zdHlsZS5oZWlnaHQ9XCJhdXRvXCI7dmFyIGU9Z2V0Q29tcHV0ZWRTdHlsZSh0KS5oZWlnaHQ7dC5zdHlsZS5oZWlnaHQ9ZSx0Lm9mZnNldEhlaWdodCx0LnN0eWxlLmhlaWdodD1cIjBweFwifSxjbGVhckhlaWdodDpmdW5jdGlvbih0KXt0LnN0eWxlLmhlaWdodD1udWxsfSxlbWl0U3RhdGU6ZnVuY3Rpb24oKXt0aGlzLiRlbWl0KFwiaW5wdXRcIix0aGlzLnNob3cpLHRoaXMuJHJvb3QuJGVtaXQoXCJjb2xsYXBzZTo6dG9nZ2xlOjpzdGF0ZVwiLHRoaXMuaWQsdGhpcy5zaG93KSx0aGlzLmFjY29yZGlvbiYmdGhpcy5zaG93JiZ0aGlzLiRyb290LiRlbWl0KFwiYWNjb3JkaW9uOjp0b2dnbGVcIix0aGlzLmlkLHRoaXMuYWNjb3JkaW9uKX19LGNyZWF0ZWQ6ZnVuY3Rpb24oKXt2YXIgdD10aGlzO3RoaXMuJHJvb3QuJG9uKFwiY29sbGFwc2U6OnRvZ2dsZVwiLGZ1bmN0aW9uKGUpe2U9PT10LmlkJiZ0LnRvZ2dsZSgpfSksdGhpcy4kcm9vdC4kb24oXCJhY2NvcmRpb246OnRvZ2dsZVwiLGZ1bmN0aW9uKGUsbil7dC5hY2NvcmRpb24mJm49PT10LmFjY29yZGlvbiYmKGU9PT10LmlkP3Quc2hvd3x8dC50b2dnbGUoKTp0LnNob3cmJnQudG9nZ2xlKCkpfSl9LG1vdW50ZWQ6ZnVuY3Rpb24oKXt0aGlzLmVtaXRTdGF0ZSgpfX0sZHJvcGRvd24kMT17cmVuZGVyOmZ1bmN0aW9uKCl7dmFyIHQ9dGhpcyxlPXQuJGNyZWF0ZUVsZW1lbnQsbj10Ll9zZWxmLl9jfHxlO3JldHVybiBuKFwiZGl2XCIse2NsYXNzOltcImRyb3Bkb3duXCIsXCJidG4tZ3JvdXBcIix7ZHJvcHVwOnQuZHJvcHVwLHNob3c6dC52aXNpYmxlfV0sYXR0cnM6e2lkOnQuaWR8fG51bGx9fSxbbihcImItYnV0dG9uXCIse3JlZjpcImJ1dHRvblwiLGNsYXNzOntcImRyb3Bkb3duLXRvZ2dsZVwiOiF0LnNwbGl0LFwiYnRuLWxpbmtcIjp0Lmxpbmt9LGF0dHJzOntpZDp0LmlkP3QuaWQrXCJfX0JWX2J1dHRvbl9cIjpudWxsLFwiYXJpYS1oYXNwb3B1cFwiOnQuc3BsaXQ/bnVsbDpcInRydWVcIixcImFyaWEtZXhwYW5kZWRcIjp0LnNwbGl0P251bGw6dC52aXNpYmxlP1widHJ1ZVwiOlwiZmFsc2VcIix2YXJpYW50OnQudmFyaWFudCxzaXplOnQuc2l6ZSxkaXNhYmxlZDp0LmRpc2FibGVkfSxvbjp7Y2xpY2s6ZnVuY3Rpb24oZSl7ZS5zdG9wUHJvcGFnYXRpb24oKSxlLnByZXZlbnREZWZhdWx0KCksdC5jbGljayhlKX19fSxbdC5fdChcInRleHRcIixbdC5fdih0Ll9zKHQudGV4dCkpXSldLDIpLHQuc3BsaXQ/bihcImItYnV0dG9uXCIse3JlZjpcInRvZ2dsZVwiLGNsYXNzOltcImRyb3Bkb3duLXRvZ2dsZVwiLFwiZHJvcGRvd24tdG9nZ2xlLXNwbGl0XCIse1wiYnRuLWxpbmtcIjp0Lmxpbmt9XSxhdHRyczp7aWQ6dC5pZD90LmlkK1wiX19CVl90b2dnbGVfXCI6bnVsbCxcImFyaWEtaGFzcG9wdXBcIjp0LnNwbGl0P1widHJ1ZVwiOm51bGwsXCJhcmlhLWV4cGFuZGVkXCI6dC5zcGxpdD90LnZpc2libGU/XCJ0cnVlXCI6XCJmYWxzZVwiOm51bGwsdmFyaWFudDp0LnZhcmlhbnQsc2l6ZTp0LnNpemUsZGlzYWJsZWQ6dC5kaXNhYmxlZH0sb246e2NsaWNrOmZ1bmN0aW9uKGUpe2Uuc3RvcFByb3BhZ2F0aW9uKCksZS5wcmV2ZW50RGVmYXVsdCgpLHQudG9nZ2xlKGUpfX19LFtuKFwic3BhblwiLHtzdGF0aWNDbGFzczpcInNyLW9ubHlcIn0sW3QuX3YodC5fcyh0LnRvZ2dsZVRleHQpKV0pXSk6dC5fZSgpLG4oXCJkaXZcIix7cmVmOlwibWVudVwiLGNsYXNzOltcImRyb3Bkb3duLW1lbnVcIix7XCJkcm9wZG93bi1tZW51LXJpZ2h0XCI6dC5yaWdodH1dLGF0dHJzOntyb2xlOlwibWVudVwiLFwiYXJpYS1sYWJlbGxlZGJ5XCI6dC5pZD90LmlkKyh0LnNwbGl0P1wiX19CVl90b2dnbGVfXCI6XCJfX0JWX2J1dHRvbl9cIik6bnVsbH0sb246e2tleXVwOmZ1bmN0aW9uKGUpe2lmKCEoXCJidXR0b25cImluIGUpJiZ0Ll9rKGUua2V5Q29kZSxcImVzY1wiLDI3KSlyZXR1cm4gbnVsbDt0Lm9uRXNjKGUpfSxrZXlkb3duOltmdW5jdGlvbihlKXtpZighKFwiYnV0dG9uXCJpbiBlKSYmdC5fayhlLmtleUNvZGUsXCJ0YWJcIiw5KSlyZXR1cm4gbnVsbDt0Lm9uVGFiKGUpfSxmdW5jdGlvbihlKXtpZighKFwiYnV0dG9uXCJpbiBlKSYmdC5fayhlLmtleUNvZGUsXCJ1cFwiLDM4KSlyZXR1cm4gbnVsbDt0LmZvY3VzTmV4dChlLCEwKX0sZnVuY3Rpb24oZSl7aWYoIShcImJ1dHRvblwiaW4gZSkmJnQuX2soZS5rZXlDb2RlLFwiZG93blwiLDQwKSlyZXR1cm4gbnVsbDt0LmZvY3VzTmV4dChlLCExKX1dLG1vdXNlb3ZlcjpmdW5jdGlvbihlKXt0LmZvY3VzSG92ZXJlZChlKX19fSxbdC5fdChcImRlZmF1bHRcIildLDIpXSwxKX0sc3RhdGljUmVuZGVyRm5zOltdLG1peGluczpbY2xpY2tPdXQsZHJvcGRvd25dLGNvbXBvbmVudHM6e2JCdXR0b246YkJ0bn0sZGF0YTpmdW5jdGlvbigpe3JldHVybnt2aXNpYmxlOiExfX0scHJvcHM6e2lkOnt0eXBlOlN0cmluZ30sdG9nZ2xlVGV4dDp7dHlwZTpTdHJpbmcsZGVmYXVsdDpcIlRvZ2dsZSBEcm9wZG93blwifSxzaXplOnt0eXBlOlN0cmluZyxkZWZhdWx0Om51bGx9LHZhcmlhbnQ6e3R5cGU6U3RyaW5nLGRlZmF1bHQ6bnVsbH0sbGluazp7dHlwZTpCb29sZWFuLGRlZmF1bHQ6ITF9fSxtZXRob2RzOntjbGlja091dExpc3RlbmVyOmZ1bmN0aW9uKCl7dGhpcy52aXNpYmxlPSExfSxjbGljazpmdW5jdGlvbih0KXt0aGlzLmRpc2FibGVkP3RoaXMudmlzaWJsZT0hMTp0aGlzLnNwbGl0Pyh0aGlzLiRlbWl0KFwiY2xpY2tcIix0KSx0aGlzLiRyb290LiRlbWl0KFwic2hvd246OmRyb3Bkb3duXCIsdGhpcykpOnRoaXMudG9nZ2xlKCl9fX0sZHJvcGRvd25JdGVtPXtyZW5kZXI6ZnVuY3Rpb24oKXt2YXIgdD10aGlzLGU9dC4kY3JlYXRlRWxlbWVudDtyZXR1cm4odC5fc2VsZi5fY3x8ZSkoXCJiLWxpbmtcIix0Ll9iKHtzdGF0aWNDbGFzczpcImRyb3Bkb3duLWl0ZW1cIixhdHRyczp7cm9sZTpcIm1lbnVpdGVtXCJ9LG9uOntjbGljazpmdW5jdGlvbihlKXt0LiRlbWl0KFwiY2xpY2tcIixlKX19fSxcImItbGlua1wiLHQubGlua1Byb3BzKSxbdC5fdChcImRlZmF1bHRcIildLDIpfSxzdGF0aWNSZW5kZXJGbnM6W10sY29tcG9uZW50czp7Ykxpbms6Ykxpbmt9LHByb3BzOnByb3BzLGNvbXB1dGVkOntsaW5rUHJvcHM6Y29tcHV0ZWQubGlua1Byb3BzfX0sZHJvcGRvd25JdGVtQnV0dG9uPXtyZW5kZXI6ZnVuY3Rpb24oKXt2YXIgdD10aGlzLGU9dC4kY3JlYXRlRWxlbWVudDtyZXR1cm4odC5fc2VsZi5fY3x8ZSkoXCJidXR0b25cIix7c3RhdGljQ2xhc3M6XCJkcm9wZG93bi1pdGVtXCIsYXR0cnM6e3R5cGU6XCJidXR0b25cIixyb2xlOlwibWVudWl0ZW1cIixkaXNhYmxlZDp0LmRpc2FibGVkfSxvbjp7Y2xpY2s6dC5vbkNsaWNrfX0sW3QuX3QoXCJkZWZhdWx0XCIpXSwyKX0sc3RhdGljUmVuZGVyRm5zOltdLHByb3BzOntkaXNhYmxlZDp7dHlwZTpCb29sZWFuLGRlZmF1bHQ6ITF9fSxtZXRob2RzOntvbkNsaWNrOmZ1bmN0aW9uKHQpe3RoaXMuJHJvb3QuJGVtaXQoXCJjbGlja2VkOjpsaW5rXCIsdGhpcyksdGhpcy4kZW1pdChcImNsaWNrXCIsdCl9fX0sZHJvcGRvd25EaXZpZGVyPXtyZW5kZXI6ZnVuY3Rpb24oKXt2YXIgdD10aGlzLGU9dC4kY3JlYXRlRWxlbWVudDtyZXR1cm4odC5fc2VsZi5fY3x8ZSkoXCJkaXZcIix7c3RhdGljQ2xhc3M6XCJkcm9wZG93bi1kaXZpZGVyXCIsYXR0cnM6e3JvbGU6XCJzZXBhcmF0b3JcIn19KX0sc3RhdGljUmVuZGVyRm5zOltdLHByb3BzOnt9fSxkcm9wZG93bkhlYWRlcj17cmVuZGVyOmZ1bmN0aW9uKCl7dmFyIHQ9dGhpcyxlPXQuJGNyZWF0ZUVsZW1lbnQ7cmV0dXJuKHQuX3NlbGYuX2N8fGUpKHQudGFnLHt0YWc6XCJjb21wb25lbnRcIixzdGF0aWNDbGFzczpcImRyb3Bkb3duLWhlYWRlclwiLGF0dHJzOnt0YWJpbmRleDpcIi0xXCJ9fSxbdC5fdChcImRlZmF1bHRcIildLDIpfSxzdGF0aWNSZW5kZXJGbnM6W10scHJvcHM6e3RhZzp7dHlwZTpTdHJpbmcsZGVmYXVsdDpcImg2XCJ9fX0sZHJvcGRvd25TZWxlY3Q9e3JlbmRlcjpmdW5jdGlvbigpe3ZhciB0PXRoaXMsZT10LiRjcmVhdGVFbGVtZW50LG49dC5fc2VsZi5fY3x8ZTtyZXR1cm4gbihcImRpdlwiLHtzdGF0aWNDbGFzczpcImRyb3Bkb3duLXNlbGVjdFwiLGNsYXNzOntvcGVuOnQuc2hvdyxkcm9wZG93bjohdC5kcm9wdXAsZHJvcHVwOnQuZHJvcHVwfX0sW24oXCJidXR0b25cIix7Y2xhc3M6W1wiYnRuXCIsXCJkcm9wZG93blwiLHQuZHJvcGRvd25Ub2dnbGUsdC5idG5WYXJpYW50LHQuYnRuU2l6ZV0sYXR0cnM6e2lkOnQuaWQscm9sZTpcImJ1dHRvblwiLFwiYXJpYS1oYXNwb3B1cFwiOlwidHJ1ZVwiLFwiYXJpYS1leHBhbmRlZFwiOlwic2hvd1wiLGRpc2FibGVkOnQuZGlzYWJsZWR9LG9uOntjbGljazpmdW5jdGlvbihlKXtlLnByZXZlbnREZWZhdWx0KCksdC50b2dnbGUoZSl9fX0sW24oXCJzcGFuXCIse3N0YXRpY0NsYXNzOlwiY2hlY2tlZC1pdGVtc1wiLGRvbVByb3BzOntpbm5lckhUTUw6dC5fcyh0LmRpc3BsYXlJdGVtKX19KV0pLG4oXCJ1bFwiLHtzdGF0aWNDbGFzczpcImRyb3Bkb3duLW1lbnVcIixjbGFzczp7XCJkcm9wZG93bi1tZW51LXJpZ2h0XCI6XCJyaWdodFwiPT10LnBvc2l0aW9ufSxhdHRyczp7XCJhcmlhLWxhYmVsbGVkYnlcIjpcImRMYWJlbFwifX0sdC5fbCh0Lmxpc3QsZnVuY3Rpb24oZSl7cmV0dXJuIG4oXCJsaVwiLFtuKFwiYnV0dG9uXCIse3N0YXRpY0NsYXNzOlwiZHJvcGRvd24taXRlbVwiLGF0dHJzOntjbGljazp0LnNlbGVjdChlKX19LFt0Ll92KHQuX3MoZS50ZXh0KSldKV0pfSkpXSl9LHN0YXRpY1JlbmRlckZuczpbXSxkYXRhOmZ1bmN0aW9uKCl7cmV0dXJue3Nob3c6ITEsc2VsZWN0ZWQ6ITF9fSxjb21wdXRlZDp7YnRuVmFyaWFudDpmdW5jdGlvbigpe3JldHVybiB0aGlzLnZhcmlhbnQmJlwiZGVmYXVsdFwiIT09dGhpcy52YXJpYW50P1wiYnRuLVwiK3RoaXMudmFyaWFudDpcImJ0bi1zZWNvbmRhcnlcIn0sYnRuU2l6ZTpmdW5jdGlvbigpe3JldHVybiB0aGlzLnNpemUmJlwiZGVmYXVsdFwiIT09dGhpcy5zaXplP1wiYnRuLVwiK3RoaXMuc2l6ZTpcIlwifSxkcm9wZG93blRvZ2dsZTpmdW5jdGlvbigpe3JldHVybiB0aGlzLmNhcmV0P1wiZHJvcGRvd24tdG9nZ2xlXCI6XCJcIn0sZGlzcGxheUl0ZW06ZnVuY3Rpb24oKXtpZih0aGlzLnJldHVybk9iamVjdCYmdGhpcy5tb2RlbCYmIXRoaXMubW9kZWwudGV4dHx8IXRoaXMucmV0dXJuT2JqZWN0JiZ0aGlzLm1vZGVsJiYwPT09dGhpcy5tb2RlbC5sZW5ndGh8fHRoaXMuZm9yY2VEZWZhdWx0KXJldHVybiB0aGlzLmRlZmF1bHRUZXh0O2lmKHRoaXMucmV0dXJuT2JqZWN0JiZ0aGlzLm1vZGVsJiZ0aGlzLm1vZGVsLnRleHQpcmV0dXJuIHRoaXMubW9kZWwudGV4dDtpZighdGhpcy5yZXR1cm5PYmplY3QmJnRoaXMubW9kZWwpe3ZhciB0PXRoaXMubW9kZWx8fFwiXCI7cmV0dXJuIHRoaXMubGlzdC5mb3JFYWNoKGZ1bmN0aW9uKGUpe2UudmFsdWU9PT10aGlzLm1vZGVsJiYodD1lLnRleHQpfSksdH1yZXR1cm5cIlwifX0scHJvcHM6e2lkOnt0eXBlOlN0cmluZ30sbW9kZWw6e3JlcXVpcmVkOiExfSxsaXN0Ont0eXBlOkFycmF5LGRlZmF1bHQ6W10scmVxdWlyZWQ6ITB9LGNhcmV0Ont0eXBlOkJvb2xlYW4sZGVmYXVsdDohMH0scG9zaXRpb246e3R5cGU6U3RyaW5nLGRlZmF1bHQ6XCJsZWZ0XCJ9LHNpemU6e3R5cGU6U3RyaW5nLGRlZmF1bHQ6XCJcIn0sdmFyaWFudDp7dHlwZTpTdHJpbmcsZGVmYXVsdDpcImRlZmF1bHRcIn0sZGVmYXVsdFRleHQ6e3R5cGU6U3RyaW5nLGRlZmF1bHQ6XCJQbGFzZSBzZWxlY3Qgb25lXCJ9LGZvcmNlRGVmYXVsdDp7dHlwZTpCb29sZWFuLGRlZmF1bHQ6ITF9LHJldHVybk9iamVjdDp7dHlwZTpCb29sZWFuLGRlZmF1bHQ6ITF9LGRyb3B1cDp7dHlwZTpCb29sZWFuLGRlZmF1bHQ6ITF9LGRpc2FibGVkOnt0eXBlOkJvb2xlYW4sZGVmYXVsdDohMX19LG1ldGhvZHM6e3RvZ2dsZTpmdW5jdGlvbih0KXt0aGlzLnNob3c9IXRoaXMuc2hvdyx0aGlzLnNob3c/KHRoaXMuJHJvb3QuJGVtaXQoXCJzaG93bjpkcm9wZG93blwiLHRoaXMuaWQpLHQuc3RvcFByb3BhZ2F0aW9uKCkpOnRoaXMuJHJvb3QuJGVtaXQoXCJoaWRkZW46OmRyb3Bkb3duXCIsdGhpcy5pZCl9LHNlbGVjdDpmdW5jdGlvbih0KXt0aGlzLnJldHVybk9iamVjdD90aGlzLm1vZGVsPXQ6dGhpcy5tb2RlbD10LnZhbHVlLHRoaXMuc2hvdz0hMSx0aGlzLiRyb290LiRlbWl0KFwic2VsZWN0ZWQ6OmRyb3Bkb3duXCIsdGhpcy5pZCx0aGlzLm1vZGVsKX19LGNyZWF0ZWQ6ZnVuY3Rpb24oKXt0aGlzLiRyb290LiRvbihcImhpZGU6OmRyb3Bkb3duXCIsZnVuY3Rpb24oKXt0aGlzLnNob3c9ITF9KX19LGJGb3JtPXtyZW5kZXI6ZnVuY3Rpb24oKXt2YXIgdD10aGlzLGU9dC4kY3JlYXRlRWxlbWVudDtyZXR1cm4odC5fc2VsZi5fY3x8ZSkoXCJmb3JtXCIse2NsYXNzOnQuY2xhc3NPYmplY3R9LFt0Ll90KFwiZGVmYXVsdFwiKV0sMil9LHN0YXRpY1JlbmRlckZuczpbXSxjb21wdXRlZDp7Y2xhc3NPYmplY3Q6ZnVuY3Rpb24oKXtyZXR1cm5bdGhpcy5pbmxpbmU/XCJmb3JtLWlubGluZVwiOlwiXCJdfX0scHJvcHM6e2lubGluZTp7dHlwZTpCb29sZWFuLGRlZmF1bHQ6ITF9fX0sZm9ybUZpZWxkc2V0PXtyZW5kZXI6ZnVuY3Rpb24oKXt2YXIgdD10aGlzLGU9dC4kY3JlYXRlRWxlbWVudCxuPXQuX3NlbGYuX2N8fGU7cmV0dXJuIG4oXCJkaXZcIix7Y2xhc3M6W1wiZm9ybS1ncm91cFwiLFwicm93XCIsdC5pbnB1dFN0YXRlXSxhdHRyczp7aWQ6dC5pZHx8bnVsbCxyb2xlOlwiZ3JvdXBcIixcImFyaWEtZGVzY3JpYmVkYnlcIjp0LmRlc2NyaWJlZEJ5fX0sW3QubGFiZWw/bihcImxhYmVsXCIse2NsYXNzOlt0LmxhYmVsU3JPbmx5P1wic3Itb25seVwiOlwiY29sLWZvcm0tbGFiZWxcIix0LmxhYmVsTGF5b3V0LHQubGFiZWxBbGlnbkNsYXNzXSxhdHRyczp7Zm9yOnQudGFyZ2V0LGlkOnQubGFiZWxJZH0sZG9tUHJvcHM6e2lubmVySFRNTDp0Ll9zKHQubGFiZWwpfX0pOnQuX2UoKSxuKFwiZGl2XCIse3JlZjpcImNvbnRlbnRcIixjbGFzczp0LmlucHV0TGF5b3V0fSxbdC5fdChcImRlZmF1bHRcIiksdC5mZWVkYmFjaz9uKFwiZGl2XCIse3N0YXRpY0NsYXNzOlwiZm9ybS10ZXh0IGZvcm0tY29udHJvbC1mZWVkYmFja1wiLGF0dHJzOntpZDp0LmZlZWRiYWNrSWQscm9sZTpcImFsZXJ0XCIsXCJhcmlhLWxpdmVcIjpcImFzc2VydGl2ZVwiLFwiYXJpYS1hdG9taWNcIjpcInRydWVcIn0sZG9tUHJvcHM6e2lubmVySFRNTDp0Ll9zKHQuZmVlZGJhY2spfX0pOnQuX2UoKSx0LmRlc2NyaXB0aW9uP24oXCJzbWFsbFwiLHtzdGF0aWNDbGFzczpcImZvcm0tdGV4dCB0ZXh0LW11dGVkXCIsYXR0cnM6e2lkOnQuZGVzY3JpcHRpb25JZH0sZG9tUHJvcHM6e2lubmVySFRNTDp0Ll9zKHQuZGVzY3JpcHRpb24pfX0pOnQuX2UoKV0sMildKX0sc3RhdGljUmVuZGVyRm5zOltdLGRhdGE6ZnVuY3Rpb24oKXtyZXR1cm57dGFyZ2V0Om51bGx9fSxjb21wdXRlZDp7bGFiZWxJZDpmdW5jdGlvbigpe3JldHVybiB0aGlzLmlkJiZ0aGlzLmxhYmVsP3RoaXMuaWQrXCJfX0JWX2xhYmVsX1wiOm51bGx9LGRlc2NyaXB0aW9uSWQ6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5pZCYmdGhpcy5kZXNjcmlwdGlvbj90aGlzLmlkK1wiX19CVl9kZXNjcmlwdGlvbl9cIjpudWxsfSxmZWVkYmFja0lkOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuaWQmJnRoaXMuZmVlZGJhY2s/dGhpcy5pZCtcIl9fQlZfZmVlZGJhY2tfXCI6bnVsbH0sZGVzY3JpYmVkQnk6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5pZCYmKHRoaXMubGFiZWx8fHRoaXMuZmVlZGJhY2t8fHRoaXMuZGVzY3JpcHRpb24pP1t0aGlzLmxhYmVsSWQsdGhpcy5kZXNjcmlwdGlvbklkLHRoaXMuZmVlZGJhY2tJZF0uZmlsdGVyKGZ1bmN0aW9uKHQpe3JldHVybiB0fSkuam9pbihcIiBcIik6bnVsbH0saW5wdXRTdGF0ZTpmdW5jdGlvbigpe3JldHVybiB0aGlzLnN0YXRlP1wiaGFzLVwiK3RoaXMuc3RhdGU6XCJcIn0sbGFiZWxMYXlvdXQ6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5sYWJlbFNyT25seT9udWxsOnRoaXMuaG9yaXpvbnRhbD9cImNvbC1zbS1cIit0aGlzLmxhYmVsU2l6ZTpcImNvbC0xMlwifSxsYWJlbEFsaWduQ2xhc3M6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5sYWJlbFNyT25seT9udWxsOnRoaXMubGFiZWxUZXh0QWxpZ24/XCJ0ZXh0LVwiK3RoaXMubGFiZWxUZXh0QWxpZ246bnVsbH0saW5wdXRMYXlvdXQ6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5ob3Jpem9udGFsP1wiY29sLXNtLVwiKygxMi10aGlzLmxhYmVsU2l6ZSk6XCJjb2wtMTJcIn19LG1ldGhvZHM6e3VwZGF0ZVRhcmdldDpmdW5jdGlvbigpe2lmKHRoaXMuZm9yJiZ0aGlzLiRlbCYmdGhpcy4kZWwucXVlcnlTZWxlY3RvcihcIiNcIit0aGlzLmZvcikpcmV0dXJuIHRoaXMuZm9yO3ZhciB0PXRoaXMuJHJlZnMuY29udGVudDtpZighdClyZXR1cm4gbnVsbDt2YXIgZT10LnF1ZXJ5U2VsZWN0b3IodGhpcy5pbnB1dFNlbGVjdG9yKTt0aGlzLnRhcmdldD1lJiZlLmlkP2UuaWQ6bnVsbH19LG1vdW50ZWQ6ZnVuY3Rpb24oKXt0aGlzLnVwZGF0ZVRhcmdldCgpfSx1cGRhdGVkOmZ1bmN0aW9uKCl7dGhpcy51cGRhdGVUYXJnZXQoKX0scHJvcHM6e2lkOnt0eXBlOlN0cmluZyxkZWZhdWx0Om51bGx9LGZvcjp7dHlwZTpTdHJpbmcsZGVmYXVsdDpudWxsfSxzdGF0ZTp7dHlwZTpTdHJpbmcsZGVmYXVsdDpudWxsfSxob3Jpem9udGFsOnt0eXBlOkJvb2xlYW4sZGVmYXVsdDohMX0sbGFiZWxTaXplOnt0eXBlOk51bWJlcixkZWZhdWx0OjN9LGxhYmVsVGV4dEFsaWduOnt0eXBlOlN0cmluZyxkZWZhdWx0Om51bGx9LGxhYmVsOnt0eXBlOlN0cmluZyxkZWZhdWx0Om51bGx9LGxhYmVsU3JPbmx5Ont0eXBlOkJvb2xlYW4sZGVmYXVsdDohMX0sZGVzY3JpcHRpb246e3R5cGU6U3RyaW5nLGRlZmF1bHQ6bnVsbH0sZmVlZGJhY2s6e3R5cGU6U3RyaW5nLGRlZmF1bHQ6bnVsbH0saW5wdXRTZWxlY3Rvcjp7dHlwZTpTdHJpbmcsZGVmYXVsdDonW3JvbGU9XCJyYWRpb2dyb3VwXCJdLGlucHV0LHNlbGVjdCx0ZXh0YXJlYSwuZm9ybS1jb250cm9sLC5mb3JtLWNvbnRyb2wtc3RhdGljLC5kcm9wZG93biwuZHJvcHVwJ319fSxmb3JtTWl4aW49e2NvbXB1dGVkOntpbnB1dENsYXNzOmZ1bmN0aW9uKCl7cmV0dXJuW3RoaXMuc2l6ZT9cImZvcm0tY29udHJvbC1cIit0aGlzLnNpemU6bnVsbCx0aGlzLnN0YXRlP1wiZm9ybS1jb250cm9sLVwiK3RoaXMuc3RhdGU6bnVsbF19LGN1c3RvbTpmdW5jdGlvbigpe3JldHVybiF0aGlzLnBsYWlufX0scHJvcHM6e25hbWU6e3R5cGU6U3RyaW5nfSxkaXNhYmxlZDp7dHlwZTpCb29sZWFufSxwbGFpbjp7dHlwZTpCb29sZWFuLGRlZmF1bHQ6ITF9LHN0YXRlOnt0eXBlOlN0cmluZ30sc2l6ZTp7dHlwZTpTdHJpbmd9LGlkOnt0eXBlOlN0cmluZ319fSxmb3JtQ2hlY2tCb3hNaXhpbj17Y29tcHV0ZWQ6e2NoZWNrYm94Q2xhc3M6ZnVuY3Rpb24oKXtyZXR1cm57XCJjdXN0b20tY29udHJvbFwiOnRoaXMuY3VzdG9tLFwiZm9ybS1jaGVjay1pbmxpbmVcIjp0aGlzLmlubGluZX19fX0sZm9ybUNoZWNrYm94PXtyZW5kZXI6ZnVuY3Rpb24oKXt2YXIgdD10aGlzLGU9dC4kY3JlYXRlRWxlbWVudCxuPXQuX3NlbGYuX2N8fGU7cmV0dXJuIG4oXCJsYWJlbFwiLHtjbGFzczpbdC5pbnB1dENsYXNzLHQuY2hlY2tib3hDbGFzcyx0LmN1c3RvbT9cImN1c3RvbS1jaGVja2JveFwiOm51bGxdfSxbbihcImlucHV0XCIse2NsYXNzOlt0LmN1c3RvbT9cImN1c3RvbS1jb250cm9sLWlucHV0XCI6bnVsbF0sYXR0cnM6e3R5cGU6XCJjaGVja2JveFwiLGlkOnQuaWR8fG51bGwsbmFtZTp0Lm5hbWUsZGlzYWJsZWQ6dC5kaXNhYmxlZH0sZG9tUHJvcHM6e3ZhbHVlOnQudmFsdWUsY2hlY2tlZDp0LmlzQ2hlY2tlZH0sb246e2NoYW5nZTp0LmhhbmRsZUNoYW5nZX19KSx0Ll92KFwiIFwiKSx0LmN1c3RvbT9uKFwic3BhblwiLHtzdGF0aWNDbGFzczpcImN1c3RvbS1jb250cm9sLWluZGljYXRvclwiLGF0dHJzOntcImFyaWEtaGlkZGVuXCI6XCJ0cnVlXCJ9fSk6dC5fZSgpLHQuX3YoXCIgXCIpLG4oXCJzcGFuXCIse2NsYXNzOlt0LmN1c3RvbT9cImN1c3RvbS1jb250cm9sLWRlc2NyaXB0aW9uXCI6bnVsbF19LFt0Ll90KFwiZGVmYXVsdFwiKV0sMildKX0sc3RhdGljUmVuZGVyRm5zOltdLG1peGluczpbZm9ybU1peGluLGZvcm1DaGVja0JveE1peGluXSxtb2RlbDp7cHJvcDpcImNoZWNrZWRcIixldmVudDpcImNoYW5nZVwifSxwcm9wczp7dmFsdWU6e2RlZmF1bHQ6ITB9LHVuY2hlY2tlZFZhbHVlOntkZWZhdWx0OiExfSxjaGVja2VkOntkZWZhdWx0OiEwfX0sY29tcHV0ZWQ6e2lzQ2hlY2tlZDpmdW5jdGlvbigpe3JldHVybiB0aGlzLmNoZWNrZWQuaW5jbHVkZXModGhpcy52YWx1ZSl9fSxtZXRob2RzOntoYW5kbGVDaGFuZ2U6ZnVuY3Rpb24odCl7dmFyIGU9dGhpcyxuPXQudGFyZ2V0LmNoZWNrZWQ7QXJyYXkuaXNBcnJheSh0aGlzLmNoZWNrZWQpP3RoaXMuaXNDaGVja2VkP3RoaXMuJGVtaXQoXCJjaGFuZ2VcIix0aGlzLmNoZWNrZWQuZmlsdGVyKGZ1bmN0aW9uKHQpe3JldHVybiB0IT09ZS52YWx1ZX0pKTp0aGlzLiRlbWl0KFwiY2hhbmdlXCIsdGhpcy5jaGVja2VkLmNvbmNhdChbdGhpcy52YWx1ZV0pKTp0aGlzLiRlbWl0KFwiY2hhbmdlXCIsbj90aGlzLnZhbHVlOnRoaXMudW5jaGVja2VkVmFsdWUpfX19LGZvcm1PcHRpb25zPXtjb21wdXRlZDp7Zm9ybU9wdGlvbnM6ZnVuY3Rpb24oKXt2YXIgdD10aGlzLGU9dGhpcy5vcHRpb25zfHx7fTtyZXR1cm4gZT1BcnJheS5pc0FycmF5KGUpP2UubWFwKGZ1bmN0aW9uKGUpe3JldHVyblwib2JqZWN0XCI9PXR5cGVvZiBlP3t2YWx1ZTplW3QudmFsdWVGaWVsZF0sdGV4dDplW3QudGV4dEZpZWxkXSxkaXNhYmxlZDplLmRpc2FibGVkfHwhMX06e3RleHQ6U3RyaW5nKGUpLHZhbHVlOmV8fHt9fX0pOk9iamVjdC5rZXlzKGUpLm1hcChmdW5jdGlvbihuKXt2YXIgaT1lW25dfHx7fTtyZXR1cm5cIm9iamVjdFwiIT10eXBlb2YgaSYmKGk9e3RleHQ6U3RyaW5nKGkpfSksaS52YWx1ZT1pW3QudmFsdWVGaWVsZF18fG4saX0pfSxzZWxlY3RlZFZhbHVlOmZ1bmN0aW9uKCl7Zm9yKHZhciB0PXRoaXMsZT10aGlzLmZvcm1PcHRpb25zLG49MDtuPGUubGVuZ3RoO24rKylpZihlW25dLnZhbHVlPT09dC5sb2NhbFZhbHVlKXJldHVybiB0LnJldHVybk9iamVjdD9lW25dOmVbbl0udmFsdWV9fSxwcm9wczp7dmFsdWVGaWVsZDp7dHlwZTpbU3RyaW5nXSxkZWZhdWx0OlwidmFsdWVcIn0sdGV4dEZpZWxkOnt0eXBlOltTdHJpbmddLGRlZmF1bHQ6XCJ0ZXh0XCJ9fSx3YXRjaDp7bG9jYWxWYWx1ZTpmdW5jdGlvbih0LGUpe3QhPT1lJiZ0aGlzLiRlbWl0KFwiaW5wdXRcIix0aGlzLnNlbGVjdGVkVmFsdWUpfSx2YWx1ZTpmdW5jdGlvbih0LGUpe3QhPT1lJiYodGhpcy5sb2NhbFZhbHVlPXQpfX19LGZvcm1SYWRpbz17cmVuZGVyOmZ1bmN0aW9uKCl7dmFyIHQ9dGhpcyxlPXQuJGNyZWF0ZUVsZW1lbnQsbj10Ll9zZWxmLl9jfHxlO3JldHVybiBuKFwiZGl2XCIse2NsYXNzOlt0LmlucHV0Q2xhc3MsdC5pbnB1dFN0YXRlLHRoaXMuc3RhY2tlZD9cImN1c3RvbS1jb250cm9scy1zdGFja2VkXCI6XCJcIl0sYXR0cnM6e2lkOnQuaWR8fG51bGwscm9sZTpcInJhZGlvZ3JvdXBcIn19LHQuX2wodC5mb3JtT3B0aW9ucyxmdW5jdGlvbihlKXtyZXR1cm4gbihcImxhYmVsXCIse2NsYXNzOlt0LmNoZWNrYm94Q2xhc3MsdC5jdXN0b20/XCJjdXN0b20tcmFkaW9cIjpudWxsXX0sW24oXCJpbnB1dFwiLHtkaXJlY3RpdmVzOlt7bmFtZTpcIm1vZGVsXCIscmF3TmFtZTpcInYtbW9kZWxcIix2YWx1ZTp0LmxvY2FsVmFsdWUsZXhwcmVzc2lvbjpcImxvY2FsVmFsdWVcIn1dLHJlZjpcImlucHV0c1wiLHJlZkluRm9yOiEwLGNsYXNzOnQuY3VzdG9tP1wiY3VzdG9tLWNvbnRyb2wtaW5wdXRcIjpudWxsLGF0dHJzOntpZDplLmlkfHxudWxsLHR5cGU6XCJyYWRpb1wiLG5hbWU6ZS5uYW1lLGRpc2FibGVkOmUuZGlzYWJsZWR9LGRvbVByb3BzOnt2YWx1ZTplLnZhbHVlLGNoZWNrZWQ6dC5fcSh0LmxvY2FsVmFsdWUsZS52YWx1ZSl9LG9uOntjaGFuZ2U6ZnVuY3Rpb24obil7dC4kZW1pdChcImNoYW5nZVwiLHQucmV0dXJuT2JqZWN0P2U6ZS52YWx1ZSl9LF9fYzpmdW5jdGlvbihuKXt0LmxvY2FsVmFsdWU9ZS52YWx1ZX19fSksdC5fdihcIiBcIiksdC5jdXN0b20/bihcInNwYW5cIix7c3RhdGljQ2xhc3M6XCJjdXN0b20tY29udHJvbC1pbmRpY2F0b3JcIixhdHRyczp7XCJhcmlhLWhpZGRlblwiOlwidHJ1ZVwifX0pOnQuX2UoKSx0Ll92KFwiIFwiKSxuKFwic3BhblwiLHtjbGFzczp0LmN1c3RvbT9cImN1c3RvbS1jb250cm9sLWRlc2NyaXB0aW9uXCI6bnVsbCxkb21Qcm9wczp7aW5uZXJIVE1MOnQuX3MoZS50ZXh0KX19KV0pfSkpfSxzdGF0aWNSZW5kZXJGbnM6W10sbWl4aW5zOltmb3JtTWl4aW4sZm9ybUNoZWNrQm94TWl4aW4sZm9ybU9wdGlvbnNdLGRhdGE6ZnVuY3Rpb24oKXtyZXR1cm57bG9jYWxWYWx1ZTp0aGlzLnZhbHVlfX0sY29tcHV0ZWQ6e2lucHV0U3RhdGU6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5zdGF0ZT9cImhhcy1cIit0aGlzLnN0YXRlOlwiXCJ9fSxwcm9wczp7dmFsdWU6e30sb3B0aW9uczp7dHlwZTpbQXJyYXksT2JqZWN0XSxkZWZhdWx0Om51bGwscmVxdWlyZWQ6ITB9LHN0YWNrZWQ6e3R5cGU6Qm9vbGVhbixkZWZhdWx0OiExfSxyZXR1cm5PYmplY3Q6e3R5cGU6Qm9vbGVhbixkZWZhdWx0OiExfX19LGJGb3JtSW5wdXRTdGF0aWM9e3JlbmRlcjpmdW5jdGlvbigpe3ZhciB0PXRoaXMsZT10LiRjcmVhdGVFbGVtZW50O3JldHVybih0Ll9zZWxmLl9jfHxlKShcInBcIix7Y2xhc3M6W1wiZm9ybS1jb250cm9sLXN0YXRpY1wiLHQuaW5wdXRDbGFzc10sYXR0cnM6e2lkOnQuaWR8fG51bGx9LGRvbVByb3BzOntpbm5lckhUTUw6dC5fcyh0LnN0YXRpY1ZhbHVlKX19LFt0Ll90KFwiZGVmYXVsdFwiKV0sMil9LHN0YXRpY1JlbmRlckZuczpbXSxtaXhpbnM6W2Zvcm1NaXhpbl0sY29tcHV0ZWQ6e3N0YXRpY1ZhbHVlOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuZm9ybWF0dGVyP3RoaXMuZm9ybWF0dGVyKHRoaXMudmFsdWUpOnRoaXMudmFsdWV9fSxwcm9wczp7dmFsdWU6e2RlZmF1bHQ6bnVsbH0sZm9ybWF0dGVyOnt0eXBlOkZ1bmN0aW9ufX19LGZvcm1JbnB1dD17cmVuZGVyOmZ1bmN0aW9uKCl7dmFyIHQ9dGhpcyxlPXQuJGNyZWF0ZUVsZW1lbnQsbj10Ll9zZWxmLl9jfHxlO3JldHVybiB0LnN0YXRpYz9uKFwiYi1mb3JtLWlucHV0LXN0YXRpY1wiLHthdHRyczp7aWQ6dC5pZHx8bnVsbCx2YWx1ZTp0LnZhbHVlLGZvcm1hdHRlcjp0LmZvcm1hdHRlcn19KTpuKHQudGV4dGFyZWE/XCJ0ZXh0YXJlYVwiOlwiaW5wdXRcIix7cmVmOlwiaW5wdXRcIix0YWc6XCJpbnB1dFwiLGNsYXNzOltcImZvcm0tY29udHJvbFwiLHQuaW5wdXRDbGFzc10sYXR0cnM6e3R5cGU6dC50eXBlLG5hbWU6dC5uYW1lLGlkOnQuaWR8fG51bGwsZGlzYWJsZWQ6dC5kaXNhYmxlZCxyZWFkb25seTp0LnJlYWRvbmx5LHJvd3M6dC5yb3dzfHx0LnJvd3NDb3VudCxwbGFjZWhvbGRlcjp0LnBsYWNlaG9sZGVyfSxkb21Qcm9wczp7dmFsdWU6dC52YWx1ZX0sb246e2lucHV0OmZ1bmN0aW9uKGUpe3Qub25JbnB1dChlLnRhcmdldC52YWx1ZSl9LGNoYW5nZTpmdW5jdGlvbihlKXt0Lm9uQ2hhbmdlKGUudGFyZ2V0LnZhbHVlKX0sa2V5dXA6ZnVuY3Rpb24oZSl7dC5vbktleVVwKGUpfSxmb2N1czpmdW5jdGlvbihlKXt0LiRlbWl0KFwiZm9jdXNcIil9LGJsdXI6ZnVuY3Rpb24oZSl7dC4kZW1pdChcImJsdXJcIil9fX0pfSxzdGF0aWNSZW5kZXJGbnM6W10sbWl4aW5zOltmb3JtTWl4aW5dLGNvbXBvbmVudHM6e2JGb3JtSW5wdXRTdGF0aWM6YkZvcm1JbnB1dFN0YXRpY30sY29tcHV0ZWQ6e3Jvd3NDb3VudDpmdW5jdGlvbigpe3JldHVybih0aGlzLnZhbHVlfHxcIlwiKS50b1N0cmluZygpLnNwbGl0KFwiXFxuXCIpLmxlbmd0aH19LG1ldGhvZHM6e2Zvcm1hdDpmdW5jdGlvbih0KXtpZih0aGlzLmZvcm1hdHRlcil7dmFyIGU9dGhpcy5mb3JtYXR0ZXIodCk7ZSE9PXQmJih0PWUsdGhpcy4kcmVmcy5pbnB1dC52YWx1ZT1lKX1yZXR1cm4gdH0sb25JbnB1dDpmdW5jdGlvbih0KXt0aGlzLmxhenlGb3JtYXR0ZXJ8fCh0PXRoaXMuZm9ybWF0KHQpKSx0aGlzLiRlbWl0KFwiaW5wdXRcIix0KX0sb25DaGFuZ2U6ZnVuY3Rpb24odCl7dD10aGlzLmZvcm1hdCh0KSx0aGlzLiRlbWl0KFwiaW5wdXRcIix0KSx0aGlzLiRlbWl0KFwiY2hhbmdlXCIsdCl9LG9uS2V5VXA6ZnVuY3Rpb24odCl7dGhpcy4kZW1pdChcImtleXVwXCIsdCl9LGZvY3VzOmZ1bmN0aW9uKCl7dGhpcy4kcmVmcy5pbnB1dC5mb2N1cygpfX0scHJvcHM6e3ZhbHVlOntkZWZhdWx0Om51bGx9LHR5cGU6e3R5cGU6U3RyaW5nLGRlZmF1bHQ6XCJ0ZXh0XCJ9LHJlYWRvbmx5Ont0eXBlOkJvb2xlYW4sZGVmYXVsdDohMX0sc3RhdGljOnt0eXBlOkJvb2xlYW4sZGVmYXVsdDohMX0scGxhY2Vob2xkZXI6e3R5cGU6U3RyaW5nLGRlZmF1bHQ6bnVsbH0scm93czp7dHlwZTpOdW1iZXIsZGVmYXVsdDpudWxsfSx0ZXh0YXJlYTp7dHlwZTpCb29sZWFuLGRlZmF1bHQ6ITF9LGZvcm1hdHRlcjp7dHlwZTpGdW5jdGlvbn0sbGF6eUZvcm1hdHRlcjp7dHlwZTpCb29sZWFuLGRlZmF1bHQ6ITF9fX0sZm9ybUZpbGU9e3JlbmRlcjpmdW5jdGlvbigpe3ZhciB0PXRoaXMsZT10LiRjcmVhdGVFbGVtZW50LG49dC5fc2VsZi5fY3x8ZTtyZXR1cm4gbihcImRpdlwiLHtjbGFzczpbXCJmb3JtLWNvbnRyb2xcIix0LmN1c3RvbT9cImN1c3RvbS1maWxlXCI6bnVsbCx0LmlucHV0Q2xhc3NdLGF0dHJzOntpZDp0LmlkP3QuaWQrXCJfX0JWX2ZpbGVfb3V0ZXJfXCI6bnVsbH0sb246e2RyYWdvdmVyOmZ1bmN0aW9uKGUpe2Uuc3RvcFByb3BhZ2F0aW9uKCksZS5wcmV2ZW50RGVmYXVsdCgpLHQuZHJhZ292ZXIoZSl9fX0sW3QuZHJhZ2dpbmcmJnQuY3VzdG9tP24oXCJzcGFuXCIse3N0YXRpY0NsYXNzOlwiZHJvcC1oZXJlXCIsYXR0cnM6e1wiZGF0YS1kcm9wXCI6dC5kcm9wTGFiZWx9LG9uOntkcmFnb3ZlcjpmdW5jdGlvbihlKXtlLnN0b3BQcm9wYWdhdGlvbigpLGUucHJldmVudERlZmF1bHQoKSx0LmRyYWdvdmVyKGUpfSxkcm9wOmZ1bmN0aW9uKGUpe2Uuc3RvcFByb3BhZ2F0aW9uKCksZS5wcmV2ZW50RGVmYXVsdCgpLHQuZHJvcChlKX0sZHJhZ2xlYXZlOmZ1bmN0aW9uKGUpe2Uuc3RvcFByb3BhZ2F0aW9uKCksZS5wcmV2ZW50RGVmYXVsdCgpLHQuZHJhZ2dpbmc9ITF9fX0pOnQuX2UoKSxuKFwiaW5wdXRcIix7cmVmOlwiaW5wdXRcIixjbGFzczp0LmN1c3RvbT9cImN1c3RvbS1maWxlLWlucHV0XCI6XCJcIixhdHRyczp7dHlwZTpcImZpbGVcIixuYW1lOnQubmFtZSxpZDp0LmlkfHxudWxsLGRpc2FibGVkOnQuZGlzYWJsZWQsYWNjZXB0OnQuYWNjZXB0fHxudWxsLG11bHRpcGxlOnQubXVsdGlwbGUsd2Via2l0ZGlyZWN0b3J5OnQuZGlyZWN0b3J5LFwiYXJpYS1kZXNjcmliZWRieVwiOnQuY3VzdG9tJiZ0LmlkP3QuaWQrXCJfX0JWX2ZpbGVfY29udHJvbF9cIjpudWxsfSxvbjp7Y2hhbmdlOnQub25GaWxlQ2hhbmdlfX0pLHQuX3YoXCIgXCIpLHQuY3VzdG9tP24oXCJzcGFuXCIse2NsYXNzOltcImN1c3RvbS1maWxlLWNvbnRyb2xcIix0LmRyYWdnaW5nP1wiZHJhZ2dpbmdcIjpudWxsLHQuaW5wdXRDbGFzc10sYXR0cnM6e2lkOnQuaWQ/dC5pZCtcIl9fQlZfZmlsZV9jb250cm9sX1wiOm51bGwsXCJkYXRhLWNob29zZVwiOnQuY29tcHV0ZWRDaG9vc2VMYWJlbCxcImRhdGEtc2VsZWN0ZWRcIjp0LnNlbGVjdGVkTGFiZWx9fSk6dC5fZSgpXSl9LHN0YXRpY1JlbmRlckZuczpbXSxfc2NvcGVJZDpcImRhdGEtdi1jNjhiZDVmOFwiLG1peGluczpbZm9ybU1peGluXSxkYXRhOmZ1bmN0aW9uKCl7cmV0dXJue3NlbGVjdGVkRmlsZTpudWxsLGRyYWdnaW5nOiExfX0sY29tcHV0ZWQ6e3NlbGVjdGVkTGFiZWw6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5zZWxlY3RlZEZpbGUmJjAhPT10aGlzLnNlbGVjdGVkRmlsZS5sZW5ndGg/dGhpcy5tdWx0aXBsZT8xPT09dGhpcy5zZWxlY3RlZEZpbGUubGVuZ3RoP3RoaXMuc2VsZWN0ZWRGaWxlWzBdLm5hbWU6dGhpcy5zZWxlY3RlZEZvcm1hdC5yZXBsYWNlKFwiOm5hbWVzXCIsdGhpcy5zZWxlY3RlZEZpbGUubWFwKGZ1bmN0aW9uKHQpe3JldHVybiB0Lm5hbWV9KS5qb2luKFwiLFwiKSkucmVwbGFjZShcIjpjb3VudFwiLHRoaXMuc2VsZWN0ZWRGaWxlLmxlbmd0aCk6dGhpcy5zZWxlY3RlZEZpbGUubmFtZTp0aGlzLnBsYWNlaG9sZGVyfHxcIk5vIGZpbGUgY2hvc2VuXCJ9LGNvbXB1dGVkQ2hvb3NlTGFiZWw6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5jaG9vc2VMYWJlbHx8KHRoaXMubXVsdGlwbGU/XCJDaG9vc2UgRmlsZXNcIjpcIkNob29zZSBGaWxlXCIpfX0sd2F0Y2g6e3NlbGVjdGVkRmlsZTpmdW5jdGlvbih0LGUpe3QhPT1lJiYoIXQmJnRoaXMubXVsdGlwbGU/dGhpcy4kZW1pdChcImlucHV0XCIsW10pOnRoaXMuJGVtaXQoXCJpbnB1dFwiLHQpKX19LG1ldGhvZHM6e3Jlc2V0OmZ1bmN0aW9uKCl7dHJ5e3RoaXMuJHJlZnMuaW5wdXQudmFsdWU9XCJcIn1jYXRjaCh0KXt9dGhpcy4kcmVmcy5pbnB1dC50eXBlPVwiXCIsdGhpcy4kcmVmcy5pbnB1dC50eXBlPVwiZmlsZVwiLHRoaXMuc2VsZWN0ZWRGaWxlPXRoaXMubXVsdGlwbGU/W106bnVsbH0sb25GaWxlQ2hhbmdlOmZ1bmN0aW9uKHQpe3ZhciBlPXRoaXM7dGhpcy4kZW1pdChcImNoYW5nZVwiLHQpO3ZhciBuPXQuZGF0YVRyYW5zZmVyJiZ0LmRhdGFUcmFuc2Zlci5pdGVtcztpZighbnx8dGhpcy5ub1RyYXZlcnNlKXRoaXMuc2V0RmlsZXModC50YXJnZXQuZmlsZXN8fHQuZGF0YVRyYW5zZmVyLmZpbGVzKTtlbHNle2Zvcih2YXIgaT1bXSxvPTA7bzxuLmxlbmd0aDtvKyspe3ZhciByPW5bb10ud2Via2l0R2V0QXNFbnRyeSgpO3ImJmkucHVzaChlLnRyYXZlcnNlRmlsZVRyZWUocikpfVByb21pc2UuYWxsKGkpLnRoZW4oZnVuY3Rpb24odCl7ZS5zZXRGaWxlcyhBcnJheS5wcm90b3R5cGUuY29uY2F0LmFwcGx5KFtdLHQpKX0pfX0sc2V0RmlsZXM6ZnVuY3Rpb24odCl7dmFyIGU9dGhpcztpZih0KWlmKHRoaXMubXVsdGlwbGUpe2Zvcih2YXIgbj1bXSxpPTA7aTx0Lmxlbmd0aDtpKyspdFtpXS50eXBlLm1hdGNoKGUuYWNjZXB0KSYmbi5wdXNoKHRbaV0pO3RoaXMuc2VsZWN0ZWRGaWxlPW59ZWxzZSB0aGlzLnNlbGVjdGVkRmlsZT10WzBdO2Vsc2UgdGhpcy5zZWxlY3RlZEZpbGU9bnVsbH0sZHJhZ292ZXI6ZnVuY3Rpb24odCl7IXRoaXMubm9Ecm9wJiZ0aGlzLmN1c3RvbSYmKHRoaXMuZHJhZ2dpbmc9ITAsdC5kYXRhVHJhbnNmZXIuZHJvcEVmZmVjdD1cImNvcHlcIil9LGRyb3A6ZnVuY3Rpb24odCl7dGhpcy5ub0Ryb3B8fCh0aGlzLmRyYWdnaW5nPSExLHQuZGF0YVRyYW5zZmVyLmZpbGVzJiZ0LmRhdGFUcmFuc2Zlci5maWxlcy5sZW5ndGg+MCYmdGhpcy5vbkZpbGVDaGFuZ2UodCkpfSx0cmF2ZXJzZUZpbGVUcmVlOmZ1bmN0aW9uKHQsZSl7dmFyIG49dGhpcztyZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24oaSl7ZT1lfHxcIlwiLHQuaXNGaWxlP3QuZmlsZShmdW5jdGlvbih0KXt0LiRwYXRoPWUsaSh0KX0pOnQuaXNEaXJlY3RvcnkmJnQuY3JlYXRlUmVhZGVyKCkucmVhZEVudHJpZXMoZnVuY3Rpb24obyl7Zm9yKHZhciByPVtdLHM9MDtzPG8ubGVuZ3RoO3MrKylyLnB1c2gobi50cmF2ZXJzZUZpbGVUcmVlKG9bc10sZSt0Lm5hbWUrXCIvXCIpKTtQcm9taXNlLmFsbChyKS50aGVuKGZ1bmN0aW9uKHQpe2koQXJyYXkucHJvdG90eXBlLmNvbmNhdC5hcHBseShbXSx0KSl9KX0pfSl9fSxwcm9wczp7YWNjZXB0Ont0eXBlOlN0cmluZyxkZWZhdWx0OlwiXCJ9LHBsYWNlaG9sZGVyOnt0eXBlOlN0cmluZyxkZWZhdWx0Om51bGx9LGNob29zZUxhYmVsOnt0eXBlOlN0cmluZyxkZWZhdWx0Om51bGx9LG11bHRpcGxlOnt0eXBlOkJvb2xlYW4sZGVmYXVsdDohMX0sZGlyZWN0b3J5Ont0eXBlOkJvb2xlYW4sZGVmYXVsdDohMX0sbm9UcmF2ZXJzZTp7dHlwZTpCb29sZWFuLGRlZmF1bHQ6ITF9LHNlbGVjdGVkRm9ybWF0Ont0eXBlOlN0cmluZyxkZWZhdWx0OlwiOmNvdW50IEZpbGVzXCJ9LG5vRHJvcDp7dHlwZTpCb29sZWFuLGRlZmF1bHQ6ITF9LGRyb3BMYWJlbDp7dHlwZTpTdHJpbmcsZGVmYXVsdDpcIkRyb3AgZmlsZXMgaGVyZVwifX19LGZvcm1TZWxlY3Q9e3JlbmRlcjpmdW5jdGlvbigpe3ZhciB0PXRoaXMsZT10LiRjcmVhdGVFbGVtZW50LG49dC5fc2VsZi5fY3x8ZTtyZXR1cm4gbihcInNlbGVjdFwiLHtkaXJlY3RpdmVzOlt7bmFtZTpcIm1vZGVsXCIscmF3TmFtZTpcInYtbW9kZWxcIix2YWx1ZTp0LmxvY2FsVmFsdWUsZXhwcmVzc2lvbjpcImxvY2FsVmFsdWVcIn1dLHJlZjpcImlucHV0XCIsY2xhc3M6W1wiZm9ybS1jb250cm9sXCIsdC5pbnB1dENsYXNzLHQuY3VzdG9tP1wiY3VzdG9tLXNlbGVjdFwiOm51bGxdLGF0dHJzOntuYW1lOnQubmFtZSxpZDp0LmlkfHxudWxsLGRpc2FibGVkOnQuZGlzYWJsZWR9LG9uOntjaGFuZ2U6ZnVuY3Rpb24oZSl7dmFyIG49QXJyYXkucHJvdG90eXBlLmZpbHRlci5jYWxsKGUudGFyZ2V0Lm9wdGlvbnMsZnVuY3Rpb24odCl7cmV0dXJuIHQuc2VsZWN0ZWR9KS5tYXAoZnVuY3Rpb24odCl7cmV0dXJuXCJfdmFsdWVcImluIHQ/dC5fdmFsdWU6dC52YWx1ZX0pO3QubG9jYWxWYWx1ZT1lLnRhcmdldC5tdWx0aXBsZT9uOm5bMF19fX0sdC5fbCh0LmZvcm1PcHRpb25zLGZ1bmN0aW9uKGUpe3JldHVybiBuKFwib3B0aW9uXCIse2F0dHJzOntkaXNhYmxlZDplLmRpc2FibGVkfSxkb21Qcm9wczp7dmFsdWU6ZS52YWx1ZSxpbm5lckhUTUw6dC5fcyhlLnRleHQpfX0pfSkpfSxzdGF0aWNSZW5kZXJGbnM6W10sbWl4aW5zOltmb3JtTWl4aW4sZm9ybU9wdGlvbnNdLGRhdGE6ZnVuY3Rpb24oKXtyZXR1cm57bG9jYWxWYWx1ZTp0aGlzLnZhbHVlfX0scHJvcHM6e3ZhbHVlOnt9LG9wdGlvbnM6e3R5cGU6W0FycmF5LE9iamVjdF0scmVxdWlyZWQ6ITB9LHJldHVybk9iamVjdDp7dHlwZTpCb29sZWFuLGRlZmF1bHQ6ITF9fX0sanVtYm90cm9uPXtyZW5kZXI6ZnVuY3Rpb24oKXt2YXIgdD10aGlzLGU9dC4kY3JlYXRlRWxlbWVudCxuPXQuX3NlbGYuX2N8fGU7cmV0dXJuIG4oXCJkaXZcIix7Y2xhc3M6W1wianVtYm90cm9uXCIsdC5mbHVpZD9cImp1bWJvdHJvbi1mbHVpZFwiOm51bGxdfSxbbihcImRpdlwiLHtjbGFzczp0LmNvbnRhaW5lckZsdWlkP1wiY29udGFpbmVyLWZsdWlkXCI6XCJjb250YWluZXJcIn0sW3QuaGVhZGVyP24oXCJoMVwiLHtzdGF0aWNDbGFzczpcImRpc3BsYXktM1wiLGRvbVByb3BzOntpbm5lckhUTUw6dC5fcyh0LmhlYWRlcil9fSk6dC5fZSgpLHQubGVhZD9uKFwicFwiLHtzdGF0aWNDbGFzczpcImxlYWRcIixkb21Qcm9wczp7aW5uZXJIVE1MOnQuX3ModC5sZWFkKX19KTp0Ll9lKCksdC5fdChcImRlZmF1bHRcIildLDIpXSl9LHN0YXRpY1JlbmRlckZuczpbXSxjb21wdXRlZDp7fSxwcm9wczp7Zmx1aWQ6e3R5cGU6Qm9vbGVhbixkZWZhdWx0OiExfSxjb250YWluZXJGbHVpZDp7dHlwZTpCb29sZWFuLGRlZmF1bHQ6ITF9LGhlYWRlcjp7dHlwZTpTdHJpbmcsZGVmYXVsdDpudWxsfSxsZWFkOnt0eXBlOlN0cmluZyxkZWZhdWx0Om51bGx9fX0sYmFkZ2U9e3JlbmRlcjpmdW5jdGlvbigpe3ZhciB0PXRoaXMsZT10LiRjcmVhdGVFbGVtZW50O3JldHVybih0Ll9zZWxmLl9jfHxlKShcInNwYW5cIix7Y2xhc3M6W1wiYmFkZ2VcIix0LmJhZGdlVmFyaWFudCx0LmJhZGdlUGlsbF19LFt0Ll90KFwiZGVmYXVsdFwiKV0sMil9LHN0YXRpY1JlbmRlckZuczpbXSxjb21wdXRlZDp7YmFkZ2VWYXJpYW50OmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMudmFyaWFudCYmXCJkZWZhdWx0XCIhPT10aGlzLnZhcmlhbnQ/XCJiYWRnZS1cIit0aGlzLnZhcmlhbnQ6XCJiYWRnZS1kZWZhdWx0XCJ9LGJhZGdlUGlsbDpmdW5jdGlvbigpe3JldHVybiB0aGlzLnBpbGw/XCJiYWRnZS1waWxsXCI6XCJcIn19LHByb3BzOnt2YXJpYW50Ont0eXBlOlN0cmluZyxkZWZhdWx0OlwiZGVmYXVsdFwifSxwaWxsOnt0eXBlOkJvb2xlYW4sZGVmYXVsdDohMX19fSxsaXN0R3JvdXA9e3JlbmRlcjpmdW5jdGlvbigpe3ZhciB0PXRoaXMsZT10LiRjcmVhdGVFbGVtZW50O3JldHVybih0Ll9zZWxmLl9jfHxlKSh0LnRhZyx7dGFnOlwiY29tcG9uZW50XCIsY2xhc3M6W1wibGlzdC1ncm91cFwiLHQuZmx1c2g/XCJsaXN0LWdyb3VwLWZsdXNoXCI6bnVsbF19LFt0Ll90KFwiZGVmYXVsdFwiKV0sMil9LHN0YXRpY1JlbmRlckZuczpbXSxwcm9wczp7dGFnOnt0eXBlOlN0cmluZyxkZWZhdWx0OlwiZGl2XCJ9LGZsdXNoOnt0eXBlOkJvb2xlYW4sZGVmYXVsdDohMX19fSxsaW5rUHJvcHMkMT1PYmplY3QuYXNzaWduKG9taXRMaW5rUHJvcHMoXCJocmVmXCIsXCJ0b1wiKSx7aHJlZjp7dHlwZTpwcm9wcy5ocmVmLnR5cGV9LHRvOnt0eXBlOnByb3BzLnRvLnR5cGV9LHRhZzp7dHlwZTpwcm9wcy50YWcudHlwZX19KSxhY3Rpb25UYWdzPVtcImFcIixcInJvdXRlci1saW5rXCIsXCJidXR0b25cIixcImItbGlua1wiXSxsaXN0R3JvdXBJdGVtPXtyZW5kZXI6ZnVuY3Rpb24oKXt2YXIgdD10aGlzLGU9dC4kY3JlYXRlRWxlbWVudDtyZXR1cm4odC5fc2VsZi5fY3x8ZSkodC5teVRhZyx0Ll9iKHtyZWY6XCJpdGVtXCIsdGFnOlwiY29tcG9uZW50XCIsY2xhc3M6dC5jbGFzc09iamVjdH0sXCJjb21wb25lbnRcIix0LmNvbmRpdGlvbmFsTGlua1Byb3BzKSxbdC5fdChcImRlZmF1bHRcIildLDIpfSxzdGF0aWNSZW5kZXJGbnM6W10sY29tcG9uZW50czp7Ykxpbms6Ykxpbmt9LGNvbXB1dGVkOntsaW5rUHJvcHM6Y29tcHV0ZWQubGlua1Byb3BzLGNsYXNzT2JqZWN0OmZ1bmN0aW9uKCl7cmV0dXJuW1wibGlzdC1ncm91cC1pdGVtXCIsdGhpcy5saXN0U3RhdGUsdGhpcy5hY3RpdmU/XCJhY3RpdmVcIjpudWxsLHRoaXMuZGlzYWJsZWQ/XCJkaXNhYmxlZFwiOm51bGwsdGhpcy5pc0FjdGlvbj9cImxpc3QtZ3JvdXAtaXRlbS1hY3Rpb25cIjpudWxsXX0saXNBY3Rpb246ZnVuY3Rpb24oKXtyZXR1cm4hMSE9PXRoaXMuYWN0aW9uJiYhISh0aGlzLmFjdGlvbnx8dGhpcy50b3x8dGhpcy5ocmVmfHxhY3Rpb25UYWdzLmluY2x1ZGVzKHRoaXMudGFnKSl9LGxpc3RTdGF0ZTpmdW5jdGlvbigpe3JldHVybiB0aGlzLnZhcmlhbnQ/XCJsaXN0LWdyb3VwLWl0ZW0tXCIrdGhpcy52YXJpYW50Om51bGx9LG15VGFnOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMudGFnP3RoaXMudGFnOnRoaXMudG98fHRoaXMuaHJlZj9cImItbGlua1wiOlwiZGl2XCJ9LGNvbmRpdGlvbmFsTGlua1Byb3BzOmZ1bmN0aW9uKCl7cmV0dXJuXCJiLWxpbmtcIiE9PXRoaXMubXlUYWc/e306dGhpcy5saW5rUHJvcHN9fSxwcm9wczpPYmplY3QuYXNzaWduKGxpbmtQcm9wcyQxLHthY3Rpb246e3R5cGU6Qm9vbGVhbixkZWZhdWx0Om51bGx9LHZhcmlhbnQ6e3R5cGU6U3RyaW5nLGRlZmF1bHQ6bnVsbH19KX0sbWVkaWE9e3JlbmRlcjpmdW5jdGlvbigpe3ZhciB0PXRoaXMsZT10LiRjcmVhdGVFbGVtZW50LG49dC5fc2VsZi5fY3x8ZTtyZXR1cm4gbihcImRpdlwiLHtzdGF0aWNDbGFzczpcIm1lZGlhXCJ9LFt0LnJpZ2h0QWxpZ24/dC5fZSgpOm4oXCJkaXZcIix7Y2xhc3M6W1wiZC1mbGV4XCIsXCJtci0zXCIsdC52ZXJ0aWNhbEFsaWduQ2xhc3NdfSxbdC5fdChcImFzaWRlXCIpXSwyKSxuKFwiZGl2XCIse3N0YXRpY0NsYXNzOlwibWVkaWEtYm9keVwifSxbdC5fdChcImRlZmF1bHRcIildLDIpLHQucmlnaHRBbGlnbj9uKFwiZGl2XCIse2NsYXNzOltcImQtZmxleFwiLFwibWwtM1wiLHQudmVydGljYWxBbGlnbkNsYXNzXX0sW3QuX3QoXCJhc2lkZVwiKV0sMik6dC5fZSgpXSl9LHN0YXRpY1JlbmRlckZuczpbXSxjb21wdXRlZDp7dmVydGljYWxBbGlnbkNsYXNzOmZ1bmN0aW9uKCl7cmV0dXJuXCJhbGlnbi1zZWxmLVwiK3RoaXMudmVydGljYWxBbGlnbn19LHByb3BzOntyaWdodEFsaWduOnt0eXBlOkJvb2xlYW4sZGVmYXVsdDohMX0sdmVydGljYWxBbGlnbjp7dHlwZTpTdHJpbmcsZGVmYXVsdDpcInRvcFwifX19LEZPQ1VTX1NFTEVDVE9SPVtcImJ1dHRvbjpub3QoW2Rpc2FibGVkXSlcIixcImlucHV0Om5vdChbZGlzYWJsZWRdKVwiLFwic2VsZWN0Om5vdChbZGlzYWJsZWRdKVwiLFwidGV4dGFyZWE6bm90KFtkaXNhYmxlZF0pXCIsXCJhOm5vdChbZGlzYWJsZWRdKTpub3QoLmRpc2FibGVkKVwiLFwiW3RhYmluZGV4XTpub3QoW2Rpc2FibGVkXSk6bm90KC5kaXNhYmxlZClcIl0uam9pbihcIixcIiksbW9kYWw9e3JlbmRlcjpmdW5jdGlvbigpe3ZhciB0PXRoaXMsZT10LiRjcmVhdGVFbGVtZW50LG49dC5fc2VsZi5fY3x8ZTtyZXR1cm4gbihcImRpdlwiLFtuKFwidHJhbnNpdGlvbi1ncm91cFwiLHthdHRyczp7XCJlbnRlci1jbGFzc1wiOlwiaGlkZGVuXCIsXCJlbnRlci10by1jbGFzc1wiOlwiXCIsXCJlbnRlci1hY3RpdmUtY2xhc3NcIjpcIlwiLFwibGVhdmUtY2xhc3NcIjpcInNob3dcIixcImxlYXZlLWFjdGl2ZS1jbGFzc1wiOlwiXCIsXCJsZWF2ZS10by1jbGFzc1wiOlwiaGlkZGVuXCJ9LG9uOntcImFmdGVyLWVudGVyXCI6dC5mb2N1c0ZpcnN0fX0sW24oXCJkaXZcIix7ZGlyZWN0aXZlczpbe25hbWU6XCJzaG93XCIscmF3TmFtZTpcInYtc2hvd1wiLHZhbHVlOnQuaXNfdmlzaWJsZSxleHByZXNzaW9uOlwiaXNfdmlzaWJsZVwifV0sa2V5OlwibW9kYWxcIixyZWY6XCJtb2RhbFwiLGNsYXNzOltcIm1vZGFsXCIse2ZhZGU6IXQubm9GYWRlLHNob3c6dC5pc192aXNpYmxlfV0sYXR0cnM6e2lkOnQuaWR8fG51bGwscm9sZTpcImRpYWxvZ1wifSxvbjp7Y2xpY2s6ZnVuY3Rpb24oZSl7dC5vbkNsaWNrT3V0KCl9LGtleXVwOmZ1bmN0aW9uKGUpe2lmKCEoXCJidXR0b25cImluIGUpJiZ0Ll9rKGUua2V5Q29kZSxcImVzY1wiLDI3KSlyZXR1cm4gbnVsbDt0Lm9uRXNjKCl9fX0sW24oXCJkaXZcIix7Y2xhc3M6W1wibW9kYWwtZGlhbG9nXCIsXCJtb2RhbC1cIit0LnNpemVdfSxbbihcImRpdlwiLHtyZWY6XCJjb250ZW50XCIsc3RhdGljQ2xhc3M6XCJtb2RhbC1jb250ZW50XCIsYXR0cnM6e3RhYmluZGV4OlwiLTFcIixyb2xlOlwiZG9jdW1lbnRcIixcImFyaWEtbGFiZWxsZWRieVwiOnQuaGlkZUhlYWRlcnx8IXQuaWQ/bnVsbDp0LmlkK1wiX19CVl90aXRsZV9cIixcImFyaWEtZGVzY3JpYmVkYnlcIjp0LmlkP3QuaWQrXCJfX0JWX2JvZHlfXCI6bnVsbH0sb246e2NsaWNrOmZ1bmN0aW9uKHQpe3Quc3RvcFByb3BhZ2F0aW9uKCl9fX0sW3QuaGlkZUhlYWRlcj90Ll9lKCk6bihcImhlYWRlclwiLHtyZWY6XCJoZWFkZXJcIixzdGF0aWNDbGFzczpcIm1vZGFsLWhlYWRlclwifSxbdC5fdChcIm1vZGFsLWhlYWRlclwiLFtuKFwiaDVcIix7c3RhdGljQ2xhc3M6XCJtb2RhbC10aXRsZVwiLGF0dHJzOntpZDp0LmlkP3QuaWQrXCJfX0JWX3RpdGxlX1wiOm51bGx9fSxbdC5fdChcIm1vZGFsLXRpdGxlXCIsW3QuX3YodC5fcyh0LnRpdGxlKSldKV0sMiksdC5oaWRlSGVhZGVyQ2xvc2U/dC5fZSgpOm4oXCJidXR0b25cIix7c3RhdGljQ2xhc3M6XCJjbG9zZVwiLGF0dHJzOnt0eXBlOlwiYnV0dG9uXCIsXCJhcmlhLWxhYmVsXCI6dC5oZWFkZXJDbG9zZUxhYmVsfSxvbjp7Y2xpY2s6dC5oaWRlfX0sW24oXCJzcGFuXCIse2F0dHJzOntcImFyaWEtaGlkZGVuXCI6XCJ0cnVlXCJ9fSxbdC5fdihcIsOXXCIpXSldKV0pXSwyKSxuKFwiZGl2XCIse3JlZjpcImJvZHlcIixzdGF0aWNDbGFzczpcIm1vZGFsLWJvZHlcIixhdHRyczp7aWQ6dC5pZD90LmlkK1wiX19CVl9ib2R5X1wiOm51bGx9fSxbdC5fdChcImRlZmF1bHRcIildLDIpLHQuaGlkZUZvb3Rlcj90Ll9lKCk6bihcImZvb3RlclwiLHtyZWY6XCJmb290ZXJcIixzdGF0aWNDbGFzczpcIm1vZGFsLWZvb3RlclwifSxbdC5fdChcIm1vZGFsLWZvb3RlclwiLFt0Lm9rT25seT90Ll9lKCk6bihcImItYnRuXCIse2F0dHJzOnt2YXJpYW50Olwic2Vjb25kYXJ5XCIsc2l6ZTp0LmJ1dHRvblNpemV9LG9uOntjbGljazpmdW5jdGlvbihlKXt0LmhpZGUoITEpfX19LFt0Ll90KFwibW9kYWwtY2FuY2VsXCIsW3QuX3YodC5fcyh0LmNsb3NlVGl0bGUpKV0pXSwyKSxuKFwiYi1idG5cIix7YXR0cnM6e3ZhcmlhbnQ6XCJwcmltYXJ5XCIsc2l6ZTp0LmJ1dHRvblNpemUsZGlzYWJsZWQ6dC5va0Rpc2FibGVkfSxvbjp7Y2xpY2s6ZnVuY3Rpb24oZSl7dC5oaWRlKCEwKX19fSxbdC5fdChcIm1vZGFsLW9rXCIsW3QuX3YodC5fcyh0Lm9rVGl0bGUpKV0pXSwyKV0pXSwyKV0pXSldKSx0LmlzX3Zpc2libGU/bihcImRpdlwiLHtrZXk6XCJtb2RhbC1iYWNrZHJvcFwiLGNsYXNzOltcIm1vZGFsLWJhY2tkcm9wXCIse2ZhZGU6IXQubm9GYWRlLHNob3c6dC5pc192aXNpYmxlfV19KTp0Ll9lKCldKV0sMSl9LHN0YXRpY1JlbmRlckZuczpbXSxfc2NvcGVJZDpcImRhdGEtdi0xYjRjYmI2OFwiLGNvbXBvbmVudHM6e2JCdG46YkJ0bn0sZGF0YTpmdW5jdGlvbigpe3JldHVybntpc192aXNpYmxlOiExLHJldHVybl9mb2N1czp0aGlzLnJldHVybkZvY3VzfHxudWxsfX0sbW9kZWw6e3Byb3A6XCJ2aXNpYmxlXCIsZXZlbnQ6XCJjaGFuZ2VcIn0sY29tcHV0ZWQ6e2JvZHk6ZnVuY3Rpb24oKXtpZihcInVuZGVmaW5lZFwiIT10eXBlb2YgZG9jdW1lbnQpcmV0dXJuIGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoXCJib2R5XCIpfX0sd2F0Y2g6e3Zpc2libGU6ZnVuY3Rpb24odCxlKXt0IT09ZSYmKHQ/dGhpcy5zaG93KCk6dGhpcy5oaWRlKCkpfX0scHJvcHM6e2lkOnt0eXBlOlN0cmluZyxkZWZhdWx0Om51bGx9LHRpdGxlOnt0eXBlOlN0cmluZyxkZWZhdWx0OlwiXCJ9LHNpemU6e3R5cGU6U3RyaW5nLGRlZmF1bHQ6XCJtZFwifSxidXR0b25TaXplOnt0eXBlOlN0cmluZyxkZWZhdWx0OlwibWRcIn0sbm9GYWRlOnt0eXBlOkJvb2xlYW4sZGVmYXVsdDohMX0sbm9DbG9zZU9uQmFja2Ryb3A6e3R5cGU6Qm9vbGVhbixkZWZhdWx0OiExfSxub0Nsb3NlT25Fc2M6e3R5cGU6Qm9vbGVhbixkZWZhdWx0OiExfSxub0F1dG9Gb2N1czp7dHlwZTpCb29sZWFuLGRlZmF1bHQ6ITF9LGhpZGVIZWFkZXI6e3R5cGU6Qm9vbGVhbixkZWZhdWx0OiExfSxoaWRlRm9vdGVyOnt0eXBlOkJvb2xlYW4sZGVmYXVsdDohMX0sb2tPbmx5Ont0eXBlOkJvb2xlYW4sZGVmYXVsdDohMX0sb2tEaXNhYmxlZDp7dHlwZTpCb29sZWFuLGRlZmF1bHQ6ITF9LGhpZGVIZWFkZXJDbG9zZTp7dHlwZTpCb29sZWFuLGRlZmF1bHQ6ITF9LHZpc2libGU6e3R5cGU6Qm9vbGVhbixkZWZhdWx0OiExfSxyZXR1cm5Gb2N1czp7ZGVmYXVsdDpudWxsfSxoZWFkZXJDbG9zZUxhYmVsOnt0eXBlOlN0cmluZyxkZWZhdWx0OlwiQ2xvc2VcIn0sY2xvc2VUaXRsZTp7dHlwZTpTdHJpbmcsZGVmYXVsdDpcIkNsb3NlXCJ9LG9rVGl0bGU6e3R5cGU6U3RyaW5nLGRlZmF1bHQ6XCJPS1wifX0sbWV0aG9kczp7c2hvdzpmdW5jdGlvbigpe3RoaXMuaXNfdmlzaWJsZXx8KHRoaXMuJGVtaXQoXCJzaG93XCIpLHRoaXMuaXNfdmlzaWJsZT0hMCx0aGlzLiRyb290LiRlbWl0KFwic2hvd246Om1vZGFsXCIsdGhpcy5pZCksdGhpcy5ib2R5LmNsYXNzTGlzdC5hZGQoXCJtb2RhbC1vcGVuXCIpLHRoaXMuJGVtaXQoXCJzaG93blwiKSx0aGlzLiRlbWl0KFwiY2hhbmdlXCIsITApLFwidW5kZWZpbmVkXCIhPXR5cGVvZiBkb2N1bWVudCYmKGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJmb2N1c2luXCIsdGhpcy5lbmZvcmNlRm9jdXMsITEpLGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJmb2N1c2luXCIsdGhpcy5lbmZvcmNlRm9jdXMsITEpKSl9LGhpZGU6ZnVuY3Rpb24odCl7aWYodGhpcy5pc192aXNpYmxlKXt2YXIgZT0hMSxuPXtpc09LOnQsY2FuY2VsOmZ1bmN0aW9uKCl7ZT0hMH19O3RoaXMuJGVtaXQoXCJjaGFuZ2VcIiwhMSksdGhpcy4kZW1pdChcImhpZGVcIixuKSwhMD09PXQ/dGhpcy4kZW1pdChcIm9rXCIsbik6ITE9PT10JiZ0aGlzLiRlbWl0KFwiY2FuY2VsXCIsbiksZXx8KFwidW5kZWZpbmVkXCIhPXR5cGVvZiBkb2N1bWVudCYmKGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJmb2N1c2luXCIsdGhpcy5lbmZvcmNlRm9jdXMsITEpLHRoaXMucmV0dXJuRm9jdXNUbygpKSx0aGlzLmlzX3Zpc2libGU9ITEsdGhpcy4kcm9vdC4kZW1pdChcImhpZGRlbjo6bW9kYWxcIix0aGlzLmlkKSx0aGlzLiRlbWl0KFwiaGlkZGVuXCIsbiksdGhpcy5ib2R5LmNsYXNzTGlzdC5yZW1vdmUoXCJtb2RhbC1vcGVuXCIpKX19LG9uQ2xpY2tPdXQ6ZnVuY3Rpb24oKXt0aGlzLmlzX3Zpc2libGUmJiF0aGlzLm5vQ2xvc2VPbkJhY2tkcm9wJiZ0aGlzLmhpZGUoKX0sb25Fc2M6ZnVuY3Rpb24oKXt0aGlzLmlzX3Zpc2libGUmJiF0aGlzLm5vQ2xvc2VPbkVzYyYmdGhpcy5oaWRlKCl9LGZvY3VzRmlyc3Q6ZnVuY3Rpb24oKXt2YXIgdD10aGlzO1widW5kZWZpbmVkXCIhPXR5cGVvZiBkb2N1bWVudCYmdGhpcy4kbmV4dFRpY2soZnVuY3Rpb24oKXtpZighZG9jdW1lbnQuYWN0aXZlRWxlbWVudHx8IXQuJHJlZnMuY29udGVudC5jb250YWlucyhkb2N1bWVudC5hY3RpdmVFbGVtZW50KSl7dmFyIGU7dC5ub0F1dG9Gb2N1c3x8KHQuJHJlZnMuYm9keSYmKGU9ZmluZEZpcnN0VmlzaWJsZSh0LiRyZWZzLmJvZHksRk9DVVNfU0VMRUNUT1IpKSwhZSYmdC4kcmVmcy5mb290ZXImJihlPWZpbmRGaXJzdFZpc2libGUodC4kcmVmcy5mb290ZXIsRk9DVVNfU0VMRUNUT1IpKSwhZSYmdC4kcmVmcy5oZWFkZXImJihlPWZpbmRGaXJzdFZpc2libGUodC4kcmVmcy5oZWFkZXIsRk9DVVNfU0VMRUNUT1IpKSksZXx8KGU9dC4kcmVmcy5jb250ZW50KSxlJiZlLmZvY3VzJiZlLmZvY3VzKCl9fSl9LHJldHVybkZvY3VzVG86ZnVuY3Rpb24oKXt2YXIgdD10aGlzLnJldHVybkZvY3VzfHx0aGlzLnJldHVybl9mb2N1c3x8bnVsbDt0JiYoXCJzdHJpbmdcIj09dHlwZW9mIHQmJih0PWRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IodCkpLHQmJnQuJGVsJiZcImZ1bmN0aW9uXCI9PXR5cGVvZiB0LiRlbC5mb2N1cz90LiRlbC5mb2N1cygpOnQmJlwiZnVuY3Rpb25cIj09dHlwZW9mIHQuZm9jdXMmJnQuZm9jdXMoKSl9LGVuZm9yY2VGb2N1czpmdW5jdGlvbih0KXt0aGlzLmlzX3Zpc2libGUmJmRvY3VtZW50IT09dC50YXJnZXQmJnRoaXMuJHJlZnMuY29udGVudCYmdGhpcy4kcmVmcy5jb250ZW50IT09dC50YXJnZXQmJiF0aGlzLiRyZWZzLmNvbnRlbnQuY29udGFpbnModC50YXJnZXQpJiZ0aGlzLiRyZWZzLmNvbnRlbnQuZm9jdXMoKX19LGNyZWF0ZWQ6ZnVuY3Rpb24oKXt2YXIgdD10aGlzO3RoaXMuJHJvb3QuJG9uKFwic2hvdzo6bW9kYWxcIixmdW5jdGlvbihlLG4pe2U9PT10LmlkJiYodC5yZXR1cm5fZm9jdXM9bnx8bnVsbCx0LnNob3coKSl9KSx0aGlzLiRyb290LiRvbihcImhpZGU6Om1vZGFsXCIsZnVuY3Rpb24oZSl7ZT09PXQuaWQmJnQuaGlkZSgpfSl9LG1vdW50ZWQ6ZnVuY3Rpb24oKXshMD09PXRoaXMudmlzaWJsZSYmdGhpcy5zaG93KCl9LGRlc3Ryb3llZDpmdW5jdGlvbigpe1widW5kZWZpbmVkXCIhPXR5cGVvZiBkb2N1bWVudCYmZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImZvY3VzaW5cIix0aGlzLmVuZm9yY2VGb2N1cywhMSl9fSxuYXY9e3JlbmRlcjpmdW5jdGlvbigpe3ZhciB0PXRoaXMsZT10LiRjcmVhdGVFbGVtZW50O3JldHVybih0Ll9zZWxmLl9jfHxlKSh0LnR5cGUse3RhZzpcImNvbXBvbmVudFwiLGNsYXNzOnQuY2xhc3NPYmplY3R9LFt0Ll90KFwiZGVmYXVsdFwiKV0sMil9LHN0YXRpY1JlbmRlckZuczpbXSxjb21wdXRlZDp7Y2xhc3NPYmplY3Q6ZnVuY3Rpb24oKXtyZXR1cm57bmF2OiEwLFwibmF2YmFyLW5hdlwiOnRoaXMuaXNOYXZCYXIsXCJuYXYtdGFic1wiOnRoaXMudGFicyxcIm5hdi1waWxsc1wiOnRoaXMucGlsbHMsXCJmbGV4LWNvbHVtblwiOnRoaXMudmVydGljYWwsXCJuYXYtZmlsbFwiOnRoaXMuZmlsbCxcIm5hdi1qdXN0aWZpZWRcIjp0aGlzLmp1c3RpZmllZH19fSxwcm9wczp7dHlwZTp7dHlwZTpTdHJpbmcsZGVmYXVsdDpcInVsXCJ9LGZpbGw6e3R5cGU6Qm9vbGVhbixkZWZhdWx0OiExfSxqdXN0aWZpZWQ6e3R5cGU6Qm9vbGVhbixkZWZhdWx0OiExfSx0YWJzOnt0eXBlOkJvb2xlYW4sZGVmYXVsdDohMX0scGlsbHM6e3R5cGU6Qm9vbGVhbixkZWZhdWx0OiExfSx2ZXJ0aWNhbDp7dHlwZTpCb29sZWFuLGRlZmF1bHQ6ITF9LGlzTmF2QmFyOnt0eXBlOkJvb2xlYW4sZGVmYXVsdDohMX19fSxuYXZJdGVtPXtyZW5kZXI6ZnVuY3Rpb24oKXt2YXIgdD10aGlzLGU9dC4kY3JlYXRlRWxlbWVudCxuPXQuX3NlbGYuX2N8fGU7cmV0dXJuIG4oXCJsaVwiLHtzdGF0aWNDbGFzczpcIm5hdi1pdGVtXCJ9LFtuKFwiYi1saW5rXCIsdC5fYih7c3RhdGljQ2xhc3M6XCJuYXYtbGlua1wiLG9uOntjbGljazpmdW5jdGlvbihlKXt0LiRlbWl0KFwiY2xpY2tcIixlKX19fSxcImItbGlua1wiLHQubGlua1Byb3BzKSxbdC5fdChcImRlZmF1bHRcIildLDIpXSwxKX0sc3RhdGljUmVuZGVyRm5zOltdLGNvbXBvbmVudHM6e2JMaW5rOmJMaW5rfSxwcm9wczpwcm9wcyxjb21wdXRlZDp7bGlua1Byb3BzOmNvbXB1dGVkLmxpbmtQcm9wc319LG5hdkl0ZW1Ecm9wZG93bj17cmVuZGVyOmZ1bmN0aW9uKCl7dmFyIHQ9dGhpcyxlPXQuJGNyZWF0ZUVsZW1lbnQsbj10Ll9zZWxmLl9jfHxlO3JldHVybiBuKFwibGlcIix7Y2xhc3M6W1wibmF2LWl0ZW1cIixcImRyb3Bkb3duXCIse2Ryb3B1cDp0LmRyb3B1cCxzaG93OnQudmlzaWJsZX1dLGF0dHJzOntpZDp0LmlkfHxudWxsfX0sW24oXCJhXCIse3JlZjpcImJ1dHRvblwiLGNsYXNzOltcIm5hdi1saW5rXCIsdC5kcm9wZG93blRvZ2dsZSx7ZGlzYWJsZWQ6dC5kaXNhYmxlZH1dLGF0dHJzOntocmVmOlwiI1wiLGlkOnQuaWQ/dC5pZCtcIl9fQlZfYnV0dG9uX1wiOm51bGwsXCJhcmlhLWhhc3BvcHVwXCI6XCJ0cnVlXCIsXCJhcmlhLWV4cGFuZGVkXCI6dC52aXNpYmxlP1widHJ1ZVwiOlwiZmFsc2VcIixkaXNhYmxlZDp0LmRpc2FibGVkfSxvbjp7Y2xpY2s6ZnVuY3Rpb24oZSl7ZS5zdG9wUHJvcGFnYXRpb24oKSxlLnByZXZlbnREZWZhdWx0KCksdC50b2dnbGUoZSl9LGtleWRvd246W2Z1bmN0aW9uKGUpe2lmKCEoXCJidXR0b25cImluIGUpJiZ0Ll9rKGUua2V5Q29kZSxcImVudGVyXCIsMTMpKXJldHVybiBudWxsO2Uuc3RvcFByb3BhZ2F0aW9uKCksZS5wcmV2ZW50RGVmYXVsdCgpLHQudG9nZ2xlKGUpfSxmdW5jdGlvbihlKXtpZighKFwiYnV0dG9uXCJpbiBlKSYmdC5fayhlLmtleUNvZGUsXCJzcGFjZVwiLDMyKSlyZXR1cm4gbnVsbDtlLnN0b3BQcm9wYWdhdGlvbigpLGUucHJldmVudERlZmF1bHQoKSx0LnRvZ2dsZShlKX1dfX0sW3QuX3QoXCJ0ZXh0XCIsW24oXCJzcGFuXCIse2RvbVByb3BzOntpbm5lckhUTUw6dC5fcyh0LnRleHQpfX0pXSldLDIpLG4oXCJkaXZcIix7cmVmOlwibWVudVwiLGNsYXNzOltcImRyb3Bkb3duLW1lbnVcIix7XCJkcm9wZG93bi1tZW51LXJpZ2h0XCI6dC5yaWdodH1dLGF0dHJzOntyb2xlOlwibWVudVwiLFwiYXJpYS1sYWJlbGxlZGJ5XCI6dC5pZD90LmlkK1wiX19CVl9idXR0b25fXCI6bnVsbH0sb246e2tleXVwOmZ1bmN0aW9uKGUpe2lmKCEoXCJidXR0b25cImluIGUpJiZ0Ll9rKGUua2V5Q29kZSxcImVzY1wiLDI3KSlyZXR1cm4gbnVsbDt0Lm9uRXNjKGUpfSxrZXlkb3duOltmdW5jdGlvbihlKXtpZighKFwiYnV0dG9uXCJpbiBlKSYmdC5fayhlLmtleUNvZGUsXCJ0YWJcIiw5KSlyZXR1cm4gbnVsbDt0Lm9uVGFiKGUpfSxmdW5jdGlvbihlKXtpZighKFwiYnV0dG9uXCJpbiBlKSYmdC5fayhlLmtleUNvZGUsXCJ1cFwiLDM4KSlyZXR1cm4gbnVsbDt0LmZvY3VzTmV4dChlLCEwKX0sZnVuY3Rpb24oZSl7aWYoIShcImJ1dHRvblwiaW4gZSkmJnQuX2soZS5rZXlDb2RlLFwiZG93blwiLDQwKSlyZXR1cm4gbnVsbDt0LmZvY3VzTmV4dChlLCExKX1dLG1vdXNlb3ZlcjpmdW5jdGlvbihlKXt0LmZvY3VzSG92ZXJlZChlKX19fSxbdC5fdChcImRlZmF1bHRcIildLDIpXSl9LHN0YXRpY1JlbmRlckZuczpbXSxtaXhpbnM6W2NsaWNrT3V0LGRyb3Bkb3duXSxkYXRhOmZ1bmN0aW9uKCl7cmV0dXJue3Zpc2libGU6ITF9fSxjb21wdXRlZDp7ZHJvcGRvd25Ub2dnbGU6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5jYXJldD9cImRyb3Bkb3duLXRvZ2dsZVwiOlwiXCJ9fSxwcm9wczp7aWQ6e3R5cGU6U3RyaW5nfSxjYXJldDp7dHlwZTpCb29sZWFuLGRlZmF1bHQ6ITB9fSxtZXRob2RzOntjbGlja091dExpc3RlbmVyOmZ1bmN0aW9uKCl7dGhpcy52aXNpYmxlPSExfX19LG5hdlRvZ2dsZT17cmVuZGVyOmZ1bmN0aW9uKCl7dmFyIHQ9dGhpcyxlPXQuJGNyZWF0ZUVsZW1lbnQsbj10Ll9zZWxmLl9jfHxlO3JldHVybiBuKFwiYnV0dG9uXCIse2NsYXNzOnQuY2xhc3NPYmplY3QsYXR0cnM6e3R5cGU6XCJidXR0b25cIixcImFyaWEtbGFiZWxcIjp0LmxhYmVsLFwiYXJpYS1jb250cm9sc1wiOnQudGFyZ2V0LmlkP3QudGFyZ2V0LmlkOnQudGFyZ2V0LFwiYXJpYS1leHBhbmRlZFwiOnQudG9nZ2xlU3RhdGU/XCJ0cnVlXCI6XCJmYWxzZVwifSxvbjp7Y2xpY2s6dC5vbmNsaWNrfX0sW24oXCJzcGFuXCIse3N0YXRpY0NsYXNzOlwibmF2YmFyLXRvZ2dsZXItaWNvblwifSldKX0sc3RhdGljUmVuZGVyRm5zOltdLGNvbXB1dGVkOntjbGFzc09iamVjdDpmdW5jdGlvbigpe3JldHVybltcIm5hdmJhci10b2dnbGVyXCIsXCJuYXZiYXItdG9nZ2xlci1cIit0aGlzLnBvc2l0aW9uXX19LGRhdGE6ZnVuY3Rpb24oKXtyZXR1cm57dG9nZ2xlU3RhdGU6ITF9fSxwcm9wczp7bGFiZWw6e3R5cGU6U3RyaW5nLGRlZmF1bHQ6XCJUb2dnbGUgbmF2aWdhdGlvblwifSxwb3NpdGlvbjp7dHlwZTpTdHJpbmcsZGVmYXVsdDpcInJpZ2h0XCJ9LHRhcmdldDp7cmVxdWlyZWQ6ITB9fSxtZXRob2RzOntvbmNsaWNrOmZ1bmN0aW9uKCl7dmFyIHQ9dGhpcy50YXJnZXQ7dC50b2dnbGUmJnQudG9nZ2xlKCksdGhpcy4kcm9vdC4kZW1pdChcImNvbGxhcHNlOjp0b2dnbGVcIix0aGlzLnRhcmdldCl9fSxjcmVhdGVkOmZ1bmN0aW9uKCl7dmFyIHQ9dGhpczt0aGlzLiRyb290LiRvbihcImNvbGxhcHNlOjp0b2dnbGU6OnN0YXRlXCIsZnVuY3Rpb24oZSxuKXtlIT09dC50YXJnZXQmJmUhPT10LnRhcmdldC5pZHx8KHQudG9nZ2xlU3RhdGU9bil9KX19LG5hdmJhcj17cmVuZGVyOmZ1bmN0aW9uKCl7dmFyIHQ9dGhpcyxlPXQuJGNyZWF0ZUVsZW1lbnQ7cmV0dXJuKHQuX3NlbGYuX2N8fGUpKFwibmF2XCIse2NsYXNzOnQuY2xhc3NPYmplY3R9LFt0Ll90KFwiZGVmYXVsdFwiKV0sMil9LHN0YXRpY1JlbmRlckZuczpbXSxjb21wdXRlZDp7Y2xhc3NPYmplY3Q6ZnVuY3Rpb24oKXtyZXR1cm5bXCJuYXZiYXJcIix0aGlzLnR5cGU/XCJuYXZiYXItXCIrdGhpcy50eXBlOm51bGwsdGhpcy52YXJpYW50P1wiYmctXCIrdGhpcy52YXJpYW50Om51bGwsdGhpcy5maXhlZD9cImZpeGVkLVwiK3RoaXMuZml4ZWQ6bnVsbCx0aGlzLnN0aWNreT9cInN0aWNreS10b3BcIjpudWxsLHRoaXMudG9nZ2xlYWJsZT90aGlzLnRvZ2dsZWFibGVDbGFzczpudWxsXX0sdG9nZ2xlYWJsZUNsYXNzOmZ1bmN0aW9uKCl7dmFyIHQ9XCJuYXZiYXItdG9nZ2xlYWJsZVwiO3JldHVybiB0aGlzLnRvZ2dsZUJyZWFrcG9pbnQmJih0Kz1cIi1cIit0aGlzLnRvZ2dsZUJyZWFrcG9pbnQpLHR9fSxwcm9wczp7dHlwZTp7dHlwZTpTdHJpbmcsZGVmYXVsdDpcImxpZ2h0XCJ9LHZhcmlhbnQ6e3R5cGU6U3RyaW5nfSx0b2dnbGVhYmxlOnt0eXBlOkJvb2xlYW4sZGVmYXVsdDohMX0sdG9nZ2xlQnJlYWtwb2ludDp7dHlwZTpTdHJpbmcsZGVmYXVsdDpudWxsfSxmaXhlZDp7dHlwZTpTdHJpbmd9LHN0aWNreTp7dHlwZTpCb29sZWFuLGRlZmF1bHQ6ITF9fX0sbmF2VGV4dD17cmVuZGVyOmZ1bmN0aW9uKCl7dmFyIHQ9dGhpcyxlPXQuJGNyZWF0ZUVsZW1lbnQ7cmV0dXJuKHQuX3NlbGYuX2N8fGUpKFwic3BhblwiLHtzdGF0aWNDbGFzczpcIm5hdmJhci10ZXh0XCJ9LFt0Ll90KFwiZGVmYXVsdFwiKV0sMil9LHN0YXRpY1JlbmRlckZuczpbXSxwcm9wczp7fX0sbmF2Rm9ybT17cmVuZGVyOmZ1bmN0aW9uKCl7dmFyIHQ9dGhpcyxlPXQuJGNyZWF0ZUVsZW1lbnQ7cmV0dXJuKHQuX3NlbGYuX2N8fGUpKFwiYi1mb3JtXCIse2F0dHJzOntpZDp0LmlkfHxudWxsLGlubGluZTpcIlwifX0sW3QuX3QoXCJkZWZhdWx0XCIpXSwyKX0sc3RhdGljUmVuZGVyRm5zOltdLGNvbXBvbmVudHM6W2JGb3JtXSxwcm9wczp7aWQ6e3R5cGU6U3RyaW5nfX19LEVMTElQU0lTX1RIUkVTSE9MRD0zLHBhZ2luYXRpb249e3JlbmRlcjpmdW5jdGlvbigpe3ZhciB0PXRoaXMsZT10LiRjcmVhdGVFbGVtZW50LG49dC5fc2VsZi5fY3x8ZTtyZXR1cm4gbihcInVsXCIse2NsYXNzOltcInBhZ2luYXRpb25cIix0LmJ0blNpemVdLGF0dHJzOntyb2xlOnQucm9sZSxcImFyaWEtZGlzYWJsZWRcIjp0LmRpc2FibGVkP1widHJ1ZVwiOlwiZmFsc2VcIixcImFyaWEtbGFiZWxcIjp0LmFyaWFMYWJlbD90LmFyaWFMYWJlbDpudWxsfSxvbjp7Zm9jdXNpbjpmdW5jdGlvbihlKXtpZihlLnRhcmdldCE9PWUuY3VycmVudFRhcmdldClyZXR1cm4gbnVsbDt0LmZvY3VzQ3VycmVudChlKX0sa2V5ZG93bjpbZnVuY3Rpb24oZSl7cmV0dXJuXCJidXR0b25cImluIGV8fCF0Ll9rKGUua2V5Q29kZSxcImxlZnRcIiwzNyk/XCJidXR0b25cImluIGUmJjAhPT1lLmJ1dHRvbj9udWxsOihlLnByZXZlbnREZWZhdWx0KCksdm9pZCB0LmZvY3VzUHJldihlKSk6bnVsbH0sZnVuY3Rpb24oZSl7cmV0dXJuXCJidXR0b25cImluIGV8fCF0Ll9rKGUua2V5Q29kZSxcInJpZ2h0XCIsMzkpP1wiYnV0dG9uXCJpbiBlJiYyIT09ZS5idXR0b24/bnVsbDooZS5wcmV2ZW50RGVmYXVsdCgpLHZvaWQgdC5mb2N1c05leHQoZSkpOm51bGx9LGZ1bmN0aW9uKGUpe3JldHVybihcImJ1dHRvblwiaW4gZXx8IXQuX2soZS5rZXlDb2RlLFwibGVmdFwiLDM3KSkmJmUuc2hpZnRLZXk/XCJidXR0b25cImluIGUmJjAhPT1lLmJ1dHRvbj9udWxsOihlLnByZXZlbnREZWZhdWx0KCksdm9pZCB0LmZvY3VzRmlyc3QoZSkpOm51bGx9LGZ1bmN0aW9uKGUpe3JldHVybihcImJ1dHRvblwiaW4gZXx8IXQuX2soZS5rZXlDb2RlLFwicmlnaHRcIiwzOSkpJiZlLnNoaWZ0S2V5P1wiYnV0dG9uXCJpbiBlJiYyIT09ZS5idXR0b24/bnVsbDooZS5wcmV2ZW50RGVmYXVsdCgpLHZvaWQgdC5mb2N1c0xhc3QoZSkpOm51bGx9XX19LFt0LmhpZGVHb3RvRW5kQnV0dG9ucz90Ll9lKCk6W3QuaXNBY3RpdmUoMSl8fHQuZGlzYWJsZWQ/bihcImxpXCIse3N0YXRpY0NsYXNzOlwicGFnZS1pdGVtIGRpc2FibGVkXCIsYXR0cnM6e1wiYXJpYS1oaWRkZW5cIjpcInRydWVcIn19LFtuKFwic3BhblwiLHtzdGF0aWNDbGFzczpcInBhZ2UtbGlua1wiLGRvbVByb3BzOntpbm5lckhUTUw6dC5fcyh0LmZpcnN0VGV4dCl9fSldKTpuKFwibGlcIix7c3RhdGljQ2xhc3M6XCJwYWdlLWl0ZW1cIn0sW24oXCJhXCIse3N0YXRpY0NsYXNzOlwicGFnZS1saW5rXCIsYXR0cnM6e3JvbGU6dC5idXR0b25Sb2xlLFwiYXJpYS1sYWJlbFwiOnQubGFiZWxGaXJzdFBhZ2UsdGFiaW5kZXg6XCItMVwiLGhyZWY6XCIjXCJ9LG9uOntjbGljazpmdW5jdGlvbihlKXtlLnByZXZlbnREZWZhdWx0KCksdC5zZXRQYWdlKGUsMSl9LGtleWRvd246W2Z1bmN0aW9uKGUpe2lmKCEoXCJidXR0b25cImluIGUpJiZ0Ll9rKGUua2V5Q29kZSxcImVudGVyXCIsMTMpKXJldHVybiBudWxsO2UucHJldmVudERlZmF1bHQoKSx0LnNldFBhZ2UoZSwxKX0sZnVuY3Rpb24oZSl7aWYoIShcImJ1dHRvblwiaW4gZSkmJnQuX2soZS5rZXlDb2RlLFwic3BhY2VcIiwzMikpcmV0dXJuIG51bGw7ZS5wcmV2ZW50RGVmYXVsdCgpLHQuc2V0UGFnZShlLDEpfV19fSxbbihcInNwYW5cIix7YXR0cnM6e1wiYXJpYS1oaWRkZW5cIjpcInRydWVcIn0sZG9tUHJvcHM6e2lubmVySFRNTDp0Ll9zKHQuZmlyc3RUZXh0KX19KV0pXSldLHQuaXNBY3RpdmUoMSl8fHQuZGlzYWJsZWQ/bihcImxpXCIse3N0YXRpY0NsYXNzOlwicGFnZS1pdGVtIGRpc2FibGVkXCIsYXR0cnM6e1wiYXJpYS1oaWRkZW5cIjpcInRydWVcIn19LFtuKFwic3BhblwiLHtzdGF0aWNDbGFzczpcInBhZ2UtbGlua1wiLGRvbVByb3BzOntpbm5lckhUTUw6dC5fcyh0LnByZXZUZXh0KX19KV0pOm4oXCJsaVwiLHtzdGF0aWNDbGFzczpcInBhZ2UtaXRlbVwifSxbbihcImFcIix7c3RhdGljQ2xhc3M6XCJwYWdlLWxpbmtcIixhdHRyczp7cm9sZTp0LmJ1dHRvblJvbGUsXCJhcmlhLWxhYmVsXCI6dC5sYWJlbFByZXZQYWdlLHRhYmluZGV4OlwiLTFcIixocmVmOlwiI1wifSxvbjp7Y2xpY2s6ZnVuY3Rpb24oZSl7ZS5wcmV2ZW50RGVmYXVsdCgpLHQuc2V0UGFnZShlLHQuY3VycmVudFBhZ2UtMSl9LGtleWRvd246W2Z1bmN0aW9uKGUpe2lmKCEoXCJidXR0b25cImluIGUpJiZ0Ll9rKGUua2V5Q29kZSxcImVudGVyXCIsMTMpKXJldHVybiBudWxsO2UucHJldmVudERlZmF1bHQoKSx0LnNldFBhZ2UoZSx0LmN1cnJlbnRQYWdlLTEpfSxmdW5jdGlvbihlKXtpZighKFwiYnV0dG9uXCJpbiBlKSYmdC5fayhlLmtleUNvZGUsXCJzcGFjZVwiLDMyKSlyZXR1cm4gbnVsbDtlLnByZXZlbnREZWZhdWx0KCksdC5zZXRQYWdlKGUsdC5jdXJyZW50UGFnZS0xKX1dfX0sW24oXCJzcGFuXCIse2F0dHJzOntcImFyaWEtaGlkZGVuXCI6XCJ0cnVlXCJ9LGRvbVByb3BzOntpbm5lckhUTUw6dC5fcyh0LnByZXZUZXh0KX19KV0pXSksdC5zaG93Rmlyc3REb3RzP24oXCJsaVwiLHtzdGF0aWNDbGFzczpcInBhZ2UtaXRlbSBkaXNhYmxlZCBoaWRkZW4teHMtZG93blwiLGF0dHJzOntyb2xlOlwic2VwZXJhdG9yXCJ9fSxbbihcInNwYW5cIix7c3RhdGljQ2xhc3M6XCJwYWdlLWxpbmtcIixkb21Qcm9wczp7aW5uZXJIVE1MOnQuX3ModC5lbGxpcHNpc1RleHQpfX0pXSk6dC5fZSgpLHQuX2wodC5wYWdlTGlzdCxmdW5jdGlvbihlKXtyZXR1cm4gbihcImxpXCIse2tleTplLm51bWJlcixjbGFzczp0LnBhZ2VJdGVtQ2xhc3NlcyhlKX0sW24oXCJhXCIse2NsYXNzOnQucGFnZUxpbmtDbGFzc2VzKGUpLGF0dHJzOntyb2xlOnQuYnV0dG9uUm9sZSxkaXNhYmxlZDp0LmRpc2FibGVkLFwiYXJpYS1kaXNhYmxlZFwiOnQuZGlzYWJsZWQ/XCJ0cnVlXCI6XCJmYWxzZVwiLFwiYXJpYS1sYWJlbFwiOnQubGFiZWxQYWdlK1wiIFwiK2UubnVtYmVyLFwiYXJpYS1jdXJyZW50XCI6dC5pc0FjdGl2ZShlKT9cInRydWVcIjpcImZhbHNlXCIsXCJhcmlhLXBvc2luc2V0XCI6ZS5udW1iZXIsXCJhcmlhLXNldHNpemVcIjp0Lm51bWJlck9mUGFnZXMsdGFiaW5kZXg6XCItMVwifSxvbjp7Y2xpY2s6ZnVuY3Rpb24obil7bi5wcmV2ZW50RGVmYXVsdCgpLHQuc2V0UGFnZShuLGUubnVtYmVyKX0sa2V5ZG93bjpbZnVuY3Rpb24obil7aWYoIShcImJ1dHRvblwiaW4gbikmJnQuX2sobi5rZXlDb2RlLFwiZW50ZXJcIiwxMykpcmV0dXJuIG51bGw7bi5wcmV2ZW50RGVmYXVsdCgpLHQuc2V0UGFnZShuLGUubnVtYmVyKX0sZnVuY3Rpb24obil7aWYoIShcImJ1dHRvblwiaW4gbikmJnQuX2sobi5rZXlDb2RlLFwic3BhY2VcIiwzMikpcmV0dXJuIG51bGw7bi5wcmV2ZW50RGVmYXVsdCgpLHQuc2V0UGFnZShuLGUubnVtYmVyKX1dfX0sW3QuX3YodC5fcyhlLm51bWJlcikpXSldKX0pLHQuc2hvd0xhc3REb3RzP24oXCJsaVwiLHtzdGF0aWNDbGFzczpcInBhZ2UtaXRlbSBkaXNhYmxlZCBoaWRkZW4teHMtZG93blwiLGF0dHJzOntyb2xlOlwic2VwZXJhdG9yXCJ9fSxbbihcInNwYW5cIix7c3RhdGljQ2xhc3M6XCJwYWdlLWxpbmtcIixkb21Qcm9wczp7aW5uZXJIVE1MOnQuX3ModC5lbGxpcHNpc1RleHQpfX0pXSk6dC5fZSgpLHQuaXNBY3RpdmUodC5udW1iZXJPZlBhZ2VzKXx8dC5kaXNhYmxlZD9uKFwibGlcIix7c3RhdGljQ2xhc3M6XCJwYWdlLWl0ZW0gZGlzYWJsZWRcIixhdHRyczp7XCJhcmlhLWhpZGRlblwiOlwidHJ1ZVwifX0sW24oXCJzcGFuXCIse3N0YXRpY0NsYXNzOlwicGFnZS1saW5rXCIsZG9tUHJvcHM6e2lubmVySFRNTDp0Ll9zKHQubmV4dFRleHQpfX0pXSk6bihcImxpXCIse3N0YXRpY0NsYXNzOlwicGFnZS1pdGVtXCJ9LFtuKFwiYVwiLHtzdGF0aWNDbGFzczpcInBhZ2UtbGlua1wiLGF0dHJzOntyb2xlOnQuYnV0dG9uUm9sZSxcImFyaWEtbGFiZWxcIjp0LmxhYmVsTmV4dFBhZ2UsdGFiaW5kZXg6XCItMVwifSxvbjp7Y2xpY2s6ZnVuY3Rpb24oZSl7ZS5wcmV2ZW50RGVmYXVsdCgpLHQuc2V0UGFnZShlLHQuY3VycmVudFBhZ2UrMSl9LGtleWRvd246W2Z1bmN0aW9uKGUpe2lmKCEoXCJidXR0b25cImluIGUpJiZ0Ll9rKGUua2V5Q29kZSxcImVudGVyXCIsMTMpKXJldHVybiBudWxsO2UucHJldmVudERlZmF1bHQoKSx0LnNldFBhZ2UoZSx0LmN1cnJlbnRQYWdlKzEpfSxmdW5jdGlvbihlKXtpZighKFwiYnV0dG9uXCJpbiBlKSYmdC5fayhlLmtleUNvZGUsXCJzcGFjZVwiLDMyKSlyZXR1cm4gbnVsbDtlLnByZXZlbnREZWZhdWx0KCksdC5zZXRQYWdlKGUsdC5jdXJyZW50UGFnZSsxKX1dfX0sW24oXCJzcGFuXCIse2F0dHJzOntcImFyaWEtaGlkZGVuXCI6XCJ0cnVlXCJ9LGRvbVByb3BzOntpbm5lckhUTUw6dC5fcyh0Lm5leHRUZXh0KX19KV0pXSksdC5oaWRlR290b0VuZEJ1dHRvbnM/dC5fZSgpOlt0LmlzQWN0aXZlKHQubnVtYmVyT2ZQYWdlcyl8fHQuZGlzYWJsZWQ/bihcImxpXCIse3N0YXRpY0NsYXNzOlwicGFnZS1pdGVtIGRpc2FibGVkXCIsYXR0cnM6e1wiYXJpYS1oaWRkZW5cIjpcInRydWVcIn19LFtuKFwic3BhblwiLHtzdGF0aWNDbGFzczpcInBhZ2UtbGlua1wiLGRvbVByb3BzOntpbm5lckhUTUw6dC5fcyh0Lmxhc3RUZXh0KX19KV0pOm4oXCJsaVwiLHtzdGF0aWNDbGFzczpcInBhZ2UtaXRlbVwifSxbbihcImFcIix7c3RhdGljQ2xhc3M6XCJwYWdlLWxpbmtcIixhdHRyczp7cm9sZTp0LmJ1dHRvblJvbGUsXCJhcmlhLWxhYmVsXCI6dC5sYWJlbExhc3RQYWdlLHRhYmluZGV4OlwiLTFcIn0sb246e2NsaWNrOmZ1bmN0aW9uKGUpe2UucHJldmVudERlZmF1bHQoKSx0LnNldFBhZ2UoZSx0Lm51bWJlck9mUGFnZXMpfSxrZXlkb3duOltmdW5jdGlvbihlKXtpZighKFwiYnV0dG9uXCJpbiBlKSYmdC5fayhlLmtleUNvZGUsXCJlbnRlclwiLDEzKSlyZXR1cm4gbnVsbDtlLnByZXZlbnREZWZhdWx0KCksdC5zZXRQYWdlKGUsdC5udW1iZXJPZlBhZ2VzKX0sZnVuY3Rpb24oZSl7aWYoIShcImJ1dHRvblwiaW4gZSkmJnQuX2soZS5rZXlDb2RlLFwic3BhY2VcIiwzMikpcmV0dXJuIG51bGw7ZS5wcmV2ZW50RGVmYXVsdCgpLHQuc2V0UGFnZShlLHQubnVtYmVyT2ZQYWdlcyl9XX19LFtuKFwic3BhblwiLHthdHRyczp7XCJhcmlhLWhpZGRlblwiOlwidHJ1ZVwifSxkb21Qcm9wczp7aW5uZXJIVE1MOnQuX3ModC5sYXN0VGV4dCl9fSldKV0pXV0sMil9LHN0YXRpY1JlbmRlckZuczpbXSxfc2NvcGVJZDpcImRhdGEtdi0yNzkyOTYwYlwiLGRhdGE6ZnVuY3Rpb24oKXtyZXR1cm57c2hvd0ZpcnN0RG90czohMSxzaG93TGFzdERvdHM6ITEsY3VycmVudFBhZ2U6dGhpcy52YWx1ZX19LGNvbXB1dGVkOntudW1iZXJPZlBhZ2VzOmZ1bmN0aW9uKCl7dmFyIHQ9TWF0aC5jZWlsKHRoaXMudG90YWxSb3dzL3RoaXMucGVyUGFnZSk7cmV0dXJuIHQ8MT8xOnR9LGJ0blNpemU6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5zaXplP1wicGFnaW5hdGlvbi1cIit0aGlzLnNpemU6XCJcIn0scGFnZUxpc3Q6ZnVuY3Rpb24oKXt0aGlzLmN1cnJlbnRQYWdlPnRoaXMubnVtYmVyT2ZQYWdlcz90aGlzLmN1cnJlbnRQYWdlPXRoaXMubnVtYmVyT2ZQYWdlczp0aGlzLmN1cnJlbnRQYWdlPDEmJih0aGlzLmN1cnJlbnRQYWdlPTEpLHRoaXMuc2hvd0ZpcnN0RG90cz0hMSx0aGlzLnNob3dMYXN0RG90cz0hMTt2YXIgdD10aGlzLmxpbWl0LGU9MTt0aGlzLm51bWJlck9mUGFnZXM8PXRoaXMubGltaXQ/dD10aGlzLm51bWJlck9mUGFnZXM6dGhpcy5jdXJyZW50UGFnZTx0aGlzLmxpbWl0LTEmJnRoaXMubGltaXQ+RUxMSVBTSVNfVEhSRVNIT0xEP3RoaXMuaGlkZUVsbGlwc2lzfHwodD10aGlzLmxpbWl0LTEsdGhpcy5zaG93TGFzdERvdHM9ITApOnRoaXMubnVtYmVyT2ZQYWdlcy10aGlzLmN1cnJlbnRQYWdlKzI8dGhpcy5saW1pdCYmdGhpcy5saW1pdD5FTExJUFNJU19USFJFU0hPTEQ/KHRoaXMuaGlkZUVsbGlwc2lzfHwodGhpcy5zaG93Rmlyc3REb3RzPSEwLHQ9dGhpcy5saW1pdC0xKSxlPXRoaXMubnVtYmVyT2ZQYWdlcy10KzEpOih0aGlzLmxpbWl0PkVMTElQU0lTX1RIUkVTSE9MRCYmIXRoaXMuaGlkZUVsbGlwc2lzJiYodGhpcy5zaG93Rmlyc3REb3RzPSEwLHRoaXMuc2hvd0xhc3REb3RzPSEwLHQ9dGhpcy5saW1pdC0yKSxlPXRoaXMuY3VycmVudFBhZ2UtTWF0aC5mbG9vcih0LzIpKSxlPDE/ZT0xOmU+dGhpcy5udW1iZXJPZlBhZ2VzLXQmJihlPXRoaXMubnVtYmVyT2ZQYWdlcy10KzEpO3ZhciBuPW1ha2VQYWdlQXJyYXkoZSx0KTtpZihuLmxlbmd0aD4zKXt2YXIgaT10aGlzLmN1cnJlbnRQYWdlLWU7aWYoMD09PWkpZm9yKHZhciBvPTM7bzxuLmxlbmd0aDtvKyspbltvXS5jbGFzc05hbWU9XCJoaWRkZW4teHMtZG93blwiO2Vsc2UgaWYoaT09PW4ubGVuZ3RoLTEpZm9yKHZhciByPTA7cjxuLmxlbmd0aC0zO3IrKyluW3JdLmNsYXNzTmFtZT1cImhpZGRlbi14cy1kb3duXCI7ZWxzZXtmb3IodmFyIHM9MDtzPGktMTtzKyspbltzXS5jbGFzc05hbWU9XCJoaWRkZW4teHMtZG93blwiO2Zvcih2YXIgYT1uLmxlbmd0aC0xO2E+aSsxO2EtLSluW2FdLmNsYXNzTmFtZT1cImhpZGRlbi14cy1kb3duXCJ9fXJldHVybiBufX0sbWV0aG9kczp7aXNBY3RpdmU6ZnVuY3Rpb24odCl7cmV0dXJuIHQ9PT10aGlzLmN1cnJlbnRQYWdlfSxwYWdlSXRlbUNsYXNzZXM6ZnVuY3Rpb24odCl7dmFyIGU9dGhpcy5pc0FjdGl2ZSh0Lm51bWJlcik7cmV0dXJuW1wicGFnZS1pdGVtXCIsdGhpcy5kaXNhYmxlZD9cImRpc2FibGVkXCI6XCJcIixlP1wiYWN0aXZlXCI6XCJcIix0LmNsYXNzTmFtZV19LHBhZ2VMaW5rQ2xhc3NlczpmdW5jdGlvbih0KXt2YXIgZT10aGlzLmlzQWN0aXZlKHQubnVtYmVyKTtyZXR1cm5bXCJwYWdlLWxpbmtcIix0aGlzLmRpc2FibGVkP1wiZGlzYWJsZWRcIjpcIlwiLGU/XCJhY3RpdmVcIjpcIlwiXX0sc2V0UGFnZTpmdW5jdGlvbih0LGUpe3ZhciBuPXRoaXM7aWYodGhpcy5kaXNhYmxlZClyZXR1cm4gdC5wcmV2ZW50RGVmYXVsdCgpLHZvaWQgdC5zdG9wUHJvcGFnYXRpb24oKTtlPnRoaXMubnVtYmVyT2ZQYWdlcz90aGlzLmN1cnJlbnRQYWdlPXRoaXMubnVtYmVyT2ZQYWdlczplPDE/dGhpcy5jdXJyZW50cGFnZT0xOnRoaXMuY3VycmVudFBhZ2U9ZSx0aGlzLiRuZXh0VGljayhmdW5jdGlvbigpe2lzVmlzaWJsZSQxKHQudGFyZ2V0KSYmdC50YXJnZXQuZm9jdXM/dC50YXJnZXQuZm9jdXMoKTpuLmZvY3VzQ3VycmVudCgpfSksdGhpcy4kZW1pdChcImNoYW5nZVwiLHRoaXMuY3VycmVudFBhZ2UpfSxnZXRCdXR0b25zOmZ1bmN0aW9uKCl7cmV0dXJuIEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKHRoaXMuJGVsLnF1ZXJ5U2VsZWN0b3JBbGwoXCJhLnBhZ2UtbGlua1wiKSkuZmlsdGVyKGZ1bmN0aW9uKHQpe3JldHVybiBpc1Zpc2libGUkMSh0KX0pfSxzZXRCdG5Gb2N1czpmdW5jdGlvbih0KXt0aGlzLiRuZXh0VGljayhmdW5jdGlvbigpe3QuZm9jdXMoKX0pfSxmb2N1c0ZpcnN0OmZ1bmN0aW9uKCl7dmFyIHQ9dGhpcy5nZXRCdXR0b25zKCkuZmluZChmdW5jdGlvbih0KXtyZXR1cm4hdC5kaXNhYmxlZH0pO3QmJnQuZm9jdXMmJnQhPT1kb2N1bWVudC5hY3RpdmVFbGVtZW50JiZ0aGlzLnNldEJ0bkZvY3VzKHQpfSxmb2N1c0xhc3Q6ZnVuY3Rpb24oKXt2YXIgdD10aGlzLmdldEJ1dHRvbnMoKS5yZXZlcnNlKCkuZmluZChmdW5jdGlvbih0KXtyZXR1cm4hdC5kaXNhYmxlZH0pO3QmJnQuZm9jdXMmJnQhPT1kb2N1bWVudC5hY3RpdmVFbGVtZW50JiZ0aGlzLnNldEJ0bkZvY3VzKHQpfSxmb2N1c0N1cnJlbnQ6ZnVuY3Rpb24oKXt2YXIgdD10aGlzLGU9dGhpcy5nZXRCdXR0b25zKCkuZmluZChmdW5jdGlvbihlKXtyZXR1cm4gcGFyc2VJbnQoZS5nZXRBdHRyaWJ1dGUoXCJhcmlhLXBvc2luc2V0XCIpLDEwKT09PXQuY3VycmVudFBhZ2V9KTtlJiZlLmZvY3VzP3RoaXMuc2V0QnRuRm9jdXMoZSk6dGhpcy5mb2N1c0ZpcnN0KCl9LGZvY3VzUHJldjpmdW5jdGlvbigpe3ZhciB0PXRoaXMuZ2V0QnV0dG9ucygpLGU9dC5pbmRleE9mKGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQpO2U+MCYmIXRbZS0xXS5kaXNhYmxlZCYmdFtlLTFdLmZvY3VzJiZ0aGlzLnNldEJ0bkZvY3VzKHRbZS0xXSl9LGZvY3VzTmV4dDpmdW5jdGlvbigpe3ZhciB0PXRoaXMuZ2V0QnV0dG9ucygpLGU9dC5pbmRleE9mKGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQpO2U8dC5sZW5ndGgtMSYmIXRbZSsxXS5kaXNhYmxlZCYmdFtlKzFdLmZvY3VzJiZ0aGlzLnNldEJ0bkZvY3VzKHRbZSsxXSl9fSx3YXRjaDp7Y3VycmVudFBhZ2U6ZnVuY3Rpb24odCxlKXt0IT09ZSYmdGhpcy4kZW1pdChcImlucHV0XCIsdCl9LHZhbHVlOmZ1bmN0aW9uKHQsZSl7dCE9PWUmJih0aGlzLmN1cnJlbnRQYWdlPXQpfX0scHJvcHM6e2Rpc2FibGVkOnt0eXBlOkJvb2xlYW4sZGVmYXVsdDohMX0sdmFsdWU6e3R5cGU6TnVtYmVyLGRlZmF1bHQ6MX0sbGltaXQ6e3R5cGU6TnVtYmVyLGRlZmF1bHQ6NX0scGVyUGFnZTp7dHlwZTpOdW1iZXIsZGVmYXVsdDoyMH0sdG90YWxSb3dzOnt0eXBlOk51bWJlcixkZWZhdWx0OjIwfSxzaXplOnt0eXBlOlN0cmluZyxkZWZhdWx0OlwibWRcIn0saGlkZUdvdG9FbmRCdXR0b25zOnt0eXBlOkJvb2xlYW4sZGVmYXVsdDohMX0sYXJpYUxhYmVsOnt0eXBlOlN0cmluZyxkZWZhdWx0OlwiUGFnaW5hdGlvblwifSxsYWJlbEZpcnN0UGFnZTp7dHlwZTpTdHJpbmcsZGVmYXVsdDpcIkdvdG8gZmlyc3QgcGFnZVwifSxmaXJzdFRleHQ6e3R5cGU6U3RyaW5nLGRlZmF1bHQ6XCImbGFxdW9cIn0sbGFiZWxQcmV2UGFnZTp7dHlwZTpTdHJpbmcsZGVmYXVsdDpcIkdvdG8gcHJldmlvdXMgcGFnZVwifSxwcmV2VGV4dDp7dHlwZTpTdHJpbmcsZGVmYXVsdDpcIiZsc2FxdW87XCJ9LGxhYmVsTmV4dFBhZ2U6e3R5cGU6U3RyaW5nLGRlZmF1bHQ6XCJHb3RvIG5leHQgcGFnZVwifSxuZXh0VGV4dDp7dHlwZTpTdHJpbmcsZGVmYXVsdDpcIiZyc2FxdW87XCJ9LGxhYmVsTGFzdFBhZ2U6e3R5cGU6U3RyaW5nLGRlZmF1bHQ6XCJHb3RvIGxhc3QgcGFnZVwifSxsYXN0VGV4dDp7dHlwZTpTdHJpbmcsZGVmYXVsdDpcIiZyYXF1bztcIn0sbGFiZWxQYWdlOnt0eXBlOlN0cmluZyxkZWZhdWx0OlwiR290byBwYWdlXCJ9LGhpZGVFbGxpcHNpczp7dHlwZTpCb29sZWFuLGRlZmF1bHQ6ITF9LGVsbGlwc2lzVGV4dDp7dHlwZTpTdHJpbmcsZGVmYXVsdDpcIiZoZWxsaXA7XCJ9LHJvbGU6e3R5cGU6U3RyaW5nLGRlZmF1bHQ6XCJncm91cFwifSxidXR0b25Sb2xlOnt0eXBlOlN0cmluZyxkZWZhdWx0OlwiYnV0dG9uXCJ9fX0sVFJJR0dFUl9MSVNURU5FUlM9e2NsaWNrOntjbGljazpcInRvZ2dsZVwifSxob3Zlcjp7bW91c2VlbnRlcjpcInNob3dcIixtb3VzZWxlYXZlOlwiaGlkZVwifSxmb2N1czp7Zm9jdXM6XCJzaG93XCIsYmx1cjpcImhpZGVcIn19LFBMQUNFTUVOVF9QQVJBTVM9e3RvcDpcImJvdHRvbSBjZW50ZXJcIixib3R0b206XCJ0b3AgY2VudGVyXCIsbGVmdDpcIm1pZGRsZSByaWdodFwiLHJpZ2h0OlwibWlkZGxlIGxlZnRcIn0sVEVUSEVSX0NMQVNTX1BSRUZJWD1cImJzLXRldGhlclwiLFRFVEhFUl9DTEFTU0VTPXtlbGVtZW50OiExLGVuYWJsZWQ6ITF9LFRSQU5TSVRJT05fRFVSQVRJT049MTUwLHBvcG92ZXIkMT17cHJvcHM6e2NvbnN0cmFpbnRzOnt0eXBlOkFycmF5LGRlZmF1bHQ6ZnVuY3Rpb24oKXtyZXR1cm5bXX19LGRlYm91bmNlOnt0eXBlOltOdW1iZXJdLGRlZmF1bHQ6MzAwLHZhbGlkYXRvcjpmdW5jdGlvbih0KXtyZXR1cm4gdD49MH19LGRlbGF5Ont0eXBlOltOdW1iZXIsT2JqZWN0XSxkZWZhdWx0OjAsdmFsaWRhdG9yOmZ1bmN0aW9uKHQpe3JldHVyblwibnVtYmVyXCI9PXR5cGVvZiB0P3Q+PTA6bnVsbCE9PXQmJlwib2JqZWN0XCI9PXR5cGVvZiB0JiYoXCJudW1iZXJcIj09dHlwZW9mIHQuc2hvdyYmXCJudW1iZXJcIj09dHlwZW9mIHQuaGlkZSYmdC5zaG93Pj0wJiZ0LmhpZGU+PTApfX0sb2Zmc2V0Ont0eXBlOlN0cmluZyxkZWZhdWx0OlwiMCAwXCIsdmFsaWRhdG9yOmZ1bmN0aW9uKHQpe3JldHVybi9eKCgwXFxzPyl8KFsrLV0/WzAtOV0rKHB4fCUpXFxzPykpezJ9JC8udGVzdCh0KX19LHBsYWNlbWVudDp7dHlwZTpTdHJpbmcsZGVmYXVsdDpcInRvcFwiLHZhbGlkYXRvcjpmdW5jdGlvbih0KXtyZXR1cm4tMSE9PU9iamVjdC5rZXlzKFBMQUNFTUVOVF9QQVJBTVMpLmluZGV4T2YodCl9fSxwb3BvdmVyU3R5bGU6e3R5cGU6T2JqZWN0LGRlZmF1bHQ6bnVsbH0sc2hvdzp7dHlwZTpCb29sZWFuLGRlZmF1bHQ6bnVsbH0sdGFyZ2V0T2Zmc2V0Ont0eXBlOlN0cmluZyxkZWZhdWx0OlwiMCAwXCIsdmFsaWRhdG9yOmZ1bmN0aW9uKHQpe3JldHVybi9eKCgwXFxzPyl8KFsrLV0/WzAtOV0rKHB4fCUpXFxzPykpezJ9JC8udGVzdCh0KX19LHRyaWdnZXJzOnt0eXBlOltCb29sZWFuLFN0cmluZyxBcnJheV0sZGVmYXVsdDpmdW5jdGlvbigpe3JldHVybltcImNsaWNrXCIsXCJmb2N1c1wiXX0sdmFsaWRhdG9yOmZ1bmN0aW9uKHQpe2lmKCExPT09dHx8XCJcIj09PXQpcmV0dXJuITA7aWYoXCJzdHJpbmdcIj09dHlwZW9mIHQpcmV0dXJuLTEhPT1PYmplY3Qua2V5cyhUUklHR0VSX0xJU1RFTkVSUykuaW5kZXhPZih0KTtpZihBcnJheS5pc0FycmF5KHQpKXt2YXIgZT1PYmplY3Qua2V5cyhUUklHR0VSX0xJU1RFTkVSUyk7cmV0dXJuIHQuZm9yRWFjaChmdW5jdGlvbih0KXtpZigtMT09PWUuaW5kZXhPZih0KSlyZXR1cm4hMX0pLCEwfXJldHVybiExfX19LGRhdGE6ZnVuY3Rpb24oKXtyZXR1cm57dHJpZ2dlclN0YXRlOnRoaXMuc2hvdyxjbGFzc1N0YXRlOnRoaXMuc2hvdyxsYXN0RXZlbnQ6bnVsbH19LGNvbXB1dGVkOntub3JtYWxpemVkVHJpZ2dlcnM6ZnVuY3Rpb24oKXtyZXR1cm4hMT09PXRoaXMudHJpZ2dlcnM/W106XCJzdHJpbmdcIj09dHlwZW9mIHRoaXMudHJpZ2dlcnM/W3RoaXMudHJpZ2dlcnNdOnRoaXMudHJpZ2dlcnN9LHBvcG92ZXJBbGlnbm1lbnQ6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5wbGFjZW1lbnQmJlwiZGVmYXVsdFwiIT09dGhpcy5wbGFjZW1lbnQ/XCJwb3BvdmVyLVwiK3RoaXMucGxhY2VtZW50OlwicG9wb3Zlci10b3BcIn0sc2hvd1N0YXRlOmZ1bmN0aW9uKCl7cmV0dXJuITEhPT10aGlzLnNob3cmJih0aGlzLnRyaWdnZXJTdGF0ZXx8dGhpcy5zaG93KX19LHdhdGNoOntjb25zdHJhaW50czpmdW5jdGlvbigpe3RoaXMuc2V0T3B0aW9ucygpfSxub3JtYWxpemVkVHJpZ2dlcnM6ZnVuY3Rpb24odCxlKXt0aGlzLnVwZGF0ZUxpc3RlbmVycyh0LGUpfSxvZmZzZXQ6ZnVuY3Rpb24oKXt0aGlzLnNldE9wdGlvbnMoKX0scGxhY2VtZW50OmZ1bmN0aW9uKCl7dGhpcy5zZXRPcHRpb25zKCl9LHNob3dTdGF0ZTpmdW5jdGlvbih0KXt2YXIgZT10aGlzLG49dGhpcy5nZXREZWxheSh0KTtjbGVhclRpbWVvdXQodGhpcy4kZGF0YS5fdGltZW91dCksbj90aGlzLiRkYXRhLl90aW1lb3V0PXNldFRpbWVvdXQoZnVuY3Rpb24oKXtyZXR1cm4gZS50b2dnbGVQb3BvdmVyKHQpfSxuKTp0aGlzLnRvZ2dsZVBvcG92ZXIodCl9fSxtZXRob2RzOnthZGRMaXN0ZW5lcjpmdW5jdGlvbih0KXt2YXIgZT10aGlzO2Zvcih2YXIgbiBpbiBUUklHR0VSX0xJU1RFTkVSU1t0XSllLiRkYXRhLl90cmlnZ2VyLmFkZEV2ZW50TGlzdGVuZXIobixmdW5jdGlvbih0KXtyZXR1cm4gZS5ldmVudEhhbmRsZXIodCl9KX0sZGVzdHJveVRldGhlcjpmdW5jdGlvbigpe2lmKHRoaXMuJGRhdGEuX3RldGhlciYmIXRoaXMuc2hvd1N0YXRlKXt0aGlzLiRkYXRhLl90ZXRoZXIuZGVzdHJveSgpLHRoaXMuJGRhdGEuX3RldGhlcj1udWxsO3ZhciB0PW5ldyBSZWdFeHAoXCIoXnxbXi1dXFxcXGIpKFwiK1RFVEhFUl9DTEFTU19QUkVGSVgrXCJcXFxcUyopXCIsXCJnXCIpO3RoaXMuJGRhdGEuX3RyaWdnZXIuY2xhc3NOYW1lPXRoaXMuJGRhdGEuX3RyaWdnZXIuY2xhc3NOYW1lLnJlcGxhY2UodCxcIlwiKX19LGV2ZW50SGFuZGxlcjpmdW5jdGlvbih0KXt2YXIgZT10aGlzO2lmKCEodGhpcy5ub3JtYWxpemVkVHJpZ2dlcnMubGVuZ3RoPjEmJnRoaXMuZGVib3VuY2U+MCYmbnVsbCE9PXRoaXMubGFzdEV2ZW50JiZ0LnRpbWVTdGFtcDw9dGhpcy5sYXN0RXZlbnQrdGhpcy5kZWJvdW5jZSkpZm9yKHZhciBuIGluIFRSSUdHRVJfTElTVEVORVJTKWZvcih2YXIgaSBpbiBUUklHR0VSX0xJU1RFTkVSU1tuXSlpZihpPT09dC50eXBlKXt2YXIgbz1UUklHR0VSX0xJU1RFTkVSU1tuXVtpXTtyZXR1cm4gdm9pZCgoXCJ0b2dnbGVcIj09PW98fGUudHJpZ2dlclN0YXRlJiZcImhpZGVcIj09PW98fCFlLnRyaWdnZXJTdGF0ZSYmXCJzaG93XCI9PT1vKSYmKGUudHJpZ2dlclN0YXRlPSFlLnRyaWdnZXJTdGF0ZSxlLmxhc3RFdmVudD10LnRpbWVTdGFtcCkpfX0sZ2V0RGVsYXk6ZnVuY3Rpb24odCl7cmV0dXJuXCJvYmplY3RcIj09dHlwZW9mIHRoaXMuZGVsYXk/dD90aGlzLmRlbGF5LnNob3c6dGhpcy5kZWxheS5oaWRlOnRoaXMuZGVsYXl9LGdldFRldGhlck9wdGlvbnM6ZnVuY3Rpb24oKXtyZXR1cm57YXR0YWNobWVudDpQTEFDRU1FTlRfUEFSQU1TW3RoaXMucGxhY2VtZW50XSxlbGVtZW50OnRoaXMuJGRhdGEuX3BvcG92ZXIsdGFyZ2V0OnRoaXMuJGRhdGEuX3RyaWdnZXIsY2xhc3NlczpURVRIRVJfQ0xBU1NFUyxjbGFzc1ByZWZpeDpURVRIRVJfQ0xBU1NfUFJFRklYLG9mZnNldDp0aGlzLm9mZnNldCxjb25zdHJhaW50czp0aGlzLmNvbnN0cmFpbnRzLHRhcmdldE9mZnNldDp0aGlzLnRhcmdldE9mZnNldH19LGhpZGVQb3BvdmVyOmZ1bmN0aW9uKCl7dmFyIHQ9dGhpczt0aGlzLmNsYXNzU3RhdGU9ITEsY2xlYXJUaW1lb3V0KHRoaXMuJGRhdGEuX3RpbWVvdXQpLHRoaXMuJGRhdGEuX3RpbWVvdXQ9c2V0VGltZW91dChmdW5jdGlvbigpe3QuJGRhdGEuX3BvcG92ZXIuc3R5bGUuZGlzcGxheT1cIm5vbmVcIix0LmRlc3Ryb3lUZXRoZXIoKX0sVFJBTlNJVElPTl9EVVJBVElPTil9LHJlZnJlc2hQb3NpdGlvbjpmdW5jdGlvbigpe3ZhciB0PXRoaXM7dGhpcy4kZGF0YS5fdGV0aGVyJiZ0aGlzLiRuZXh0VGljayhmdW5jdGlvbigpe3QuJGRhdGEuX3RldGhlci5wb3NpdGlvbigpfSl9LHJlbW92ZUxpc3RlbmVyOmZ1bmN0aW9uKHQpe3ZhciBlPXRoaXM7Zm9yKHZhciBuIGluIFRSSUdHRVJfTElTVEVORVJTW3RdKWUuJGRhdGEuX3RyaWdnZXIucmVtb3ZlRXZlbnRMaXN0ZW5lcihuLGZ1bmN0aW9uKHQpe3JldHVybiBlLmV2ZW50SGFuZGxlcih0KX0pfSxzZXRPcHRpb25zOmZ1bmN0aW9uKCl7dGhpcy4kZGF0YS5fdGV0aGVyJiZ0aGlzLiRkYXRhLl90ZXRoZXIuc2V0T3B0aW9ucyh0aGlzLmdldFRldGhlck9wdGlvbnMoKSl9LHNob3dQb3BvdmVyOmZ1bmN0aW9uKCl7dmFyIHQ9dGhpcztjbGVhclRpbWVvdXQodGhpcy4kZGF0YS5fdGltZW91dCksdGhpcy4kZGF0YS5fdGV0aGVyfHwodGhpcy4kZGF0YS5fdGV0aGVyPW5ldyBUZXRoZXIodGhpcy5nZXRUZXRoZXJPcHRpb25zKCkpKSx0aGlzLiRkYXRhLl9wb3BvdmVyLnN0eWxlLmRpc3BsYXk9XCJibG9ja1wiLHRoaXMucmVmcmVzaFBvc2l0aW9uKCksdGhpcy4kbmV4dFRpY2soZnVuY3Rpb24oKXt0LmNsYXNzU3RhdGU9ITB9KX0sdG9nZ2xlUG9wb3ZlcjpmdW5jdGlvbih0KXt0aGlzLiRlbWl0KFwic2hvd0NoYW5nZVwiLHQpLHQ/KHRoaXMuc2hvd1BvcG92ZXIoKSx0aGlzLiRyb290LiRlbWl0KFwic2hvd246OnBvcG92ZXJcIikpOih0aGlzLmhpZGVQb3BvdmVyKCksdGhpcy4kcm9vdC4kZW1pdChcImhpZGRlbjo6cG9wb3ZlclwiKSl9LHVwZGF0ZUxpc3RlbmVyczpmdW5jdGlvbih0LGUpe3ZhciBuPXRoaXM7dm9pZCAwPT09ZSYmKGU9W10pO3ZhciBpPVtdLG89W107dC5mb3JFYWNoKGZ1bmN0aW9uKHQpey0xPT09ZS5pbmRleE9mKHQpJiZpLnB1c2godCl9KSxlLmZvckVhY2goZnVuY3Rpb24oZSl7LTE9PT10LmluZGV4T2YoZSkmJm8ucHVzaChlKX0pLGkuZm9yRWFjaChmdW5jdGlvbih0KXtyZXR1cm4gbi5hZGRMaXN0ZW5lcih0KX0pLG8uZm9yRWFjaChmdW5jdGlvbih0KXtyZXR1cm4gbi5yZW1vdmVMaXN0ZW5lcih0KX0pfX0sY3JlYXRlZDpmdW5jdGlvbigpe3ZhciB0PXRoaXM7dGhpcy4kcm9vdC4kb24oXCJoaWRlOjpwb3BvdmVyXCIsZnVuY3Rpb24oKXt0LnRyaWdnZXJTdGF0ZT0hMX0pfSxtb3VudGVkOmZ1bmN0aW9uKCl7dGhpcy4kZGF0YS5fdHJpZ2dlcj10aGlzLiRyZWZzLnRyaWdnZXIuY2hpbGRyZW5bMF18fHRoaXMuJHJlZnMudHJpZ2dlcix0aGlzLiRkYXRhLl9wb3BvdmVyPXRoaXMuJHJlZnMucG9wb3Zlcix0aGlzLiRkYXRhLl9wb3BvdmVyLnN0eWxlLmRpc3BsYXk9XCJub25lXCIsdGhpcy4kZGF0YS5fdGV0aGVyPW5ldyBUZXRoZXIodGhpcy5nZXRUZXRoZXJPcHRpb25zKCkpLHRoaXMuJGRhdGEuX3RpbWVvdXQ9MCx0aGlzLnVwZGF0ZUxpc3RlbmVycyh0aGlzLm5vcm1hbGl6ZWRUcmlnZ2VycyksdGhpcy5zaG93U3RhdGUmJnRoaXMuc2hvd1BvcG92ZXIoKX0sdXBkYXRlZDpmdW5jdGlvbigpe3RoaXMucmVmcmVzaFBvc2l0aW9uKCl9LGJlZm9yZURlc3Ryb3k6ZnVuY3Rpb24oKXt2YXIgdD10aGlzO3RoaXMubm9ybWFsaXplZFRyaWdnZXJzLmZvckVhY2goZnVuY3Rpb24oZSl7cmV0dXJuIHQucmVtb3ZlTGlzdGVuZXIoZSl9KSxjbGVhclRpbWVvdXQodGhpcy4kZGF0YS5fdGltZW91dCksdGhpcy5kZXN0cm95VGV0aGVyKCl9LGRlc3Ryb3llZDpmdW5jdGlvbigpe3RoaXMuJGRhdGEuX3BvcG92ZXIucGFyZW50RWxlbWVudD09PWRvY3VtZW50LmJvZHkmJmRvY3VtZW50LmJvZHkucmVtb3ZlQ2hpbGQodGhpcy4kZGF0YS5fcG9wb3Zlcil9fSxwb3BvdmVyPXtyZW5kZXI6ZnVuY3Rpb24oKXt2YXIgdD10aGlzLGU9dC4kY3JlYXRlRWxlbWVudCxuPXQuX3NlbGYuX2N8fGU7cmV0dXJuIG4oXCJkaXZcIixbbihcInNwYW5cIix7cmVmOlwidHJpZ2dlclwifSxbdC5fdChcImRlZmF1bHRcIildLDIpLG4oXCJkaXZcIix7cmVmOlwicG9wb3ZlclwiLGNsYXNzOltcInBvcG92ZXJcIixcImZhZGVcIix0LmNsYXNzU3RhdGU/XCJzaG93XCI6XCJcIix0LnBvcG92ZXJBbGlnbm1lbnRdLHN0eWxlOnQucG9wb3ZlclN0eWxlLGF0dHJzOnt0YWJpbmRleDpcIi0xXCJ9LG9uOntmb2N1czpmdW5jdGlvbihlKXt0LiRlbWl0KFwiZm9jdXNcIil9LGJsdXI6ZnVuY3Rpb24oZSl7dC4kZW1pdChcImJsdXJcIil9fX0sW24oXCJkaXZcIix7c3RhdGljQ2xhc3M6XCJwb3BvdmVyLWFycm93XCJ9KSx0LnRpdGxlP24oXCJoM1wiLHtzdGF0aWNDbGFzczpcInBvcG92ZXItdGl0bGVcIixkb21Qcm9wczp7aW5uZXJIVE1MOnQuX3ModC50aXRsZSl9fSk6dC5fZSgpLG4oXCJkaXZcIix7c3RhdGljQ2xhc3M6XCJwb3BvdmVyLWNvbnRlbnRcIn0sW24oXCJkaXZcIix7c3RhdGljQ2xhc3M6XCJwb3BvdmVyLWNvbnRlbnQtd3JhcHBlclwifSxbdC5fdChcImNvbnRlbnRcIixbbihcInNwYW5cIix7ZG9tUHJvcHM6e2lubmVySFRNTDp0Ll9zKHQuY29udGVudCl9fSldKV0sMildKV0pXSl9LHN0YXRpY1JlbmRlckZuczpbXSxtaXhpbnM6W3BvcG92ZXIkMV0scHJvcHM6e3RpdGxlOnt0eXBlOlN0cmluZyxkZWZhdWx0OlwiXCJ9LGNvbnRlbnQ6e3R5cGU6U3RyaW5nLGRlZmF1bHQ6XCJcIn0scG9wb3ZlclN0eWxlOnt0eXBlOk9iamVjdCxkZWZhdWx0Om51bGx9fX0scHJvZ3Jlc3M9e3JlbmRlcjpmdW5jdGlvbigpe3ZhciB0PXRoaXMsZT10LiRjcmVhdGVFbGVtZW50LG49dC5fc2VsZi5fY3x8ZTtyZXR1cm4gbihcImRpdlwiLHtzdGF0aWNDbGFzczpcInByb2dyZXNzXCJ9LFtuKFwidHJhbnNpdGlvblwiLFtuKFwiZGl2XCIse2NsYXNzOnQuY2xhc3NPYmplY3Qsc3R5bGU6dC5zdHlsZU9iamVjdCxhdHRyczp7cm9sZTpcInByb2dyZXNzYmFyXCIsXCJhcmlhLXZhbHVlbm93XCI6dC52YWx1ZSxcImFyaWEtdmFsdWVtaW5cIjowLFwiYXJpYS12YWx1ZW1heFwiOnQubWF4fX0sW3QuX3QoXCJkZWZhdWx0XCIsW3Quc2hvd1Byb2dyZXNzP1t0Ll92KHQuX3ModC5wcm9ncmVzcykrXCIlXCIpXTp0LnNob3dWYWx1ZT9bdC5fdih0Ll9zKHQudmFsdWUpKV06dC5fZSgpXSldLDIpXSldLDEpfSxzdGF0aWNSZW5kZXJGbnM6W10sY29tcHV0ZWQ6e2NsYXNzT2JqZWN0OmZ1bmN0aW9uKCl7cmV0dXJuW1wicHJvZ3Jlc3MtYmFyXCIsdGhpcy5wcm9ncmVzc1ZhcmlhbnQsdGhpcy5zdHJpcGVkfHx0aGlzLmFuaW1hdGVkP1wicHJvZ3Jlc3MtYmFyLXN0cmlwZWRcIjpcIlwiLHRoaXMuYW5pbWF0ZWQ/XCJwcm9ncmVzcy1iYXItYW5pbWF0ZWRcIjpcIlwiXX0sc3R5bGVPYmplY3Q6ZnVuY3Rpb24oKXtyZXR1cm57d2lkdGg6dGhpcy5wcm9ncmVzcytcIiVcIn19LHByb2dyZXNzVmFyaWFudDpmdW5jdGlvbigpe3JldHVybiB0aGlzLnZhcmlhbnQ/XCJiZy1cIit0aGlzLnZhcmlhbnQ6bnVsbH0scHJvZ3Jlc3M6ZnVuY3Rpb24oKXt2YXIgdD1NYXRoLnBvdygxMCx0aGlzLnByZWNpc2lvbik7cmV0dXJuIE1hdGgucm91bmQoMTAwKnQqdGhpcy52YWx1ZS90aGlzLm1heCkvdH19LHByb3BzOntzdHJpcGVkOnt0eXBlOkJvb2xlYW4sZGVmYXVsdDohMX0sYW5pbWF0ZWQ6e3R5cGU6Qm9vbGVhbixkZWZhdWx0OiExfSxwcmVjaXNpb246e3R5cGU6TnVtYmVyLGRlZmF1bHQ6MH0sdmFsdWU6e3R5cGU6TnVtYmVyLGRlZmF1bHQ6MH0sbWF4Ont0eXBlOk51bWJlcixkZWZhdWx0OjEwMH0sdmFyaWFudDp7dHlwZTpTdHJpbmcsZGVmYXVsdDpudWxsfSxzaG93UHJvZ3Jlc3M6e3R5cGU6Qm9vbGVhbixkZWZhdWx0OiExfSxzaG93VmFsdWU6e3R5cGU6Qm9vbGVhbixkZWZhdWx0OiExfX19LHRvU3RyaW5nPWZ1bmN0aW9uKHQpe3JldHVybiB0P3QgaW5zdGFuY2VvZiBPYmplY3Q/T2JqZWN0LmtleXModCkubWFwKGZ1bmN0aW9uKGUpe3JldHVybiB0b1N0cmluZyh0W2VdKX0pLmpvaW4oXCIgXCIpOlN0cmluZyh0KTpcIlwifSxyZWNUb1N0cmluZz1mdW5jdGlvbih0KXtpZighKHQgaW5zdGFuY2VvZiBPYmplY3QpKXJldHVyblwiXCI7dmFyIGU9e3N0YXRlOiEwLF9yb3dWYXJpYW50OiEwfTtyZXR1cm4gdG9TdHJpbmcoT2JqZWN0LmtleXModCkucmVkdWNlKGZ1bmN0aW9uKG4saSl7cmV0dXJuIGVbaV18fChuW2ldPXRbaV0pLG59LHt9KSl9LGRlZmF1bHRTb3J0Q29tcGFyZT1mdW5jdGlvbih0LGUsbil7cmV0dXJuXCJudW1iZXJcIj09dHlwZW9mIHRbbl0mJlwibnVtYmVyXCI9PXR5cGVvZiBlW25dP3Rbbl08ZVtuXT8tMTp0W25dPmVbbl0/MTowOnRvU3RyaW5nKHRbbl0pLmxvY2FsZUNvbXBhcmUodG9TdHJpbmcoZVtuXSksdm9pZCAwLHtudW1lcmljOiEwfSl9LHRhYmxlPXtyZW5kZXI6ZnVuY3Rpb24oKXt2YXIgdD10aGlzLGU9dC4kY3JlYXRlRWxlbWVudCxuPXQuX3NlbGYuX2N8fGU7cmV0dXJuIG4oXCJ0YWJsZVwiLHtjbGFzczp0LnRhYmxlQ2xhc3MsYXR0cnM6e2lkOnQuaWR8fG51bGwscm9sZTpcImdyaWRcIixcImFyaWEtYnVzeVwiOnQuYnVzeT9cInRydWVcIjpcImZhbHNlXCJ9fSxbbihcInRoZWFkXCIse2NsYXNzOnQuaGVhZENsYXNzfSxbbihcInRyXCIse2F0dHJzOntyb2xlOlwicm93XCJ9fSx0Ll9sKHQuZmllbGRzLGZ1bmN0aW9uKGUsaSl7cmV0dXJuIG4oXCJ0aFwiLHtrZXk6aSxjbGFzczp0LmZpZWxkQ2xhc3MoZSxpKSxzdHlsZTplLnRoU3R5bGV8fHt9LGF0dHJzOntcImFyaWEtbGFiZWxcIjplLnNvcnRhYmxlP3Quc29ydERlc2MmJnQuc29ydEJ5PT09aT90LmxhYmVsU29ydEFzYzp0LmxhYmVsU29ydERlc2M6bnVsbCxcImFyaWEtc29ydFwiOmUuc29ydGFibGUmJnQuc29ydEJ5PT09aT90LnNvcnREZXNjP1wiZGVzY2VuZGluZ1wiOlwiYXNjZW5kaW5nXCI6bnVsbCx0YWJpbmRleDplLnNvcnRhYmxlP1wiMFwiOm51bGx9LG9uOntjbGljazpmdW5jdGlvbihuKXtuLnN0b3BQcm9wYWdhdGlvbigpLG4ucHJldmVudERlZmF1bHQoKSx0LmhlYWRDbGlja2VkKG4sZSxpKX0sa2V5ZG93bjpbZnVuY3Rpb24obil7aWYoIShcImJ1dHRvblwiaW4gbikmJnQuX2sobi5rZXlDb2RlLFwiZW50ZXJcIiwxMykpcmV0dXJuIG51bGw7bi5zdG9wUHJvcGFnYXRpb24oKSxuLnByZXZlbnREZWZhdWx0KCksdC5oZWFkQ2xpY2tlZChuLGUsaSl9LGZ1bmN0aW9uKG4pe2lmKCEoXCJidXR0b25cImluIG4pJiZ0Ll9rKG4ua2V5Q29kZSxcInNwYWNlXCIsMzIpKXJldHVybiBudWxsO24uc3RvcFByb3BhZ2F0aW9uKCksbi5wcmV2ZW50RGVmYXVsdCgpLHQuaGVhZENsaWNrZWQobixlLGkpfV19fSxbdC5fdChcIkhFQURfXCIraSxbbihcImRpdlwiLHtkb21Qcm9wczp7aW5uZXJIVE1MOnQuX3MoZS5sYWJlbCl9fSldLHtsYWJlbDplLmxhYmVsLGNvbHVtbjppLGZpZWxkOmV9KV0sMil9KSldKSx0LmZvb3RDbG9uZT9uKFwidGZvb3RcIix7Y2xhc3M6dC5mb290Q2xhc3N9LFtuKFwidHJcIix7YXR0cnM6e3JvbGU6XCJyb3dcIn19LHQuX2wodC5maWVsZHMsZnVuY3Rpb24oZSxpKXtyZXR1cm4gbihcInRoXCIse2tleTppLGNsYXNzOnQuZmllbGRDbGFzcyhlLGkpLHN0eWxlOmUudGhTdHlsZXx8e30sYXR0cnM6e1wiYXJpYS1sYWJlbFwiOmUuc29ydGFibGU/dC5zb3J0RGVzYyYmdC5zb3J0Qnk9PT1pP3QubGFiZWxTb3J0QXNjOnQubGFiZWxTb3J0RGVzYzpudWxsLFwiYXJpYS1zb3J0XCI6ZS5zb3J0YWJsZSYmdC5zb3J0Qnk9PT1pP3Quc29ydERlc2M/XCJkZXNjZW5kaW5nXCI6XCJhc2NlbmRpbmdcIjpudWxsLHRhYmluZGV4OmUuc29ydGFibGU/XCIwXCI6bnVsbH0sb246e2NsaWNrOmZ1bmN0aW9uKG4pe24uc3RvcFByb3BhZ2F0aW9uKCksbi5wcmV2ZW50RGVmYXVsdCgpLHQuaGVhZENsaWNrZWQobixlLGkpfSxrZXlkb3duOltmdW5jdGlvbihuKXtpZighKFwiYnV0dG9uXCJpbiBuKSYmdC5fayhuLmtleUNvZGUsXCJlbnRlclwiLDEzKSlyZXR1cm4gbnVsbDtuLnN0b3BQcm9wYWdhdGlvbigpLG4ucHJldmVudERlZmF1bHQoKSx0LmhlYWRDbGlja2VkKG4sZSxpKX0sZnVuY3Rpb24obil7aWYoIShcImJ1dHRvblwiaW4gbikmJnQuX2sobi5rZXlDb2RlLFwic3BhY2VcIiwzMikpcmV0dXJuIG51bGw7bi5zdG9wUHJvcGFnYXRpb24oKSxuLnByZXZlbnREZWZhdWx0KCksdC5oZWFkQ2xpY2tlZChuLGUsaSl9XX19LFt0LiRzY29wZWRTbG90c1tcIkZPT1RfXCIraV0/dC5fdChcIkZPT1RfXCIraSxbbihcImRpdlwiLHtkb21Qcm9wczp7aW5uZXJIVE1MOnQuX3MoZS5sYWJlbCl9fSldLHtsYWJlbDplLmxhYmVsLGNvbHVtbjppLGZpZWxkOmV9KTp0Ll90KFwiSEVBRF9cIitpLFtuKFwiZGl2XCIse2RvbVByb3BzOntpbm5lckhUTUw6dC5fcyhlLmxhYmVsKX19KV0se2xhYmVsOmUubGFiZWwsY29sdW1uOmksZmllbGQ6ZX0pXSwyKX0pKV0pOnQuX2UoKSxuKFwidGJvZHlcIixbdC5fbCh0Ll9pdGVtcyxmdW5jdGlvbihlLGkpe3JldHVybiBuKFwidHJcIix7a2V5OmksY2xhc3M6dC5yb3dDbGFzcyhlKSxhdHRyczp7cm9sZTpcInJvd1wifSxvbjp7Y2xpY2s6ZnVuY3Rpb24obil7dC5yb3dDbGlja2VkKG4sZSxpKX0saG92ZXI6ZnVuY3Rpb24obil7dC5yb3dIb3ZlcmVkKG4sZSxpKX19fSx0Ll9sKHQuZmllbGRzLGZ1bmN0aW9uKG8scil7cmV0dXJuIG4oXCJ0ZFwiLHtrZXk6cixjbGFzczp0LnRkQ2xhc3MobyxlLHIpfSxbdC5fdChyLFt0Ll92KHQuX3MoZVtyXSkpXSx7dmFsdWU6ZVtyXSxpdGVtOmUsaW5kZXg6aX0pXSwyKX0pKX0pLCF0LnNob3dFbXB0eXx8dC5faXRlbXMmJjAhPT10Ll9pdGVtcy5sZW5ndGg/dC5fZSgpOm4oXCJ0clwiLHthdHRyczp7cm9sZTpcInJvd1wifX0sW24oXCJ0ZFwiLHthdHRyczp7Y29sc3BhbjpPYmplY3Qua2V5cyh0LmZpZWxkcykubGVuZ3RofX0sW3QuZmlsdGVyP24oXCJkaXZcIix7YXR0cnM6e3JvbGU6XCJhbGVydFwiLFwiYXJpYS1saXZlXCI6XCJwb2xpdGVcIn19LFt0Ll90KFwiZW1wdHlmaWx0ZXJlZFwiLFtuKFwiZGl2XCIse3N0YXRpY0NsYXNzOlwidGV4dC1jZW50ZXIgbXktMlwiLGRvbVByb3BzOntpbm5lckhUTUw6dC5fcyh0LmVtcHR5RmlsdGVyZWRUZXh0KX19KV0pXSwyKTpuKFwiZGl2XCIse2F0dHJzOntyb2xlOlwiYWxlcnRcIixcImFyaWEtbGl2ZVwiOlwicG9saXRlXCJ9fSxbdC5fdChcImVtcHR5XCIsW24oXCJkaXZcIix7c3RhdGljQ2xhc3M6XCJ0ZXh0LWNlbnRlciBteS0yXCIsZG9tUHJvcHM6e2lubmVySFRNTDp0Ll9zKHQuZW1wdHlUZXh0KX19KV0pXSwyKV0pXSldLDIpXSwxKX0sc3RhdGljUmVuZGVyRm5zOltdLGRhdGE6ZnVuY3Rpb24oKXtyZXR1cm57c29ydEJ5Om51bGwsc29ydERlc2M6ITAsbG9jYWxJdGVtczpbXX19LHByb3BzOntpZDp7dHlwZTpTdHJpbmcsZGVmYXVsdDpcIlwifSxpdGVtczp7dHlwZTpbQXJyYXksRnVuY3Rpb25dLGRlZmF1bHQ6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcyYmdGhpcy5pdGVtc1Byb3ZpZGVyPyh3YXJuKFwiYi10YWJsZTogcHJvcCBpdGVtcy1wcm92aWRlciBoYXMgYmVlbiBkZXByZWNhdGVkLiBQYXNzIGEgZnVuY3Rpb24gdG8gaXRlbXMgaW5zdGVhZFwiKSx0aGlzLml0ZW1zUHJvdmlkZXIpOltdfX0sZmllbGRzOnt0eXBlOk9iamVjdCxkZWZhdWx0Ont9fSxzdHJpcGVkOnt0eXBlOkJvb2xlYW4sZGVmYXVsdDohMX0sYm9yZGVyZWQ6e3R5cGU6Qm9vbGVhbixkZWZhdWx0OiExfSxpbnZlcnNlOnt0eXBlOkJvb2xlYW4sZGVmYXVsdDohMX0saG92ZXI6e3R5cGU6Qm9vbGVhbixkZWZhdWx0OiExfSxzbWFsbDp7dHlwZTpCb29sZWFuLGRlZmF1bHQ6ITF9LHJlc3BvbnNpdmU6e3R5cGU6Qm9vbGVhbixkZWZhdWx0OiExfSxoZWFkVmFyaWFudDp7dHlwZTpTdHJpbmcsZGVmYXVsdDpcIlwifSxmb290VmFyaWFudDp7dHlwZTpTdHJpbmcsZGVmYXVsdDpcIlwifSxwZXJQYWdlOnt0eXBlOk51bWJlcixkZWZhdWx0Om51bGx9LGN1cnJlbnRQYWdlOnt0eXBlOk51bWJlcixkZWZhdWx0OjF9LGZpbHRlcjp7dHlwZTpbU3RyaW5nLFJlZ0V4cCxGdW5jdGlvbl0sZGVmYXVsdDpudWxsfSxzb3J0Q29tcGFyZTp7dHlwZTpGdW5jdGlvbixkZWZhdWx0Om51bGx9LGl0ZW1zUHJvdmlkZXI6e3R5cGU6RnVuY3Rpb24sZGVmYXVsdDpudWxsfSxub1Byb3ZpZGVyUGFnaW5nOnt0eXBlOkJvb2xlYW4sZGVmYXVsdDohMX0sbm9Qcm92aWRlclNvcnRpbmc6e3R5cGU6Qm9vbGVhbixkZWZhdWx0OiExfSxub1Byb3ZpZGVyRmlsdGVyaW5nOnt0eXBlOkJvb2xlYW4sZGVmYXVsdDohMX0sYnVzeTp7dHlwZTpCb29sZWFuLGRlZmF1bHQ6ITF9LHZhbHVlOnt0eXBlOkFycmF5LGRlZmF1bHQ6ZnVuY3Rpb24oKXtyZXR1cm5bXX19LGZvb3RDbG9uZTp7dHlwZTpCb29sZWFuLGRlZmF1bHQ6ITF9LGxhYmVsU29ydEFzYzp7dHlwZTpTdHJpbmcsZGVmYXVsdDpcIkNsaWNrIHRvIHNvcnQgQXNjZW5kaW5nXCJ9LGxhYmVsU29ydERlc2M6e3R5cGU6U3RyaW5nLGRlZmF1bHQ6XCJDbGljayB0byBzb3J0IERlc2NlbmRpbmdcIn0sc2hvd0VtcHR5Ont0eXBlOkJvb2xlYW4sZGVmYXVsdDohMX0sZW1wdHlUZXh0Ont0eXBlOlN0cmluZyxkZWZhdWx0OlwiVGhlcmUgYXJlIG5vIHJlY29yZHMgdG8gc2hvd1wifSxlbXB0eUZpbHRlcmVkVGV4dDp7dHlwZTpTdHJpbmcsZGVmYXVsdDpcIlRoZXJlIGFyZSBubyByZWNvcmRzIG1hdGNoaW5nIHlvdXIgcmVxdWVzdFwifX0sd2F0Y2g6e2l0ZW1zOmZ1bmN0aW9uKHQsZSl7ZSE9PXQmJnRoaXMuX3Byb3ZpZGVyVXBkYXRlKCl9LHNvcnREZXNjOmZ1bmN0aW9uKHQsZSl7ZT09PXR8fHRoaXMubm9Qcm92aWRlclNvcnRpbmd8fHRoaXMuX3Byb3ZpZGVyVXBkYXRlKCl9LHNvcnRCeTpmdW5jdGlvbih0LGUpe2U9PT10fHx0aGlzLm5vUHJvdmlkZXJTb3J0aW5nfHx0aGlzLl9wcm92aWRlclVwZGF0ZSgpfSxwZXJQYWdlOmZ1bmN0aW9uKHQsZSl7ZT09PXR8fHRoaXMubm9Qcm92aWRlclBhZ2luZ3x8dGhpcy5fcHJvdmlkZXJVcGRhdGUoKX0sY3VycmVudFBhZ2U6ZnVuY3Rpb24odCxlKXtlPT09dHx8dGhpcy5ub1Byb3ZpZGVyUGFnaW5nfHx0aGlzLl9wcm92aWRlclVwZGF0ZSgpfSxmaWx0ZXI6ZnVuY3Rpb24odCxlKXtlPT09dHx8dGhpcy5ub1Byb3ZpZGVyRmlsdGVyaW5nfHx0aGlzLl9wcm92aWRlclVwZGF0ZSgpfX0sbW91bnRlZDpmdW5jdGlvbigpe3ZhciB0PXRoaXM7dGhpcy5oYXNQcm92aWRlciYmdGhpcy5fcHJvdmlkZXJVcGRhdGUoKSx0aGlzLiRyb290LiRvbihcInRhYmxlOjpyZWZyZXNoXCIsZnVuY3Rpb24oZSl7ZT09PXQuaWQmJnQuX3Byb3ZpZGVyVXBkYXRlKCl9KX0sY29tcHV0ZWQ6e3RhYmxlQ2xhc3M6ZnVuY3Rpb24oKXtyZXR1cm5bXCJ0YWJsZVwiLFwiYi10YWJsZVwiLHRoaXMuc3RyaXBlZD9cInRhYmxlLXN0cmlwZWRcIjpcIlwiLHRoaXMuaG92ZXI/XCJ0YWJsZS1ob3ZlclwiOlwiXCIsdGhpcy5pbnZlcnNlP1widGFibGUtaW52ZXJzZVwiOlwiXCIsdGhpcy5ib3JkZXJlZD9cInRhYmxlLWJvcmRlcmVkXCI6XCJcIix0aGlzLnJlc3BvbnNpdmU/XCJ0YWJsZS1yZXNwb25zaXZlXCI6XCJcIix0aGlzLnNtYWxsP1widGFibGUtc21cIjpcIlwiXX0saGVhZENsYXNzOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuaGVhZFZhcmlhbnQ/XCJ0aGVhZC1cIit0aGlzLmhlYWRWYXJpYW50OlwiXCJ9LGZvb3RDbGFzczpmdW5jdGlvbigpe3ZhciB0PXRoaXMuZm9vdFZhcmlhbnR8fHRoaXMuaGVhZFZhcmlhbnR8fG51bGw7cmV0dXJuIHQ/XCJ0aGVhZC1cIit0OlwiXCJ9LGhhc1Byb3ZpZGVyOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuaXRlbXMgaW5zdGFuY2VvZiBGdW5jdGlvbn0scHJvdmlkZXJGaWx0ZXJpbmc6ZnVuY3Rpb24oKXtyZXR1cm4gQm9vbGVhbih0aGlzLmhhc1Byb3ZpZGVyJiYhdGhpcy5ub1Byb3ZpZGVyRmlsdGVyaW5nKX0scHJvdmlkZXJTb3J0aW5nOmZ1bmN0aW9uKCl7cmV0dXJuIEJvb2xlYW4odGhpcy5oYXNQcm92aWRlciYmIXRoaXMubm9Qcm92aWRlclNvcnRpbmcpfSxwcm92aWRlclBhZ2luZzpmdW5jdGlvbigpe3JldHVybiBCb29sZWFuKHRoaXMuaGFzUHJvdmlkZXImJiF0aGlzLm5vUHJvdmlkZXJQYWdpbmcpfSxjb250ZXh0OmZ1bmN0aW9uKCl7cmV0dXJue3BlclBhZ2U6dGhpcy5wZXJQYWdlLGN1cnJlbnRQYWdlOnRoaXMuY3VycmVudFBhZ2UsZmlsdGVyOnRoaXMuZmlsdGVyLHNvcnRCeTp0aGlzLnNvcnRCeSxzb3J0RGVzYzp0aGlzLnNvcnREZXNjfX0sX2l0ZW1zOmZ1bmN0aW9uKCl7dmFyIHQ9dGhpcyxlPXRoaXMucGVyUGFnZSxuPXRoaXMuY3VycmVudFBhZ2UsaT10aGlzLmZpbHRlcixvPSh0aGlzLnNvcnRCeSx0aGlzLnNvcnREZXNjLHRoaXMuc29ydENvbXBhcmV8fGRlZmF1bHRTb3J0Q29tcGFyZSkscj10aGlzLmhhc1Byb3ZpZGVyP3RoaXMubG9jYWxJdGVtczp0aGlzLml0ZW1zO2lmKCFyKXJldHVybiB0aGlzLiRuZXh0VGljayh0aGlzLl9wcm92aWRlclVwZGF0ZSksW107aWYocj1yLnNsaWNlKCksaSYmIXRoaXMucHJvdmlkZXJGaWx0ZXJpbmcpaWYoaSBpbnN0YW5jZW9mIEZ1bmN0aW9uKXI9ci5maWx0ZXIoaSk7ZWxzZXt2YXIgcztzPWkgaW5zdGFuY2VvZiBSZWdFeHA/aTpuZXcgUmVnRXhwKFwiLipcIitpK1wiLipcIixcImlnXCIpLHI9ci5maWx0ZXIoZnVuY3Rpb24odCl7dmFyIGU9cy50ZXN0KHJlY1RvU3RyaW5nKHQpKTtyZXR1cm4gcy5sYXN0SW5kZXg9MCxlfSl9cmV0dXJuIHRoaXMuc29ydEJ5JiYhdGhpcy5wcm92aWRlclNvcnRpbmcmJihyPXIuc29ydChmdW5jdGlvbihlLG4pe3ZhciBpPW8oZSxuLHQuc29ydEJ5KTtyZXR1cm4gdC5zb3J0RGVzYz9pOi0xKml9KSksZSYmIXRoaXMucHJvdmlkZXJQYWdpbmcmJihyPXIuc2xpY2UoKG4tMSkqZSxuKmUpKSx0aGlzLiRlbWl0KFwiaW5wdXRcIixyKSxyfX0sbWV0aG9kczp7ZmllbGRDbGFzczpmdW5jdGlvbih0LGUpe3JldHVyblt0LnNvcnRhYmxlP1wic29ydGluZ1wiOlwiXCIsdC5zb3J0YWJsZSYmdGhpcy5zb3J0Qnk9PT1lP1wic29ydGluZ19cIisodGhpcy5zb3J0RGVzYz9cImRlc2NcIjpcImFzY1wiKTpcIlwiLHQudmFyaWFudD9cInRhYmxlLVwiK3QudmFyaWFudDpcIlwiLHQuY2xhc3M/dC5jbGFzczpcIlwiLHQudGhDbGFzcz90LnRoQ2xhc3M6XCJcIl19LHRkQ2xhc3M6ZnVuY3Rpb24odCxlLG4pe3ZhciBpPVwiXCI7cmV0dXJuIGUuX2NlbGxWYXJpYW50cyYmZS5fY2VsbFZhcmlhbnRzW25dJiYoaT0odGhpcy5pbnZlcnNlP1wiYmctXCI6XCJ0YWJsZS1cIikrZS5fY2VsbFZhcmlhbnRzW25dKSxbdC52YXJpYW50JiYhaT8odGhpcy5pbnZlcnNlP1wiYmctXCI6XCJ0YWJsZS1cIikrdC52YXJpYW50OlwiXCIsaSx0LmNsYXNzP3QuY2xhc3M6XCJcIix0LnRkQ2xhc3M/dC50ZENsYXNzOlwiXCJdfSxyb3dDbGFzczpmdW5jdGlvbih0KXt2YXIgZT10Ll9yb3dWYXJpYW50fHx0LnN0YXRlfHxudWxsO3JldHVybltlPyh0aGlzLmludmVyc2U/XCJiZy1cIjpcInRhYmxlLVwiKStlOlwiXCJdfSxyb3dDbGlja2VkOmZ1bmN0aW9uKHQsZSxuKXtpZih0aGlzLmJ1c3kpcmV0dXJuIHQucHJldmVudERlZmF1bHQoKSx2b2lkIHQuc3RvcFByb3BhZ2F0aW9uKCk7dGhpcy4kZW1pdChcInJvdy1jbGlja2VkXCIsZSxuKX0scm93SG92ZXJlZDpmdW5jdGlvbih0LGUsbil7aWYodGhpcy5idXN5KXJldHVybiB0LnByZXZlbnREZWZhdWx0KCksdm9pZCB0LnN0b3BQcm9wYWdhdGlvbigpO3RoaXMuJGVtaXQoXCJyb3ctaG92ZXJlZFwiLGUsbil9LGhlYWRDbGlja2VkOmZ1bmN0aW9uKHQsZSxuKXtpZih0aGlzLmJ1c3kpcmV0dXJuIHQucHJldmVudERlZmF1bHQoKSx2b2lkIHQuc3RvcFByb3BhZ2F0aW9uKCk7dmFyIGk9ITE7ZS5zb3J0YWJsZT8obj09PXRoaXMuc29ydEJ5P3RoaXMuc29ydERlc2M9IXRoaXMuc29ydERlc2M6KHRoaXMuc29ydEJ5PW4sdGhpcy5zb3J0RGVzYz0hMCksaT0hMCk6dGhpcy5zb3J0QnkmJih0aGlzLnNvcnRCeT1udWxsLGk9ITApLHRoaXMuJGVtaXQoXCJoZWFkLWNsaWNrZWRcIixuLGUpLGkmJnRoaXMuJGVtaXQoXCJzb3J0LWNoYW5nZWRcIix0aGlzLmNvbnRleHQpfSxyZWZyZXNoOmZ1bmN0aW9uKCl7dGhpcy5oYXNQcm92aWRlciYmdGhpcy5fcHJvdmlkZXJVcGRhdGUoKX0sX3Byb3ZpZGVyU2V0TG9jYWw6ZnVuY3Rpb24odCl7dGhpcy5sb2NhbEl0ZW1zPXQmJnQubGVuZ3RoPjA/dC5zbGljZSgpOltdLHRoaXMuJGVtaXQoXCJyZWZyZXNoZWRcIiksdGhpcy4kcm9vdC4kZW1pdChcInRhYmxlOjpyZWZyZXNoZWRcIix0aGlzLmlkKX0sX3Byb3ZpZGVyVXBkYXRlOmZ1bmN0aW9uKCl7dmFyIHQ9dGhpcztpZighdGhpcy5idXN5JiZ0aGlzLmhhc1Byb3ZpZGVyKXt2YXIgZT10aGlzLml0ZW1zKHRoaXMuY29udGV4dCx0aGlzLl9wcm92aWRlclNldExvY2FsKTtlJiYoZS50aGVuJiZcImZ1bmN0aW9uXCI9PXR5cGVvZiBlLnRoZW4/ZS50aGVuKGZ1bmN0aW9uKGUpe3QuX3Byb3ZpZGVyU2V0TG9jYWwoZSl9KTp0aGlzLl9wcm92aWRlclNldExvY2FsKGUpKX19fX0sdGFicz17cmVuZGVyOmZ1bmN0aW9uKCl7dmFyIHQ9dGhpcyxlPXQuJGNyZWF0ZUVsZW1lbnQsbj10Ll9zZWxmLl9jfHxlO3JldHVybiBuKHQudGFnLHt0YWc6XCJjb21wb25lbnRcIixzdGF0aWNDbGFzczpcInRhYnNcIixhdHRyczp7aWQ6dC5pZHx8bnVsbH19LFt0LmJvdHRvbT9uKFwiZGl2XCIse3JlZjpcInRhYnNDb250YWluZXJcIixjbGFzczpbXCJ0YWItY29udGVudFwiLHtcImNhcmQtYmxvY2tcIjp0LmNhcmR9XX0sW3QuX3QoXCJkZWZhdWx0XCIpLHQudGFicyYmdC50YWJzLmxlbmd0aD90Ll9lKCk6dC5fdChcImVtcHR5XCIpXSwyKTp0Ll9lKCksbihcImRpdlwiLHtjbGFzczp7XCJjYXJkLWhlYWRlclwiOnQuY2FyZH19LFtuKFwidWxcIix7Y2xhc3M6W1wibmF2XCIsXCJuYXYtXCIrdC5uYXZTdHlsZSx0LmNhcmQ/XCJjYXJkLWhlYWRlci1cIit0Lm5hdlN0eWxlOm51bGxdLGF0dHJzOntyb2xlOlwidGFibGlzdFwiLHRhYmluZGV4OlwiMFwiLFwiYXJpYS1zZXRzaXplXCI6dC50YWJzLmxlbmd0aCxcImFyaWEtcG9zaW5zZXRcIjp0LmN1cnJlbnRUYWIrMX0sb246e2tleWRvd246W2Z1bmN0aW9uKGUpe3JldHVyblwiYnV0dG9uXCJpbiBlfHwhdC5fayhlLmtleUNvZGUsXCJsZWZ0XCIsMzcpP1wiYnV0dG9uXCJpbiBlJiYwIT09ZS5idXR0b24/bnVsbDp2b2lkIHQucHJldmlvdXNUYWIoZSk6bnVsbH0sZnVuY3Rpb24oZSl7aWYoIShcImJ1dHRvblwiaW4gZSkmJnQuX2soZS5rZXlDb2RlLFwidXBcIiwzOCkpcmV0dXJuIG51bGw7dC5wcmV2aW91c1RhYihlKX0sZnVuY3Rpb24oZSl7cmV0dXJuXCJidXR0b25cImluIGV8fCF0Ll9rKGUua2V5Q29kZSxcInJpZ2h0XCIsMzkpP1wiYnV0dG9uXCJpbiBlJiYyIT09ZS5idXR0b24/bnVsbDp2b2lkIHQubmV4dFRhYihlKTpudWxsfSxmdW5jdGlvbihlKXtpZighKFwiYnV0dG9uXCJpbiBlKSYmdC5fayhlLmtleUNvZGUsXCJkb3duXCIsNDApKXJldHVybiBudWxsO3QubmV4dFRhYihlKX0sZnVuY3Rpb24oZSl7cmV0dXJuKFwiYnV0dG9uXCJpbiBlfHwhdC5fayhlLmtleUNvZGUsXCJsZWZ0XCIsMzcpKSYmZS5zaGlmdEtleT9cImJ1dHRvblwiaW4gZSYmMCE9PWUuYnV0dG9uP251bGw6dm9pZCB0LnNldFRhYigtMSwhMSwxKTpudWxsfSxmdW5jdGlvbihlKXtyZXR1cm4oXCJidXR0b25cImluIGV8fCF0Ll9rKGUua2V5Q29kZSxcInVwXCIsMzgpKSYmZS5zaGlmdEtleT92b2lkIHQuc2V0VGFiKC0xLCExLDEpOm51bGx9LGZ1bmN0aW9uKGUpe3JldHVybihcImJ1dHRvblwiaW4gZXx8IXQuX2soZS5rZXlDb2RlLFwicmlnaHRcIiwzOSkpJiZlLnNoaWZ0S2V5P1wiYnV0dG9uXCJpbiBlJiYyIT09ZS5idXR0b24/bnVsbDp2b2lkIHQuc2V0VGFiKHQudGFicy5sZW5ndGgsITEsLTEpOm51bGx9LGZ1bmN0aW9uKGUpe3JldHVybihcImJ1dHRvblwiaW4gZXx8IXQuX2soZS5rZXlDb2RlLFwiZG93blwiLDQwKSkmJmUuc2hpZnRLZXk/dm9pZCB0LnNldFRhYih0LnRhYnMubGVuZ3RoLCExLC0xKTpudWxsfV19fSxbdC5fbCh0LnRhYnMsZnVuY3Rpb24oZSxpKXtyZXR1cm4gbihcImxpXCIse3N0YXRpY0NsYXNzOlwibmF2LWl0ZW1cIixhdHRyczp7cm9sZTpcInByZXNlbnRhdGlvblwifX0sW2UuaGVhZEh0bWw/bihcImRpdlwiLHtjbGFzczpbXCJ0YWItaGVhZFwiLHtzbWFsbDp0LnNtYWxsLGFjdGl2ZTplLmxvY2FsQWN0aXZlLGRpc2FibGVkOmUuZGlzYWJsZWR9XSxhdHRyczp7cm9sZTpcImhlYWRpbmdcIix0YWJpbmRleDpcIi0xXCJ9LGRvbVByb3BzOntpbm5lckhUTUw6dC5fcyhlLmhlYWRIdG1sKX19KTpuKFwiYVwiLHtjbGFzczpbXCJuYXYtbGlua1wiLHtzbWFsbDp0LnNtYWxsLGFjdGl2ZTplLmxvY2FsQWN0aXZlLGRpc2FibGVkOmUuZGlzYWJsZWR9XSxhdHRyczp7aHJlZjplLmhyZWYscm9sZTpcInRhYlwiLFwiYXJpYS1zZWxlY3RlZFwiOmUubG9jYWxBY3RpdmU/XCJ0cnVlXCI6XCJmYWxzZVwiLFwiYXJpYS1jb250cm9sc1wiOmUuaWR8fG51bGwsaWQ6ZS5jb250cm9sbGVkQnl8fG51bGwsdGFiaW5kZXg6XCItMVwifSxkb21Qcm9wczp7aW5uZXJIVE1MOnQuX3MoZS50aXRsZSl9LG9uOntjbGljazpmdW5jdGlvbihlKXtlLnByZXZlbnREZWZhdWx0KCksZS5zdG9wUHJvcGFnYXRpb24oKSx0LnNldFRhYihpKX0sa2V5ZG93bjpbZnVuY3Rpb24oZSl7aWYoIShcImJ1dHRvblwiaW4gZSkmJnQuX2soZS5rZXlDb2RlLFwic3BhY2VcIiwzMikpcmV0dXJuIG51bGw7ZS5wcmV2ZW50RGVmYXVsdCgpLGUuc3RvcFByb3BhZ2F0aW9uKCksdC5zZXRUYWIoaSl9LGZ1bmN0aW9uKGUpe2lmKCEoXCJidXR0b25cImluIGUpJiZ0Ll9rKGUua2V5Q29kZSxcImVudGVyXCIsMTMpKXJldHVybiBudWxsO2UucHJldmVudERlZmF1bHQoKSxlLnN0b3BQcm9wYWdhdGlvbigpLHQuc2V0VGFiKGkpfV19fSldKX0pLHQuX3QoXCJ0YWJzXCIpXSwyKV0pLHQuYm90dG9tP3QuX2UoKTpuKFwiZGl2XCIse3JlZjpcInRhYnNDb250YWluZXJcIixjbGFzczpbXCJ0YWItY29udGVudFwiLHtcImNhcmQtYmxvY2tcIjp0LmNhcmR9XX0sW3QuX3QoXCJkZWZhdWx0XCIpLHQudGFicyYmdC50YWJzLmxlbmd0aD90Ll9lKCk6dC5fdChcImVtcHR5XCIpXSwyKV0pfSxzdGF0aWNSZW5kZXJGbnM6W10sZGF0YTpmdW5jdGlvbigpe3JldHVybntjdXJyZW50VGFiOnRoaXMudmFsdWUsdGFiczpbXX19LHByb3BzOntpZDp7dHlwZTpTdHJpbmcsZGVmYXVsdDpcIlwifSx0YWc6e3R5cGU6U3RyaW5nLGRlZmF1bHQ6XCJkaXZcIn0sbm9GYWRlOnt0eXBlOkJvb2xlYW4sZGVmYXVsdDohMX0sY2FyZDp7dHlwZTpCb29sZWFuLGRlZmF1bHQ6ITF9LHNtYWxsOnt0eXBlOkJvb2xlYW4sZGVmYXVsdDohMX0sdmFsdWU6e3R5cGU6TnVtYmVyLGRlZmF1bHQ6MH0scGlsbHM6e3R5cGU6Qm9vbGVhbixkZWZhdWx0OiExfSxsYXp5Ont0eXBlOkJvb2xlYW4sZGVmYXVsdDohMX0sYm90dG9tOnt0eXBlOkJvb2xlYW4sZGVmYXVsdDohMX19LHdhdGNoOntjdXJyZW50VGFiOmZ1bmN0aW9uKHQsZSl7dCE9PWUmJih0aGlzLiRyb290LiRlbWl0KFwiY2hhbmdlZDo6dGFiXCIsdGhpcyx0LHRoaXMudGFic1t0XSksdGhpcy4kZW1pdChcImlucHV0XCIsdCksdGhpcy50YWJzW3RdLiRlbWl0KFwiY2xpY2tcIikpfSx2YWx1ZTpmdW5jdGlvbih0LGUpe3QhPT1lJiZ0aGlzLnNldFRhYih0KX0sZmFkZTpmdW5jdGlvbih0LGUpe3ZhciBuPXRoaXM7dCE9PWUmJnRoaXMudGFicy5mb3JFYWNoKGZ1bmN0aW9uKGUpe24uJHNldChlLFwiZmFkZVwiLHQpfSl9fSxjb21wdXRlZDp7ZmFkZTpmdW5jdGlvbigpe3JldHVybiF0aGlzLm5vRmFkZX0sbmF2U3R5bGU6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5waWxscz9cInBpbGxzXCI6XCJ0YWJzXCJ9fSxtZXRob2RzOntzaWduOmZ1bmN0aW9uKHQpe3JldHVybiAwPT09dD8wOnQ+MD8xOi0xfSxuZXh0VGFiOmZ1bmN0aW9uKCl7dGhpcy5zZXRUYWIodGhpcy5jdXJyZW50VGFiLCExLDEpfSxwcmV2aW91c1RhYjpmdW5jdGlvbigpe3RoaXMuc2V0VGFiKHRoaXMuY3VycmVudFRhYiwhMSwtMSl9LHNldFRhYjpmdW5jdGlvbih0LGUsbil7dmFyIGk9dGhpcztpZihuPW58fDAsZXx8dCtuIT09dGhpcy5jdXJyZW50VGFiKXt2YXIgbz10aGlzLnRhYnNbdCtuXTtvJiYoby5kaXNhYmxlZD9uJiZ0aGlzLnNldFRhYih0LGUsbit0aGlzLnNpZ24obikpOih0aGlzLnRhYnMuZm9yRWFjaChmdW5jdGlvbih0KXt0IT09byYmdC5sb2NhbEFjdGl2ZSYmaS4kc2V0KHQsXCJsb2NhbEFjdGl2ZVwiLCExKX0pLHRoaXMuJHNldChvLFwibG9jYWxBY3RpdmVcIiwhMCksdGhpcy5jdXJyZW50VGFiPXQrbikpfX0sdXBkYXRlVGFiczpmdW5jdGlvbigpe3ZhciB0PXRoaXM7dGhpcy4kc2xvdHMuZGVmYXVsdD90aGlzLnRhYnM9dGhpcy4kc2xvdHMuZGVmYXVsdC5maWx0ZXIoZnVuY3Rpb24odCl7cmV0dXJuIHQuY29tcG9uZW50SW5zdGFuY2V8fCExfSkubWFwKGZ1bmN0aW9uKHQpe3JldHVybiB0LmNvbXBvbmVudEluc3RhbmNlfSk6dGhpcy50YWJzPVtdLHRoaXMudGFicy5mb3JFYWNoKGZ1bmN0aW9uKGUpe3QuJHNldChlLFwiZmFkZVwiLHQuZmFkZSksdC4kc2V0KGUsXCJsYXp5XCIsdC5sYXp5KX0pO3ZhciBlPXRoaXMuY3VycmVudFRhYjtudWxsIT09ZSYmdm9pZCAwIT09ZXx8dGhpcy50YWJzLmZvckVhY2goZnVuY3Rpb24odCxuKXt0LmFjdGl2ZSYmKGU9bil9KTt2YXIgbj0wO2U+dGhpcy50YWJzLmxlbmd0aC0xJiYobj0tMSksdGhpcy5zZXRUYWIoZXx8MCwhMCxuKX19LG1vdW50ZWQ6ZnVuY3Rpb24oKXt0aGlzLnVwZGF0ZVRhYnMoKSxvYnNlcnZlRE9NKHRoaXMuJHJlZnMudGFic0NvbnRhaW5lcix0aGlzLnVwZGF0ZVRhYnMuYmluZCh0aGlzKSx7c3VidHJlZTohMX0pfX0sdGFiPXtyZW5kZXI6ZnVuY3Rpb24oKXt2YXIgdD10aGlzLGU9dC4kY3JlYXRlRWxlbWVudCxuPXQuX3NlbGYuX2N8fGU7cmV0dXJuIG4oXCJ0cmFuc2l0aW9uXCIse2F0dHJzOnttb2RlOlwib3V0LWluXCJ9LG9uOntlbnRlcjp0LmVudGVyLFwiYmVmb3JlLWxlYXZlXCI6dC5iZWZvcmVMZWF2ZX19LFt0LmxvY2FsQWN0aXZlfHwhdC5sYXp5P24odC50YWcse2RpcmVjdGl2ZXM6W3tuYW1lOlwic2hvd1wiLHJhd05hbWU6XCJ2LXNob3dcIix2YWx1ZTp0LmxvY2FsQWN0aXZlfHx0LmxhenksZXhwcmVzc2lvbjpcImxvY2FsQWN0aXZlIHx8IGxhenlcIn1dLHJlZjpcInBhbmVsXCIsdGFnOlwiY29tcG9uZW50XCIsY2xhc3M6W1widGFiLXBhbmVcIix7c2hvdzp0LnNob3csZmFkZTp0LmZhZGUsZGlzYWJsZWQ6dC5kaXNhYmxlZCxhY3RpdmU6dC5sb2NhbEFjdGl2ZX1dLGF0dHJzOntpZDp0LmlkfHxudWxsLHJvbGU6XCJ0YWJwYW5lbFwiLFwiYXJpYS1oaWRkZW5cIjp0LmxvY2FsQWN0aXZlP1wiZmFsc2VcIjpcInRydWVcIixcImFyaWEtZXhwYW5kZWRcIjp0LmxvY2FsQWN0aXZlP1widHJ1ZVwiOlwiZmFsc2VcIixcImFyaWEtbGFibGVsbGVkYnlcIjp0LmNvbnRyb2xsZWRCeXx8bnVsbH19LFt0Ll90KFwiZGVmYXVsdFwiKV0sMik6dC5fZSgpXSwxKX0sc3RhdGljUmVuZGVyRm5zOltdLG1ldGhvZHM6e2VudGVyOmZ1bmN0aW9uKCl7dGhpcy5zaG93PSEwfSxiZWZvcmVMZWF2ZTpmdW5jdGlvbigpe3RoaXMuc2hvdz0hMX19LGRhdGE6ZnVuY3Rpb24oKXtyZXR1cm57ZmFkZTohMSxsb2NhbEFjdGl2ZTohMSxsYXp5OiEwLHNob3c6ITF9fSxjb21wdXRlZDp7Y29udHJvbGxlZEJ5OmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuYnV0dG9uSWR8fCh0aGlzLmlkP3RoaXMuaWQrXCJfX0JWX3RhYl9idXR0b25fX1wiOm51bGwpfX0scHJvcHM6e2lkOnt0eXBlOlN0cmluZyxkZWZhdWx0OlwiXCJ9LHRhZzp7dHlwZTpTdHJpbmcsZGVmYXVsdDpcImRpdlwifSxidXR0b25JZDp7dHlwZTpTdHJpbmcsZGVmYXVsdDpcIlwifSx0aXRsZTp7dHlwZTpTdHJpbmcsZGVmYXVsdDpcIlwifSxoZWFkSHRtbDp7dHlwZTpTdHJpbmcsZGVmYXVsdDpudWxsfSxkaXNhYmxlZDp7dHlwZTpCb29sZWFuLGRlZmF1bHQ6ITF9LGFjdGl2ZTp7dHlwZTpCb29sZWFuLGRlZmF1bHQ6ITF9LGhyZWY6e3R5cGU6U3RyaW5nLGRlZmF1bHQ6XCIjXCJ9fX0sdG9vbHRpcD17cmVuZGVyOmZ1bmN0aW9uKCl7dmFyIHQ9dGhpcyxlPXQuJGNyZWF0ZUVsZW1lbnQsbj10Ll9zZWxmLl9jfHxlO3JldHVybiBuKFwiZGl2XCIse3N0YXRpY0NsYXNzOlwiZC1pbmxpbmUtYmxvY2tcIn0sW24oXCJzcGFuXCIse3JlZjpcInRyaWdnZXJcIixzdGF0aWNDbGFzczpcImQtaW5saW5lLWJsb2NrXCJ9LFt0Ll90KFwiZGVmYXVsdFwiKV0sMiksbihcImRpdlwiLHtyZWY6XCJwb3BvdmVyXCIsY2xhc3M6W1widG9vbHRpcFwiLFwidG9vbHRpcC1cIit0aGlzLnBsYWNlbWVudF0sc3R5bGU6e29wYWNpdHk6dC5zaG93U3RhdGU/MTowfSxhdHRyczp7dGFiaW5kZXg6XCItMVwifSxvbjp7Zm9jdXM6ZnVuY3Rpb24oZSl7dC4kZW1pdChcImZvY3VzXCIpfSxibHVyOmZ1bmN0aW9uKGUpe3QuJGVtaXQoXCJibHVyXCIpfX19LFtuKFwiZGl2XCIse3N0YXRpY0NsYXNzOlwidG9vbHRpcC1pbm5lclwifSxbdC5fdChcImNvbnRlbnRcIixbbihcInNwYW5cIix7ZG9tUHJvcHM6e2lubmVySFRNTDp0Ll9zKHQuY29udGVudCl9fSldKV0sMildKV0pfSxzdGF0aWNSZW5kZXJGbnM6W10sbWl4aW5zOltwb3BvdmVyJDFdLHByb3BzOntjb250ZW50Ont0eXBlOlN0cmluZyxkZWZhdWx0OlwiXCJ9LHRyaWdnZXJzOnt0eXBlOltCb29sZWFuLFN0cmluZyxBcnJheV0sZGVmYXVsdDpcImhvdmVyXCJ9fX0sY29tcG9uZW50cz1PYmplY3QuZnJlZXplKHtiQWxlcnQ6YWxlcnQsYkJyZWFkY3J1bWI6YnJlYWRjcnVtYixiQnV0dG9uOmJCdG4sYkJ0bjpiQnRuLGJCdXR0b25Ub29sYmFyOmJ1dHRvblRvb2xiYXIsYkJ0blRvb2xiYXI6YnV0dG9uVG9vbGJhcixiQnV0dG9uR3JvdXA6YnV0dG9uR3JvdXAsYkJ0bkdyb3VwOmJ1dHRvbkdyb3VwLGJCdXR0b25Hcm91cERyb3Bkb3duOmJ1dHRvbkdyb3VwRHJvcGRvd24sYkJ0bkdyb3VwRHJvcGRvd246YnV0dG9uR3JvdXBEcm9wZG93bixiSW5wdXRHcm91cDppbnB1dEdyb3VwLGJJbnB1dEdyb3VwQWRkb246aW5wdXRHcm91cEFkZG9uLGJJbnB1dEdyb3VwQnV0dG9uOmlucHV0R3JvdXBCdXR0b24sYklucHV0R3JvdXBCdG46aW5wdXRHcm91cEJ1dHRvbixiQ2FyZDpjYXJkLGJDYXJkR3JvdXA6Y2FyZEdyb3VwLGJEcm9wZG93bjpkcm9wZG93biQxLGJEcm9wZG93bkl0ZW06ZHJvcGRvd25JdGVtLGJEcm9wZG93bkl0ZW1CdXR0b246ZHJvcGRvd25JdGVtQnV0dG9uLGJEcm9wZG93bkl0ZW1CdG46ZHJvcGRvd25JdGVtQnV0dG9uLGJEcm9wZG93bkRpdmlkZXI6ZHJvcGRvd25EaXZpZGVyLGJEcm9wZG93bkhlYWRlcjpkcm9wZG93bkhlYWRlcixiRHJvcGRvd25TZWxlY3Q6ZHJvcGRvd25TZWxlY3QsYkZvcm06YkZvcm0sYkZvcm1DaGVja2JveDpmb3JtQ2hlY2tib3gsYkZvcm1GaWVsZHNldDpmb3JtRmllbGRzZXQsYkZvcm1GaWxlOmZvcm1GaWxlLGJGb3JtUmFkaW86Zm9ybVJhZGlvLGJGb3JtSW5wdXQ6Zm9ybUlucHV0LGJGb3JtSW5wdXRTdGF0aWM6YkZvcm1JbnB1dFN0YXRpYyxiRm9ybVNlbGVjdDpmb3JtU2VsZWN0LGJKdW1ib3Ryb246anVtYm90cm9uLGJCYWRnZTpiYWRnZSxiTWVkaWE6bWVkaWEsYk1vZGFsOm1vZGFsLGJOYXZiYXI6bmF2YmFyLGJOYXZUZXh0Om5hdlRleHQsYk5hdkZvcm06bmF2Rm9ybSxiUGFnaW5hdGlvbjpwYWdpbmF0aW9uLGJQb3BvdmVyOnBvcG92ZXIsYlByb2dyZXNzOnByb2dyZXNzLGJUYWJsZTp0YWJsZSxiVG9vbHRpcDp0b29sdGlwLGJUYWI6dGFiLGJUYWJzOnRhYnMsYk5hdjpuYXYsYk5hdkl0ZW06bmF2SXRlbSxiTmF2SXRlbURyb3Bkb3duOm5hdkl0ZW1Ecm9wZG93bixiTmF2VG9nZ2xlOm5hdlRvZ2dsZSxiTGlzdEdyb3VwSXRlbTpsaXN0R3JvdXBJdGVtLGJMaXN0R3JvdXA6bGlzdEdyb3VwLGJDYXJvdXNlbFNsaWRlOmNhcm91c2VsU2xpZGUsYkNhcm91c2VsOmNhcm91c2VsLGJDb2xsYXBzZTpjb2xsYXBzZSxiTGluazpiTGlua30pLGFsbF9saXN0ZW5fdHlwZXM9e2hvdmVyOiEwLGNsaWNrOiEwLGZvY3VzOiEwfSxpbkJyb3dzZXI9XCJ1bmRlZmluZWRcIiE9dHlwZW9mIHdpbmRvdyxsaXN0ZW5fdHlwZXM9e2NsaWNrOiEwfSx0b2dnbGU9e2JpbmQ6ZnVuY3Rpb24odCxlKXt2YXIgbj10YXJnZXRzKHQsZSxsaXN0ZW5fdHlwZXMsZnVuY3Rpb24odCl7dmFyIGU9dC50YXJnZXRzLG49dC52bTtlLmZvckVhY2goZnVuY3Rpb24odCl7bi4kcm9vdC4kZW1pdChcImNvbGxhcHNlOjp0b2dnbGVcIix0KX0pfSk7aW5Ccm93c2VyJiZ0Ll9fdnVlX18mJm4ubGVuZ3RoPjAmJih0LnNldEF0dHJpYnV0ZShcImFyaWEtY29udHJvbHNcIixuLmpvaW4oXCIgXCIpKSx0LnNldEF0dHJpYnV0ZShcImFyaWEtZXhwYW5kZWRcIixcImZhbHNlXCIpLHQuX192dWVfXy4kcm9vdC4kb24oXCJjb2xsYXBzZTo6dG9nZ2xlOjpzdGF0ZVwiLGZ1bmN0aW9uKGUsaSl7LTEhPT1uLmluZGV4T2YoZSkmJnQuc2V0QXR0cmlidXRlKFwiYXJpYS1leHBhbmRlZFwiLGk/XCJ0cnVlXCI6XCJmYWxzZVwiKX0pKX19LGxpc3Rlbl90eXBlcyQxPXtjbGljazohMH0sbW9kYWwkMT17YmluZDpmdW5jdGlvbih0LGUpe3RhcmdldHModCxlLGxpc3Rlbl90eXBlcyQxLGZ1bmN0aW9uKGUpe3ZhciBuPWUudGFyZ2V0cyxpPWUudm07bi5mb3JFYWNoKGZ1bmN0aW9uKGUpe2kuJHJvb3QuJGVtaXQoXCJzaG93Ojptb2RhbFwiLGUsdCl9KX0pfX0saW5Ccm93c2VyJDE9XCJ1bmRlZmluZWRcIiE9dHlwZW9mIHdpbmRvdyxpc1NlcnZlcj0haW5Ccm93c2VyJDE7aW5Ccm93c2VyJDEmJndpbmRvdy5FbGVtZW50JiYhRWxlbWVudC5wcm90b3R5cGUuY2xvc2VzdCYmKEVsZW1lbnQucHJvdG90eXBlLmNsb3Nlc3Q9ZnVuY3Rpb24odCl7dmFyIGUsbj0odGhpcy5kb2N1bWVudHx8dGhpcy5vd25lckRvY3VtZW50KS5xdWVyeVNlbGVjdG9yQWxsKHQpLGk9dGhpcztkb3tmb3IoZT1uLmxlbmd0aDstLWU+PTAmJm4uaXRlbShlKSE9PWk7KTt9d2hpbGUoZTwwJiYoaT1pLnBhcmVudEVsZW1lbnQpKTtyZXR1cm4gaX0pO3ZhciBOQU1FPVwidi1iLXNjcm9sbHNweVwiLEVWRU5UPVwic2Nyb2xsc3B5OjphY3RpdmF0ZVwiLEJWU1M9XCJfX0JWX1Njcm9sbFNweV9fXCIsRGVmYXVsdD17ZWxlbWVudDpcImJvZHlcIixvZmZzZXQ6MTAsbWV0aG9kOlwiYXV0b1wiLHRocm90dGxlOjIwMH0sRGVmYXVsdFR5cGU9e2VsZW1lbnQ6XCIoc3RyaW5nfGVsZW1lbnQpXCIsb2Zmc2V0OlwibnVtYmVyXCIsbWV0aG9kOlwic3RyaW5nXCIsdGhyb3R0bGU6XCJudW1iZXJcIn0sQ2xhc3NOYW1lPXtEUk9QRE9XTl9JVEVNOlwiZHJvcGRvd24taXRlbVwiLERST1BET1dOX01FTlU6XCJkcm9wZG93bi1tZW51XCIsRFJPUERPV05fVE9HR0xFOlwiZHJvcGRvd24tdG9nZ2xlXCIsTkFWX0xJTks6XCJuYXYtbGlua1wiLExJU1RfSVRFTTpcImxpc3QtZ3JvdXAtaXRlbVwiLEFDVElWRTpcImFjdGl2ZVwifSxTZWxlY3Rvcj17QUNUSVZFOlwiLmFjdGl2ZVwiLE5BVl9MSVNUX0dST1VQOlwiLm5hdiwgLmxpc3QtZ3JvdXBcIixOQVY6XCIubmF2XCIsTElTVF9HUk9VUDpcIi5saXN0LWdyb3VwXCIsTkFWX0xJTktTOlwiLm5hdi1saW5rXCIsTElTVF9JVEVNUzpcIi5saXN0LWdyb3VwLWl0ZW1cIixEUk9QRE9XTjpcIi5kcm9wZG93blwiLERST1BET1dOX0lURU1TOlwiLmRyb3Bkb3duLWl0ZW1cIixEUk9QRE9XTl9UT0dHTEU6XCIuZHJvcGRvd24tdG9nZ2xlXCJ9LE9mZnNldE1ldGhvZD17T0ZGU0VUOlwib2Zmc2V0XCIsUE9TSVRJT046XCJwb3NpdGlvblwifTtTY3JvbGxTcHkucHJvdG90eXBlLnVwZGF0ZUNvbmZpZz1mdW5jdGlvbih0KXt2YXIgZT10aGlzO3QuYXJnJiYodGhpcy5fY29uZmlnLmVsZW1lbnQ9XCIjXCIrdC5hcmcpLE9iamVjdC5rZXlzKHQubW9kaWZpZXJzKS5mb3JFYWNoKGZ1bmN0aW9uKHQpey9eXFxkKyQvLnRlc3QodCk/ZS5fY29uZmlnLm9mZnNldD1wYXJzZUludCh0LDEwKTovXihhdXRvfHBvc2l0aW9ufG9mZnNldCkkLy50ZXN0KHQpJiYoZS5fY29uZmlnLm1ldGhvZD10KX0pLFwic3RyaW5nXCI9PXR5cGVvZiB0LnZhbHVlP3RoaXMuX2NvbmZpZy5lbGVtZW50PXQudmFsdWU6XCJudW1iZXJcIj09dHlwZW9mIHQudmFsdWU/dGhpcy5fY29uZmlnLm9mZnNldD1NYXRoLnJvdW5kKHQudmFsdWUpOlwib2JqZWN0XCI9PXR5cGVvZiB0LnZhbHVlJiZPYmplY3Qua2V5cyh0LnZhbHVlKS5maWx0ZXIoZnVuY3Rpb24odCl7cmV0dXJuIEJvb2xlYW4oRGVmYXVsdFR5cGVbdF0pfSkuZm9yRWFjaChmdW5jdGlvbihuKXtlLl9jb25maWdbbl09dC52YWx1ZVtuXX0pLHR5cGVDaGVja0NvbmZpZyhOQU1FLHRoaXMuX2NvbmZpZyxEZWZhdWx0VHlwZSk7dmFyIG49Z2V0Vm0odGhpcy5fJGVsKTtyZXR1cm4gbiYmbi4kcm9vdCYmKHRoaXMuXyRyb290PW4uJHJvb3QpLHRoaXN9LFNjcm9sbFNweS5wcm90b3R5cGUubGlzdGVuPWZ1bmN0aW9uKCl7dmFyIHQ9dGhpcy5fZ2V0U2Nyb2xsZXIoKTtyZXR1cm4gdCYmKFwiQk9EWVwiIT09dC50YWdOYW1lJiZ0LmFkZEV2ZW50TGlzdGVuZXIoXCJzY3JvbGxcIix0aGlzLCExKSx3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihcInNjcm9sbFwiLHRoaXMsITEpLHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwib3JpZW50YXRpb25jaGFuZ2VcIix0aGlzLCExKSx3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihcInJlc2l6ZVwiLHRoaXMsITEpKSx0aGlzfSxTY3JvbGxTcHkucHJvdG90eXBlLnVuTGlzdGVuPWZ1bmN0aW9uKCl7dmFyIHQ9dGhpcy5fZ2V0U2Nyb2xsZXIoKTtyZXR1cm4gdCYmKFwiQk9EWVwiIT09dC50YWdOYW1lJiZ0LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJzY3JvbGxcIix0aGlzLCExKSx3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcihcInNjcm9sbFwiLHRoaXMsITEpLHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKFwib3JpZW50YXRpb25jaGFuZ2VcIix0aGlzLCExKSx3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcihcInJlc2l6ZVwiLHRoaXMsITEpKSx0aGlzfSxTY3JvbGxTcHkucHJvdG90eXBlLnJlZnJlc2g9ZnVuY3Rpb24oKXt2YXIgdD10aGlzLGU9dGhpcy5fZ2V0U2Nyb2xsZXIoKTtpZighZSlyZXR1cm4gdGhpczt2YXIgbj1cIkJPRFlcIj09PWUudGFnTmFtZT9PZmZzZXRNZXRob2QuT0ZGU0VUOk9mZnNldE1ldGhvZC5QT1NJVElPTixpPVwiYXV0b1wiPT09dGhpcy5fY29uZmlnLm1ldGhvZD9uOnRoaXMuX2NvbmZpZy5tZXRob2Qsbz1pPT09T2Zmc2V0TWV0aG9kLk9GRlNFVD8wOnRoaXMuX2dldFNjcm9sbFRvcCgpO3JldHVybiB0aGlzLl9vZmZzZXRzPVtdLHRoaXMuX3RhcmdldHM9W10sdGhpcy5fc2Nyb2xsSGVpZ2h0PXRoaXMuX2dldFNjcm9sbEhlaWdodCgpLCRRU0EodGhpcy5fc2VsZWN0b3IsdGhpcy5fJGVsKS5tYXAoZnVuY3Rpb24odCl7dmFyIG49dC5nZXRBdHRyaWJ1dGUoXCJocmVmXCIpO2lmKG4mJlwiI1wiPT09bi5jaGFyQXQoMCkmJlwiI1wiIT09biYmLTE9PT1uLmluZGV4T2YoXCIjL1wiKSl7dmFyIHI9JFFTKG4sZSk7aWYoIXIpcmV0dXJuIG51bGw7dmFyIHM9ci5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtpZihzLndpZHRofHxzLmhlaWdodClyZXR1cm57b2Zmc2V0OihpPT09T2Zmc2V0TWV0aG9kLk9GRlNFVD9zLnRvcDpyLm9mZnNldFRvcCkrbyxocmVmOm59fXJldHVybiBudWxsfSkuZmlsdGVyKGZ1bmN0aW9uKHQpe3JldHVybiB0fSkuc29ydChmdW5jdGlvbih0LGUpe3JldHVybiB0Lm9mZnNldC1lLm9mZnNldH0pLmZvckVhY2goZnVuY3Rpb24oZSl7dC5fb2Zmc2V0cy5wdXNoKGUub2Zmc2V0KSx0Ll90YXJnZXRzLnB1c2goZS5ocmVmKX0pLHRoaXN9LFNjcm9sbFNweS5wcm90b3R5cGUucHJvY2Vzcz1mdW5jdGlvbigpe3ZhciB0PXRoaXM7aWYoIXRoaXMuX2dldFNjcm9sbGVyKXJldHVybiB0aGlzO3ZhciBlPXRoaXMuX2dldFNjcm9sbFRvcCgpK3RoaXMuX2NvbmZpZy5vZmZzZXQsbj10aGlzLl9nZXRTY3JvbGxIZWlnaHQoKSxpPXRoaXMuX2NvbmZpZy5vZmZzZXQrbi10aGlzLl9nZXRPZmZzZXRIZWlnaHQoKTtpZih0aGlzLl9zY3JvbGxIZWlnaHQhPT1uJiZ0aGlzLnJlZnJlc2goKSxlPj1pKXt2YXIgbz10aGlzLl90YXJnZXRzW3RoaXMuX3RhcmdldHMubGVuZ3RoLTFdO3JldHVybiB0aGlzLl9hY3RpdmVUYXJnZXQhPT1vJiZ0aGlzLl9hY3RpdmF0ZShvKSx0aGlzfWlmKHRoaXMuX2FjdGl2ZVRhcmdldCYmZTx0aGlzLl9vZmZzZXRzWzBdJiZ0aGlzLl9vZmZzZXRzWzBdPjApcmV0dXJuIHRoaXMuX2FjdGl2ZVRhcmdldD1udWxsLHRoaXMuX2NsZWFyKCksdGhpcztmb3IodmFyIHI9dGhpcy5fb2Zmc2V0cy5sZW5ndGg7ci0tOyl0Ll9hY3RpdmVUYXJnZXQhPT10Ll90YXJnZXRzW3JdJiZlPj10Ll9vZmZzZXRzW3JdJiYodm9pZCAwPT09dC5fb2Zmc2V0c1tyKzFdfHxlPHQuX29mZnNldHNbcisxXSkmJnQuX2FjdGl2YXRlKHQuX3RhcmdldHNbcl0pO3JldHVybiB0aGlzfSxTY3JvbGxTcHkucHJvdG90eXBlLmRpc3Bvc2U9ZnVuY3Rpb24oKXt0aGlzLnVuTGlzdGVuKCksY2xlYXJUaW1lb3V0KHRoaXMuX3Jlc2l6ZVRpbWVvdXQpLHRoaXMuX3Jlc2l6ZVRpbWVvdXQ9bnVsbCx0aGlzLl8kZWw9bnVsbCx0aGlzLl9jb25maWc9bnVsbCx0aGlzLl9zZWxlY3Rvcj1udWxsLHRoaXMuX29mZnNldHM9bnVsbCx0aGlzLl90YXJnZXRzPW51bGwsdGhpcy5fYWN0aXZlVGFyZ2V0PW51bGwsdGhpcy5fc2Nyb2xsSGVpZ2h0PW51bGwsdGhpcy5fJHJvb3Q9bnVsbH0sU2Nyb2xsU3B5LnByb3RvdHlwZS5oYW5kbGVFdmVudD1mdW5jdGlvbih0KXt2YXIgZT10aGlzO1wic2Nyb2xsXCI9PT10LnR5cGU/dGhpcy5wcm9jZXNzKCk6XCJvcmllbnRhdGlvbmNoYW5nZVwiPT09dC50eXBlP3RoaXMucmVmcmVzaCgpLnByb2Nlc3MoKTpcInJlc2l6ZVwiPT09dC50eXBlJiZmdW5jdGlvbigpe2NsZWFyVGltZW91dCh0aGlzLl9yZXNpemVUaW1lb3V0KSx0aGlzLl9yZXNpemVUaW1lb3V0PXNldFRpbWVvdXQoZnVuY3Rpb24oKXtlLnJlZnJlc2goKS5wcm9jZXNzKCl9LGUuX2NvbmZpZy50aHJvdHRsZXx8RGVmYXVsdC50aHJvdHRsZSl9KCl9LFNjcm9sbFNweS5wcm90b3R5cGUuX2dldFNjcm9sbGVyPWZ1bmN0aW9uKCl7aWYoaXNTZXJ2ZXIpcmV0dXJuIG51bGw7dmFyIHQ9dGhpcy5fY29uZmlnLmVsZW1lbnQ7cmV0dXJuIHQ/dCYmaXNFbGVtZW50KHQpP3Q6XCJzdHJpbmdcIj09dHlwZW9mIHQ/XCJib2R5XCI9PT10P2RvY3VtZW50LmJvZHk6JFFTKHQpOm51bGw6bnVsbH0sU2Nyb2xsU3B5LnByb3RvdHlwZS5fZ2V0U2Nyb2xsVG9wPWZ1bmN0aW9uKCl7dmFyIHQ9dGhpcy5fZ2V0U2Nyb2xsZXIoKTtyZXR1cm4gdD9cIkJPRFlcIj09PXQudGFnTmFtZT93aW5kb3cucGFnZVlPZmZzZXQ6dC5zY3JvbGxUb3A6MH0sU2Nyb2xsU3B5LnByb3RvdHlwZS5fZ2V0U2Nyb2xsSGVpZ2h0PWZ1bmN0aW9uKCl7dmFyIHQ9dGhpcy5fZ2V0U2Nyb2xsZXIoKTtyZXR1cm4gdD9cIkJPRFlcIj09PXQudGFnTmFtZT9NYXRoLm1heChkb2N1bWVudC5ib2R5LnNjcm9sbEhlaWdodCxkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuc2Nyb2xsSGVpZ2h0KTp0LnNjcm9sbEhlaWdodDowfSxTY3JvbGxTcHkucHJvdG90eXBlLl9nZXRPZmZzZXRIZWlnaHQ9ZnVuY3Rpb24oKXt2YXIgdD10aGlzLl9nZXRTY3JvbGxlcigpO3JldHVybiB0P1wiQk9EWVwiPT09dC50YWdOYW1lP3dpbmRvdy5pbm5lckhlaWdodDp0LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLmhlaWdodDowfSxTY3JvbGxTcHkucHJvdG90eXBlLl9hY3RpdmF0ZT1mdW5jdGlvbih0KXt2YXIgZT10aGlzO3RoaXMuX2FjdGl2ZVRhcmdldD10LHRoaXMuX2NsZWFyKCk7dmFyIG49dGhpcy5fc2VsZWN0b3Iuc3BsaXQoXCIsXCIpLGk9JFFTQSgobj1uLm1hcChmdW5jdGlvbihlKXtyZXR1cm4gZSsnW2hyZWY9XCInK3QrJ1wiXSd9KSkuam9pbihcIixcIiksdGhpcy5fJGVsKTtpLmZvckVhY2goZnVuY3Rpb24odCl7aWYodC5jbGFzc0xpc3QuY29udGFpbnMoQ2xhc3NOYW1lLkRST1BET1dOX0lURU0pKXt2YXIgbj1jbG9zZXN0KHQsU2VsZWN0b3IuRFJPUERPV04pO2lmKG4pe3ZhciBpPSRRUyhTZWxlY3Rvci5EUk9QRE9XTl9UT0dHTEUsbik7aSYmZS5fc2V0QWN0aXZlU3RhdGUoaSwhMCl9ZS5fc2V0QWN0aXZlU3RhdGUodCwhMCl9ZWxzZSBlLl9zZXRBY3RpdmVTdGF0ZSh0LCEwKSxlLl9zZXRQYXJlbnRzU2libGluZ0FjdGl2ZVN0YXRlKHQsU2VsZWN0b3IuTkFWX0xJU1RfR1JPVVAsW0NsYXNzTmFtZS5OQVZfTElOSyxDbGFzc05hbWUuTElTVF9JVEVNXSwhMCl9KSxpJiZpLmxlbmd0aD4wJiZ0aGlzLl8kcm9vdCYmdGhpcy5fJHJvb3QuJGVtaXQmJnRoaXMuXyRyb290LiRlbWl0KEVWRU5ULHQpfSxTY3JvbGxTcHkucHJvdG90eXBlLl9jbGVhcj1mdW5jdGlvbigpe3ZhciB0PXRoaXM7JFFTQSh0aGlzLl9zZWxlY3Rvcix0aGlzLl8kZWwpLmZpbHRlcihmdW5jdGlvbih0KXtpZih0LmNsYXNzTGlzdC5jb250YWlucyhDbGFzc05hbWUuQUNUSVZFKSl7dmFyIGU9dC5nZXRBdHRyaWJ1dGUoXCJocmVmXCIpO3JldHVyblwiI1wiPT09ZS5jaGFyQXQoMCkmJjAhPT1lLmluZGV4T2YoXCIjL1wiKX1yZXR1cm4hMX0pLmZvckVhY2goZnVuY3Rpb24oZSl7dC5fc2V0QWN0aXZlU3RhdGUoZSwhMSl9KX0sU2Nyb2xsU3B5LnByb3RvdHlwZS5fc2V0QWN0aXZlU3RhdGU9ZnVuY3Rpb24odCxlKXtpZih0KXt0LmNsYXNzTGlzdC5jb250YWlucyhDbGFzc05hbWUuTkFWX0xJTkspJiYhdC5jbGFzc0xpc3QuY29udGFpbnMoQ2xhc3NOYW1lLkRST1BET1dOX1RPR0dMRSkmJih0PXQucGFyZW50RWxlbWVudCk7dmFyIG49Z2V0Vm0odCk7biYmT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG4uJHByb3BzLFwiYWN0aXZlXCIpP24uJHByb3BzLmFjdGl2ZT1lOnQuY2xhc3NMaXN0W2U/XCJhZGRcIjpcInJlbW92ZVwiXShDbGFzc05hbWUuQUNUSVZFKX19LFNjcm9sbFNweS5wcm90b3R5cGUuX3NldFBhcmVudHNTaWJsaW5nQWN0aXZlU3RhdGU9ZnVuY3Rpb24odCxlLG4saSl7dmFyIG89dGhpcztpZihuKXtBcnJheS5pc0FycmF5KG4pfHwobj1bbl0pO2Zvcih2YXIgcj10O3I7KWlmKChyPWNsb3Nlc3QocixlKSkmJnIucHJldmlvdXNFbGVtZW50U2libGluZylmb3IodmFyIHM9MDtzPG4ubGVuZ3RoLTE7cysrKXIucHJldmlvdXNFbGVtZW50U2libGluZy5jbGFzc0xpc3QuY29udGFpbnMobltzXSkmJm8uX3NldEFjdGl2ZVN0YXRlKHIsaSl9fTt2YXIgc2Nyb2xsc3B5PXtiaW5kOmZ1bmN0aW9uKHQsZSl7aXNTZXJ2ZXJ8fHRbQlZTU118fCh0W0JWU1NdPW5ldyBTY3JvbGxTcHkodCxlKSl9LGluc2VydGVkOmZ1bmN0aW9uKHQsZSl7IWlzU2VydmVyJiZ0W0JWU1NdJiZ0W0JWU1NdLnVwZGF0ZUNvbmZpZyhlKS5saXN0ZW4oKS5yZWZyZXNoKCkucHJvY2VzcygpfSx1cGRhdGU6ZnVuY3Rpb24odCxlKXshaXNTZXJ2ZXImJnRbQlZTU10mJnRbQlZTU10udXBkYXRlQ29uZmlnKGUpLnJlZnJlc2goKS5wcm9jZXNzKCl9LGNvbXBvbmVudFVwZGF0ZWQ6ZnVuY3Rpb24odCxlKXshaXNTZXJ2ZXImJnRbQlZTU10mJnRbQlZTU10udXBkYXRlQ29uZmlnKGUpLnJlZnJlc2goKS5wcm9jZXNzKCl9LHVuYmluZDpmdW5jdGlvbih0KXshaXNTZXJ2ZXImJnRbQlZTU10mJih0W0JWU1NdLnVuTGlzdGVuKCkuZGlzcG9zZSgpLHRbQlZTU109bnVsbCl9fSxkaXJlY3RpdmVzPU9iamVjdC5mcmVlemUoe2JUb2dnbGU6dG9nZ2xlLGJNb2RhbDptb2RhbCQxLGJTY3JvbGxzcHk6c2Nyb2xsc3B5fSksVnVlUGx1Z2luPXtpbnN0YWxsOmZ1bmN0aW9uKHQpe2lmKCF0Ll9ib290c3RyYXBfdnVlX2luc3RhbGxlZCl7dC5fYm9vdHN0cmFwX3Z1ZV9pbnN0YWxsZWQ9ITA7Zm9yKHZhciBlIGluIGNvbXBvbmVudHMpdC5jb21wb25lbnQoZSxjb21wb25lbnRzW2VdKTtmb3IodmFyIG4gaW4gZGlyZWN0aXZlcyl0LmRpcmVjdGl2ZShuLGRpcmVjdGl2ZXNbbl0pfX19O1widW5kZWZpbmVkXCIhPXR5cGVvZiB3aW5kb3cmJndpbmRvdy5WdWUmJndpbmRvdy5WdWUudXNlKFZ1ZVBsdWdpbik7ZXhwb3J0IGRlZmF1bHQgVnVlUGx1Z2luO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Ym9vdHN0cmFwLXZ1ZS5lc20uanMubWFwXG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L19ib290c3RyYXAtdnVlQDAuMTcuMUBib290c3RyYXAtdnVlL2Rpc3QvYm9vdHN0cmFwLXZ1ZS5lc20uanMiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///67\n");

/***/ }),

/***/ 68:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("Object.defineProperty(__webpack_exports__, \"__esModule\", { value: true });\n/* WEBPACK VAR INJECTION */(function(process) {/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Store\", function() { return Store; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"install\", function() { return install; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"mapState\", function() { return mapState; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"mapMutations\", function() { return mapMutations; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"mapGetters\", function() { return mapGetters; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"mapActions\", function() { return mapActions; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"createNamespacedHelpers\", function() { return createNamespacedHelpers; });\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\n/**\n * vuex v2.5.0\n * (c) 2017 Evan You\n * @license MIT\n */\nvar applyMixin = function applyMixin(Vue) {\n  var version = Number(Vue.version.split('.')[0]);\n\n  if (version >= 2) {\n    Vue.mixin({ beforeCreate: vuexInit });\n  } else {\n    // override init and inject vuex init procedure\n    // for 1.x backwards compatibility.\n    var _init = Vue.prototype._init;\n    Vue.prototype._init = function (options) {\n      if (options === void 0) options = {};\n\n      options.init = options.init ? [vuexInit].concat(options.init) : vuexInit;\n      _init.call(this, options);\n    };\n  }\n\n  /**\n   * Vuex init hook, injected into each instances init hooks list.\n   */\n\n  function vuexInit() {\n    var options = this.$options;\n    // store injection\n    if (options.store) {\n      this.$store = typeof options.store === 'function' ? options.store() : options.store;\n    } else if (options.parent && options.parent.$store) {\n      this.$store = options.parent.$store;\n    }\n  }\n};\n\nvar devtoolHook = typeof window !== 'undefined' && window.__VUE_DEVTOOLS_GLOBAL_HOOK__;\n\nfunction devtoolPlugin(store) {\n  if (!devtoolHook) {\n    return;\n  }\n\n  store._devtoolHook = devtoolHook;\n\n  devtoolHook.emit('vuex:init', store);\n\n  devtoolHook.on('vuex:travel-to-state', function (targetState) {\n    store.replaceState(targetState);\n  });\n\n  store.subscribe(function (mutation, state) {\n    devtoolHook.emit('vuex:mutation', mutation, state);\n  });\n}\n\n/**\n * Get the first item that pass the test\n * by second argument function\n *\n * @param {Array} list\n * @param {Function} f\n * @return {*}\n */\n/**\n * Deep copy the given object considering circular structure.\n * This function caches all nested objects and its copies.\n * If it detects circular structure, use cached copy to avoid infinite loop.\n *\n * @param {*} obj\n * @param {Array<Object>} cache\n * @return {*}\n */\n\n/**\n * forEach for object\n */\nfunction forEachValue(obj, fn) {\n  Object.keys(obj).forEach(function (key) {\n    return fn(obj[key], key);\n  });\n}\n\nfunction isObject(obj) {\n  return obj !== null && (typeof obj === 'undefined' ? 'undefined' : _typeof(obj)) === 'object';\n}\n\nfunction isPromise(val) {\n  return val && typeof val.then === 'function';\n}\n\nfunction assert(condition, msg) {\n  if (!condition) {\n    throw new Error(\"[vuex] \" + msg);\n  }\n}\n\nvar Module = function Module(rawModule, runtime) {\n  this.runtime = runtime;\n  this._children = Object.create(null);\n  this._rawModule = rawModule;\n  var rawState = rawModule.state;\n  this.state = (typeof rawState === 'function' ? rawState() : rawState) || {};\n};\n\nvar prototypeAccessors$1 = { namespaced: { configurable: true } };\n\nprototypeAccessors$1.namespaced.get = function () {\n  return !!this._rawModule.namespaced;\n};\n\nModule.prototype.addChild = function addChild(key, module) {\n  this._children[key] = module;\n};\n\nModule.prototype.removeChild = function removeChild(key) {\n  delete this._children[key];\n};\n\nModule.prototype.getChild = function getChild(key) {\n  return this._children[key];\n};\n\nModule.prototype.update = function update(rawModule) {\n  this._rawModule.namespaced = rawModule.namespaced;\n  if (rawModule.actions) {\n    this._rawModule.actions = rawModule.actions;\n  }\n  if (rawModule.mutations) {\n    this._rawModule.mutations = rawModule.mutations;\n  }\n  if (rawModule.getters) {\n    this._rawModule.getters = rawModule.getters;\n  }\n};\n\nModule.prototype.forEachChild = function forEachChild(fn) {\n  forEachValue(this._children, fn);\n};\n\nModule.prototype.forEachGetter = function forEachGetter(fn) {\n  if (this._rawModule.getters) {\n    forEachValue(this._rawModule.getters, fn);\n  }\n};\n\nModule.prototype.forEachAction = function forEachAction(fn) {\n  if (this._rawModule.actions) {\n    forEachValue(this._rawModule.actions, fn);\n  }\n};\n\nModule.prototype.forEachMutation = function forEachMutation(fn) {\n  if (this._rawModule.mutations) {\n    forEachValue(this._rawModule.mutations, fn);\n  }\n};\n\nObject.defineProperties(Module.prototype, prototypeAccessors$1);\n\nvar ModuleCollection = function ModuleCollection(rawRootModule) {\n  // register root module (Vuex.Store options)\n  this.register([], rawRootModule, false);\n};\n\nModuleCollection.prototype.get = function get(path) {\n  return path.reduce(function (module, key) {\n    return module.getChild(key);\n  }, this.root);\n};\n\nModuleCollection.prototype.getNamespace = function getNamespace(path) {\n  var module = this.root;\n  return path.reduce(function (namespace, key) {\n    module = module.getChild(key);\n    return namespace + (module.namespaced ? key + '/' : '');\n  }, '');\n};\n\nModuleCollection.prototype.update = function update$1(rawRootModule) {\n  update([], this.root, rawRootModule);\n};\n\nModuleCollection.prototype.register = function register(path, rawModule, runtime) {\n  var this$1 = this;\n  if (runtime === void 0) runtime = true;\n\n  if (process.env.NODE_ENV !== 'production') {\n    assertRawModule(path, rawModule);\n  }\n\n  var newModule = new Module(rawModule, runtime);\n  if (path.length === 0) {\n    this.root = newModule;\n  } else {\n    var parent = this.get(path.slice(0, -1));\n    parent.addChild(path[path.length - 1], newModule);\n  }\n\n  // register nested modules\n  if (rawModule.modules) {\n    forEachValue(rawModule.modules, function (rawChildModule, key) {\n      this$1.register(path.concat(key), rawChildModule, runtime);\n    });\n  }\n};\n\nModuleCollection.prototype.unregister = function unregister(path) {\n  var parent = this.get(path.slice(0, -1));\n  var key = path[path.length - 1];\n  if (!parent.getChild(key).runtime) {\n    return;\n  }\n\n  parent.removeChild(key);\n};\n\nfunction update(path, targetModule, newModule) {\n  if (process.env.NODE_ENV !== 'production') {\n    assertRawModule(path, newModule);\n  }\n\n  // update target module\n  targetModule.update(newModule);\n\n  // update nested modules\n  if (newModule.modules) {\n    for (var key in newModule.modules) {\n      if (!targetModule.getChild(key)) {\n        if (process.env.NODE_ENV !== 'production') {\n          console.warn(\"[vuex] trying to add a new module '\" + key + \"' on hot reloading, \" + 'manual reload is needed');\n        }\n        return;\n      }\n      update(path.concat(key), targetModule.getChild(key), newModule.modules[key]);\n    }\n  }\n}\n\nvar functionAssert = {\n  assert: function assert(value) {\n    return typeof value === 'function';\n  },\n  expected: 'function'\n};\n\nvar objectAssert = {\n  assert: function assert(value) {\n    return typeof value === 'function' || (typeof value === 'undefined' ? 'undefined' : _typeof(value)) === 'object' && typeof value.handler === 'function';\n  },\n  expected: 'function or object with \"handler\" function'\n};\n\nvar assertTypes = {\n  getters: functionAssert,\n  mutations: functionAssert,\n  actions: objectAssert\n};\n\nfunction assertRawModule(path, rawModule) {\n  Object.keys(assertTypes).forEach(function (key) {\n    if (!rawModule[key]) {\n      return;\n    }\n\n    var assertOptions = assertTypes[key];\n\n    forEachValue(rawModule[key], function (value, type) {\n      assert(assertOptions.assert(value), makeAssertionMessage(path, key, type, value, assertOptions.expected));\n    });\n  });\n}\n\nfunction makeAssertionMessage(path, key, type, value, expected) {\n  var buf = key + \" should be \" + expected + \" but \\\"\" + key + \".\" + type + \"\\\"\";\n  if (path.length > 0) {\n    buf += \" in module \\\"\" + path.join('.') + \"\\\"\";\n  }\n  buf += \" is \" + JSON.stringify(value) + \".\";\n  return buf;\n}\n\nvar Vue; // bind on install\n\nvar Store = function Store(options) {\n  var this$1 = this;\n  if (options === void 0) options = {};\n\n  // Auto install if it is not done yet and `window` has `Vue`.\n  // To allow users to avoid auto-installation in some cases,\n  // this code should be placed here. See #731\n  if (!Vue && typeof window !== 'undefined' && window.Vue) {\n    install(window.Vue);\n  }\n\n  if (process.env.NODE_ENV !== 'production') {\n    assert(Vue, \"must call Vue.use(Vuex) before creating a store instance.\");\n    assert(typeof Promise !== 'undefined', \"vuex requires a Promise polyfill in this browser.\");\n    assert(this instanceof Store, \"Store must be called with the new operator.\");\n  }\n\n  var plugins = options.plugins;if (plugins === void 0) plugins = [];\n  var strict = options.strict;if (strict === void 0) strict = false;\n\n  var state = options.state;if (state === void 0) state = {};\n  if (typeof state === 'function') {\n    state = state() || {};\n  }\n\n  // store internal state\n  this._committing = false;\n  this._actions = Object.create(null);\n  this._actionSubscribers = [];\n  this._mutations = Object.create(null);\n  this._wrappedGetters = Object.create(null);\n  this._modules = new ModuleCollection(options);\n  this._modulesNamespaceMap = Object.create(null);\n  this._subscribers = [];\n  this._watcherVM = new Vue();\n\n  // bind commit and dispatch to self\n  var store = this;\n  var ref = this;\n  var dispatch = ref.dispatch;\n  var commit = ref.commit;\n  this.dispatch = function boundDispatch(type, payload) {\n    return dispatch.call(store, type, payload);\n  };\n  this.commit = function boundCommit(type, payload, options) {\n    return commit.call(store, type, payload, options);\n  };\n\n  // strict mode\n  this.strict = strict;\n\n  // init root module.\n  // this also recursively registers all sub-modules\n  // and collects all module getters inside this._wrappedGetters\n  installModule(this, state, [], this._modules.root);\n\n  // initialize the store vm, which is responsible for the reactivity\n  // (also registers _wrappedGetters as computed properties)\n  resetStoreVM(this, state);\n\n  // apply plugins\n  plugins.forEach(function (plugin) {\n    return plugin(this$1);\n  });\n\n  if (Vue.config.devtools) {\n    devtoolPlugin(this);\n  }\n};\n\nvar prototypeAccessors = { state: { configurable: true } };\n\nprototypeAccessors.state.get = function () {\n  return this._vm._data.$$state;\n};\n\nprototypeAccessors.state.set = function (v) {\n  if (process.env.NODE_ENV !== 'production') {\n    assert(false, \"Use store.replaceState() to explicit replace store state.\");\n  }\n};\n\nStore.prototype.commit = function commit(_type, _payload, _options) {\n  var this$1 = this;\n\n  // check object-style commit\n  var ref = unifyObjectStyle(_type, _payload, _options);\n  var type = ref.type;\n  var payload = ref.payload;\n  var options = ref.options;\n\n  var mutation = { type: type, payload: payload };\n  var entry = this._mutations[type];\n  if (!entry) {\n    if (process.env.NODE_ENV !== 'production') {\n      console.error(\"[vuex] unknown mutation type: \" + type);\n    }\n    return;\n  }\n  this._withCommit(function () {\n    entry.forEach(function commitIterator(handler) {\n      handler(payload);\n    });\n  });\n  this._subscribers.forEach(function (sub) {\n    return sub(mutation, this$1.state);\n  });\n\n  if (process.env.NODE_ENV !== 'production' && options && options.silent) {\n    console.warn(\"[vuex] mutation type: \" + type + \". Silent option has been removed. \" + 'Use the filter functionality in the vue-devtools');\n  }\n};\n\nStore.prototype.dispatch = function dispatch(_type, _payload) {\n  var this$1 = this;\n\n  // check object-style dispatch\n  var ref = unifyObjectStyle(_type, _payload);\n  var type = ref.type;\n  var payload = ref.payload;\n\n  var action = { type: type, payload: payload };\n  var entry = this._actions[type];\n  if (!entry) {\n    if (process.env.NODE_ENV !== 'production') {\n      console.error(\"[vuex] unknown action type: \" + type);\n    }\n    return;\n  }\n\n  this._actionSubscribers.forEach(function (sub) {\n    return sub(action, this$1.state);\n  });\n\n  return entry.length > 1 ? Promise.all(entry.map(function (handler) {\n    return handler(payload);\n  })) : entry[0](payload);\n};\n\nStore.prototype.subscribe = function subscribe(fn) {\n  return genericSubscribe(fn, this._subscribers);\n};\n\nStore.prototype.subscribeAction = function subscribeAction(fn) {\n  return genericSubscribe(fn, this._actionSubscribers);\n};\n\nStore.prototype.watch = function watch(getter, cb, options) {\n  var this$1 = this;\n\n  if (process.env.NODE_ENV !== 'production') {\n    assert(typeof getter === 'function', \"store.watch only accepts a function.\");\n  }\n  return this._watcherVM.$watch(function () {\n    return getter(this$1.state, this$1.getters);\n  }, cb, options);\n};\n\nStore.prototype.replaceState = function replaceState(state) {\n  var this$1 = this;\n\n  this._withCommit(function () {\n    this$1._vm._data.$$state = state;\n  });\n};\n\nStore.prototype.registerModule = function registerModule(path, rawModule, options) {\n  if (options === void 0) options = {};\n\n  if (typeof path === 'string') {\n    path = [path];\n  }\n\n  if (process.env.NODE_ENV !== 'production') {\n    assert(Array.isArray(path), \"module path must be a string or an Array.\");\n    assert(path.length > 0, 'cannot register the root module by using registerModule.');\n  }\n\n  this._modules.register(path, rawModule);\n  installModule(this, this.state, path, this._modules.get(path), options.preserveState);\n  // reset store to update getters...\n  resetStoreVM(this, this.state);\n};\n\nStore.prototype.unregisterModule = function unregisterModule(path) {\n  var this$1 = this;\n\n  if (typeof path === 'string') {\n    path = [path];\n  }\n\n  if (process.env.NODE_ENV !== 'production') {\n    assert(Array.isArray(path), \"module path must be a string or an Array.\");\n  }\n\n  this._modules.unregister(path);\n  this._withCommit(function () {\n    var parentState = getNestedState(this$1.state, path.slice(0, -1));\n    Vue.delete(parentState, path[path.length - 1]);\n  });\n  resetStore(this);\n};\n\nStore.prototype.hotUpdate = function hotUpdate(newOptions) {\n  this._modules.update(newOptions);\n  resetStore(this, true);\n};\n\nStore.prototype._withCommit = function _withCommit(fn) {\n  var committing = this._committing;\n  this._committing = true;\n  fn();\n  this._committing = committing;\n};\n\nObject.defineProperties(Store.prototype, prototypeAccessors);\n\nfunction genericSubscribe(fn, subs) {\n  if (subs.indexOf(fn) < 0) {\n    subs.push(fn);\n  }\n  return function () {\n    var i = subs.indexOf(fn);\n    if (i > -1) {\n      subs.splice(i, 1);\n    }\n  };\n}\n\nfunction resetStore(store, hot) {\n  store._actions = Object.create(null);\n  store._mutations = Object.create(null);\n  store._wrappedGetters = Object.create(null);\n  store._modulesNamespaceMap = Object.create(null);\n  var state = store.state;\n  // init all modules\n  installModule(store, state, [], store._modules.root, true);\n  // reset vm\n  resetStoreVM(store, state, hot);\n}\n\nfunction resetStoreVM(store, state, hot) {\n  var oldVm = store._vm;\n\n  // bind store public getters\n  store.getters = {};\n  var wrappedGetters = store._wrappedGetters;\n  var computed = {};\n  forEachValue(wrappedGetters, function (fn, key) {\n    // use computed to leverage its lazy-caching mechanism\n    computed[key] = function () {\n      return fn(store);\n    };\n    Object.defineProperty(store.getters, key, {\n      get: function get() {\n        return store._vm[key];\n      },\n      enumerable: true // for local getters\n    });\n  });\n\n  // use a Vue instance to store the state tree\n  // suppress warnings just in case the user has added\n  // some funky global mixins\n  var silent = Vue.config.silent;\n  Vue.config.silent = true;\n  store._vm = new Vue({\n    data: {\n      $$state: state\n    },\n    computed: computed\n  });\n  Vue.config.silent = silent;\n\n  // enable strict mode for new vm\n  if (store.strict) {\n    enableStrictMode(store);\n  }\n\n  if (oldVm) {\n    if (hot) {\n      // dispatch changes in all subscribed watchers\n      // to force getter re-evaluation for hot reloading.\n      store._withCommit(function () {\n        oldVm._data.$$state = null;\n      });\n    }\n    Vue.nextTick(function () {\n      return oldVm.$destroy();\n    });\n  }\n}\n\nfunction installModule(store, rootState, path, module, hot) {\n  var isRoot = !path.length;\n  var namespace = store._modules.getNamespace(path);\n\n  // register in namespace map\n  if (module.namespaced) {\n    store._modulesNamespaceMap[namespace] = module;\n  }\n\n  // set state\n  if (!isRoot && !hot) {\n    var parentState = getNestedState(rootState, path.slice(0, -1));\n    var moduleName = path[path.length - 1];\n    store._withCommit(function () {\n      Vue.set(parentState, moduleName, module.state);\n    });\n  }\n\n  var local = module.context = makeLocalContext(store, namespace, path);\n\n  module.forEachMutation(function (mutation, key) {\n    var namespacedType = namespace + key;\n    registerMutation(store, namespacedType, mutation, local);\n  });\n\n  module.forEachAction(function (action, key) {\n    var type = action.root ? key : namespace + key;\n    var handler = action.handler || action;\n    registerAction(store, type, handler, local);\n  });\n\n  module.forEachGetter(function (getter, key) {\n    var namespacedType = namespace + key;\n    registerGetter(store, namespacedType, getter, local);\n  });\n\n  module.forEachChild(function (child, key) {\n    installModule(store, rootState, path.concat(key), child, hot);\n  });\n}\n\n/**\n * make localized dispatch, commit, getters and state\n * if there is no namespace, just use root ones\n */\nfunction makeLocalContext(store, namespace, path) {\n  var noNamespace = namespace === '';\n\n  var local = {\n    dispatch: noNamespace ? store.dispatch : function (_type, _payload, _options) {\n      var args = unifyObjectStyle(_type, _payload, _options);\n      var payload = args.payload;\n      var options = args.options;\n      var type = args.type;\n\n      if (!options || !options.root) {\n        type = namespace + type;\n        if (process.env.NODE_ENV !== 'production' && !store._actions[type]) {\n          console.error(\"[vuex] unknown local action type: \" + args.type + \", global type: \" + type);\n          return;\n        }\n      }\n\n      return store.dispatch(type, payload);\n    },\n\n    commit: noNamespace ? store.commit : function (_type, _payload, _options) {\n      var args = unifyObjectStyle(_type, _payload, _options);\n      var payload = args.payload;\n      var options = args.options;\n      var type = args.type;\n\n      if (!options || !options.root) {\n        type = namespace + type;\n        if (process.env.NODE_ENV !== 'production' && !store._mutations[type]) {\n          console.error(\"[vuex] unknown local mutation type: \" + args.type + \", global type: \" + type);\n          return;\n        }\n      }\n\n      store.commit(type, payload, options);\n    }\n  };\n\n  // getters and state object must be gotten lazily\n  // because they will be changed by vm update\n  Object.defineProperties(local, {\n    getters: {\n      get: noNamespace ? function () {\n        return store.getters;\n      } : function () {\n        return makeLocalGetters(store, namespace);\n      }\n    },\n    state: {\n      get: function get() {\n        return getNestedState(store.state, path);\n      }\n    }\n  });\n\n  return local;\n}\n\nfunction makeLocalGetters(store, namespace) {\n  var gettersProxy = {};\n\n  var splitPos = namespace.length;\n  Object.keys(store.getters).forEach(function (type) {\n    // skip if the target getter is not match this namespace\n    if (type.slice(0, splitPos) !== namespace) {\n      return;\n    }\n\n    // extract local getter type\n    var localType = type.slice(splitPos);\n\n    // Add a port to the getters proxy.\n    // Define as getter property because\n    // we do not want to evaluate the getters in this time.\n    Object.defineProperty(gettersProxy, localType, {\n      get: function get() {\n        return store.getters[type];\n      },\n      enumerable: true\n    });\n  });\n\n  return gettersProxy;\n}\n\nfunction registerMutation(store, type, handler, local) {\n  var entry = store._mutations[type] || (store._mutations[type] = []);\n  entry.push(function wrappedMutationHandler(payload) {\n    handler.call(store, local.state, payload);\n  });\n}\n\nfunction registerAction(store, type, handler, local) {\n  var entry = store._actions[type] || (store._actions[type] = []);\n  entry.push(function wrappedActionHandler(payload, cb) {\n    var res = handler.call(store, {\n      dispatch: local.dispatch,\n      commit: local.commit,\n      getters: local.getters,\n      state: local.state,\n      rootGetters: store.getters,\n      rootState: store.state\n    }, payload, cb);\n    if (!isPromise(res)) {\n      res = Promise.resolve(res);\n    }\n    if (store._devtoolHook) {\n      return res.catch(function (err) {\n        store._devtoolHook.emit('vuex:error', err);\n        throw err;\n      });\n    } else {\n      return res;\n    }\n  });\n}\n\nfunction registerGetter(store, type, rawGetter, local) {\n  if (store._wrappedGetters[type]) {\n    if (process.env.NODE_ENV !== 'production') {\n      console.error(\"[vuex] duplicate getter key: \" + type);\n    }\n    return;\n  }\n  store._wrappedGetters[type] = function wrappedGetter(store) {\n    return rawGetter(local.state, // local state\n    local.getters, // local getters\n    store.state, // root state\n    store.getters // root getters\n    );\n  };\n}\n\nfunction enableStrictMode(store) {\n  store._vm.$watch(function () {\n    return this._data.$$state;\n  }, function () {\n    if (process.env.NODE_ENV !== 'production') {\n      assert(store._committing, \"Do not mutate vuex store state outside mutation handlers.\");\n    }\n  }, { deep: true, sync: true });\n}\n\nfunction getNestedState(state, path) {\n  return path.length ? path.reduce(function (state, key) {\n    return state[key];\n  }, state) : state;\n}\n\nfunction unifyObjectStyle(type, payload, options) {\n  if (isObject(type) && type.type) {\n    options = payload;\n    payload = type;\n    type = type.type;\n  }\n\n  if (process.env.NODE_ENV !== 'production') {\n    assert(typeof type === 'string', \"Expects string as the type, but found \" + (typeof type === 'undefined' ? 'undefined' : _typeof(type)) + \".\");\n  }\n\n  return { type: type, payload: payload, options: options };\n}\n\nfunction install(_Vue) {\n  if (Vue && _Vue === Vue) {\n    if (process.env.NODE_ENV !== 'production') {\n      console.error('[vuex] already installed. Vue.use(Vuex) should be called only once.');\n    }\n    return;\n  }\n  Vue = _Vue;\n  applyMixin(Vue);\n}\n\nvar mapState = normalizeNamespace(function (namespace, states) {\n  var res = {};\n  normalizeMap(states).forEach(function (ref) {\n    var key = ref.key;\n    var val = ref.val;\n\n    res[key] = function mappedState() {\n      var state = this.$store.state;\n      var getters = this.$store.getters;\n      if (namespace) {\n        var module = getModuleByNamespace(this.$store, 'mapState', namespace);\n        if (!module) {\n          return;\n        }\n        state = module.context.state;\n        getters = module.context.getters;\n      }\n      return typeof val === 'function' ? val.call(this, state, getters) : state[val];\n    };\n    // mark vuex getter for devtools\n    res[key].vuex = true;\n  });\n  return res;\n});\n\nvar mapMutations = normalizeNamespace(function (namespace, mutations) {\n  var res = {};\n  normalizeMap(mutations).forEach(function (ref) {\n    var key = ref.key;\n    var val = ref.val;\n\n    res[key] = function mappedMutation() {\n      var args = [],\n          len = arguments.length;\n      while (len--) {\n        args[len] = arguments[len];\n      }var commit = this.$store.commit;\n      if (namespace) {\n        var module = getModuleByNamespace(this.$store, 'mapMutations', namespace);\n        if (!module) {\n          return;\n        }\n        commit = module.context.commit;\n      }\n      return typeof val === 'function' ? val.apply(this, [commit].concat(args)) : commit.apply(this.$store, [val].concat(args));\n    };\n  });\n  return res;\n});\n\nvar mapGetters = normalizeNamespace(function (namespace, getters) {\n  var res = {};\n  normalizeMap(getters).forEach(function (ref) {\n    var key = ref.key;\n    var val = ref.val;\n\n    val = namespace + val;\n    res[key] = function mappedGetter() {\n      if (namespace && !getModuleByNamespace(this.$store, 'mapGetters', namespace)) {\n        return;\n      }\n      if (process.env.NODE_ENV !== 'production' && !(val in this.$store.getters)) {\n        console.error(\"[vuex] unknown getter: \" + val);\n        return;\n      }\n      return this.$store.getters[val];\n    };\n    // mark vuex getter for devtools\n    res[key].vuex = true;\n  });\n  return res;\n});\n\nvar mapActions = normalizeNamespace(function (namespace, actions) {\n  var res = {};\n  normalizeMap(actions).forEach(function (ref) {\n    var key = ref.key;\n    var val = ref.val;\n\n    res[key] = function mappedAction() {\n      var args = [],\n          len = arguments.length;\n      while (len--) {\n        args[len] = arguments[len];\n      }var dispatch = this.$store.dispatch;\n      if (namespace) {\n        var module = getModuleByNamespace(this.$store, 'mapActions', namespace);\n        if (!module) {\n          return;\n        }\n        dispatch = module.context.dispatch;\n      }\n      return typeof val === 'function' ? val.apply(this, [dispatch].concat(args)) : dispatch.apply(this.$store, [val].concat(args));\n    };\n  });\n  return res;\n});\n\nvar createNamespacedHelpers = function createNamespacedHelpers(namespace) {\n  return {\n    mapState: mapState.bind(null, namespace),\n    mapGetters: mapGetters.bind(null, namespace),\n    mapMutations: mapMutations.bind(null, namespace),\n    mapActions: mapActions.bind(null, namespace)\n  };\n};\n\nfunction normalizeMap(map) {\n  return Array.isArray(map) ? map.map(function (key) {\n    return { key: key, val: key };\n  }) : Object.keys(map).map(function (key) {\n    return { key: key, val: map[key] };\n  });\n}\n\nfunction normalizeNamespace(fn) {\n  return function (namespace, map) {\n    if (typeof namespace !== 'string') {\n      map = namespace;\n      namespace = '';\n    } else if (namespace.charAt(namespace.length - 1) !== '/') {\n      namespace += '/';\n    }\n    return fn(namespace, map);\n  };\n}\n\nfunction getModuleByNamespace(store, helper, namespace) {\n  var module = store._modulesNamespaceMap[namespace];\n  if (process.env.NODE_ENV !== 'production' && !module) {\n    console.error(\"[vuex] module namespace not found in \" + helper + \"(): \" + namespace);\n  }\n  return module;\n}\n\nvar index_esm = {\n  Store: Store,\n  install: install,\n  version: '2.5.0',\n  mapState: mapState,\n  mapMutations: mapMutations,\n  mapGetters: mapGetters,\n  mapActions: mapActions,\n  createNamespacedHelpers: createNamespacedHelpers\n};\n\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (index_esm);\n/* WEBPACK VAR INJECTION */}.call(__webpack_exports__, __webpack_require__(43)))\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L192dWV4QDIuNS4wQHZ1ZXgvZGlzdC92dWV4LmVzbS5qcz83NzM0Il0sIm5hbWVzIjpbImFwcGx5TWl4aW4iLCJWdWUiLCJ2ZXJzaW9uIiwiTnVtYmVyIiwic3BsaXQiLCJtaXhpbiIsImJlZm9yZUNyZWF0ZSIsInZ1ZXhJbml0IiwiX2luaXQiLCJwcm90b3R5cGUiLCJvcHRpb25zIiwiaW5pdCIsImNvbmNhdCIsImNhbGwiLCIkb3B0aW9ucyIsInN0b3JlIiwiJHN0b3JlIiwicGFyZW50IiwiZGV2dG9vbEhvb2siLCJ3aW5kb3ciLCJfX1ZVRV9ERVZUT09MU19HTE9CQUxfSE9PS19fIiwiZGV2dG9vbFBsdWdpbiIsIl9kZXZ0b29sSG9vayIsImVtaXQiLCJvbiIsInRhcmdldFN0YXRlIiwicmVwbGFjZVN0YXRlIiwic3Vic2NyaWJlIiwibXV0YXRpb24iLCJzdGF0ZSIsImZvckVhY2hWYWx1ZSIsIm9iaiIsImZuIiwiT2JqZWN0Iiwia2V5cyIsImZvckVhY2giLCJrZXkiLCJpc09iamVjdCIsImlzUHJvbWlzZSIsInZhbCIsInRoZW4iLCJhc3NlcnQiLCJjb25kaXRpb24iLCJtc2ciLCJFcnJvciIsIk1vZHVsZSIsInJhd01vZHVsZSIsInJ1bnRpbWUiLCJfY2hpbGRyZW4iLCJjcmVhdGUiLCJfcmF3TW9kdWxlIiwicmF3U3RhdGUiLCJwcm90b3R5cGVBY2Nlc3NvcnMkMSIsIm5hbWVzcGFjZWQiLCJjb25maWd1cmFibGUiLCJnZXQiLCJhZGRDaGlsZCIsIm1vZHVsZSIsInJlbW92ZUNoaWxkIiwiZ2V0Q2hpbGQiLCJ1cGRhdGUiLCJhY3Rpb25zIiwibXV0YXRpb25zIiwiZ2V0dGVycyIsImZvckVhY2hDaGlsZCIsImZvckVhY2hHZXR0ZXIiLCJmb3JFYWNoQWN0aW9uIiwiZm9yRWFjaE11dGF0aW9uIiwiZGVmaW5lUHJvcGVydGllcyIsIk1vZHVsZUNvbGxlY3Rpb24iLCJyYXdSb290TW9kdWxlIiwicmVnaXN0ZXIiLCJwYXRoIiwicmVkdWNlIiwicm9vdCIsImdldE5hbWVzcGFjZSIsIm5hbWVzcGFjZSIsInVwZGF0ZSQxIiwidGhpcyQxIiwicHJvY2VzcyIsImVudiIsIk5PREVfRU5WIiwiYXNzZXJ0UmF3TW9kdWxlIiwibmV3TW9kdWxlIiwibGVuZ3RoIiwic2xpY2UiLCJtb2R1bGVzIiwicmF3Q2hpbGRNb2R1bGUiLCJ1bnJlZ2lzdGVyIiwidGFyZ2V0TW9kdWxlIiwiY29uc29sZSIsIndhcm4iLCJmdW5jdGlvbkFzc2VydCIsInZhbHVlIiwiZXhwZWN0ZWQiLCJvYmplY3RBc3NlcnQiLCJoYW5kbGVyIiwiYXNzZXJ0VHlwZXMiLCJhc3NlcnRPcHRpb25zIiwidHlwZSIsIm1ha2VBc3NlcnRpb25NZXNzYWdlIiwiYnVmIiwiam9pbiIsIkpTT04iLCJzdHJpbmdpZnkiLCJTdG9yZSIsImluc3RhbGwiLCJQcm9taXNlIiwicGx1Z2lucyIsInN0cmljdCIsIl9jb21taXR0aW5nIiwiX2FjdGlvbnMiLCJfYWN0aW9uU3Vic2NyaWJlcnMiLCJfbXV0YXRpb25zIiwiX3dyYXBwZWRHZXR0ZXJzIiwiX21vZHVsZXMiLCJfbW9kdWxlc05hbWVzcGFjZU1hcCIsIl9zdWJzY3JpYmVycyIsIl93YXRjaGVyVk0iLCJyZWYiLCJkaXNwYXRjaCIsImNvbW1pdCIsImJvdW5kRGlzcGF0Y2giLCJwYXlsb2FkIiwiYm91bmRDb21taXQiLCJpbnN0YWxsTW9kdWxlIiwicmVzZXRTdG9yZVZNIiwicGx1Z2luIiwiY29uZmlnIiwiZGV2dG9vbHMiLCJwcm90b3R5cGVBY2Nlc3NvcnMiLCJfdm0iLCJfZGF0YSIsIiQkc3RhdGUiLCJzZXQiLCJ2IiwiX3R5cGUiLCJfcGF5bG9hZCIsIl9vcHRpb25zIiwidW5pZnlPYmplY3RTdHlsZSIsImVudHJ5IiwiZXJyb3IiLCJfd2l0aENvbW1pdCIsImNvbW1pdEl0ZXJhdG9yIiwic3ViIiwic2lsZW50IiwiYWN0aW9uIiwiYWxsIiwibWFwIiwiZ2VuZXJpY1N1YnNjcmliZSIsInN1YnNjcmliZUFjdGlvbiIsIndhdGNoIiwiZ2V0dGVyIiwiY2IiLCIkd2F0Y2giLCJyZWdpc3Rlck1vZHVsZSIsIkFycmF5IiwiaXNBcnJheSIsInByZXNlcnZlU3RhdGUiLCJ1bnJlZ2lzdGVyTW9kdWxlIiwicGFyZW50U3RhdGUiLCJnZXROZXN0ZWRTdGF0ZSIsImRlbGV0ZSIsInJlc2V0U3RvcmUiLCJob3RVcGRhdGUiLCJuZXdPcHRpb25zIiwiY29tbWl0dGluZyIsInN1YnMiLCJpbmRleE9mIiwicHVzaCIsImkiLCJzcGxpY2UiLCJob3QiLCJvbGRWbSIsIndyYXBwZWRHZXR0ZXJzIiwiY29tcHV0ZWQiLCJkZWZpbmVQcm9wZXJ0eSIsImVudW1lcmFibGUiLCJkYXRhIiwiZW5hYmxlU3RyaWN0TW9kZSIsIm5leHRUaWNrIiwiJGRlc3Ryb3kiLCJyb290U3RhdGUiLCJpc1Jvb3QiLCJtb2R1bGVOYW1lIiwibG9jYWwiLCJjb250ZXh0IiwibWFrZUxvY2FsQ29udGV4dCIsIm5hbWVzcGFjZWRUeXBlIiwicmVnaXN0ZXJNdXRhdGlvbiIsInJlZ2lzdGVyQWN0aW9uIiwicmVnaXN0ZXJHZXR0ZXIiLCJjaGlsZCIsIm5vTmFtZXNwYWNlIiwiYXJncyIsIm1ha2VMb2NhbEdldHRlcnMiLCJnZXR0ZXJzUHJveHkiLCJzcGxpdFBvcyIsImxvY2FsVHlwZSIsIndyYXBwZWRNdXRhdGlvbkhhbmRsZXIiLCJ3cmFwcGVkQWN0aW9uSGFuZGxlciIsInJlcyIsInJvb3RHZXR0ZXJzIiwicmVzb2x2ZSIsImNhdGNoIiwiZXJyIiwicmF3R2V0dGVyIiwid3JhcHBlZEdldHRlciIsImRlZXAiLCJzeW5jIiwiX1Z1ZSIsIm1hcFN0YXRlIiwibm9ybWFsaXplTmFtZXNwYWNlIiwic3RhdGVzIiwibm9ybWFsaXplTWFwIiwibWFwcGVkU3RhdGUiLCJnZXRNb2R1bGVCeU5hbWVzcGFjZSIsInZ1ZXgiLCJtYXBNdXRhdGlvbnMiLCJtYXBwZWRNdXRhdGlvbiIsImxlbiIsImFyZ3VtZW50cyIsImFwcGx5IiwibWFwR2V0dGVycyIsIm1hcHBlZEdldHRlciIsIm1hcEFjdGlvbnMiLCJtYXBwZWRBY3Rpb24iLCJjcmVhdGVOYW1lc3BhY2VkSGVscGVycyIsImJpbmQiLCJjaGFyQXQiLCJoZWxwZXIiLCJpbmRleF9lc20iXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7QUFBQTs7Ozs7QUFLQSxJQUFJQSxhQUFhLFNBQWJBLFVBQWEsQ0FBVUMsR0FBVixFQUFlO0FBQzlCLE1BQUlDLFVBQVVDLE9BQU9GLElBQUlDLE9BQUosQ0FBWUUsS0FBWixDQUFrQixHQUFsQixFQUF1QixDQUF2QixDQUFQLENBQWQ7O0FBRUEsTUFBSUYsV0FBVyxDQUFmLEVBQWtCO0FBQ2hCRCxRQUFJSSxLQUFKLENBQVUsRUFBRUMsY0FBY0MsUUFBaEIsRUFBVjtBQUNELEdBRkQsTUFFTztBQUNMO0FBQ0E7QUFDQSxRQUFJQyxRQUFRUCxJQUFJUSxTQUFKLENBQWNELEtBQTFCO0FBQ0FQLFFBQUlRLFNBQUosQ0FBY0QsS0FBZCxHQUFzQixVQUFVRSxPQUFWLEVBQW1CO0FBQ3ZDLFVBQUtBLFlBQVksS0FBSyxDQUF0QixFQUEwQkEsVUFBVSxFQUFWOztBQUUxQkEsY0FBUUMsSUFBUixHQUFlRCxRQUFRQyxJQUFSLEdBQ1gsQ0FBQ0osUUFBRCxFQUFXSyxNQUFYLENBQWtCRixRQUFRQyxJQUExQixDQURXLEdBRVhKLFFBRko7QUFHQUMsWUFBTUssSUFBTixDQUFXLElBQVgsRUFBaUJILE9BQWpCO0FBQ0QsS0FQRDtBQVFEOztBQUVEOzs7O0FBSUEsV0FBU0gsUUFBVCxHQUFxQjtBQUNuQixRQUFJRyxVQUFVLEtBQUtJLFFBQW5CO0FBQ0E7QUFDQSxRQUFJSixRQUFRSyxLQUFaLEVBQW1CO0FBQ2pCLFdBQUtDLE1BQUwsR0FBYyxPQUFPTixRQUFRSyxLQUFmLEtBQXlCLFVBQXpCLEdBQ1ZMLFFBQVFLLEtBQVIsRUFEVSxHQUVWTCxRQUFRSyxLQUZaO0FBR0QsS0FKRCxNQUlPLElBQUlMLFFBQVFPLE1BQVIsSUFBa0JQLFFBQVFPLE1BQVIsQ0FBZUQsTUFBckMsRUFBNkM7QUFDbEQsV0FBS0EsTUFBTCxHQUFjTixRQUFRTyxNQUFSLENBQWVELE1BQTdCO0FBQ0Q7QUFDRjtBQUNGLENBbENEOztBQW9DQSxJQUFJRSxjQUNGLE9BQU9DLE1BQVAsS0FBa0IsV0FBbEIsSUFDQUEsT0FBT0MsNEJBRlQ7O0FBSUEsU0FBU0MsYUFBVCxDQUF3Qk4sS0FBeEIsRUFBK0I7QUFDN0IsTUFBSSxDQUFDRyxXQUFMLEVBQWtCO0FBQUU7QUFBUTs7QUFFNUJILFFBQU1PLFlBQU4sR0FBcUJKLFdBQXJCOztBQUVBQSxjQUFZSyxJQUFaLENBQWlCLFdBQWpCLEVBQThCUixLQUE5Qjs7QUFFQUcsY0FBWU0sRUFBWixDQUFlLHNCQUFmLEVBQXVDLFVBQVVDLFdBQVYsRUFBdUI7QUFDNURWLFVBQU1XLFlBQU4sQ0FBbUJELFdBQW5CO0FBQ0QsR0FGRDs7QUFJQVYsUUFBTVksU0FBTixDQUFnQixVQUFVQyxRQUFWLEVBQW9CQyxLQUFwQixFQUEyQjtBQUN6Q1gsZ0JBQVlLLElBQVosQ0FBaUIsZUFBakIsRUFBa0NLLFFBQWxDLEVBQTRDQyxLQUE1QztBQUNELEdBRkQ7QUFHRDs7QUFFRDs7Ozs7Ozs7QUFRQTs7Ozs7Ozs7OztBQVdBOzs7QUFHQSxTQUFTQyxZQUFULENBQXVCQyxHQUF2QixFQUE0QkMsRUFBNUIsRUFBZ0M7QUFDOUJDLFNBQU9DLElBQVAsQ0FBWUgsR0FBWixFQUFpQkksT0FBakIsQ0FBeUIsVUFBVUMsR0FBVixFQUFlO0FBQUUsV0FBT0osR0FBR0QsSUFBSUssR0FBSixDQUFILEVBQWFBLEdBQWIsQ0FBUDtBQUEyQixHQUFyRTtBQUNEOztBQUVELFNBQVNDLFFBQVQsQ0FBbUJOLEdBQW5CLEVBQXdCO0FBQ3RCLFNBQU9BLFFBQVEsSUFBUixJQUFnQixRQUFPQSxHQUFQLHlDQUFPQSxHQUFQLE9BQWUsUUFBdEM7QUFDRDs7QUFFRCxTQUFTTyxTQUFULENBQW9CQyxHQUFwQixFQUF5QjtBQUN2QixTQUFPQSxPQUFPLE9BQU9BLElBQUlDLElBQVgsS0FBb0IsVUFBbEM7QUFDRDs7QUFFRCxTQUFTQyxNQUFULENBQWlCQyxTQUFqQixFQUE0QkMsR0FBNUIsRUFBaUM7QUFDL0IsTUFBSSxDQUFDRCxTQUFMLEVBQWdCO0FBQUUsVUFBTSxJQUFJRSxLQUFKLENBQVcsWUFBWUQsR0FBdkIsQ0FBTjtBQUFvQztBQUN2RDs7QUFFRCxJQUFJRSxTQUFTLFNBQVNBLE1BQVQsQ0FBaUJDLFNBQWpCLEVBQTRCQyxPQUE1QixFQUFxQztBQUNoRCxPQUFLQSxPQUFMLEdBQWVBLE9BQWY7QUFDQSxPQUFLQyxTQUFMLEdBQWlCZixPQUFPZ0IsTUFBUCxDQUFjLElBQWQsQ0FBakI7QUFDQSxPQUFLQyxVQUFMLEdBQWtCSixTQUFsQjtBQUNBLE1BQUlLLFdBQVdMLFVBQVVqQixLQUF6QjtBQUNBLE9BQUtBLEtBQUwsR0FBYSxDQUFDLE9BQU9zQixRQUFQLEtBQW9CLFVBQXBCLEdBQWlDQSxVQUFqQyxHQUE4Q0EsUUFBL0MsS0FBNEQsRUFBekU7QUFDRCxDQU5EOztBQVFBLElBQUlDLHVCQUF1QixFQUFFQyxZQUFZLEVBQUVDLGNBQWMsSUFBaEIsRUFBZCxFQUEzQjs7QUFFQUYscUJBQXFCQyxVQUFyQixDQUFnQ0UsR0FBaEMsR0FBc0MsWUFBWTtBQUNoRCxTQUFPLENBQUMsQ0FBQyxLQUFLTCxVQUFMLENBQWdCRyxVQUF6QjtBQUNELENBRkQ7O0FBSUFSLE9BQU9wQyxTQUFQLENBQWlCK0MsUUFBakIsR0FBNEIsU0FBU0EsUUFBVCxDQUFtQnBCLEdBQW5CLEVBQXdCcUIsTUFBeEIsRUFBZ0M7QUFDMUQsT0FBS1QsU0FBTCxDQUFlWixHQUFmLElBQXNCcUIsTUFBdEI7QUFDRCxDQUZEOztBQUlBWixPQUFPcEMsU0FBUCxDQUFpQmlELFdBQWpCLEdBQStCLFNBQVNBLFdBQVQsQ0FBc0J0QixHQUF0QixFQUEyQjtBQUN4RCxTQUFPLEtBQUtZLFNBQUwsQ0FBZVosR0FBZixDQUFQO0FBQ0QsQ0FGRDs7QUFJQVMsT0FBT3BDLFNBQVAsQ0FBaUJrRCxRQUFqQixHQUE0QixTQUFTQSxRQUFULENBQW1CdkIsR0FBbkIsRUFBd0I7QUFDbEQsU0FBTyxLQUFLWSxTQUFMLENBQWVaLEdBQWYsQ0FBUDtBQUNELENBRkQ7O0FBSUFTLE9BQU9wQyxTQUFQLENBQWlCbUQsTUFBakIsR0FBMEIsU0FBU0EsTUFBVCxDQUFpQmQsU0FBakIsRUFBNEI7QUFDcEQsT0FBS0ksVUFBTCxDQUFnQkcsVUFBaEIsR0FBNkJQLFVBQVVPLFVBQXZDO0FBQ0EsTUFBSVAsVUFBVWUsT0FBZCxFQUF1QjtBQUNyQixTQUFLWCxVQUFMLENBQWdCVyxPQUFoQixHQUEwQmYsVUFBVWUsT0FBcEM7QUFDRDtBQUNELE1BQUlmLFVBQVVnQixTQUFkLEVBQXlCO0FBQ3ZCLFNBQUtaLFVBQUwsQ0FBZ0JZLFNBQWhCLEdBQTRCaEIsVUFBVWdCLFNBQXRDO0FBQ0Q7QUFDRCxNQUFJaEIsVUFBVWlCLE9BQWQsRUFBdUI7QUFDckIsU0FBS2IsVUFBTCxDQUFnQmEsT0FBaEIsR0FBMEJqQixVQUFVaUIsT0FBcEM7QUFDRDtBQUNGLENBWEQ7O0FBYUFsQixPQUFPcEMsU0FBUCxDQUFpQnVELFlBQWpCLEdBQWdDLFNBQVNBLFlBQVQsQ0FBdUJoQyxFQUF2QixFQUEyQjtBQUN6REYsZUFBYSxLQUFLa0IsU0FBbEIsRUFBNkJoQixFQUE3QjtBQUNELENBRkQ7O0FBSUFhLE9BQU9wQyxTQUFQLENBQWlCd0QsYUFBakIsR0FBaUMsU0FBU0EsYUFBVCxDQUF3QmpDLEVBQXhCLEVBQTRCO0FBQzNELE1BQUksS0FBS2tCLFVBQUwsQ0FBZ0JhLE9BQXBCLEVBQTZCO0FBQzNCakMsaUJBQWEsS0FBS29CLFVBQUwsQ0FBZ0JhLE9BQTdCLEVBQXNDL0IsRUFBdEM7QUFDRDtBQUNGLENBSkQ7O0FBTUFhLE9BQU9wQyxTQUFQLENBQWlCeUQsYUFBakIsR0FBaUMsU0FBU0EsYUFBVCxDQUF3QmxDLEVBQXhCLEVBQTRCO0FBQzNELE1BQUksS0FBS2tCLFVBQUwsQ0FBZ0JXLE9BQXBCLEVBQTZCO0FBQzNCL0IsaUJBQWEsS0FBS29CLFVBQUwsQ0FBZ0JXLE9BQTdCLEVBQXNDN0IsRUFBdEM7QUFDRDtBQUNGLENBSkQ7O0FBTUFhLE9BQU9wQyxTQUFQLENBQWlCMEQsZUFBakIsR0FBbUMsU0FBU0EsZUFBVCxDQUEwQm5DLEVBQTFCLEVBQThCO0FBQy9ELE1BQUksS0FBS2tCLFVBQUwsQ0FBZ0JZLFNBQXBCLEVBQStCO0FBQzdCaEMsaUJBQWEsS0FBS29CLFVBQUwsQ0FBZ0JZLFNBQTdCLEVBQXdDOUIsRUFBeEM7QUFDRDtBQUNGLENBSkQ7O0FBTUFDLE9BQU9tQyxnQkFBUCxDQUF5QnZCLE9BQU9wQyxTQUFoQyxFQUEyQzJDLG9CQUEzQzs7QUFFQSxJQUFJaUIsbUJBQW1CLFNBQVNBLGdCQUFULENBQTJCQyxhQUEzQixFQUEwQztBQUMvRDtBQUNBLE9BQUtDLFFBQUwsQ0FBYyxFQUFkLEVBQWtCRCxhQUFsQixFQUFpQyxLQUFqQztBQUNELENBSEQ7O0FBS0FELGlCQUFpQjVELFNBQWpCLENBQTJCOEMsR0FBM0IsR0FBaUMsU0FBU0EsR0FBVCxDQUFjaUIsSUFBZCxFQUFvQjtBQUNuRCxTQUFPQSxLQUFLQyxNQUFMLENBQVksVUFBVWhCLE1BQVYsRUFBa0JyQixHQUFsQixFQUF1QjtBQUN4QyxXQUFPcUIsT0FBT0UsUUFBUCxDQUFnQnZCLEdBQWhCLENBQVA7QUFDRCxHQUZNLEVBRUosS0FBS3NDLElBRkQsQ0FBUDtBQUdELENBSkQ7O0FBTUFMLGlCQUFpQjVELFNBQWpCLENBQTJCa0UsWUFBM0IsR0FBMEMsU0FBU0EsWUFBVCxDQUF1QkgsSUFBdkIsRUFBNkI7QUFDckUsTUFBSWYsU0FBUyxLQUFLaUIsSUFBbEI7QUFDQSxTQUFPRixLQUFLQyxNQUFMLENBQVksVUFBVUcsU0FBVixFQUFxQnhDLEdBQXJCLEVBQTBCO0FBQzNDcUIsYUFBU0EsT0FBT0UsUUFBUCxDQUFnQnZCLEdBQWhCLENBQVQ7QUFDQSxXQUFPd0MsYUFBYW5CLE9BQU9KLFVBQVAsR0FBb0JqQixNQUFNLEdBQTFCLEdBQWdDLEVBQTdDLENBQVA7QUFDRCxHQUhNLEVBR0osRUFISSxDQUFQO0FBSUQsQ0FORDs7QUFRQWlDLGlCQUFpQjVELFNBQWpCLENBQTJCbUQsTUFBM0IsR0FBb0MsU0FBU2lCLFFBQVQsQ0FBbUJQLGFBQW5CLEVBQWtDO0FBQ3BFVixTQUFPLEVBQVAsRUFBVyxLQUFLYyxJQUFoQixFQUFzQkosYUFBdEI7QUFDRCxDQUZEOztBQUlBRCxpQkFBaUI1RCxTQUFqQixDQUEyQjhELFFBQTNCLEdBQXNDLFNBQVNBLFFBQVQsQ0FBbUJDLElBQW5CLEVBQXlCMUIsU0FBekIsRUFBb0NDLE9BQXBDLEVBQTZDO0FBQy9FLE1BQUkrQixTQUFTLElBQWI7QUFDQSxNQUFLL0IsWUFBWSxLQUFLLENBQXRCLEVBQTBCQSxVQUFVLElBQVY7O0FBRTVCLE1BQUlnQyxRQUFRQyxHQUFSLENBQVlDLFFBQVosS0FBeUIsWUFBN0IsRUFBMkM7QUFDekNDLG9CQUFnQlYsSUFBaEIsRUFBc0IxQixTQUF0QjtBQUNEOztBQUVELE1BQUlxQyxZQUFZLElBQUl0QyxNQUFKLENBQVdDLFNBQVgsRUFBc0JDLE9BQXRCLENBQWhCO0FBQ0EsTUFBSXlCLEtBQUtZLE1BQUwsS0FBZ0IsQ0FBcEIsRUFBdUI7QUFDckIsU0FBS1YsSUFBTCxHQUFZUyxTQUFaO0FBQ0QsR0FGRCxNQUVPO0FBQ0wsUUFBSWxFLFNBQVMsS0FBS3NDLEdBQUwsQ0FBU2lCLEtBQUthLEtBQUwsQ0FBVyxDQUFYLEVBQWMsQ0FBQyxDQUFmLENBQVQsQ0FBYjtBQUNBcEUsV0FBT3VDLFFBQVAsQ0FBZ0JnQixLQUFLQSxLQUFLWSxNQUFMLEdBQWMsQ0FBbkIsQ0FBaEIsRUFBdUNELFNBQXZDO0FBQ0Q7O0FBRUQ7QUFDQSxNQUFJckMsVUFBVXdDLE9BQWQsRUFBdUI7QUFDckJ4RCxpQkFBYWdCLFVBQVV3QyxPQUF2QixFQUFnQyxVQUFVQyxjQUFWLEVBQTBCbkQsR0FBMUIsRUFBK0I7QUFDN0QwQyxhQUFPUCxRQUFQLENBQWdCQyxLQUFLNUQsTUFBTCxDQUFZd0IsR0FBWixDQUFoQixFQUFrQ21ELGNBQWxDLEVBQWtEeEMsT0FBbEQ7QUFDRCxLQUZEO0FBR0Q7QUFDRixDQXRCRDs7QUF3QkFzQixpQkFBaUI1RCxTQUFqQixDQUEyQitFLFVBQTNCLEdBQXdDLFNBQVNBLFVBQVQsQ0FBcUJoQixJQUFyQixFQUEyQjtBQUNqRSxNQUFJdkQsU0FBUyxLQUFLc0MsR0FBTCxDQUFTaUIsS0FBS2EsS0FBTCxDQUFXLENBQVgsRUFBYyxDQUFDLENBQWYsQ0FBVCxDQUFiO0FBQ0EsTUFBSWpELE1BQU1vQyxLQUFLQSxLQUFLWSxNQUFMLEdBQWMsQ0FBbkIsQ0FBVjtBQUNBLE1BQUksQ0FBQ25FLE9BQU8wQyxRQUFQLENBQWdCdkIsR0FBaEIsRUFBcUJXLE9BQTFCLEVBQW1DO0FBQUU7QUFBUTs7QUFFN0M5QixTQUFPeUMsV0FBUCxDQUFtQnRCLEdBQW5CO0FBQ0QsQ0FORDs7QUFRQSxTQUFTd0IsTUFBVCxDQUFpQlksSUFBakIsRUFBdUJpQixZQUF2QixFQUFxQ04sU0FBckMsRUFBZ0Q7QUFDOUMsTUFBSUosUUFBUUMsR0FBUixDQUFZQyxRQUFaLEtBQXlCLFlBQTdCLEVBQTJDO0FBQ3pDQyxvQkFBZ0JWLElBQWhCLEVBQXNCVyxTQUF0QjtBQUNEOztBQUVEO0FBQ0FNLGVBQWE3QixNQUFiLENBQW9CdUIsU0FBcEI7O0FBRUE7QUFDQSxNQUFJQSxVQUFVRyxPQUFkLEVBQXVCO0FBQ3JCLFNBQUssSUFBSWxELEdBQVQsSUFBZ0IrQyxVQUFVRyxPQUExQixFQUFtQztBQUNqQyxVQUFJLENBQUNHLGFBQWE5QixRQUFiLENBQXNCdkIsR0FBdEIsQ0FBTCxFQUFpQztBQUMvQixZQUFJMkMsUUFBUUMsR0FBUixDQUFZQyxRQUFaLEtBQXlCLFlBQTdCLEVBQTJDO0FBQ3pDUyxrQkFBUUMsSUFBUixDQUNFLHdDQUF3Q3ZELEdBQXhDLEdBQThDLHNCQUE5QyxHQUNBLHlCQUZGO0FBSUQ7QUFDRDtBQUNEO0FBQ0R3QixhQUNFWSxLQUFLNUQsTUFBTCxDQUFZd0IsR0FBWixDQURGLEVBRUVxRCxhQUFhOUIsUUFBYixDQUFzQnZCLEdBQXRCLENBRkYsRUFHRStDLFVBQVVHLE9BQVYsQ0FBa0JsRCxHQUFsQixDQUhGO0FBS0Q7QUFDRjtBQUNGOztBQUVELElBQUl3RCxpQkFBaUI7QUFDbkJuRCxVQUFRLGdCQUFVb0QsS0FBVixFQUFpQjtBQUFFLFdBQU8sT0FBT0EsS0FBUCxLQUFpQixVQUF4QjtBQUFxQyxHQUQ3QztBQUVuQkMsWUFBVTtBQUZTLENBQXJCOztBQUtBLElBQUlDLGVBQWU7QUFDakJ0RCxVQUFRLGdCQUFVb0QsS0FBVixFQUFpQjtBQUFFLFdBQU8sT0FBT0EsS0FBUCxLQUFpQixVQUFqQixJQUMvQixRQUFPQSxLQUFQLHlDQUFPQSxLQUFQLE9BQWlCLFFBQWpCLElBQTZCLE9BQU9BLE1BQU1HLE9BQWIsS0FBeUIsVUFEOUI7QUFDNEMsR0FGdEQ7QUFHakJGLFlBQVU7QUFITyxDQUFuQjs7QUFNQSxJQUFJRyxjQUFjO0FBQ2hCbEMsV0FBUzZCLGNBRE87QUFFaEI5QixhQUFXOEIsY0FGSztBQUdoQi9CLFdBQVNrQztBQUhPLENBQWxCOztBQU1BLFNBQVNiLGVBQVQsQ0FBMEJWLElBQTFCLEVBQWdDMUIsU0FBaEMsRUFBMkM7QUFDekNiLFNBQU9DLElBQVAsQ0FBWStELFdBQVosRUFBeUI5RCxPQUF6QixDQUFpQyxVQUFVQyxHQUFWLEVBQWU7QUFDOUMsUUFBSSxDQUFDVSxVQUFVVixHQUFWLENBQUwsRUFBcUI7QUFBRTtBQUFROztBQUUvQixRQUFJOEQsZ0JBQWdCRCxZQUFZN0QsR0FBWixDQUFwQjs7QUFFQU4saUJBQWFnQixVQUFVVixHQUFWLENBQWIsRUFBNkIsVUFBVXlELEtBQVYsRUFBaUJNLElBQWpCLEVBQXVCO0FBQ2xEMUQsYUFDRXlELGNBQWN6RCxNQUFkLENBQXFCb0QsS0FBckIsQ0FERixFQUVFTyxxQkFBcUI1QixJQUFyQixFQUEyQnBDLEdBQTNCLEVBQWdDK0QsSUFBaEMsRUFBc0NOLEtBQXRDLEVBQTZDSyxjQUFjSixRQUEzRCxDQUZGO0FBSUQsS0FMRDtBQU1ELEdBWEQ7QUFZRDs7QUFFRCxTQUFTTSxvQkFBVCxDQUErQjVCLElBQS9CLEVBQXFDcEMsR0FBckMsRUFBMEMrRCxJQUExQyxFQUFnRE4sS0FBaEQsRUFBdURDLFFBQXZELEVBQWlFO0FBQy9ELE1BQUlPLE1BQU1qRSxNQUFNLGFBQU4sR0FBc0IwRCxRQUF0QixHQUFpQyxTQUFqQyxHQUE2QzFELEdBQTdDLEdBQW1ELEdBQW5ELEdBQXlEK0QsSUFBekQsR0FBZ0UsSUFBMUU7QUFDQSxNQUFJM0IsS0FBS1ksTUFBTCxHQUFjLENBQWxCLEVBQXFCO0FBQ25CaUIsV0FBTyxrQkFBbUI3QixLQUFLOEIsSUFBTCxDQUFVLEdBQVYsQ0FBbkIsR0FBcUMsSUFBNUM7QUFDRDtBQUNERCxTQUFPLFNBQVVFLEtBQUtDLFNBQUwsQ0FBZVgsS0FBZixDQUFWLEdBQW1DLEdBQTFDO0FBQ0EsU0FBT1EsR0FBUDtBQUNEOztBQUVELElBQUlwRyxHQUFKLEMsQ0FBUzs7QUFFVCxJQUFJd0csUUFBUSxTQUFTQSxLQUFULENBQWdCL0YsT0FBaEIsRUFBeUI7QUFDbkMsTUFBSW9FLFNBQVMsSUFBYjtBQUNBLE1BQUtwRSxZQUFZLEtBQUssQ0FBdEIsRUFBMEJBLFVBQVUsRUFBVjs7QUFFMUI7QUFDQTtBQUNBO0FBQ0EsTUFBSSxDQUFDVCxHQUFELElBQVEsT0FBT2tCLE1BQVAsS0FBa0IsV0FBMUIsSUFBeUNBLE9BQU9sQixHQUFwRCxFQUF5RDtBQUN2RHlHLFlBQVF2RixPQUFPbEIsR0FBZjtBQUNEOztBQUVELE1BQUk4RSxRQUFRQyxHQUFSLENBQVlDLFFBQVosS0FBeUIsWUFBN0IsRUFBMkM7QUFDekN4QyxXQUFPeEMsR0FBUCxFQUFZLDJEQUFaO0FBQ0F3QyxXQUFPLE9BQU9rRSxPQUFQLEtBQW1CLFdBQTFCLEVBQXVDLG1EQUF2QztBQUNBbEUsV0FBTyxnQkFBZ0JnRSxLQUF2QixFQUE4Qiw2Q0FBOUI7QUFDRDs7QUFFRCxNQUFJRyxVQUFVbEcsUUFBUWtHLE9BQXRCLENBQStCLElBQUtBLFlBQVksS0FBSyxDQUF0QixFQUEwQkEsVUFBVSxFQUFWO0FBQ3pELE1BQUlDLFNBQVNuRyxRQUFRbUcsTUFBckIsQ0FBNkIsSUFBS0EsV0FBVyxLQUFLLENBQXJCLEVBQXlCQSxTQUFTLEtBQVQ7O0FBRXRELE1BQUloRixRQUFRbkIsUUFBUW1CLEtBQXBCLENBQTJCLElBQUtBLFVBQVUsS0FBSyxDQUFwQixFQUF3QkEsUUFBUSxFQUFSO0FBQ25ELE1BQUksT0FBT0EsS0FBUCxLQUFpQixVQUFyQixFQUFpQztBQUMvQkEsWUFBUUEsV0FBVyxFQUFuQjtBQUNEOztBQUVEO0FBQ0EsT0FBS2lGLFdBQUwsR0FBbUIsS0FBbkI7QUFDQSxPQUFLQyxRQUFMLEdBQWdCOUUsT0FBT2dCLE1BQVAsQ0FBYyxJQUFkLENBQWhCO0FBQ0EsT0FBSytELGtCQUFMLEdBQTBCLEVBQTFCO0FBQ0EsT0FBS0MsVUFBTCxHQUFrQmhGLE9BQU9nQixNQUFQLENBQWMsSUFBZCxDQUFsQjtBQUNBLE9BQUtpRSxlQUFMLEdBQXVCakYsT0FBT2dCLE1BQVAsQ0FBYyxJQUFkLENBQXZCO0FBQ0EsT0FBS2tFLFFBQUwsR0FBZ0IsSUFBSTlDLGdCQUFKLENBQXFCM0QsT0FBckIsQ0FBaEI7QUFDQSxPQUFLMEcsb0JBQUwsR0FBNEJuRixPQUFPZ0IsTUFBUCxDQUFjLElBQWQsQ0FBNUI7QUFDQSxPQUFLb0UsWUFBTCxHQUFvQixFQUFwQjtBQUNBLE9BQUtDLFVBQUwsR0FBa0IsSUFBSXJILEdBQUosRUFBbEI7O0FBRUE7QUFDQSxNQUFJYyxRQUFRLElBQVo7QUFDQSxNQUFJd0csTUFBTSxJQUFWO0FBQ0EsTUFBSUMsV0FBV0QsSUFBSUMsUUFBbkI7QUFDQSxNQUFJQyxTQUFTRixJQUFJRSxNQUFqQjtBQUNBLE9BQUtELFFBQUwsR0FBZ0IsU0FBU0UsYUFBVCxDQUF3QnZCLElBQXhCLEVBQThCd0IsT0FBOUIsRUFBdUM7QUFDckQsV0FBT0gsU0FBUzNHLElBQVQsQ0FBY0UsS0FBZCxFQUFxQm9GLElBQXJCLEVBQTJCd0IsT0FBM0IsQ0FBUDtBQUNELEdBRkQ7QUFHQSxPQUFLRixNQUFMLEdBQWMsU0FBU0csV0FBVCxDQUFzQnpCLElBQXRCLEVBQTRCd0IsT0FBNUIsRUFBcUNqSCxPQUFyQyxFQUE4QztBQUMxRCxXQUFPK0csT0FBTzVHLElBQVAsQ0FBWUUsS0FBWixFQUFtQm9GLElBQW5CLEVBQXlCd0IsT0FBekIsRUFBa0NqSCxPQUFsQyxDQUFQO0FBQ0QsR0FGRDs7QUFJQTtBQUNBLE9BQUttRyxNQUFMLEdBQWNBLE1BQWQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0FnQixnQkFBYyxJQUFkLEVBQW9CaEcsS0FBcEIsRUFBMkIsRUFBM0IsRUFBK0IsS0FBS3NGLFFBQUwsQ0FBY3pDLElBQTdDOztBQUVBO0FBQ0E7QUFDQW9ELGVBQWEsSUFBYixFQUFtQmpHLEtBQW5COztBQUVBO0FBQ0ErRSxVQUFRekUsT0FBUixDQUFnQixVQUFVNEYsTUFBVixFQUFrQjtBQUFFLFdBQU9BLE9BQU9qRCxNQUFQLENBQVA7QUFBd0IsR0FBNUQ7O0FBRUEsTUFBSTdFLElBQUkrSCxNQUFKLENBQVdDLFFBQWYsRUFBeUI7QUFDdkI1RyxrQkFBYyxJQUFkO0FBQ0Q7QUFDRixDQWxFRDs7QUFvRUEsSUFBSTZHLHFCQUFxQixFQUFFckcsT0FBTyxFQUFFeUIsY0FBYyxJQUFoQixFQUFULEVBQXpCOztBQUVBNEUsbUJBQW1CckcsS0FBbkIsQ0FBeUIwQixHQUF6QixHQUErQixZQUFZO0FBQ3pDLFNBQU8sS0FBSzRFLEdBQUwsQ0FBU0MsS0FBVCxDQUFlQyxPQUF0QjtBQUNELENBRkQ7O0FBSUFILG1CQUFtQnJHLEtBQW5CLENBQXlCeUcsR0FBekIsR0FBK0IsVUFBVUMsQ0FBVixFQUFhO0FBQzFDLE1BQUl4RCxRQUFRQyxHQUFSLENBQVlDLFFBQVosS0FBeUIsWUFBN0IsRUFBMkM7QUFDekN4QyxXQUFPLEtBQVAsRUFBYywyREFBZDtBQUNEO0FBQ0YsQ0FKRDs7QUFNQWdFLE1BQU1oRyxTQUFOLENBQWdCZ0gsTUFBaEIsR0FBeUIsU0FBU0EsTUFBVCxDQUFpQmUsS0FBakIsRUFBd0JDLFFBQXhCLEVBQWtDQyxRQUFsQyxFQUE0QztBQUNqRSxNQUFJNUQsU0FBUyxJQUFiOztBQUVGO0FBQ0EsTUFBSXlDLE1BQU1vQixpQkFBaUJILEtBQWpCLEVBQXdCQyxRQUF4QixFQUFrQ0MsUUFBbEMsQ0FBVjtBQUNFLE1BQUl2QyxPQUFPb0IsSUFBSXBCLElBQWY7QUFDQSxNQUFJd0IsVUFBVUosSUFBSUksT0FBbEI7QUFDQSxNQUFJakgsVUFBVTZHLElBQUk3RyxPQUFsQjs7QUFFRixNQUFJa0IsV0FBVyxFQUFFdUUsTUFBTUEsSUFBUixFQUFjd0IsU0FBU0EsT0FBdkIsRUFBZjtBQUNBLE1BQUlpQixRQUFRLEtBQUszQixVQUFMLENBQWdCZCxJQUFoQixDQUFaO0FBQ0EsTUFBSSxDQUFDeUMsS0FBTCxFQUFZO0FBQ1YsUUFBSTdELFFBQVFDLEdBQVIsQ0FBWUMsUUFBWixLQUF5QixZQUE3QixFQUEyQztBQUN6Q1MsY0FBUW1ELEtBQVIsQ0FBZSxtQ0FBbUMxQyxJQUFsRDtBQUNEO0FBQ0Q7QUFDRDtBQUNELE9BQUsyQyxXQUFMLENBQWlCLFlBQVk7QUFDM0JGLFVBQU16RyxPQUFOLENBQWMsU0FBUzRHLGNBQVQsQ0FBeUIvQyxPQUF6QixFQUFrQztBQUM5Q0EsY0FBUTJCLE9BQVI7QUFDRCxLQUZEO0FBR0QsR0FKRDtBQUtBLE9BQUtOLFlBQUwsQ0FBa0JsRixPQUFsQixDQUEwQixVQUFVNkcsR0FBVixFQUFlO0FBQUUsV0FBT0EsSUFBSXBILFFBQUosRUFBY2tELE9BQU9qRCxLQUFyQixDQUFQO0FBQXFDLEdBQWhGOztBQUVBLE1BQ0VrRCxRQUFRQyxHQUFSLENBQVlDLFFBQVosS0FBeUIsWUFBekIsSUFDQXZFLE9BREEsSUFDV0EsUUFBUXVJLE1BRnJCLEVBR0U7QUFDQXZELFlBQVFDLElBQVIsQ0FDRSwyQkFBMkJRLElBQTNCLEdBQWtDLG9DQUFsQyxHQUNBLGtEQUZGO0FBSUQ7QUFDRixDQWpDRDs7QUFtQ0FNLE1BQU1oRyxTQUFOLENBQWdCK0csUUFBaEIsR0FBMkIsU0FBU0EsUUFBVCxDQUFtQmdCLEtBQW5CLEVBQTBCQyxRQUExQixFQUFvQztBQUMzRCxNQUFJM0QsU0FBUyxJQUFiOztBQUVGO0FBQ0EsTUFBSXlDLE1BQU1vQixpQkFBaUJILEtBQWpCLEVBQXdCQyxRQUF4QixDQUFWO0FBQ0UsTUFBSXRDLE9BQU9vQixJQUFJcEIsSUFBZjtBQUNBLE1BQUl3QixVQUFVSixJQUFJSSxPQUFsQjs7QUFFRixNQUFJdUIsU0FBUyxFQUFFL0MsTUFBTUEsSUFBUixFQUFjd0IsU0FBU0EsT0FBdkIsRUFBYjtBQUNBLE1BQUlpQixRQUFRLEtBQUs3QixRQUFMLENBQWNaLElBQWQsQ0FBWjtBQUNBLE1BQUksQ0FBQ3lDLEtBQUwsRUFBWTtBQUNWLFFBQUk3RCxRQUFRQyxHQUFSLENBQVlDLFFBQVosS0FBeUIsWUFBN0IsRUFBMkM7QUFDekNTLGNBQVFtRCxLQUFSLENBQWUsaUNBQWlDMUMsSUFBaEQ7QUFDRDtBQUNEO0FBQ0Q7O0FBRUQsT0FBS2Esa0JBQUwsQ0FBd0I3RSxPQUF4QixDQUFnQyxVQUFVNkcsR0FBVixFQUFlO0FBQUUsV0FBT0EsSUFBSUUsTUFBSixFQUFZcEUsT0FBT2pELEtBQW5CLENBQVA7QUFBbUMsR0FBcEY7O0FBRUEsU0FBTytHLE1BQU14RCxNQUFOLEdBQWUsQ0FBZixHQUNIdUIsUUFBUXdDLEdBQVIsQ0FBWVAsTUFBTVEsR0FBTixDQUFVLFVBQVVwRCxPQUFWLEVBQW1CO0FBQUUsV0FBT0EsUUFBUTJCLE9BQVIsQ0FBUDtBQUEwQixHQUF6RCxDQUFaLENBREcsR0FFSGlCLE1BQU0sQ0FBTixFQUFTakIsT0FBVCxDQUZKO0FBR0QsQ0F0QkQ7O0FBd0JBbEIsTUFBTWhHLFNBQU4sQ0FBZ0JrQixTQUFoQixHQUE0QixTQUFTQSxTQUFULENBQW9CSyxFQUFwQixFQUF3QjtBQUNsRCxTQUFPcUgsaUJBQWlCckgsRUFBakIsRUFBcUIsS0FBS3FGLFlBQTFCLENBQVA7QUFDRCxDQUZEOztBQUlBWixNQUFNaEcsU0FBTixDQUFnQjZJLGVBQWhCLEdBQWtDLFNBQVNBLGVBQVQsQ0FBMEJ0SCxFQUExQixFQUE4QjtBQUM5RCxTQUFPcUgsaUJBQWlCckgsRUFBakIsRUFBcUIsS0FBS2dGLGtCQUExQixDQUFQO0FBQ0QsQ0FGRDs7QUFJQVAsTUFBTWhHLFNBQU4sQ0FBZ0I4SSxLQUFoQixHQUF3QixTQUFTQSxLQUFULENBQWdCQyxNQUFoQixFQUF3QkMsRUFBeEIsRUFBNEIvSSxPQUE1QixFQUFxQztBQUN6RCxNQUFJb0UsU0FBUyxJQUFiOztBQUVGLE1BQUlDLFFBQVFDLEdBQVIsQ0FBWUMsUUFBWixLQUF5QixZQUE3QixFQUEyQztBQUN6Q3hDLFdBQU8sT0FBTytHLE1BQVAsS0FBa0IsVUFBekIsRUFBcUMsc0NBQXJDO0FBQ0Q7QUFDRCxTQUFPLEtBQUtsQyxVQUFMLENBQWdCb0MsTUFBaEIsQ0FBdUIsWUFBWTtBQUFFLFdBQU9GLE9BQU8xRSxPQUFPakQsS0FBZCxFQUFxQmlELE9BQU9mLE9BQTVCLENBQVA7QUFBOEMsR0FBbkYsRUFBcUYwRixFQUFyRixFQUF5Ri9JLE9BQXpGLENBQVA7QUFDRCxDQVBEOztBQVNBK0YsTUFBTWhHLFNBQU4sQ0FBZ0JpQixZQUFoQixHQUErQixTQUFTQSxZQUFULENBQXVCRyxLQUF2QixFQUE4QjtBQUN6RCxNQUFJaUQsU0FBUyxJQUFiOztBQUVGLE9BQUtnRSxXQUFMLENBQWlCLFlBQVk7QUFDM0JoRSxXQUFPcUQsR0FBUCxDQUFXQyxLQUFYLENBQWlCQyxPQUFqQixHQUEyQnhHLEtBQTNCO0FBQ0QsR0FGRDtBQUdELENBTkQ7O0FBUUE0RSxNQUFNaEcsU0FBTixDQUFnQmtKLGNBQWhCLEdBQWlDLFNBQVNBLGNBQVQsQ0FBeUJuRixJQUF6QixFQUErQjFCLFNBQS9CLEVBQTBDcEMsT0FBMUMsRUFBbUQ7QUFDaEYsTUFBS0EsWUFBWSxLQUFLLENBQXRCLEVBQTBCQSxVQUFVLEVBQVY7O0FBRTVCLE1BQUksT0FBTzhELElBQVAsS0FBZ0IsUUFBcEIsRUFBOEI7QUFBRUEsV0FBTyxDQUFDQSxJQUFELENBQVA7QUFBZ0I7O0FBRWhELE1BQUlPLFFBQVFDLEdBQVIsQ0FBWUMsUUFBWixLQUF5QixZQUE3QixFQUEyQztBQUN6Q3hDLFdBQU9tSCxNQUFNQyxPQUFOLENBQWNyRixJQUFkLENBQVAsRUFBNEIsMkNBQTVCO0FBQ0EvQixXQUFPK0IsS0FBS1ksTUFBTCxHQUFjLENBQXJCLEVBQXdCLDBEQUF4QjtBQUNEOztBQUVELE9BQUsrQixRQUFMLENBQWM1QyxRQUFkLENBQXVCQyxJQUF2QixFQUE2QjFCLFNBQTdCO0FBQ0ErRSxnQkFBYyxJQUFkLEVBQW9CLEtBQUtoRyxLQUF6QixFQUFnQzJDLElBQWhDLEVBQXNDLEtBQUsyQyxRQUFMLENBQWM1RCxHQUFkLENBQWtCaUIsSUFBbEIsQ0FBdEMsRUFBK0Q5RCxRQUFRb0osYUFBdkU7QUFDQTtBQUNBaEMsZUFBYSxJQUFiLEVBQW1CLEtBQUtqRyxLQUF4QjtBQUNELENBZEQ7O0FBZ0JBNEUsTUFBTWhHLFNBQU4sQ0FBZ0JzSixnQkFBaEIsR0FBbUMsU0FBU0EsZ0JBQVQsQ0FBMkJ2RixJQUEzQixFQUFpQztBQUNoRSxNQUFJTSxTQUFTLElBQWI7O0FBRUYsTUFBSSxPQUFPTixJQUFQLEtBQWdCLFFBQXBCLEVBQThCO0FBQUVBLFdBQU8sQ0FBQ0EsSUFBRCxDQUFQO0FBQWdCOztBQUVoRCxNQUFJTyxRQUFRQyxHQUFSLENBQVlDLFFBQVosS0FBeUIsWUFBN0IsRUFBMkM7QUFDekN4QyxXQUFPbUgsTUFBTUMsT0FBTixDQUFjckYsSUFBZCxDQUFQLEVBQTRCLDJDQUE1QjtBQUNEOztBQUVELE9BQUsyQyxRQUFMLENBQWMzQixVQUFkLENBQXlCaEIsSUFBekI7QUFDQSxPQUFLc0UsV0FBTCxDQUFpQixZQUFZO0FBQzNCLFFBQUlrQixjQUFjQyxlQUFlbkYsT0FBT2pELEtBQXRCLEVBQTZCMkMsS0FBS2EsS0FBTCxDQUFXLENBQVgsRUFBYyxDQUFDLENBQWYsQ0FBN0IsQ0FBbEI7QUFDQXBGLFFBQUlpSyxNQUFKLENBQVdGLFdBQVgsRUFBd0J4RixLQUFLQSxLQUFLWSxNQUFMLEdBQWMsQ0FBbkIsQ0FBeEI7QUFDRCxHQUhEO0FBSUErRSxhQUFXLElBQVg7QUFDRCxDQWZEOztBQWlCQTFELE1BQU1oRyxTQUFOLENBQWdCMkosU0FBaEIsR0FBNEIsU0FBU0EsU0FBVCxDQUFvQkMsVUFBcEIsRUFBZ0M7QUFDMUQsT0FBS2xELFFBQUwsQ0FBY3ZELE1BQWQsQ0FBcUJ5RyxVQUFyQjtBQUNBRixhQUFXLElBQVgsRUFBaUIsSUFBakI7QUFDRCxDQUhEOztBQUtBMUQsTUFBTWhHLFNBQU4sQ0FBZ0JxSSxXQUFoQixHQUE4QixTQUFTQSxXQUFULENBQXNCOUcsRUFBdEIsRUFBMEI7QUFDdEQsTUFBSXNJLGFBQWEsS0FBS3hELFdBQXRCO0FBQ0EsT0FBS0EsV0FBTCxHQUFtQixJQUFuQjtBQUNBOUU7QUFDQSxPQUFLOEUsV0FBTCxHQUFtQndELFVBQW5CO0FBQ0QsQ0FMRDs7QUFPQXJJLE9BQU9tQyxnQkFBUCxDQUF5QnFDLE1BQU1oRyxTQUEvQixFQUEwQ3lILGtCQUExQzs7QUFFQSxTQUFTbUIsZ0JBQVQsQ0FBMkJySCxFQUEzQixFQUErQnVJLElBQS9CLEVBQXFDO0FBQ25DLE1BQUlBLEtBQUtDLE9BQUwsQ0FBYXhJLEVBQWIsSUFBbUIsQ0FBdkIsRUFBMEI7QUFDeEJ1SSxTQUFLRSxJQUFMLENBQVV6SSxFQUFWO0FBQ0Q7QUFDRCxTQUFPLFlBQVk7QUFDakIsUUFBSTBJLElBQUlILEtBQUtDLE9BQUwsQ0FBYXhJLEVBQWIsQ0FBUjtBQUNBLFFBQUkwSSxJQUFJLENBQUMsQ0FBVCxFQUFZO0FBQ1ZILFdBQUtJLE1BQUwsQ0FBWUQsQ0FBWixFQUFlLENBQWY7QUFDRDtBQUNGLEdBTEQ7QUFNRDs7QUFFRCxTQUFTUCxVQUFULENBQXFCcEosS0FBckIsRUFBNEI2SixHQUE1QixFQUFpQztBQUMvQjdKLFFBQU1nRyxRQUFOLEdBQWlCOUUsT0FBT2dCLE1BQVAsQ0FBYyxJQUFkLENBQWpCO0FBQ0FsQyxRQUFNa0csVUFBTixHQUFtQmhGLE9BQU9nQixNQUFQLENBQWMsSUFBZCxDQUFuQjtBQUNBbEMsUUFBTW1HLGVBQU4sR0FBd0JqRixPQUFPZ0IsTUFBUCxDQUFjLElBQWQsQ0FBeEI7QUFDQWxDLFFBQU1xRyxvQkFBTixHQUE2Qm5GLE9BQU9nQixNQUFQLENBQWMsSUFBZCxDQUE3QjtBQUNBLE1BQUlwQixRQUFRZCxNQUFNYyxLQUFsQjtBQUNBO0FBQ0FnRyxnQkFBYzlHLEtBQWQsRUFBcUJjLEtBQXJCLEVBQTRCLEVBQTVCLEVBQWdDZCxNQUFNb0csUUFBTixDQUFlekMsSUFBL0MsRUFBcUQsSUFBckQ7QUFDQTtBQUNBb0QsZUFBYS9HLEtBQWIsRUFBb0JjLEtBQXBCLEVBQTJCK0ksR0FBM0I7QUFDRDs7QUFFRCxTQUFTOUMsWUFBVCxDQUF1Qi9HLEtBQXZCLEVBQThCYyxLQUE5QixFQUFxQytJLEdBQXJDLEVBQTBDO0FBQ3hDLE1BQUlDLFFBQVE5SixNQUFNb0gsR0FBbEI7O0FBRUE7QUFDQXBILFFBQU1nRCxPQUFOLEdBQWdCLEVBQWhCO0FBQ0EsTUFBSStHLGlCQUFpQi9KLE1BQU1tRyxlQUEzQjtBQUNBLE1BQUk2RCxXQUFXLEVBQWY7QUFDQWpKLGVBQWFnSixjQUFiLEVBQTZCLFVBQVU5SSxFQUFWLEVBQWNJLEdBQWQsRUFBbUI7QUFDOUM7QUFDQTJJLGFBQVMzSSxHQUFULElBQWdCLFlBQVk7QUFBRSxhQUFPSixHQUFHakIsS0FBSCxDQUFQO0FBQW1CLEtBQWpEO0FBQ0FrQixXQUFPK0ksY0FBUCxDQUFzQmpLLE1BQU1nRCxPQUE1QixFQUFxQzNCLEdBQXJDLEVBQTBDO0FBQ3hDbUIsV0FBSyxlQUFZO0FBQUUsZUFBT3hDLE1BQU1vSCxHQUFOLENBQVUvRixHQUFWLENBQVA7QUFBd0IsT0FESDtBQUV4QzZJLGtCQUFZLElBRjRCLENBRXZCO0FBRnVCLEtBQTFDO0FBSUQsR0FQRDs7QUFTQTtBQUNBO0FBQ0E7QUFDQSxNQUFJaEMsU0FBU2hKLElBQUkrSCxNQUFKLENBQVdpQixNQUF4QjtBQUNBaEosTUFBSStILE1BQUosQ0FBV2lCLE1BQVgsR0FBb0IsSUFBcEI7QUFDQWxJLFFBQU1vSCxHQUFOLEdBQVksSUFBSWxJLEdBQUosQ0FBUTtBQUNsQmlMLFVBQU07QUFDSjdDLGVBQVN4RztBQURMLEtBRFk7QUFJbEJrSixjQUFVQTtBQUpRLEdBQVIsQ0FBWjtBQU1BOUssTUFBSStILE1BQUosQ0FBV2lCLE1BQVgsR0FBb0JBLE1BQXBCOztBQUVBO0FBQ0EsTUFBSWxJLE1BQU04RixNQUFWLEVBQWtCO0FBQ2hCc0UscUJBQWlCcEssS0FBakI7QUFDRDs7QUFFRCxNQUFJOEosS0FBSixFQUFXO0FBQ1QsUUFBSUQsR0FBSixFQUFTO0FBQ1A7QUFDQTtBQUNBN0osWUFBTStILFdBQU4sQ0FBa0IsWUFBWTtBQUM1QitCLGNBQU16QyxLQUFOLENBQVlDLE9BQVosR0FBc0IsSUFBdEI7QUFDRCxPQUZEO0FBR0Q7QUFDRHBJLFFBQUltTCxRQUFKLENBQWEsWUFBWTtBQUFFLGFBQU9QLE1BQU1RLFFBQU4sRUFBUDtBQUEwQixLQUFyRDtBQUNEO0FBQ0Y7O0FBRUQsU0FBU3hELGFBQVQsQ0FBd0I5RyxLQUF4QixFQUErQnVLLFNBQS9CLEVBQTBDOUcsSUFBMUMsRUFBZ0RmLE1BQWhELEVBQXdEbUgsR0FBeEQsRUFBNkQ7QUFDM0QsTUFBSVcsU0FBUyxDQUFDL0csS0FBS1ksTUFBbkI7QUFDQSxNQUFJUixZQUFZN0QsTUFBTW9HLFFBQU4sQ0FBZXhDLFlBQWYsQ0FBNEJILElBQTVCLENBQWhCOztBQUVBO0FBQ0EsTUFBSWYsT0FBT0osVUFBWCxFQUF1QjtBQUNyQnRDLFVBQU1xRyxvQkFBTixDQUEyQnhDLFNBQTNCLElBQXdDbkIsTUFBeEM7QUFDRDs7QUFFRDtBQUNBLE1BQUksQ0FBQzhILE1BQUQsSUFBVyxDQUFDWCxHQUFoQixFQUFxQjtBQUNuQixRQUFJWixjQUFjQyxlQUFlcUIsU0FBZixFQUEwQjlHLEtBQUthLEtBQUwsQ0FBVyxDQUFYLEVBQWMsQ0FBQyxDQUFmLENBQTFCLENBQWxCO0FBQ0EsUUFBSW1HLGFBQWFoSCxLQUFLQSxLQUFLWSxNQUFMLEdBQWMsQ0FBbkIsQ0FBakI7QUFDQXJFLFVBQU0rSCxXQUFOLENBQWtCLFlBQVk7QUFDNUI3SSxVQUFJcUksR0FBSixDQUFRMEIsV0FBUixFQUFxQndCLFVBQXJCLEVBQWlDL0gsT0FBTzVCLEtBQXhDO0FBQ0QsS0FGRDtBQUdEOztBQUVELE1BQUk0SixRQUFRaEksT0FBT2lJLE9BQVAsR0FBaUJDLGlCQUFpQjVLLEtBQWpCLEVBQXdCNkQsU0FBeEIsRUFBbUNKLElBQW5DLENBQTdCOztBQUVBZixTQUFPVSxlQUFQLENBQXVCLFVBQVV2QyxRQUFWLEVBQW9CUSxHQUFwQixFQUF5QjtBQUM5QyxRQUFJd0osaUJBQWlCaEgsWUFBWXhDLEdBQWpDO0FBQ0F5SixxQkFBaUI5SyxLQUFqQixFQUF3QjZLLGNBQXhCLEVBQXdDaEssUUFBeEMsRUFBa0Q2SixLQUFsRDtBQUNELEdBSEQ7O0FBS0FoSSxTQUFPUyxhQUFQLENBQXFCLFVBQVVnRixNQUFWLEVBQWtCOUcsR0FBbEIsRUFBdUI7QUFDMUMsUUFBSStELE9BQU8rQyxPQUFPeEUsSUFBUCxHQUFjdEMsR0FBZCxHQUFvQndDLFlBQVl4QyxHQUEzQztBQUNBLFFBQUk0RCxVQUFVa0QsT0FBT2xELE9BQVAsSUFBa0JrRCxNQUFoQztBQUNBNEMsbUJBQWUvSyxLQUFmLEVBQXNCb0YsSUFBdEIsRUFBNEJILE9BQTVCLEVBQXFDeUYsS0FBckM7QUFDRCxHQUpEOztBQU1BaEksU0FBT1EsYUFBUCxDQUFxQixVQUFVdUYsTUFBVixFQUFrQnBILEdBQWxCLEVBQXVCO0FBQzFDLFFBQUl3SixpQkFBaUJoSCxZQUFZeEMsR0FBakM7QUFDQTJKLG1CQUFlaEwsS0FBZixFQUFzQjZLLGNBQXRCLEVBQXNDcEMsTUFBdEMsRUFBOENpQyxLQUE5QztBQUNELEdBSEQ7O0FBS0FoSSxTQUFPTyxZQUFQLENBQW9CLFVBQVVnSSxLQUFWLEVBQWlCNUosR0FBakIsRUFBc0I7QUFDeEN5RixrQkFBYzlHLEtBQWQsRUFBcUJ1SyxTQUFyQixFQUFnQzlHLEtBQUs1RCxNQUFMLENBQVl3QixHQUFaLENBQWhDLEVBQWtENEosS0FBbEQsRUFBeURwQixHQUF6RDtBQUNELEdBRkQ7QUFHRDs7QUFFRDs7OztBQUlBLFNBQVNlLGdCQUFULENBQTJCNUssS0FBM0IsRUFBa0M2RCxTQUFsQyxFQUE2Q0osSUFBN0MsRUFBbUQ7QUFDakQsTUFBSXlILGNBQWNySCxjQUFjLEVBQWhDOztBQUVBLE1BQUk2RyxRQUFRO0FBQ1ZqRSxjQUFVeUUsY0FBY2xMLE1BQU15RyxRQUFwQixHQUErQixVQUFVZ0IsS0FBVixFQUFpQkMsUUFBakIsRUFBMkJDLFFBQTNCLEVBQXFDO0FBQzVFLFVBQUl3RCxPQUFPdkQsaUJBQWlCSCxLQUFqQixFQUF3QkMsUUFBeEIsRUFBa0NDLFFBQWxDLENBQVg7QUFDQSxVQUFJZixVQUFVdUUsS0FBS3ZFLE9BQW5CO0FBQ0EsVUFBSWpILFVBQVV3TCxLQUFLeEwsT0FBbkI7QUFDQSxVQUFJeUYsT0FBTytGLEtBQUsvRixJQUFoQjs7QUFFQSxVQUFJLENBQUN6RixPQUFELElBQVksQ0FBQ0EsUUFBUWdFLElBQXpCLEVBQStCO0FBQzdCeUIsZUFBT3ZCLFlBQVl1QixJQUFuQjtBQUNBLFlBQUlwQixRQUFRQyxHQUFSLENBQVlDLFFBQVosS0FBeUIsWUFBekIsSUFBeUMsQ0FBQ2xFLE1BQU1nRyxRQUFOLENBQWVaLElBQWYsQ0FBOUMsRUFBb0U7QUFDbEVULGtCQUFRbUQsS0FBUixDQUFlLHVDQUF3Q3FELEtBQUsvRixJQUE3QyxHQUFxRCxpQkFBckQsR0FBeUVBLElBQXhGO0FBQ0E7QUFDRDtBQUNGOztBQUVELGFBQU9wRixNQUFNeUcsUUFBTixDQUFlckIsSUFBZixFQUFxQndCLE9BQXJCLENBQVA7QUFDRCxLQWhCUzs7QUFrQlZGLFlBQVF3RSxjQUFjbEwsTUFBTTBHLE1BQXBCLEdBQTZCLFVBQVVlLEtBQVYsRUFBaUJDLFFBQWpCLEVBQTJCQyxRQUEzQixFQUFxQztBQUN4RSxVQUFJd0QsT0FBT3ZELGlCQUFpQkgsS0FBakIsRUFBd0JDLFFBQXhCLEVBQWtDQyxRQUFsQyxDQUFYO0FBQ0EsVUFBSWYsVUFBVXVFLEtBQUt2RSxPQUFuQjtBQUNBLFVBQUlqSCxVQUFVd0wsS0FBS3hMLE9BQW5CO0FBQ0EsVUFBSXlGLE9BQU8rRixLQUFLL0YsSUFBaEI7O0FBRUEsVUFBSSxDQUFDekYsT0FBRCxJQUFZLENBQUNBLFFBQVFnRSxJQUF6QixFQUErQjtBQUM3QnlCLGVBQU92QixZQUFZdUIsSUFBbkI7QUFDQSxZQUFJcEIsUUFBUUMsR0FBUixDQUFZQyxRQUFaLEtBQXlCLFlBQXpCLElBQXlDLENBQUNsRSxNQUFNa0csVUFBTixDQUFpQmQsSUFBakIsQ0FBOUMsRUFBc0U7QUFDcEVULGtCQUFRbUQsS0FBUixDQUFlLHlDQUEwQ3FELEtBQUsvRixJQUEvQyxHQUF1RCxpQkFBdkQsR0FBMkVBLElBQTFGO0FBQ0E7QUFDRDtBQUNGOztBQUVEcEYsWUFBTTBHLE1BQU4sQ0FBYXRCLElBQWIsRUFBbUJ3QixPQUFuQixFQUE0QmpILE9BQTVCO0FBQ0Q7QUFqQ1MsR0FBWjs7QUFvQ0E7QUFDQTtBQUNBdUIsU0FBT21DLGdCQUFQLENBQXdCcUgsS0FBeEIsRUFBK0I7QUFDN0IxSCxhQUFTO0FBQ1BSLFdBQUswSSxjQUNELFlBQVk7QUFBRSxlQUFPbEwsTUFBTWdELE9BQWI7QUFBdUIsT0FEcEMsR0FFRCxZQUFZO0FBQUUsZUFBT29JLGlCQUFpQnBMLEtBQWpCLEVBQXdCNkQsU0FBeEIsQ0FBUDtBQUE0QztBQUh2RCxLQURvQjtBQU03Qi9DLFdBQU87QUFDTDBCLFdBQUssZUFBWTtBQUFFLGVBQU8wRyxlQUFlbEosTUFBTWMsS0FBckIsRUFBNEIyQyxJQUE1QixDQUFQO0FBQTJDO0FBRHpEO0FBTnNCLEdBQS9COztBQVdBLFNBQU9pSCxLQUFQO0FBQ0Q7O0FBRUQsU0FBU1UsZ0JBQVQsQ0FBMkJwTCxLQUEzQixFQUFrQzZELFNBQWxDLEVBQTZDO0FBQzNDLE1BQUl3SCxlQUFlLEVBQW5COztBQUVBLE1BQUlDLFdBQVd6SCxVQUFVUSxNQUF6QjtBQUNBbkQsU0FBT0MsSUFBUCxDQUFZbkIsTUFBTWdELE9BQWxCLEVBQTJCNUIsT0FBM0IsQ0FBbUMsVUFBVWdFLElBQVYsRUFBZ0I7QUFDakQ7QUFDQSxRQUFJQSxLQUFLZCxLQUFMLENBQVcsQ0FBWCxFQUFjZ0gsUUFBZCxNQUE0QnpILFNBQWhDLEVBQTJDO0FBQUU7QUFBUTs7QUFFckQ7QUFDQSxRQUFJMEgsWUFBWW5HLEtBQUtkLEtBQUwsQ0FBV2dILFFBQVgsQ0FBaEI7O0FBRUE7QUFDQTtBQUNBO0FBQ0FwSyxXQUFPK0ksY0FBUCxDQUFzQm9CLFlBQXRCLEVBQW9DRSxTQUFwQyxFQUErQztBQUM3Qy9JLFdBQUssZUFBWTtBQUFFLGVBQU94QyxNQUFNZ0QsT0FBTixDQUFjb0MsSUFBZCxDQUFQO0FBQTZCLE9BREg7QUFFN0M4RSxrQkFBWTtBQUZpQyxLQUEvQztBQUlELEdBZEQ7O0FBZ0JBLFNBQU9tQixZQUFQO0FBQ0Q7O0FBRUQsU0FBU1AsZ0JBQVQsQ0FBMkI5SyxLQUEzQixFQUFrQ29GLElBQWxDLEVBQXdDSCxPQUF4QyxFQUFpRHlGLEtBQWpELEVBQXdEO0FBQ3RELE1BQUk3QyxRQUFRN0gsTUFBTWtHLFVBQU4sQ0FBaUJkLElBQWpCLE1BQTJCcEYsTUFBTWtHLFVBQU4sQ0FBaUJkLElBQWpCLElBQXlCLEVBQXBELENBQVo7QUFDQXlDLFFBQU02QixJQUFOLENBQVcsU0FBUzhCLHNCQUFULENBQWlDNUUsT0FBakMsRUFBMEM7QUFDbkQzQixZQUFRbkYsSUFBUixDQUFhRSxLQUFiLEVBQW9CMEssTUFBTTVKLEtBQTFCLEVBQWlDOEYsT0FBakM7QUFDRCxHQUZEO0FBR0Q7O0FBRUQsU0FBU21FLGNBQVQsQ0FBeUIvSyxLQUF6QixFQUFnQ29GLElBQWhDLEVBQXNDSCxPQUF0QyxFQUErQ3lGLEtBQS9DLEVBQXNEO0FBQ3BELE1BQUk3QyxRQUFRN0gsTUFBTWdHLFFBQU4sQ0FBZVosSUFBZixNQUF5QnBGLE1BQU1nRyxRQUFOLENBQWVaLElBQWYsSUFBdUIsRUFBaEQsQ0FBWjtBQUNBeUMsUUFBTTZCLElBQU4sQ0FBVyxTQUFTK0Isb0JBQVQsQ0FBK0I3RSxPQUEvQixFQUF3QzhCLEVBQXhDLEVBQTRDO0FBQ3JELFFBQUlnRCxNQUFNekcsUUFBUW5GLElBQVIsQ0FBYUUsS0FBYixFQUFvQjtBQUM1QnlHLGdCQUFVaUUsTUFBTWpFLFFBRFk7QUFFNUJDLGNBQVFnRSxNQUFNaEUsTUFGYztBQUc1QjFELGVBQVMwSCxNQUFNMUgsT0FIYTtBQUk1QmxDLGFBQU80SixNQUFNNUosS0FKZTtBQUs1QjZLLG1CQUFhM0wsTUFBTWdELE9BTFM7QUFNNUJ1SCxpQkFBV3ZLLE1BQU1jO0FBTlcsS0FBcEIsRUFPUDhGLE9BUE8sRUFPRThCLEVBUEYsQ0FBVjtBQVFBLFFBQUksQ0FBQ25ILFVBQVVtSyxHQUFWLENBQUwsRUFBcUI7QUFDbkJBLFlBQU05RixRQUFRZ0csT0FBUixDQUFnQkYsR0FBaEIsQ0FBTjtBQUNEO0FBQ0QsUUFBSTFMLE1BQU1PLFlBQVYsRUFBd0I7QUFDdEIsYUFBT21MLElBQUlHLEtBQUosQ0FBVSxVQUFVQyxHQUFWLEVBQWU7QUFDOUI5TCxjQUFNTyxZQUFOLENBQW1CQyxJQUFuQixDQUF3QixZQUF4QixFQUFzQ3NMLEdBQXRDO0FBQ0EsY0FBTUEsR0FBTjtBQUNELE9BSE0sQ0FBUDtBQUlELEtBTEQsTUFLTztBQUNMLGFBQU9KLEdBQVA7QUFDRDtBQUNGLEdBcEJEO0FBcUJEOztBQUVELFNBQVNWLGNBQVQsQ0FBeUJoTCxLQUF6QixFQUFnQ29GLElBQWhDLEVBQXNDMkcsU0FBdEMsRUFBaURyQixLQUFqRCxFQUF3RDtBQUN0RCxNQUFJMUssTUFBTW1HLGVBQU4sQ0FBc0JmLElBQXRCLENBQUosRUFBaUM7QUFDL0IsUUFBSXBCLFFBQVFDLEdBQVIsQ0FBWUMsUUFBWixLQUF5QixZQUE3QixFQUEyQztBQUN6Q1MsY0FBUW1ELEtBQVIsQ0FBZSxrQ0FBa0MxQyxJQUFqRDtBQUNEO0FBQ0Q7QUFDRDtBQUNEcEYsUUFBTW1HLGVBQU4sQ0FBc0JmLElBQXRCLElBQThCLFNBQVM0RyxhQUFULENBQXdCaE0sS0FBeEIsRUFBK0I7QUFDM0QsV0FBTytMLFVBQ0xyQixNQUFNNUosS0FERCxFQUNRO0FBQ2I0SixVQUFNMUgsT0FGRCxFQUVVO0FBQ2ZoRCxVQUFNYyxLQUhELEVBR1E7QUFDYmQsVUFBTWdELE9BSkQsQ0FJUztBQUpULEtBQVA7QUFNRCxHQVBEO0FBUUQ7O0FBRUQsU0FBU29ILGdCQUFULENBQTJCcEssS0FBM0IsRUFBa0M7QUFDaENBLFFBQU1vSCxHQUFOLENBQVV1QixNQUFWLENBQWlCLFlBQVk7QUFBRSxXQUFPLEtBQUt0QixLQUFMLENBQVdDLE9BQWxCO0FBQTJCLEdBQTFELEVBQTRELFlBQVk7QUFDdEUsUUFBSXRELFFBQVFDLEdBQVIsQ0FBWUMsUUFBWixLQUF5QixZQUE3QixFQUEyQztBQUN6Q3hDLGFBQU8xQixNQUFNK0YsV0FBYixFQUEwQiwyREFBMUI7QUFDRDtBQUNGLEdBSkQsRUFJRyxFQUFFa0csTUFBTSxJQUFSLEVBQWNDLE1BQU0sSUFBcEIsRUFKSDtBQUtEOztBQUVELFNBQVNoRCxjQUFULENBQXlCcEksS0FBekIsRUFBZ0MyQyxJQUFoQyxFQUFzQztBQUNwQyxTQUFPQSxLQUFLWSxNQUFMLEdBQ0haLEtBQUtDLE1BQUwsQ0FBWSxVQUFVNUMsS0FBVixFQUFpQk8sR0FBakIsRUFBc0I7QUFBRSxXQUFPUCxNQUFNTyxHQUFOLENBQVA7QUFBb0IsR0FBeEQsRUFBMERQLEtBQTFELENBREcsR0FFSEEsS0FGSjtBQUdEOztBQUVELFNBQVM4RyxnQkFBVCxDQUEyQnhDLElBQTNCLEVBQWlDd0IsT0FBakMsRUFBMENqSCxPQUExQyxFQUFtRDtBQUNqRCxNQUFJMkIsU0FBUzhELElBQVQsS0FBa0JBLEtBQUtBLElBQTNCLEVBQWlDO0FBQy9CekYsY0FBVWlILE9BQVY7QUFDQUEsY0FBVXhCLElBQVY7QUFDQUEsV0FBT0EsS0FBS0EsSUFBWjtBQUNEOztBQUVELE1BQUlwQixRQUFRQyxHQUFSLENBQVlDLFFBQVosS0FBeUIsWUFBN0IsRUFBMkM7QUFDekN4QyxXQUFPLE9BQU8wRCxJQUFQLEtBQWdCLFFBQXZCLEVBQWtDLG1EQUFtREEsSUFBbkQseUNBQW1EQSxJQUFuRCxLQUEyRCxHQUE3RjtBQUNEOztBQUVELFNBQU8sRUFBRUEsTUFBTUEsSUFBUixFQUFjd0IsU0FBU0EsT0FBdkIsRUFBZ0NqSCxTQUFTQSxPQUF6QyxFQUFQO0FBQ0Q7O0FBRUQsU0FBU2dHLE9BQVQsQ0FBa0J3RyxJQUFsQixFQUF3QjtBQUN0QixNQUFJak4sT0FBT2lOLFNBQVNqTixHQUFwQixFQUF5QjtBQUN2QixRQUFJOEUsUUFBUUMsR0FBUixDQUFZQyxRQUFaLEtBQXlCLFlBQTdCLEVBQTJDO0FBQ3pDUyxjQUFRbUQsS0FBUixDQUNFLHFFQURGO0FBR0Q7QUFDRDtBQUNEO0FBQ0Q1SSxRQUFNaU4sSUFBTjtBQUNBbE4sYUFBV0MsR0FBWDtBQUNEOztBQUVELElBQUlrTixXQUFXQyxtQkFBbUIsVUFBVXhJLFNBQVYsRUFBcUJ5SSxNQUFyQixFQUE2QjtBQUM3RCxNQUFJWixNQUFNLEVBQVY7QUFDQWEsZUFBYUQsTUFBYixFQUFxQmxMLE9BQXJCLENBQTZCLFVBQVVvRixHQUFWLEVBQWU7QUFDMUMsUUFBSW5GLE1BQU1tRixJQUFJbkYsR0FBZDtBQUNBLFFBQUlHLE1BQU1nRixJQUFJaEYsR0FBZDs7QUFFQWtLLFFBQUlySyxHQUFKLElBQVcsU0FBU21MLFdBQVQsR0FBd0I7QUFDakMsVUFBSTFMLFFBQVEsS0FBS2IsTUFBTCxDQUFZYSxLQUF4QjtBQUNBLFVBQUlrQyxVQUFVLEtBQUsvQyxNQUFMLENBQVkrQyxPQUExQjtBQUNBLFVBQUlhLFNBQUosRUFBZTtBQUNiLFlBQUluQixTQUFTK0oscUJBQXFCLEtBQUt4TSxNQUExQixFQUFrQyxVQUFsQyxFQUE4QzRELFNBQTlDLENBQWI7QUFDQSxZQUFJLENBQUNuQixNQUFMLEVBQWE7QUFDWDtBQUNEO0FBQ0Q1QixnQkFBUTRCLE9BQU9pSSxPQUFQLENBQWU3SixLQUF2QjtBQUNBa0Msa0JBQVVOLE9BQU9pSSxPQUFQLENBQWUzSCxPQUF6QjtBQUNEO0FBQ0QsYUFBTyxPQUFPeEIsR0FBUCxLQUFlLFVBQWYsR0FDSEEsSUFBSTFCLElBQUosQ0FBUyxJQUFULEVBQWVnQixLQUFmLEVBQXNCa0MsT0FBdEIsQ0FERyxHQUVIbEMsTUFBTVUsR0FBTixDQUZKO0FBR0QsS0FkRDtBQWVBO0FBQ0FrSyxRQUFJckssR0FBSixFQUFTcUwsSUFBVCxHQUFnQixJQUFoQjtBQUNELEdBckJEO0FBc0JBLFNBQU9oQixHQUFQO0FBQ0QsQ0F6QmMsQ0FBZjs7QUEyQkEsSUFBSWlCLGVBQWVOLG1CQUFtQixVQUFVeEksU0FBVixFQUFxQmQsU0FBckIsRUFBZ0M7QUFDcEUsTUFBSTJJLE1BQU0sRUFBVjtBQUNBYSxlQUFheEosU0FBYixFQUF3QjNCLE9BQXhCLENBQWdDLFVBQVVvRixHQUFWLEVBQWU7QUFDN0MsUUFBSW5GLE1BQU1tRixJQUFJbkYsR0FBZDtBQUNBLFFBQUlHLE1BQU1nRixJQUFJaEYsR0FBZDs7QUFFQWtLLFFBQUlySyxHQUFKLElBQVcsU0FBU3VMLGNBQVQsR0FBMkI7QUFDcEMsVUFBSXpCLE9BQU8sRUFBWDtBQUFBLFVBQWUwQixNQUFNQyxVQUFVekksTUFBL0I7QUFDQSxhQUFRd0ksS0FBUjtBQUFnQjFCLGFBQU0wQixHQUFOLElBQWNDLFVBQVdELEdBQVgsQ0FBZDtBQUFoQixPQUVBLElBQUluRyxTQUFTLEtBQUt6RyxNQUFMLENBQVl5RyxNQUF6QjtBQUNBLFVBQUk3QyxTQUFKLEVBQWU7QUFDYixZQUFJbkIsU0FBUytKLHFCQUFxQixLQUFLeE0sTUFBMUIsRUFBa0MsY0FBbEMsRUFBa0Q0RCxTQUFsRCxDQUFiO0FBQ0EsWUFBSSxDQUFDbkIsTUFBTCxFQUFhO0FBQ1g7QUFDRDtBQUNEZ0UsaUJBQVNoRSxPQUFPaUksT0FBUCxDQUFlakUsTUFBeEI7QUFDRDtBQUNELGFBQU8sT0FBT2xGLEdBQVAsS0FBZSxVQUFmLEdBQ0hBLElBQUl1TCxLQUFKLENBQVUsSUFBVixFQUFnQixDQUFDckcsTUFBRCxFQUFTN0csTUFBVCxDQUFnQnNMLElBQWhCLENBQWhCLENBREcsR0FFSHpFLE9BQU9xRyxLQUFQLENBQWEsS0FBSzlNLE1BQWxCLEVBQTBCLENBQUN1QixHQUFELEVBQU0zQixNQUFOLENBQWFzTCxJQUFiLENBQTFCLENBRko7QUFHRCxLQWZEO0FBZ0JELEdBcEJEO0FBcUJBLFNBQU9PLEdBQVA7QUFDRCxDQXhCa0IsQ0FBbkI7O0FBMEJBLElBQUlzQixhQUFhWCxtQkFBbUIsVUFBVXhJLFNBQVYsRUFBcUJiLE9BQXJCLEVBQThCO0FBQ2hFLE1BQUkwSSxNQUFNLEVBQVY7QUFDQWEsZUFBYXZKLE9BQWIsRUFBc0I1QixPQUF0QixDQUE4QixVQUFVb0YsR0FBVixFQUFlO0FBQzNDLFFBQUluRixNQUFNbUYsSUFBSW5GLEdBQWQ7QUFDQSxRQUFJRyxNQUFNZ0YsSUFBSWhGLEdBQWQ7O0FBRUFBLFVBQU1xQyxZQUFZckMsR0FBbEI7QUFDQWtLLFFBQUlySyxHQUFKLElBQVcsU0FBUzRMLFlBQVQsR0FBeUI7QUFDbEMsVUFBSXBKLGFBQWEsQ0FBQzRJLHFCQUFxQixLQUFLeE0sTUFBMUIsRUFBa0MsWUFBbEMsRUFBZ0Q0RCxTQUFoRCxDQUFsQixFQUE4RTtBQUM1RTtBQUNEO0FBQ0QsVUFBSUcsUUFBUUMsR0FBUixDQUFZQyxRQUFaLEtBQXlCLFlBQXpCLElBQXlDLEVBQUUxQyxPQUFPLEtBQUt2QixNQUFMLENBQVkrQyxPQUFyQixDQUE3QyxFQUE0RTtBQUMxRTJCLGdCQUFRbUQsS0FBUixDQUFlLDRCQUE0QnRHLEdBQTNDO0FBQ0E7QUFDRDtBQUNELGFBQU8sS0FBS3ZCLE1BQUwsQ0FBWStDLE9BQVosQ0FBb0J4QixHQUFwQixDQUFQO0FBQ0QsS0FURDtBQVVBO0FBQ0FrSyxRQUFJckssR0FBSixFQUFTcUwsSUFBVCxHQUFnQixJQUFoQjtBQUNELEdBakJEO0FBa0JBLFNBQU9oQixHQUFQO0FBQ0QsQ0FyQmdCLENBQWpCOztBQXVCQSxJQUFJd0IsYUFBYWIsbUJBQW1CLFVBQVV4SSxTQUFWLEVBQXFCZixPQUFyQixFQUE4QjtBQUNoRSxNQUFJNEksTUFBTSxFQUFWO0FBQ0FhLGVBQWF6SixPQUFiLEVBQXNCMUIsT0FBdEIsQ0FBOEIsVUFBVW9GLEdBQVYsRUFBZTtBQUMzQyxRQUFJbkYsTUFBTW1GLElBQUluRixHQUFkO0FBQ0EsUUFBSUcsTUFBTWdGLElBQUloRixHQUFkOztBQUVBa0ssUUFBSXJLLEdBQUosSUFBVyxTQUFTOEwsWUFBVCxHQUF5QjtBQUNsQyxVQUFJaEMsT0FBTyxFQUFYO0FBQUEsVUFBZTBCLE1BQU1DLFVBQVV6SSxNQUEvQjtBQUNBLGFBQVF3SSxLQUFSO0FBQWdCMUIsYUFBTTBCLEdBQU4sSUFBY0MsVUFBV0QsR0FBWCxDQUFkO0FBQWhCLE9BRUEsSUFBSXBHLFdBQVcsS0FBS3hHLE1BQUwsQ0FBWXdHLFFBQTNCO0FBQ0EsVUFBSTVDLFNBQUosRUFBZTtBQUNiLFlBQUluQixTQUFTK0oscUJBQXFCLEtBQUt4TSxNQUExQixFQUFrQyxZQUFsQyxFQUFnRDRELFNBQWhELENBQWI7QUFDQSxZQUFJLENBQUNuQixNQUFMLEVBQWE7QUFDWDtBQUNEO0FBQ0QrRCxtQkFBVy9ELE9BQU9pSSxPQUFQLENBQWVsRSxRQUExQjtBQUNEO0FBQ0QsYUFBTyxPQUFPakYsR0FBUCxLQUFlLFVBQWYsR0FDSEEsSUFBSXVMLEtBQUosQ0FBVSxJQUFWLEVBQWdCLENBQUN0RyxRQUFELEVBQVc1RyxNQUFYLENBQWtCc0wsSUFBbEIsQ0FBaEIsQ0FERyxHQUVIMUUsU0FBU3NHLEtBQVQsQ0FBZSxLQUFLOU0sTUFBcEIsRUFBNEIsQ0FBQ3VCLEdBQUQsRUFBTTNCLE1BQU4sQ0FBYXNMLElBQWIsQ0FBNUIsQ0FGSjtBQUdELEtBZkQ7QUFnQkQsR0FwQkQ7QUFxQkEsU0FBT08sR0FBUDtBQUNELENBeEJnQixDQUFqQjs7QUEwQkEsSUFBSTBCLDBCQUEwQixTQUExQkEsdUJBQTBCLENBQVV2SixTQUFWLEVBQXFCO0FBQUUsU0FBUTtBQUMzRHVJLGNBQVVBLFNBQVNpQixJQUFULENBQWMsSUFBZCxFQUFvQnhKLFNBQXBCLENBRGlEO0FBRTNEbUosZ0JBQVlBLFdBQVdLLElBQVgsQ0FBZ0IsSUFBaEIsRUFBc0J4SixTQUF0QixDQUYrQztBQUczRDhJLGtCQUFjQSxhQUFhVSxJQUFiLENBQWtCLElBQWxCLEVBQXdCeEosU0FBeEIsQ0FINkM7QUFJM0RxSixnQkFBWUEsV0FBV0csSUFBWCxDQUFnQixJQUFoQixFQUFzQnhKLFNBQXRCO0FBSitDLEdBQVI7QUFLaEQsQ0FMTDs7QUFPQSxTQUFTMEksWUFBVCxDQUF1QmxFLEdBQXZCLEVBQTRCO0FBQzFCLFNBQU9RLE1BQU1DLE9BQU4sQ0FBY1QsR0FBZCxJQUNIQSxJQUFJQSxHQUFKLENBQVEsVUFBVWhILEdBQVYsRUFBZTtBQUFFLFdBQVEsRUFBRUEsS0FBS0EsR0FBUCxFQUFZRyxLQUFLSCxHQUFqQixFQUFSO0FBQWtDLEdBQTNELENBREcsR0FFSEgsT0FBT0MsSUFBUCxDQUFZa0gsR0FBWixFQUFpQkEsR0FBakIsQ0FBcUIsVUFBVWhILEdBQVYsRUFBZTtBQUFFLFdBQVEsRUFBRUEsS0FBS0EsR0FBUCxFQUFZRyxLQUFLNkcsSUFBSWhILEdBQUosQ0FBakIsRUFBUjtBQUF1QyxHQUE3RSxDQUZKO0FBR0Q7O0FBRUQsU0FBU2dMLGtCQUFULENBQTZCcEwsRUFBN0IsRUFBaUM7QUFDL0IsU0FBTyxVQUFVNEMsU0FBVixFQUFxQndFLEdBQXJCLEVBQTBCO0FBQy9CLFFBQUksT0FBT3hFLFNBQVAsS0FBcUIsUUFBekIsRUFBbUM7QUFDakN3RSxZQUFNeEUsU0FBTjtBQUNBQSxrQkFBWSxFQUFaO0FBQ0QsS0FIRCxNQUdPLElBQUlBLFVBQVV5SixNQUFWLENBQWlCekosVUFBVVEsTUFBVixHQUFtQixDQUFwQyxNQUEyQyxHQUEvQyxFQUFvRDtBQUN6RFIsbUJBQWEsR0FBYjtBQUNEO0FBQ0QsV0FBTzVDLEdBQUc0QyxTQUFILEVBQWN3RSxHQUFkLENBQVA7QUFDRCxHQVJEO0FBU0Q7O0FBRUQsU0FBU29FLG9CQUFULENBQStCek0sS0FBL0IsRUFBc0N1TixNQUF0QyxFQUE4QzFKLFNBQTlDLEVBQXlEO0FBQ3ZELE1BQUluQixTQUFTMUMsTUFBTXFHLG9CQUFOLENBQTJCeEMsU0FBM0IsQ0FBYjtBQUNBLE1BQUlHLFFBQVFDLEdBQVIsQ0FBWUMsUUFBWixLQUF5QixZQUF6QixJQUF5QyxDQUFDeEIsTUFBOUMsRUFBc0Q7QUFDcERpQyxZQUFRbUQsS0FBUixDQUFlLDBDQUEwQ3lGLE1BQTFDLEdBQW1ELE1BQW5ELEdBQTREMUosU0FBM0U7QUFDRDtBQUNELFNBQU9uQixNQUFQO0FBQ0Q7O0FBRUQsSUFBSThLLFlBQVk7QUFDZDlILFNBQU9BLEtBRE87QUFFZEMsV0FBU0EsT0FGSztBQUdkeEcsV0FBUyxPQUhLO0FBSWRpTixZQUFVQSxRQUpJO0FBS2RPLGdCQUFjQSxZQUxBO0FBTWRLLGNBQVlBLFVBTkU7QUFPZEUsY0FBWUEsVUFQRTtBQVFkRSwyQkFBeUJBO0FBUlgsQ0FBaEI7O0FBV0E7QUFDQSwrREFBZUksU0FBZixFIiwiZmlsZSI6IjY4LmpzIiwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiB2dWV4IHYyLjUuMFxuICogKGMpIDIwMTcgRXZhbiBZb3VcbiAqIEBsaWNlbnNlIE1JVFxuICovXG52YXIgYXBwbHlNaXhpbiA9IGZ1bmN0aW9uIChWdWUpIHtcbiAgdmFyIHZlcnNpb24gPSBOdW1iZXIoVnVlLnZlcnNpb24uc3BsaXQoJy4nKVswXSk7XG5cbiAgaWYgKHZlcnNpb24gPj0gMikge1xuICAgIFZ1ZS5taXhpbih7IGJlZm9yZUNyZWF0ZTogdnVleEluaXQgfSk7XG4gIH0gZWxzZSB7XG4gICAgLy8gb3ZlcnJpZGUgaW5pdCBhbmQgaW5qZWN0IHZ1ZXggaW5pdCBwcm9jZWR1cmVcbiAgICAvLyBmb3IgMS54IGJhY2t3YXJkcyBjb21wYXRpYmlsaXR5LlxuICAgIHZhciBfaW5pdCA9IFZ1ZS5wcm90b3R5cGUuX2luaXQ7XG4gICAgVnVlLnByb3RvdHlwZS5faW5pdCA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gICAgICBpZiAoIG9wdGlvbnMgPT09IHZvaWQgMCApIG9wdGlvbnMgPSB7fTtcblxuICAgICAgb3B0aW9ucy5pbml0ID0gb3B0aW9ucy5pbml0XG4gICAgICAgID8gW3Z1ZXhJbml0XS5jb25jYXQob3B0aW9ucy5pbml0KVxuICAgICAgICA6IHZ1ZXhJbml0O1xuICAgICAgX2luaXQuY2FsbCh0aGlzLCBvcHRpb25zKTtcbiAgICB9O1xuICB9XG5cbiAgLyoqXG4gICAqIFZ1ZXggaW5pdCBob29rLCBpbmplY3RlZCBpbnRvIGVhY2ggaW5zdGFuY2VzIGluaXQgaG9va3MgbGlzdC5cbiAgICovXG5cbiAgZnVuY3Rpb24gdnVleEluaXQgKCkge1xuICAgIHZhciBvcHRpb25zID0gdGhpcy4kb3B0aW9ucztcbiAgICAvLyBzdG9yZSBpbmplY3Rpb25cbiAgICBpZiAob3B0aW9ucy5zdG9yZSkge1xuICAgICAgdGhpcy4kc3RvcmUgPSB0eXBlb2Ygb3B0aW9ucy5zdG9yZSA9PT0gJ2Z1bmN0aW9uJ1xuICAgICAgICA/IG9wdGlvbnMuc3RvcmUoKVxuICAgICAgICA6IG9wdGlvbnMuc3RvcmU7XG4gICAgfSBlbHNlIGlmIChvcHRpb25zLnBhcmVudCAmJiBvcHRpb25zLnBhcmVudC4kc3RvcmUpIHtcbiAgICAgIHRoaXMuJHN0b3JlID0gb3B0aW9ucy5wYXJlbnQuJHN0b3JlO1xuICAgIH1cbiAgfVxufTtcblxudmFyIGRldnRvb2xIb29rID1cbiAgdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiZcbiAgd2luZG93Ll9fVlVFX0RFVlRPT0xTX0dMT0JBTF9IT09LX187XG5cbmZ1bmN0aW9uIGRldnRvb2xQbHVnaW4gKHN0b3JlKSB7XG4gIGlmICghZGV2dG9vbEhvb2spIHsgcmV0dXJuIH1cblxuICBzdG9yZS5fZGV2dG9vbEhvb2sgPSBkZXZ0b29sSG9vaztcblxuICBkZXZ0b29sSG9vay5lbWl0KCd2dWV4OmluaXQnLCBzdG9yZSk7XG5cbiAgZGV2dG9vbEhvb2sub24oJ3Z1ZXg6dHJhdmVsLXRvLXN0YXRlJywgZnVuY3Rpb24gKHRhcmdldFN0YXRlKSB7XG4gICAgc3RvcmUucmVwbGFjZVN0YXRlKHRhcmdldFN0YXRlKTtcbiAgfSk7XG5cbiAgc3RvcmUuc3Vic2NyaWJlKGZ1bmN0aW9uIChtdXRhdGlvbiwgc3RhdGUpIHtcbiAgICBkZXZ0b29sSG9vay5lbWl0KCd2dWV4Om11dGF0aW9uJywgbXV0YXRpb24sIHN0YXRlKTtcbiAgfSk7XG59XG5cbi8qKlxuICogR2V0IHRoZSBmaXJzdCBpdGVtIHRoYXQgcGFzcyB0aGUgdGVzdFxuICogYnkgc2Vjb25kIGFyZ3VtZW50IGZ1bmN0aW9uXG4gKlxuICogQHBhcmFtIHtBcnJheX0gbGlzdFxuICogQHBhcmFtIHtGdW5jdGlvbn0gZlxuICogQHJldHVybiB7Kn1cbiAqL1xuLyoqXG4gKiBEZWVwIGNvcHkgdGhlIGdpdmVuIG9iamVjdCBjb25zaWRlcmluZyBjaXJjdWxhciBzdHJ1Y3R1cmUuXG4gKiBUaGlzIGZ1bmN0aW9uIGNhY2hlcyBhbGwgbmVzdGVkIG9iamVjdHMgYW5kIGl0cyBjb3BpZXMuXG4gKiBJZiBpdCBkZXRlY3RzIGNpcmN1bGFyIHN0cnVjdHVyZSwgdXNlIGNhY2hlZCBjb3B5IHRvIGF2b2lkIGluZmluaXRlIGxvb3AuXG4gKlxuICogQHBhcmFtIHsqfSBvYmpcbiAqIEBwYXJhbSB7QXJyYXk8T2JqZWN0Pn0gY2FjaGVcbiAqIEByZXR1cm4geyp9XG4gKi9cblxuXG4vKipcbiAqIGZvckVhY2ggZm9yIG9iamVjdFxuICovXG5mdW5jdGlvbiBmb3JFYWNoVmFsdWUgKG9iaiwgZm4pIHtcbiAgT2JqZWN0LmtleXMob2JqKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHsgcmV0dXJuIGZuKG9ialtrZXldLCBrZXkpOyB9KTtcbn1cblxuZnVuY3Rpb24gaXNPYmplY3QgKG9iaikge1xuICByZXR1cm4gb2JqICE9PSBudWxsICYmIHR5cGVvZiBvYmogPT09ICdvYmplY3QnXG59XG5cbmZ1bmN0aW9uIGlzUHJvbWlzZSAodmFsKSB7XG4gIHJldHVybiB2YWwgJiYgdHlwZW9mIHZhbC50aGVuID09PSAnZnVuY3Rpb24nXG59XG5cbmZ1bmN0aW9uIGFzc2VydCAoY29uZGl0aW9uLCBtc2cpIHtcbiAgaWYgKCFjb25kaXRpb24pIHsgdGhyb3cgbmV3IEVycm9yKChcIlt2dWV4XSBcIiArIG1zZykpIH1cbn1cblxudmFyIE1vZHVsZSA9IGZ1bmN0aW9uIE1vZHVsZSAocmF3TW9kdWxlLCBydW50aW1lKSB7XG4gIHRoaXMucnVudGltZSA9IHJ1bnRpbWU7XG4gIHRoaXMuX2NoaWxkcmVuID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgdGhpcy5fcmF3TW9kdWxlID0gcmF3TW9kdWxlO1xuICB2YXIgcmF3U3RhdGUgPSByYXdNb2R1bGUuc3RhdGU7XG4gIHRoaXMuc3RhdGUgPSAodHlwZW9mIHJhd1N0YXRlID09PSAnZnVuY3Rpb24nID8gcmF3U3RhdGUoKSA6IHJhd1N0YXRlKSB8fCB7fTtcbn07XG5cbnZhciBwcm90b3R5cGVBY2Nlc3NvcnMkMSA9IHsgbmFtZXNwYWNlZDogeyBjb25maWd1cmFibGU6IHRydWUgfSB9O1xuXG5wcm90b3R5cGVBY2Nlc3NvcnMkMS5uYW1lc3BhY2VkLmdldCA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuICEhdGhpcy5fcmF3TW9kdWxlLm5hbWVzcGFjZWRcbn07XG5cbk1vZHVsZS5wcm90b3R5cGUuYWRkQ2hpbGQgPSBmdW5jdGlvbiBhZGRDaGlsZCAoa2V5LCBtb2R1bGUpIHtcbiAgdGhpcy5fY2hpbGRyZW5ba2V5XSA9IG1vZHVsZTtcbn07XG5cbk1vZHVsZS5wcm90b3R5cGUucmVtb3ZlQ2hpbGQgPSBmdW5jdGlvbiByZW1vdmVDaGlsZCAoa2V5KSB7XG4gIGRlbGV0ZSB0aGlzLl9jaGlsZHJlbltrZXldO1xufTtcblxuTW9kdWxlLnByb3RvdHlwZS5nZXRDaGlsZCA9IGZ1bmN0aW9uIGdldENoaWxkIChrZXkpIHtcbiAgcmV0dXJuIHRoaXMuX2NoaWxkcmVuW2tleV1cbn07XG5cbk1vZHVsZS5wcm90b3R5cGUudXBkYXRlID0gZnVuY3Rpb24gdXBkYXRlIChyYXdNb2R1bGUpIHtcbiAgdGhpcy5fcmF3TW9kdWxlLm5hbWVzcGFjZWQgPSByYXdNb2R1bGUubmFtZXNwYWNlZDtcbiAgaWYgKHJhd01vZHVsZS5hY3Rpb25zKSB7XG4gICAgdGhpcy5fcmF3TW9kdWxlLmFjdGlvbnMgPSByYXdNb2R1bGUuYWN0aW9ucztcbiAgfVxuICBpZiAocmF3TW9kdWxlLm11dGF0aW9ucykge1xuICAgIHRoaXMuX3Jhd01vZHVsZS5tdXRhdGlvbnMgPSByYXdNb2R1bGUubXV0YXRpb25zO1xuICB9XG4gIGlmIChyYXdNb2R1bGUuZ2V0dGVycykge1xuICAgIHRoaXMuX3Jhd01vZHVsZS5nZXR0ZXJzID0gcmF3TW9kdWxlLmdldHRlcnM7XG4gIH1cbn07XG5cbk1vZHVsZS5wcm90b3R5cGUuZm9yRWFjaENoaWxkID0gZnVuY3Rpb24gZm9yRWFjaENoaWxkIChmbikge1xuICBmb3JFYWNoVmFsdWUodGhpcy5fY2hpbGRyZW4sIGZuKTtcbn07XG5cbk1vZHVsZS5wcm90b3R5cGUuZm9yRWFjaEdldHRlciA9IGZ1bmN0aW9uIGZvckVhY2hHZXR0ZXIgKGZuKSB7XG4gIGlmICh0aGlzLl9yYXdNb2R1bGUuZ2V0dGVycykge1xuICAgIGZvckVhY2hWYWx1ZSh0aGlzLl9yYXdNb2R1bGUuZ2V0dGVycywgZm4pO1xuICB9XG59O1xuXG5Nb2R1bGUucHJvdG90eXBlLmZvckVhY2hBY3Rpb24gPSBmdW5jdGlvbiBmb3JFYWNoQWN0aW9uIChmbikge1xuICBpZiAodGhpcy5fcmF3TW9kdWxlLmFjdGlvbnMpIHtcbiAgICBmb3JFYWNoVmFsdWUodGhpcy5fcmF3TW9kdWxlLmFjdGlvbnMsIGZuKTtcbiAgfVxufTtcblxuTW9kdWxlLnByb3RvdHlwZS5mb3JFYWNoTXV0YXRpb24gPSBmdW5jdGlvbiBmb3JFYWNoTXV0YXRpb24gKGZuKSB7XG4gIGlmICh0aGlzLl9yYXdNb2R1bGUubXV0YXRpb25zKSB7XG4gICAgZm9yRWFjaFZhbHVlKHRoaXMuX3Jhd01vZHVsZS5tdXRhdGlvbnMsIGZuKTtcbiAgfVxufTtcblxuT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoIE1vZHVsZS5wcm90b3R5cGUsIHByb3RvdHlwZUFjY2Vzc29ycyQxICk7XG5cbnZhciBNb2R1bGVDb2xsZWN0aW9uID0gZnVuY3Rpb24gTW9kdWxlQ29sbGVjdGlvbiAocmF3Um9vdE1vZHVsZSkge1xuICAvLyByZWdpc3RlciByb290IG1vZHVsZSAoVnVleC5TdG9yZSBvcHRpb25zKVxuICB0aGlzLnJlZ2lzdGVyKFtdLCByYXdSb290TW9kdWxlLCBmYWxzZSk7XG59O1xuXG5Nb2R1bGVDb2xsZWN0aW9uLnByb3RvdHlwZS5nZXQgPSBmdW5jdGlvbiBnZXQgKHBhdGgpIHtcbiAgcmV0dXJuIHBhdGgucmVkdWNlKGZ1bmN0aW9uIChtb2R1bGUsIGtleSkge1xuICAgIHJldHVybiBtb2R1bGUuZ2V0Q2hpbGQoa2V5KVxuICB9LCB0aGlzLnJvb3QpXG59O1xuXG5Nb2R1bGVDb2xsZWN0aW9uLnByb3RvdHlwZS5nZXROYW1lc3BhY2UgPSBmdW5jdGlvbiBnZXROYW1lc3BhY2UgKHBhdGgpIHtcbiAgdmFyIG1vZHVsZSA9IHRoaXMucm9vdDtcbiAgcmV0dXJuIHBhdGgucmVkdWNlKGZ1bmN0aW9uIChuYW1lc3BhY2UsIGtleSkge1xuICAgIG1vZHVsZSA9IG1vZHVsZS5nZXRDaGlsZChrZXkpO1xuICAgIHJldHVybiBuYW1lc3BhY2UgKyAobW9kdWxlLm5hbWVzcGFjZWQgPyBrZXkgKyAnLycgOiAnJylcbiAgfSwgJycpXG59O1xuXG5Nb2R1bGVDb2xsZWN0aW9uLnByb3RvdHlwZS51cGRhdGUgPSBmdW5jdGlvbiB1cGRhdGUkMSAocmF3Um9vdE1vZHVsZSkge1xuICB1cGRhdGUoW10sIHRoaXMucm9vdCwgcmF3Um9vdE1vZHVsZSk7XG59O1xuXG5Nb2R1bGVDb2xsZWN0aW9uLnByb3RvdHlwZS5yZWdpc3RlciA9IGZ1bmN0aW9uIHJlZ2lzdGVyIChwYXRoLCByYXdNb2R1bGUsIHJ1bnRpbWUpIHtcbiAgICB2YXIgdGhpcyQxID0gdGhpcztcbiAgICBpZiAoIHJ1bnRpbWUgPT09IHZvaWQgMCApIHJ1bnRpbWUgPSB0cnVlO1xuXG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgYXNzZXJ0UmF3TW9kdWxlKHBhdGgsIHJhd01vZHVsZSk7XG4gIH1cblxuICB2YXIgbmV3TW9kdWxlID0gbmV3IE1vZHVsZShyYXdNb2R1bGUsIHJ1bnRpbWUpO1xuICBpZiAocGF0aC5sZW5ndGggPT09IDApIHtcbiAgICB0aGlzLnJvb3QgPSBuZXdNb2R1bGU7XG4gIH0gZWxzZSB7XG4gICAgdmFyIHBhcmVudCA9IHRoaXMuZ2V0KHBhdGguc2xpY2UoMCwgLTEpKTtcbiAgICBwYXJlbnQuYWRkQ2hpbGQocGF0aFtwYXRoLmxlbmd0aCAtIDFdLCBuZXdNb2R1bGUpO1xuICB9XG5cbiAgLy8gcmVnaXN0ZXIgbmVzdGVkIG1vZHVsZXNcbiAgaWYgKHJhd01vZHVsZS5tb2R1bGVzKSB7XG4gICAgZm9yRWFjaFZhbHVlKHJhd01vZHVsZS5tb2R1bGVzLCBmdW5jdGlvbiAocmF3Q2hpbGRNb2R1bGUsIGtleSkge1xuICAgICAgdGhpcyQxLnJlZ2lzdGVyKHBhdGguY29uY2F0KGtleSksIHJhd0NoaWxkTW9kdWxlLCBydW50aW1lKTtcbiAgICB9KTtcbiAgfVxufTtcblxuTW9kdWxlQ29sbGVjdGlvbi5wcm90b3R5cGUudW5yZWdpc3RlciA9IGZ1bmN0aW9uIHVucmVnaXN0ZXIgKHBhdGgpIHtcbiAgdmFyIHBhcmVudCA9IHRoaXMuZ2V0KHBhdGguc2xpY2UoMCwgLTEpKTtcbiAgdmFyIGtleSA9IHBhdGhbcGF0aC5sZW5ndGggLSAxXTtcbiAgaWYgKCFwYXJlbnQuZ2V0Q2hpbGQoa2V5KS5ydW50aW1lKSB7IHJldHVybiB9XG5cbiAgcGFyZW50LnJlbW92ZUNoaWxkKGtleSk7XG59O1xuXG5mdW5jdGlvbiB1cGRhdGUgKHBhdGgsIHRhcmdldE1vZHVsZSwgbmV3TW9kdWxlKSB7XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgYXNzZXJ0UmF3TW9kdWxlKHBhdGgsIG5ld01vZHVsZSk7XG4gIH1cblxuICAvLyB1cGRhdGUgdGFyZ2V0IG1vZHVsZVxuICB0YXJnZXRNb2R1bGUudXBkYXRlKG5ld01vZHVsZSk7XG5cbiAgLy8gdXBkYXRlIG5lc3RlZCBtb2R1bGVzXG4gIGlmIChuZXdNb2R1bGUubW9kdWxlcykge1xuICAgIGZvciAodmFyIGtleSBpbiBuZXdNb2R1bGUubW9kdWxlcykge1xuICAgICAgaWYgKCF0YXJnZXRNb2R1bGUuZ2V0Q2hpbGQoa2V5KSkge1xuICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICAgIGNvbnNvbGUud2FybihcbiAgICAgICAgICAgIFwiW3Z1ZXhdIHRyeWluZyB0byBhZGQgYSBuZXcgbW9kdWxlICdcIiArIGtleSArIFwiJyBvbiBob3QgcmVsb2FkaW5nLCBcIiArXG4gICAgICAgICAgICAnbWFudWFsIHJlbG9hZCBpcyBuZWVkZWQnXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm5cbiAgICAgIH1cbiAgICAgIHVwZGF0ZShcbiAgICAgICAgcGF0aC5jb25jYXQoa2V5KSxcbiAgICAgICAgdGFyZ2V0TW9kdWxlLmdldENoaWxkKGtleSksXG4gICAgICAgIG5ld01vZHVsZS5tb2R1bGVzW2tleV1cbiAgICAgICk7XG4gICAgfVxuICB9XG59XG5cbnZhciBmdW5jdGlvbkFzc2VydCA9IHtcbiAgYXNzZXJ0OiBmdW5jdGlvbiAodmFsdWUpIHsgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gJ2Z1bmN0aW9uJzsgfSxcbiAgZXhwZWN0ZWQ6ICdmdW5jdGlvbidcbn07XG5cbnZhciBvYmplY3RBc3NlcnQgPSB7XG4gIGFzc2VydDogZnVuY3Rpb24gKHZhbHVlKSB7IHJldHVybiB0eXBlb2YgdmFsdWUgPT09ICdmdW5jdGlvbicgfHxcbiAgICAodHlwZW9mIHZhbHVlID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgdmFsdWUuaGFuZGxlciA9PT0gJ2Z1bmN0aW9uJyk7IH0sXG4gIGV4cGVjdGVkOiAnZnVuY3Rpb24gb3Igb2JqZWN0IHdpdGggXCJoYW5kbGVyXCIgZnVuY3Rpb24nXG59O1xuXG52YXIgYXNzZXJ0VHlwZXMgPSB7XG4gIGdldHRlcnM6IGZ1bmN0aW9uQXNzZXJ0LFxuICBtdXRhdGlvbnM6IGZ1bmN0aW9uQXNzZXJ0LFxuICBhY3Rpb25zOiBvYmplY3RBc3NlcnRcbn07XG5cbmZ1bmN0aW9uIGFzc2VydFJhd01vZHVsZSAocGF0aCwgcmF3TW9kdWxlKSB7XG4gIE9iamVjdC5rZXlzKGFzc2VydFR5cGVzKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICBpZiAoIXJhd01vZHVsZVtrZXldKSB7IHJldHVybiB9XG5cbiAgICB2YXIgYXNzZXJ0T3B0aW9ucyA9IGFzc2VydFR5cGVzW2tleV07XG5cbiAgICBmb3JFYWNoVmFsdWUocmF3TW9kdWxlW2tleV0sIGZ1bmN0aW9uICh2YWx1ZSwgdHlwZSkge1xuICAgICAgYXNzZXJ0KFxuICAgICAgICBhc3NlcnRPcHRpb25zLmFzc2VydCh2YWx1ZSksXG4gICAgICAgIG1ha2VBc3NlcnRpb25NZXNzYWdlKHBhdGgsIGtleSwgdHlwZSwgdmFsdWUsIGFzc2VydE9wdGlvbnMuZXhwZWN0ZWQpXG4gICAgICApO1xuICAgIH0pO1xuICB9KTtcbn1cblxuZnVuY3Rpb24gbWFrZUFzc2VydGlvbk1lc3NhZ2UgKHBhdGgsIGtleSwgdHlwZSwgdmFsdWUsIGV4cGVjdGVkKSB7XG4gIHZhciBidWYgPSBrZXkgKyBcIiBzaG91bGQgYmUgXCIgKyBleHBlY3RlZCArIFwiIGJ1dCBcXFwiXCIgKyBrZXkgKyBcIi5cIiArIHR5cGUgKyBcIlxcXCJcIjtcbiAgaWYgKHBhdGgubGVuZ3RoID4gMCkge1xuICAgIGJ1ZiArPSBcIiBpbiBtb2R1bGUgXFxcIlwiICsgKHBhdGguam9pbignLicpKSArIFwiXFxcIlwiO1xuICB9XG4gIGJ1ZiArPSBcIiBpcyBcIiArIChKU09OLnN0cmluZ2lmeSh2YWx1ZSkpICsgXCIuXCI7XG4gIHJldHVybiBidWZcbn1cblxudmFyIFZ1ZTsgLy8gYmluZCBvbiBpbnN0YWxsXG5cbnZhciBTdG9yZSA9IGZ1bmN0aW9uIFN0b3JlIChvcHRpb25zKSB7XG4gIHZhciB0aGlzJDEgPSB0aGlzO1xuICBpZiAoIG9wdGlvbnMgPT09IHZvaWQgMCApIG9wdGlvbnMgPSB7fTtcblxuICAvLyBBdXRvIGluc3RhbGwgaWYgaXQgaXMgbm90IGRvbmUgeWV0IGFuZCBgd2luZG93YCBoYXMgYFZ1ZWAuXG4gIC8vIFRvIGFsbG93IHVzZXJzIHRvIGF2b2lkIGF1dG8taW5zdGFsbGF0aW9uIGluIHNvbWUgY2FzZXMsXG4gIC8vIHRoaXMgY29kZSBzaG91bGQgYmUgcGxhY2VkIGhlcmUuIFNlZSAjNzMxXG4gIGlmICghVnVlICYmIHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmIHdpbmRvdy5WdWUpIHtcbiAgICBpbnN0YWxsKHdpbmRvdy5WdWUpO1xuICB9XG5cbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICBhc3NlcnQoVnVlLCBcIm11c3QgY2FsbCBWdWUudXNlKFZ1ZXgpIGJlZm9yZSBjcmVhdGluZyBhIHN0b3JlIGluc3RhbmNlLlwiKTtcbiAgICBhc3NlcnQodHlwZW9mIFByb21pc2UgIT09ICd1bmRlZmluZWQnLCBcInZ1ZXggcmVxdWlyZXMgYSBQcm9taXNlIHBvbHlmaWxsIGluIHRoaXMgYnJvd3Nlci5cIik7XG4gICAgYXNzZXJ0KHRoaXMgaW5zdGFuY2VvZiBTdG9yZSwgXCJTdG9yZSBtdXN0IGJlIGNhbGxlZCB3aXRoIHRoZSBuZXcgb3BlcmF0b3IuXCIpO1xuICB9XG5cbiAgdmFyIHBsdWdpbnMgPSBvcHRpb25zLnBsdWdpbnM7IGlmICggcGx1Z2lucyA9PT0gdm9pZCAwICkgcGx1Z2lucyA9IFtdO1xuICB2YXIgc3RyaWN0ID0gb3B0aW9ucy5zdHJpY3Q7IGlmICggc3RyaWN0ID09PSB2b2lkIDAgKSBzdHJpY3QgPSBmYWxzZTtcblxuICB2YXIgc3RhdGUgPSBvcHRpb25zLnN0YXRlOyBpZiAoIHN0YXRlID09PSB2b2lkIDAgKSBzdGF0ZSA9IHt9O1xuICBpZiAodHlwZW9mIHN0YXRlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgc3RhdGUgPSBzdGF0ZSgpIHx8IHt9O1xuICB9XG5cbiAgLy8gc3RvcmUgaW50ZXJuYWwgc3RhdGVcbiAgdGhpcy5fY29tbWl0dGluZyA9IGZhbHNlO1xuICB0aGlzLl9hY3Rpb25zID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgdGhpcy5fYWN0aW9uU3Vic2NyaWJlcnMgPSBbXTtcbiAgdGhpcy5fbXV0YXRpb25zID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgdGhpcy5fd3JhcHBlZEdldHRlcnMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICB0aGlzLl9tb2R1bGVzID0gbmV3IE1vZHVsZUNvbGxlY3Rpb24ob3B0aW9ucyk7XG4gIHRoaXMuX21vZHVsZXNOYW1lc3BhY2VNYXAgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICB0aGlzLl9zdWJzY3JpYmVycyA9IFtdO1xuICB0aGlzLl93YXRjaGVyVk0gPSBuZXcgVnVlKCk7XG5cbiAgLy8gYmluZCBjb21taXQgYW5kIGRpc3BhdGNoIHRvIHNlbGZcbiAgdmFyIHN0b3JlID0gdGhpcztcbiAgdmFyIHJlZiA9IHRoaXM7XG4gIHZhciBkaXNwYXRjaCA9IHJlZi5kaXNwYXRjaDtcbiAgdmFyIGNvbW1pdCA9IHJlZi5jb21taXQ7XG4gIHRoaXMuZGlzcGF0Y2ggPSBmdW5jdGlvbiBib3VuZERpc3BhdGNoICh0eXBlLCBwYXlsb2FkKSB7XG4gICAgcmV0dXJuIGRpc3BhdGNoLmNhbGwoc3RvcmUsIHR5cGUsIHBheWxvYWQpXG4gIH07XG4gIHRoaXMuY29tbWl0ID0gZnVuY3Rpb24gYm91bmRDb21taXQgKHR5cGUsIHBheWxvYWQsIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gY29tbWl0LmNhbGwoc3RvcmUsIHR5cGUsIHBheWxvYWQsIG9wdGlvbnMpXG4gIH07XG5cbiAgLy8gc3RyaWN0IG1vZGVcbiAgdGhpcy5zdHJpY3QgPSBzdHJpY3Q7XG5cbiAgLy8gaW5pdCByb290IG1vZHVsZS5cbiAgLy8gdGhpcyBhbHNvIHJlY3Vyc2l2ZWx5IHJlZ2lzdGVycyBhbGwgc3ViLW1vZHVsZXNcbiAgLy8gYW5kIGNvbGxlY3RzIGFsbCBtb2R1bGUgZ2V0dGVycyBpbnNpZGUgdGhpcy5fd3JhcHBlZEdldHRlcnNcbiAgaW5zdGFsbE1vZHVsZSh0aGlzLCBzdGF0ZSwgW10sIHRoaXMuX21vZHVsZXMucm9vdCk7XG5cbiAgLy8gaW5pdGlhbGl6ZSB0aGUgc3RvcmUgdm0sIHdoaWNoIGlzIHJlc3BvbnNpYmxlIGZvciB0aGUgcmVhY3Rpdml0eVxuICAvLyAoYWxzbyByZWdpc3RlcnMgX3dyYXBwZWRHZXR0ZXJzIGFzIGNvbXB1dGVkIHByb3BlcnRpZXMpXG4gIHJlc2V0U3RvcmVWTSh0aGlzLCBzdGF0ZSk7XG5cbiAgLy8gYXBwbHkgcGx1Z2luc1xuICBwbHVnaW5zLmZvckVhY2goZnVuY3Rpb24gKHBsdWdpbikgeyByZXR1cm4gcGx1Z2luKHRoaXMkMSk7IH0pO1xuXG4gIGlmIChWdWUuY29uZmlnLmRldnRvb2xzKSB7XG4gICAgZGV2dG9vbFBsdWdpbih0aGlzKTtcbiAgfVxufTtcblxudmFyIHByb3RvdHlwZUFjY2Vzc29ycyA9IHsgc3RhdGU6IHsgY29uZmlndXJhYmxlOiB0cnVlIH0gfTtcblxucHJvdG90eXBlQWNjZXNzb3JzLnN0YXRlLmdldCA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHRoaXMuX3ZtLl9kYXRhLiQkc3RhdGVcbn07XG5cbnByb3RvdHlwZUFjY2Vzc29ycy5zdGF0ZS5zZXQgPSBmdW5jdGlvbiAodikge1xuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgIGFzc2VydChmYWxzZSwgXCJVc2Ugc3RvcmUucmVwbGFjZVN0YXRlKCkgdG8gZXhwbGljaXQgcmVwbGFjZSBzdG9yZSBzdGF0ZS5cIik7XG4gIH1cbn07XG5cblN0b3JlLnByb3RvdHlwZS5jb21taXQgPSBmdW5jdGlvbiBjb21taXQgKF90eXBlLCBfcGF5bG9hZCwgX29wdGlvbnMpIHtcbiAgICB2YXIgdGhpcyQxID0gdGhpcztcblxuICAvLyBjaGVjayBvYmplY3Qtc3R5bGUgY29tbWl0XG4gIHZhciByZWYgPSB1bmlmeU9iamVjdFN0eWxlKF90eXBlLCBfcGF5bG9hZCwgX29wdGlvbnMpO1xuICAgIHZhciB0eXBlID0gcmVmLnR5cGU7XG4gICAgdmFyIHBheWxvYWQgPSByZWYucGF5bG9hZDtcbiAgICB2YXIgb3B0aW9ucyA9IHJlZi5vcHRpb25zO1xuXG4gIHZhciBtdXRhdGlvbiA9IHsgdHlwZTogdHlwZSwgcGF5bG9hZDogcGF5bG9hZCB9O1xuICB2YXIgZW50cnkgPSB0aGlzLl9tdXRhdGlvbnNbdHlwZV07XG4gIGlmICghZW50cnkpIHtcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgY29uc29sZS5lcnJvcigoXCJbdnVleF0gdW5rbm93biBtdXRhdGlvbiB0eXBlOiBcIiArIHR5cGUpKTtcbiAgICB9XG4gICAgcmV0dXJuXG4gIH1cbiAgdGhpcy5fd2l0aENvbW1pdChmdW5jdGlvbiAoKSB7XG4gICAgZW50cnkuZm9yRWFjaChmdW5jdGlvbiBjb21taXRJdGVyYXRvciAoaGFuZGxlcikge1xuICAgICAgaGFuZGxlcihwYXlsb2FkKTtcbiAgICB9KTtcbiAgfSk7XG4gIHRoaXMuX3N1YnNjcmliZXJzLmZvckVhY2goZnVuY3Rpb24gKHN1YikgeyByZXR1cm4gc3ViKG11dGF0aW9uLCB0aGlzJDEuc3RhdGUpOyB9KTtcblxuICBpZiAoXG4gICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJlxuICAgIG9wdGlvbnMgJiYgb3B0aW9ucy5zaWxlbnRcbiAgKSB7XG4gICAgY29uc29sZS53YXJuKFxuICAgICAgXCJbdnVleF0gbXV0YXRpb24gdHlwZTogXCIgKyB0eXBlICsgXCIuIFNpbGVudCBvcHRpb24gaGFzIGJlZW4gcmVtb3ZlZC4gXCIgK1xuICAgICAgJ1VzZSB0aGUgZmlsdGVyIGZ1bmN0aW9uYWxpdHkgaW4gdGhlIHZ1ZS1kZXZ0b29scydcbiAgICApO1xuICB9XG59O1xuXG5TdG9yZS5wcm90b3R5cGUuZGlzcGF0Y2ggPSBmdW5jdGlvbiBkaXNwYXRjaCAoX3R5cGUsIF9wYXlsb2FkKSB7XG4gICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgLy8gY2hlY2sgb2JqZWN0LXN0eWxlIGRpc3BhdGNoXG4gIHZhciByZWYgPSB1bmlmeU9iamVjdFN0eWxlKF90eXBlLCBfcGF5bG9hZCk7XG4gICAgdmFyIHR5cGUgPSByZWYudHlwZTtcbiAgICB2YXIgcGF5bG9hZCA9IHJlZi5wYXlsb2FkO1xuXG4gIHZhciBhY3Rpb24gPSB7IHR5cGU6IHR5cGUsIHBheWxvYWQ6IHBheWxvYWQgfTtcbiAgdmFyIGVudHJ5ID0gdGhpcy5fYWN0aW9uc1t0eXBlXTtcbiAgaWYgKCFlbnRyeSkge1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICBjb25zb2xlLmVycm9yKChcIlt2dWV4XSB1bmtub3duIGFjdGlvbiB0eXBlOiBcIiArIHR5cGUpKTtcbiAgICB9XG4gICAgcmV0dXJuXG4gIH1cblxuICB0aGlzLl9hY3Rpb25TdWJzY3JpYmVycy5mb3JFYWNoKGZ1bmN0aW9uIChzdWIpIHsgcmV0dXJuIHN1YihhY3Rpb24sIHRoaXMkMS5zdGF0ZSk7IH0pO1xuXG4gIHJldHVybiBlbnRyeS5sZW5ndGggPiAxXG4gICAgPyBQcm9taXNlLmFsbChlbnRyeS5tYXAoZnVuY3Rpb24gKGhhbmRsZXIpIHsgcmV0dXJuIGhhbmRsZXIocGF5bG9hZCk7IH0pKVxuICAgIDogZW50cnlbMF0ocGF5bG9hZClcbn07XG5cblN0b3JlLnByb3RvdHlwZS5zdWJzY3JpYmUgPSBmdW5jdGlvbiBzdWJzY3JpYmUgKGZuKSB7XG4gIHJldHVybiBnZW5lcmljU3Vic2NyaWJlKGZuLCB0aGlzLl9zdWJzY3JpYmVycylcbn07XG5cblN0b3JlLnByb3RvdHlwZS5zdWJzY3JpYmVBY3Rpb24gPSBmdW5jdGlvbiBzdWJzY3JpYmVBY3Rpb24gKGZuKSB7XG4gIHJldHVybiBnZW5lcmljU3Vic2NyaWJlKGZuLCB0aGlzLl9hY3Rpb25TdWJzY3JpYmVycylcbn07XG5cblN0b3JlLnByb3RvdHlwZS53YXRjaCA9IGZ1bmN0aW9uIHdhdGNoIChnZXR0ZXIsIGNiLCBvcHRpb25zKSB7XG4gICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICBhc3NlcnQodHlwZW9mIGdldHRlciA9PT0gJ2Z1bmN0aW9uJywgXCJzdG9yZS53YXRjaCBvbmx5IGFjY2VwdHMgYSBmdW5jdGlvbi5cIik7XG4gIH1cbiAgcmV0dXJuIHRoaXMuX3dhdGNoZXJWTS4kd2F0Y2goZnVuY3Rpb24gKCkgeyByZXR1cm4gZ2V0dGVyKHRoaXMkMS5zdGF0ZSwgdGhpcyQxLmdldHRlcnMpOyB9LCBjYiwgb3B0aW9ucylcbn07XG5cblN0b3JlLnByb3RvdHlwZS5yZXBsYWNlU3RhdGUgPSBmdW5jdGlvbiByZXBsYWNlU3RhdGUgKHN0YXRlKSB7XG4gICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgdGhpcy5fd2l0aENvbW1pdChmdW5jdGlvbiAoKSB7XG4gICAgdGhpcyQxLl92bS5fZGF0YS4kJHN0YXRlID0gc3RhdGU7XG4gIH0pO1xufTtcblxuU3RvcmUucHJvdG90eXBlLnJlZ2lzdGVyTW9kdWxlID0gZnVuY3Rpb24gcmVnaXN0ZXJNb2R1bGUgKHBhdGgsIHJhd01vZHVsZSwgb3B0aW9ucykge1xuICAgIGlmICggb3B0aW9ucyA9PT0gdm9pZCAwICkgb3B0aW9ucyA9IHt9O1xuXG4gIGlmICh0eXBlb2YgcGF0aCA9PT0gJ3N0cmluZycpIHsgcGF0aCA9IFtwYXRoXTsgfVxuXG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgYXNzZXJ0KEFycmF5LmlzQXJyYXkocGF0aCksIFwibW9kdWxlIHBhdGggbXVzdCBiZSBhIHN0cmluZyBvciBhbiBBcnJheS5cIik7XG4gICAgYXNzZXJ0KHBhdGgubGVuZ3RoID4gMCwgJ2Nhbm5vdCByZWdpc3RlciB0aGUgcm9vdCBtb2R1bGUgYnkgdXNpbmcgcmVnaXN0ZXJNb2R1bGUuJyk7XG4gIH1cblxuICB0aGlzLl9tb2R1bGVzLnJlZ2lzdGVyKHBhdGgsIHJhd01vZHVsZSk7XG4gIGluc3RhbGxNb2R1bGUodGhpcywgdGhpcy5zdGF0ZSwgcGF0aCwgdGhpcy5fbW9kdWxlcy5nZXQocGF0aCksIG9wdGlvbnMucHJlc2VydmVTdGF0ZSk7XG4gIC8vIHJlc2V0IHN0b3JlIHRvIHVwZGF0ZSBnZXR0ZXJzLi4uXG4gIHJlc2V0U3RvcmVWTSh0aGlzLCB0aGlzLnN0YXRlKTtcbn07XG5cblN0b3JlLnByb3RvdHlwZS51bnJlZ2lzdGVyTW9kdWxlID0gZnVuY3Rpb24gdW5yZWdpc3Rlck1vZHVsZSAocGF0aCkge1xuICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gIGlmICh0eXBlb2YgcGF0aCA9PT0gJ3N0cmluZycpIHsgcGF0aCA9IFtwYXRoXTsgfVxuXG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgYXNzZXJ0KEFycmF5LmlzQXJyYXkocGF0aCksIFwibW9kdWxlIHBhdGggbXVzdCBiZSBhIHN0cmluZyBvciBhbiBBcnJheS5cIik7XG4gIH1cblxuICB0aGlzLl9tb2R1bGVzLnVucmVnaXN0ZXIocGF0aCk7XG4gIHRoaXMuX3dpdGhDb21taXQoZnVuY3Rpb24gKCkge1xuICAgIHZhciBwYXJlbnRTdGF0ZSA9IGdldE5lc3RlZFN0YXRlKHRoaXMkMS5zdGF0ZSwgcGF0aC5zbGljZSgwLCAtMSkpO1xuICAgIFZ1ZS5kZWxldGUocGFyZW50U3RhdGUsIHBhdGhbcGF0aC5sZW5ndGggLSAxXSk7XG4gIH0pO1xuICByZXNldFN0b3JlKHRoaXMpO1xufTtcblxuU3RvcmUucHJvdG90eXBlLmhvdFVwZGF0ZSA9IGZ1bmN0aW9uIGhvdFVwZGF0ZSAobmV3T3B0aW9ucykge1xuICB0aGlzLl9tb2R1bGVzLnVwZGF0ZShuZXdPcHRpb25zKTtcbiAgcmVzZXRTdG9yZSh0aGlzLCB0cnVlKTtcbn07XG5cblN0b3JlLnByb3RvdHlwZS5fd2l0aENvbW1pdCA9IGZ1bmN0aW9uIF93aXRoQ29tbWl0IChmbikge1xuICB2YXIgY29tbWl0dGluZyA9IHRoaXMuX2NvbW1pdHRpbmc7XG4gIHRoaXMuX2NvbW1pdHRpbmcgPSB0cnVlO1xuICBmbigpO1xuICB0aGlzLl9jb21taXR0aW5nID0gY29tbWl0dGluZztcbn07XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKCBTdG9yZS5wcm90b3R5cGUsIHByb3RvdHlwZUFjY2Vzc29ycyApO1xuXG5mdW5jdGlvbiBnZW5lcmljU3Vic2NyaWJlIChmbiwgc3Vicykge1xuICBpZiAoc3Vicy5pbmRleE9mKGZuKSA8IDApIHtcbiAgICBzdWJzLnB1c2goZm4pO1xuICB9XG4gIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGkgPSBzdWJzLmluZGV4T2YoZm4pO1xuICAgIGlmIChpID4gLTEpIHtcbiAgICAgIHN1YnMuc3BsaWNlKGksIDEpO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiByZXNldFN0b3JlIChzdG9yZSwgaG90KSB7XG4gIHN0b3JlLl9hY3Rpb25zID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgc3RvcmUuX211dGF0aW9ucyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gIHN0b3JlLl93cmFwcGVkR2V0dGVycyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gIHN0b3JlLl9tb2R1bGVzTmFtZXNwYWNlTWFwID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgdmFyIHN0YXRlID0gc3RvcmUuc3RhdGU7XG4gIC8vIGluaXQgYWxsIG1vZHVsZXNcbiAgaW5zdGFsbE1vZHVsZShzdG9yZSwgc3RhdGUsIFtdLCBzdG9yZS5fbW9kdWxlcy5yb290LCB0cnVlKTtcbiAgLy8gcmVzZXQgdm1cbiAgcmVzZXRTdG9yZVZNKHN0b3JlLCBzdGF0ZSwgaG90KTtcbn1cblxuZnVuY3Rpb24gcmVzZXRTdG9yZVZNIChzdG9yZSwgc3RhdGUsIGhvdCkge1xuICB2YXIgb2xkVm0gPSBzdG9yZS5fdm07XG5cbiAgLy8gYmluZCBzdG9yZSBwdWJsaWMgZ2V0dGVyc1xuICBzdG9yZS5nZXR0ZXJzID0ge307XG4gIHZhciB3cmFwcGVkR2V0dGVycyA9IHN0b3JlLl93cmFwcGVkR2V0dGVycztcbiAgdmFyIGNvbXB1dGVkID0ge307XG4gIGZvckVhY2hWYWx1ZSh3cmFwcGVkR2V0dGVycywgZnVuY3Rpb24gKGZuLCBrZXkpIHtcbiAgICAvLyB1c2UgY29tcHV0ZWQgdG8gbGV2ZXJhZ2UgaXRzIGxhenktY2FjaGluZyBtZWNoYW5pc21cbiAgICBjb21wdXRlZFtrZXldID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gZm4oc3RvcmUpOyB9O1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShzdG9yZS5nZXR0ZXJzLCBrZXksIHtcbiAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gc3RvcmUuX3ZtW2tleV07IH0sXG4gICAgICBlbnVtZXJhYmxlOiB0cnVlIC8vIGZvciBsb2NhbCBnZXR0ZXJzXG4gICAgfSk7XG4gIH0pO1xuXG4gIC8vIHVzZSBhIFZ1ZSBpbnN0YW5jZSB0byBzdG9yZSB0aGUgc3RhdGUgdHJlZVxuICAvLyBzdXBwcmVzcyB3YXJuaW5ncyBqdXN0IGluIGNhc2UgdGhlIHVzZXIgaGFzIGFkZGVkXG4gIC8vIHNvbWUgZnVua3kgZ2xvYmFsIG1peGluc1xuICB2YXIgc2lsZW50ID0gVnVlLmNvbmZpZy5zaWxlbnQ7XG4gIFZ1ZS5jb25maWcuc2lsZW50ID0gdHJ1ZTtcbiAgc3RvcmUuX3ZtID0gbmV3IFZ1ZSh7XG4gICAgZGF0YToge1xuICAgICAgJCRzdGF0ZTogc3RhdGVcbiAgICB9LFxuICAgIGNvbXB1dGVkOiBjb21wdXRlZFxuICB9KTtcbiAgVnVlLmNvbmZpZy5zaWxlbnQgPSBzaWxlbnQ7XG5cbiAgLy8gZW5hYmxlIHN0cmljdCBtb2RlIGZvciBuZXcgdm1cbiAgaWYgKHN0b3JlLnN0cmljdCkge1xuICAgIGVuYWJsZVN0cmljdE1vZGUoc3RvcmUpO1xuICB9XG5cbiAgaWYgKG9sZFZtKSB7XG4gICAgaWYgKGhvdCkge1xuICAgICAgLy8gZGlzcGF0Y2ggY2hhbmdlcyBpbiBhbGwgc3Vic2NyaWJlZCB3YXRjaGVyc1xuICAgICAgLy8gdG8gZm9yY2UgZ2V0dGVyIHJlLWV2YWx1YXRpb24gZm9yIGhvdCByZWxvYWRpbmcuXG4gICAgICBzdG9yZS5fd2l0aENvbW1pdChmdW5jdGlvbiAoKSB7XG4gICAgICAgIG9sZFZtLl9kYXRhLiQkc3RhdGUgPSBudWxsO1xuICAgICAgfSk7XG4gICAgfVxuICAgIFZ1ZS5uZXh0VGljayhmdW5jdGlvbiAoKSB7IHJldHVybiBvbGRWbS4kZGVzdHJveSgpOyB9KTtcbiAgfVxufVxuXG5mdW5jdGlvbiBpbnN0YWxsTW9kdWxlIChzdG9yZSwgcm9vdFN0YXRlLCBwYXRoLCBtb2R1bGUsIGhvdCkge1xuICB2YXIgaXNSb290ID0gIXBhdGgubGVuZ3RoO1xuICB2YXIgbmFtZXNwYWNlID0gc3RvcmUuX21vZHVsZXMuZ2V0TmFtZXNwYWNlKHBhdGgpO1xuXG4gIC8vIHJlZ2lzdGVyIGluIG5hbWVzcGFjZSBtYXBcbiAgaWYgKG1vZHVsZS5uYW1lc3BhY2VkKSB7XG4gICAgc3RvcmUuX21vZHVsZXNOYW1lc3BhY2VNYXBbbmFtZXNwYWNlXSA9IG1vZHVsZTtcbiAgfVxuXG4gIC8vIHNldCBzdGF0ZVxuICBpZiAoIWlzUm9vdCAmJiAhaG90KSB7XG4gICAgdmFyIHBhcmVudFN0YXRlID0gZ2V0TmVzdGVkU3RhdGUocm9vdFN0YXRlLCBwYXRoLnNsaWNlKDAsIC0xKSk7XG4gICAgdmFyIG1vZHVsZU5hbWUgPSBwYXRoW3BhdGgubGVuZ3RoIC0gMV07XG4gICAgc3RvcmUuX3dpdGhDb21taXQoZnVuY3Rpb24gKCkge1xuICAgICAgVnVlLnNldChwYXJlbnRTdGF0ZSwgbW9kdWxlTmFtZSwgbW9kdWxlLnN0YXRlKTtcbiAgICB9KTtcbiAgfVxuXG4gIHZhciBsb2NhbCA9IG1vZHVsZS5jb250ZXh0ID0gbWFrZUxvY2FsQ29udGV4dChzdG9yZSwgbmFtZXNwYWNlLCBwYXRoKTtcblxuICBtb2R1bGUuZm9yRWFjaE11dGF0aW9uKGZ1bmN0aW9uIChtdXRhdGlvbiwga2V5KSB7XG4gICAgdmFyIG5hbWVzcGFjZWRUeXBlID0gbmFtZXNwYWNlICsga2V5O1xuICAgIHJlZ2lzdGVyTXV0YXRpb24oc3RvcmUsIG5hbWVzcGFjZWRUeXBlLCBtdXRhdGlvbiwgbG9jYWwpO1xuICB9KTtcblxuICBtb2R1bGUuZm9yRWFjaEFjdGlvbihmdW5jdGlvbiAoYWN0aW9uLCBrZXkpIHtcbiAgICB2YXIgdHlwZSA9IGFjdGlvbi5yb290ID8ga2V5IDogbmFtZXNwYWNlICsga2V5O1xuICAgIHZhciBoYW5kbGVyID0gYWN0aW9uLmhhbmRsZXIgfHwgYWN0aW9uO1xuICAgIHJlZ2lzdGVyQWN0aW9uKHN0b3JlLCB0eXBlLCBoYW5kbGVyLCBsb2NhbCk7XG4gIH0pO1xuXG4gIG1vZHVsZS5mb3JFYWNoR2V0dGVyKGZ1bmN0aW9uIChnZXR0ZXIsIGtleSkge1xuICAgIHZhciBuYW1lc3BhY2VkVHlwZSA9IG5hbWVzcGFjZSArIGtleTtcbiAgICByZWdpc3RlckdldHRlcihzdG9yZSwgbmFtZXNwYWNlZFR5cGUsIGdldHRlciwgbG9jYWwpO1xuICB9KTtcblxuICBtb2R1bGUuZm9yRWFjaENoaWxkKGZ1bmN0aW9uIChjaGlsZCwga2V5KSB7XG4gICAgaW5zdGFsbE1vZHVsZShzdG9yZSwgcm9vdFN0YXRlLCBwYXRoLmNvbmNhdChrZXkpLCBjaGlsZCwgaG90KTtcbiAgfSk7XG59XG5cbi8qKlxuICogbWFrZSBsb2NhbGl6ZWQgZGlzcGF0Y2gsIGNvbW1pdCwgZ2V0dGVycyBhbmQgc3RhdGVcbiAqIGlmIHRoZXJlIGlzIG5vIG5hbWVzcGFjZSwganVzdCB1c2Ugcm9vdCBvbmVzXG4gKi9cbmZ1bmN0aW9uIG1ha2VMb2NhbENvbnRleHQgKHN0b3JlLCBuYW1lc3BhY2UsIHBhdGgpIHtcbiAgdmFyIG5vTmFtZXNwYWNlID0gbmFtZXNwYWNlID09PSAnJztcblxuICB2YXIgbG9jYWwgPSB7XG4gICAgZGlzcGF0Y2g6IG5vTmFtZXNwYWNlID8gc3RvcmUuZGlzcGF0Y2ggOiBmdW5jdGlvbiAoX3R5cGUsIF9wYXlsb2FkLCBfb3B0aW9ucykge1xuICAgICAgdmFyIGFyZ3MgPSB1bmlmeU9iamVjdFN0eWxlKF90eXBlLCBfcGF5bG9hZCwgX29wdGlvbnMpO1xuICAgICAgdmFyIHBheWxvYWQgPSBhcmdzLnBheWxvYWQ7XG4gICAgICB2YXIgb3B0aW9ucyA9IGFyZ3Mub3B0aW9ucztcbiAgICAgIHZhciB0eXBlID0gYXJncy50eXBlO1xuXG4gICAgICBpZiAoIW9wdGlvbnMgfHwgIW9wdGlvbnMucm9vdCkge1xuICAgICAgICB0eXBlID0gbmFtZXNwYWNlICsgdHlwZTtcbiAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgIXN0b3JlLl9hY3Rpb25zW3R5cGVdKSB7XG4gICAgICAgICAgY29uc29sZS5lcnJvcigoXCJbdnVleF0gdW5rbm93biBsb2NhbCBhY3Rpb24gdHlwZTogXCIgKyAoYXJncy50eXBlKSArIFwiLCBnbG9iYWwgdHlwZTogXCIgKyB0eXBlKSk7XG4gICAgICAgICAgcmV0dXJuXG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHN0b3JlLmRpc3BhdGNoKHR5cGUsIHBheWxvYWQpXG4gICAgfSxcblxuICAgIGNvbW1pdDogbm9OYW1lc3BhY2UgPyBzdG9yZS5jb21taXQgOiBmdW5jdGlvbiAoX3R5cGUsIF9wYXlsb2FkLCBfb3B0aW9ucykge1xuICAgICAgdmFyIGFyZ3MgPSB1bmlmeU9iamVjdFN0eWxlKF90eXBlLCBfcGF5bG9hZCwgX29wdGlvbnMpO1xuICAgICAgdmFyIHBheWxvYWQgPSBhcmdzLnBheWxvYWQ7XG4gICAgICB2YXIgb3B0aW9ucyA9IGFyZ3Mub3B0aW9ucztcbiAgICAgIHZhciB0eXBlID0gYXJncy50eXBlO1xuXG4gICAgICBpZiAoIW9wdGlvbnMgfHwgIW9wdGlvbnMucm9vdCkge1xuICAgICAgICB0eXBlID0gbmFtZXNwYWNlICsgdHlwZTtcbiAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgIXN0b3JlLl9tdXRhdGlvbnNbdHlwZV0pIHtcbiAgICAgICAgICBjb25zb2xlLmVycm9yKChcIlt2dWV4XSB1bmtub3duIGxvY2FsIG11dGF0aW9uIHR5cGU6IFwiICsgKGFyZ3MudHlwZSkgKyBcIiwgZ2xvYmFsIHR5cGU6IFwiICsgdHlwZSkpO1xuICAgICAgICAgIHJldHVyblxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHN0b3JlLmNvbW1pdCh0eXBlLCBwYXlsb2FkLCBvcHRpb25zKTtcbiAgICB9XG4gIH07XG5cbiAgLy8gZ2V0dGVycyBhbmQgc3RhdGUgb2JqZWN0IG11c3QgYmUgZ290dGVuIGxhemlseVxuICAvLyBiZWNhdXNlIHRoZXkgd2lsbCBiZSBjaGFuZ2VkIGJ5IHZtIHVwZGF0ZVxuICBPYmplY3QuZGVmaW5lUHJvcGVydGllcyhsb2NhbCwge1xuICAgIGdldHRlcnM6IHtcbiAgICAgIGdldDogbm9OYW1lc3BhY2VcbiAgICAgICAgPyBmdW5jdGlvbiAoKSB7IHJldHVybiBzdG9yZS5nZXR0ZXJzOyB9XG4gICAgICAgIDogZnVuY3Rpb24gKCkgeyByZXR1cm4gbWFrZUxvY2FsR2V0dGVycyhzdG9yZSwgbmFtZXNwYWNlKTsgfVxuICAgIH0sXG4gICAgc3RhdGU6IHtcbiAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gZ2V0TmVzdGVkU3RhdGUoc3RvcmUuc3RhdGUsIHBhdGgpOyB9XG4gICAgfVxuICB9KTtcblxuICByZXR1cm4gbG9jYWxcbn1cblxuZnVuY3Rpb24gbWFrZUxvY2FsR2V0dGVycyAoc3RvcmUsIG5hbWVzcGFjZSkge1xuICB2YXIgZ2V0dGVyc1Byb3h5ID0ge307XG5cbiAgdmFyIHNwbGl0UG9zID0gbmFtZXNwYWNlLmxlbmd0aDtcbiAgT2JqZWN0LmtleXMoc3RvcmUuZ2V0dGVycykuZm9yRWFjaChmdW5jdGlvbiAodHlwZSkge1xuICAgIC8vIHNraXAgaWYgdGhlIHRhcmdldCBnZXR0ZXIgaXMgbm90IG1hdGNoIHRoaXMgbmFtZXNwYWNlXG4gICAgaWYgKHR5cGUuc2xpY2UoMCwgc3BsaXRQb3MpICE9PSBuYW1lc3BhY2UpIHsgcmV0dXJuIH1cblxuICAgIC8vIGV4dHJhY3QgbG9jYWwgZ2V0dGVyIHR5cGVcbiAgICB2YXIgbG9jYWxUeXBlID0gdHlwZS5zbGljZShzcGxpdFBvcyk7XG5cbiAgICAvLyBBZGQgYSBwb3J0IHRvIHRoZSBnZXR0ZXJzIHByb3h5LlxuICAgIC8vIERlZmluZSBhcyBnZXR0ZXIgcHJvcGVydHkgYmVjYXVzZVxuICAgIC8vIHdlIGRvIG5vdCB3YW50IHRvIGV2YWx1YXRlIHRoZSBnZXR0ZXJzIGluIHRoaXMgdGltZS5cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZ2V0dGVyc1Byb3h5LCBsb2NhbFR5cGUsIHtcbiAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gc3RvcmUuZ2V0dGVyc1t0eXBlXTsgfSxcbiAgICAgIGVudW1lcmFibGU6IHRydWVcbiAgICB9KTtcbiAgfSk7XG5cbiAgcmV0dXJuIGdldHRlcnNQcm94eVxufVxuXG5mdW5jdGlvbiByZWdpc3Rlck11dGF0aW9uIChzdG9yZSwgdHlwZSwgaGFuZGxlciwgbG9jYWwpIHtcbiAgdmFyIGVudHJ5ID0gc3RvcmUuX211dGF0aW9uc1t0eXBlXSB8fCAoc3RvcmUuX211dGF0aW9uc1t0eXBlXSA9IFtdKTtcbiAgZW50cnkucHVzaChmdW5jdGlvbiB3cmFwcGVkTXV0YXRpb25IYW5kbGVyIChwYXlsb2FkKSB7XG4gICAgaGFuZGxlci5jYWxsKHN0b3JlLCBsb2NhbC5zdGF0ZSwgcGF5bG9hZCk7XG4gIH0pO1xufVxuXG5mdW5jdGlvbiByZWdpc3RlckFjdGlvbiAoc3RvcmUsIHR5cGUsIGhhbmRsZXIsIGxvY2FsKSB7XG4gIHZhciBlbnRyeSA9IHN0b3JlLl9hY3Rpb25zW3R5cGVdIHx8IChzdG9yZS5fYWN0aW9uc1t0eXBlXSA9IFtdKTtcbiAgZW50cnkucHVzaChmdW5jdGlvbiB3cmFwcGVkQWN0aW9uSGFuZGxlciAocGF5bG9hZCwgY2IpIHtcbiAgICB2YXIgcmVzID0gaGFuZGxlci5jYWxsKHN0b3JlLCB7XG4gICAgICBkaXNwYXRjaDogbG9jYWwuZGlzcGF0Y2gsXG4gICAgICBjb21taXQ6IGxvY2FsLmNvbW1pdCxcbiAgICAgIGdldHRlcnM6IGxvY2FsLmdldHRlcnMsXG4gICAgICBzdGF0ZTogbG9jYWwuc3RhdGUsXG4gICAgICByb290R2V0dGVyczogc3RvcmUuZ2V0dGVycyxcbiAgICAgIHJvb3RTdGF0ZTogc3RvcmUuc3RhdGVcbiAgICB9LCBwYXlsb2FkLCBjYik7XG4gICAgaWYgKCFpc1Byb21pc2UocmVzKSkge1xuICAgICAgcmVzID0gUHJvbWlzZS5yZXNvbHZlKHJlcyk7XG4gICAgfVxuICAgIGlmIChzdG9yZS5fZGV2dG9vbEhvb2spIHtcbiAgICAgIHJldHVybiByZXMuY2F0Y2goZnVuY3Rpb24gKGVycikge1xuICAgICAgICBzdG9yZS5fZGV2dG9vbEhvb2suZW1pdCgndnVleDplcnJvcicsIGVycik7XG4gICAgICAgIHRocm93IGVyclxuICAgICAgfSlcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHJlc1xuICAgIH1cbiAgfSk7XG59XG5cbmZ1bmN0aW9uIHJlZ2lzdGVyR2V0dGVyIChzdG9yZSwgdHlwZSwgcmF3R2V0dGVyLCBsb2NhbCkge1xuICBpZiAoc3RvcmUuX3dyYXBwZWRHZXR0ZXJzW3R5cGVdKSB7XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoKFwiW3Z1ZXhdIGR1cGxpY2F0ZSBnZXR0ZXIga2V5OiBcIiArIHR5cGUpKTtcbiAgICB9XG4gICAgcmV0dXJuXG4gIH1cbiAgc3RvcmUuX3dyYXBwZWRHZXR0ZXJzW3R5cGVdID0gZnVuY3Rpb24gd3JhcHBlZEdldHRlciAoc3RvcmUpIHtcbiAgICByZXR1cm4gcmF3R2V0dGVyKFxuICAgICAgbG9jYWwuc3RhdGUsIC8vIGxvY2FsIHN0YXRlXG4gICAgICBsb2NhbC5nZXR0ZXJzLCAvLyBsb2NhbCBnZXR0ZXJzXG4gICAgICBzdG9yZS5zdGF0ZSwgLy8gcm9vdCBzdGF0ZVxuICAgICAgc3RvcmUuZ2V0dGVycyAvLyByb290IGdldHRlcnNcbiAgICApXG4gIH07XG59XG5cbmZ1bmN0aW9uIGVuYWJsZVN0cmljdE1vZGUgKHN0b3JlKSB7XG4gIHN0b3JlLl92bS4kd2F0Y2goZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5fZGF0YS4kJHN0YXRlIH0sIGZ1bmN0aW9uICgpIHtcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgYXNzZXJ0KHN0b3JlLl9jb21taXR0aW5nLCBcIkRvIG5vdCBtdXRhdGUgdnVleCBzdG9yZSBzdGF0ZSBvdXRzaWRlIG11dGF0aW9uIGhhbmRsZXJzLlwiKTtcbiAgICB9XG4gIH0sIHsgZGVlcDogdHJ1ZSwgc3luYzogdHJ1ZSB9KTtcbn1cblxuZnVuY3Rpb24gZ2V0TmVzdGVkU3RhdGUgKHN0YXRlLCBwYXRoKSB7XG4gIHJldHVybiBwYXRoLmxlbmd0aFxuICAgID8gcGF0aC5yZWR1Y2UoZnVuY3Rpb24gKHN0YXRlLCBrZXkpIHsgcmV0dXJuIHN0YXRlW2tleV07IH0sIHN0YXRlKVxuICAgIDogc3RhdGVcbn1cblxuZnVuY3Rpb24gdW5pZnlPYmplY3RTdHlsZSAodHlwZSwgcGF5bG9hZCwgb3B0aW9ucykge1xuICBpZiAoaXNPYmplY3QodHlwZSkgJiYgdHlwZS50eXBlKSB7XG4gICAgb3B0aW9ucyA9IHBheWxvYWQ7XG4gICAgcGF5bG9hZCA9IHR5cGU7XG4gICAgdHlwZSA9IHR5cGUudHlwZTtcbiAgfVxuXG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgYXNzZXJ0KHR5cGVvZiB0eXBlID09PSAnc3RyaW5nJywgKFwiRXhwZWN0cyBzdHJpbmcgYXMgdGhlIHR5cGUsIGJ1dCBmb3VuZCBcIiArICh0eXBlb2YgdHlwZSkgKyBcIi5cIikpO1xuICB9XG5cbiAgcmV0dXJuIHsgdHlwZTogdHlwZSwgcGF5bG9hZDogcGF5bG9hZCwgb3B0aW9uczogb3B0aW9ucyB9XG59XG5cbmZ1bmN0aW9uIGluc3RhbGwgKF9WdWUpIHtcbiAgaWYgKFZ1ZSAmJiBfVnVlID09PSBWdWUpIHtcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgJ1t2dWV4XSBhbHJlYWR5IGluc3RhbGxlZC4gVnVlLnVzZShWdWV4KSBzaG91bGQgYmUgY2FsbGVkIG9ubHkgb25jZS4nXG4gICAgICApO1xuICAgIH1cbiAgICByZXR1cm5cbiAgfVxuICBWdWUgPSBfVnVlO1xuICBhcHBseU1peGluKFZ1ZSk7XG59XG5cbnZhciBtYXBTdGF0ZSA9IG5vcm1hbGl6ZU5hbWVzcGFjZShmdW5jdGlvbiAobmFtZXNwYWNlLCBzdGF0ZXMpIHtcbiAgdmFyIHJlcyA9IHt9O1xuICBub3JtYWxpemVNYXAoc3RhdGVzKS5mb3JFYWNoKGZ1bmN0aW9uIChyZWYpIHtcbiAgICB2YXIga2V5ID0gcmVmLmtleTtcbiAgICB2YXIgdmFsID0gcmVmLnZhbDtcblxuICAgIHJlc1trZXldID0gZnVuY3Rpb24gbWFwcGVkU3RhdGUgKCkge1xuICAgICAgdmFyIHN0YXRlID0gdGhpcy4kc3RvcmUuc3RhdGU7XG4gICAgICB2YXIgZ2V0dGVycyA9IHRoaXMuJHN0b3JlLmdldHRlcnM7XG4gICAgICBpZiAobmFtZXNwYWNlKSB7XG4gICAgICAgIHZhciBtb2R1bGUgPSBnZXRNb2R1bGVCeU5hbWVzcGFjZSh0aGlzLiRzdG9yZSwgJ21hcFN0YXRlJywgbmFtZXNwYWNlKTtcbiAgICAgICAgaWYgKCFtb2R1bGUpIHtcbiAgICAgICAgICByZXR1cm5cbiAgICAgICAgfVxuICAgICAgICBzdGF0ZSA9IG1vZHVsZS5jb250ZXh0LnN0YXRlO1xuICAgICAgICBnZXR0ZXJzID0gbW9kdWxlLmNvbnRleHQuZ2V0dGVycztcbiAgICAgIH1cbiAgICAgIHJldHVybiB0eXBlb2YgdmFsID09PSAnZnVuY3Rpb24nXG4gICAgICAgID8gdmFsLmNhbGwodGhpcywgc3RhdGUsIGdldHRlcnMpXG4gICAgICAgIDogc3RhdGVbdmFsXVxuICAgIH07XG4gICAgLy8gbWFyayB2dWV4IGdldHRlciBmb3IgZGV2dG9vbHNcbiAgICByZXNba2V5XS52dWV4ID0gdHJ1ZTtcbiAgfSk7XG4gIHJldHVybiByZXNcbn0pO1xuXG52YXIgbWFwTXV0YXRpb25zID0gbm9ybWFsaXplTmFtZXNwYWNlKGZ1bmN0aW9uIChuYW1lc3BhY2UsIG11dGF0aW9ucykge1xuICB2YXIgcmVzID0ge307XG4gIG5vcm1hbGl6ZU1hcChtdXRhdGlvbnMpLmZvckVhY2goZnVuY3Rpb24gKHJlZikge1xuICAgIHZhciBrZXkgPSByZWYua2V5O1xuICAgIHZhciB2YWwgPSByZWYudmFsO1xuXG4gICAgcmVzW2tleV0gPSBmdW5jdGlvbiBtYXBwZWRNdXRhdGlvbiAoKSB7XG4gICAgICB2YXIgYXJncyA9IFtdLCBsZW4gPSBhcmd1bWVudHMubGVuZ3RoO1xuICAgICAgd2hpbGUgKCBsZW4tLSApIGFyZ3NbIGxlbiBdID0gYXJndW1lbnRzWyBsZW4gXTtcblxuICAgICAgdmFyIGNvbW1pdCA9IHRoaXMuJHN0b3JlLmNvbW1pdDtcbiAgICAgIGlmIChuYW1lc3BhY2UpIHtcbiAgICAgICAgdmFyIG1vZHVsZSA9IGdldE1vZHVsZUJ5TmFtZXNwYWNlKHRoaXMuJHN0b3JlLCAnbWFwTXV0YXRpb25zJywgbmFtZXNwYWNlKTtcbiAgICAgICAgaWYgKCFtb2R1bGUpIHtcbiAgICAgICAgICByZXR1cm5cbiAgICAgICAgfVxuICAgICAgICBjb21taXQgPSBtb2R1bGUuY29udGV4dC5jb21taXQ7XG4gICAgICB9XG4gICAgICByZXR1cm4gdHlwZW9mIHZhbCA9PT0gJ2Z1bmN0aW9uJ1xuICAgICAgICA/IHZhbC5hcHBseSh0aGlzLCBbY29tbWl0XS5jb25jYXQoYXJncykpXG4gICAgICAgIDogY29tbWl0LmFwcGx5KHRoaXMuJHN0b3JlLCBbdmFsXS5jb25jYXQoYXJncykpXG4gICAgfTtcbiAgfSk7XG4gIHJldHVybiByZXNcbn0pO1xuXG52YXIgbWFwR2V0dGVycyA9IG5vcm1hbGl6ZU5hbWVzcGFjZShmdW5jdGlvbiAobmFtZXNwYWNlLCBnZXR0ZXJzKSB7XG4gIHZhciByZXMgPSB7fTtcbiAgbm9ybWFsaXplTWFwKGdldHRlcnMpLmZvckVhY2goZnVuY3Rpb24gKHJlZikge1xuICAgIHZhciBrZXkgPSByZWYua2V5O1xuICAgIHZhciB2YWwgPSByZWYudmFsO1xuXG4gICAgdmFsID0gbmFtZXNwYWNlICsgdmFsO1xuICAgIHJlc1trZXldID0gZnVuY3Rpb24gbWFwcGVkR2V0dGVyICgpIHtcbiAgICAgIGlmIChuYW1lc3BhY2UgJiYgIWdldE1vZHVsZUJ5TmFtZXNwYWNlKHRoaXMuJHN0b3JlLCAnbWFwR2V0dGVycycsIG5hbWVzcGFjZSkpIHtcbiAgICAgICAgcmV0dXJuXG4gICAgICB9XG4gICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiAhKHZhbCBpbiB0aGlzLiRzdG9yZS5nZXR0ZXJzKSkge1xuICAgICAgICBjb25zb2xlLmVycm9yKChcIlt2dWV4XSB1bmtub3duIGdldHRlcjogXCIgKyB2YWwpKTtcbiAgICAgICAgcmV0dXJuXG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcy4kc3RvcmUuZ2V0dGVyc1t2YWxdXG4gICAgfTtcbiAgICAvLyBtYXJrIHZ1ZXggZ2V0dGVyIGZvciBkZXZ0b29sc1xuICAgIHJlc1trZXldLnZ1ZXggPSB0cnVlO1xuICB9KTtcbiAgcmV0dXJuIHJlc1xufSk7XG5cbnZhciBtYXBBY3Rpb25zID0gbm9ybWFsaXplTmFtZXNwYWNlKGZ1bmN0aW9uIChuYW1lc3BhY2UsIGFjdGlvbnMpIHtcbiAgdmFyIHJlcyA9IHt9O1xuICBub3JtYWxpemVNYXAoYWN0aW9ucykuZm9yRWFjaChmdW5jdGlvbiAocmVmKSB7XG4gICAgdmFyIGtleSA9IHJlZi5rZXk7XG4gICAgdmFyIHZhbCA9IHJlZi52YWw7XG5cbiAgICByZXNba2V5XSA9IGZ1bmN0aW9uIG1hcHBlZEFjdGlvbiAoKSB7XG4gICAgICB2YXIgYXJncyA9IFtdLCBsZW4gPSBhcmd1bWVudHMubGVuZ3RoO1xuICAgICAgd2hpbGUgKCBsZW4tLSApIGFyZ3NbIGxlbiBdID0gYXJndW1lbnRzWyBsZW4gXTtcblxuICAgICAgdmFyIGRpc3BhdGNoID0gdGhpcy4kc3RvcmUuZGlzcGF0Y2g7XG4gICAgICBpZiAobmFtZXNwYWNlKSB7XG4gICAgICAgIHZhciBtb2R1bGUgPSBnZXRNb2R1bGVCeU5hbWVzcGFjZSh0aGlzLiRzdG9yZSwgJ21hcEFjdGlvbnMnLCBuYW1lc3BhY2UpO1xuICAgICAgICBpZiAoIW1vZHVsZSkge1xuICAgICAgICAgIHJldHVyblxuICAgICAgICB9XG4gICAgICAgIGRpc3BhdGNoID0gbW9kdWxlLmNvbnRleHQuZGlzcGF0Y2g7XG4gICAgICB9XG4gICAgICByZXR1cm4gdHlwZW9mIHZhbCA9PT0gJ2Z1bmN0aW9uJ1xuICAgICAgICA/IHZhbC5hcHBseSh0aGlzLCBbZGlzcGF0Y2hdLmNvbmNhdChhcmdzKSlcbiAgICAgICAgOiBkaXNwYXRjaC5hcHBseSh0aGlzLiRzdG9yZSwgW3ZhbF0uY29uY2F0KGFyZ3MpKVxuICAgIH07XG4gIH0pO1xuICByZXR1cm4gcmVzXG59KTtcblxudmFyIGNyZWF0ZU5hbWVzcGFjZWRIZWxwZXJzID0gZnVuY3Rpb24gKG5hbWVzcGFjZSkgeyByZXR1cm4gKHtcbiAgbWFwU3RhdGU6IG1hcFN0YXRlLmJpbmQobnVsbCwgbmFtZXNwYWNlKSxcbiAgbWFwR2V0dGVyczogbWFwR2V0dGVycy5iaW5kKG51bGwsIG5hbWVzcGFjZSksXG4gIG1hcE11dGF0aW9uczogbWFwTXV0YXRpb25zLmJpbmQobnVsbCwgbmFtZXNwYWNlKSxcbiAgbWFwQWN0aW9uczogbWFwQWN0aW9ucy5iaW5kKG51bGwsIG5hbWVzcGFjZSlcbn0pOyB9O1xuXG5mdW5jdGlvbiBub3JtYWxpemVNYXAgKG1hcCkge1xuICByZXR1cm4gQXJyYXkuaXNBcnJheShtYXApXG4gICAgPyBtYXAubWFwKGZ1bmN0aW9uIChrZXkpIHsgcmV0dXJuICh7IGtleToga2V5LCB2YWw6IGtleSB9KTsgfSlcbiAgICA6IE9iamVjdC5rZXlzKG1hcCkubWFwKGZ1bmN0aW9uIChrZXkpIHsgcmV0dXJuICh7IGtleToga2V5LCB2YWw6IG1hcFtrZXldIH0pOyB9KVxufVxuXG5mdW5jdGlvbiBub3JtYWxpemVOYW1lc3BhY2UgKGZuKSB7XG4gIHJldHVybiBmdW5jdGlvbiAobmFtZXNwYWNlLCBtYXApIHtcbiAgICBpZiAodHlwZW9mIG5hbWVzcGFjZSAhPT0gJ3N0cmluZycpIHtcbiAgICAgIG1hcCA9IG5hbWVzcGFjZTtcbiAgICAgIG5hbWVzcGFjZSA9ICcnO1xuICAgIH0gZWxzZSBpZiAobmFtZXNwYWNlLmNoYXJBdChuYW1lc3BhY2UubGVuZ3RoIC0gMSkgIT09ICcvJykge1xuICAgICAgbmFtZXNwYWNlICs9ICcvJztcbiAgICB9XG4gICAgcmV0dXJuIGZuKG5hbWVzcGFjZSwgbWFwKVxuICB9XG59XG5cbmZ1bmN0aW9uIGdldE1vZHVsZUJ5TmFtZXNwYWNlIChzdG9yZSwgaGVscGVyLCBuYW1lc3BhY2UpIHtcbiAgdmFyIG1vZHVsZSA9IHN0b3JlLl9tb2R1bGVzTmFtZXNwYWNlTWFwW25hbWVzcGFjZV07XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmICFtb2R1bGUpIHtcbiAgICBjb25zb2xlLmVycm9yKChcIlt2dWV4XSBtb2R1bGUgbmFtZXNwYWNlIG5vdCBmb3VuZCBpbiBcIiArIGhlbHBlciArIFwiKCk6IFwiICsgbmFtZXNwYWNlKSk7XG4gIH1cbiAgcmV0dXJuIG1vZHVsZVxufVxuXG52YXIgaW5kZXhfZXNtID0ge1xuICBTdG9yZTogU3RvcmUsXG4gIGluc3RhbGw6IGluc3RhbGwsXG4gIHZlcnNpb246ICcyLjUuMCcsXG4gIG1hcFN0YXRlOiBtYXBTdGF0ZSxcbiAgbWFwTXV0YXRpb25zOiBtYXBNdXRhdGlvbnMsXG4gIG1hcEdldHRlcnM6IG1hcEdldHRlcnMsXG4gIG1hcEFjdGlvbnM6IG1hcEFjdGlvbnMsXG4gIGNyZWF0ZU5hbWVzcGFjZWRIZWxwZXJzOiBjcmVhdGVOYW1lc3BhY2VkSGVscGVyc1xufTtcblxuZXhwb3J0IHsgU3RvcmUsIGluc3RhbGwsIG1hcFN0YXRlLCBtYXBNdXRhdGlvbnMsIG1hcEdldHRlcnMsIG1hcEFjdGlvbnMsIGNyZWF0ZU5hbWVzcGFjZWRIZWxwZXJzIH07XG5leHBvcnQgZGVmYXVsdCBpbmRleF9lc207XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L192dWV4QDIuNS4wQHZ1ZXgvZGlzdC92dWV4LmVzbS5qcyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///68\n");

/***/ }),

/***/ 99:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("Object.defineProperty(__webpack_exports__, \"__esModule\", { value: true });\n/* WEBPACK VAR INJECTION */(function(process) {var _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\n/**\n  * vue-router v2.8.1\n  * (c) 2017 Evan You\n  * @license MIT\n  */\n/*  */\n\nfunction assert(condition, message) {\n  if (!condition) {\n    throw new Error(\"[vue-router] \" + message);\n  }\n}\n\nfunction warn(condition, message) {\n  if (process.env.NODE_ENV !== 'production' && !condition) {\n    typeof console !== 'undefined' && console.warn(\"[vue-router] \" + message);\n  }\n}\n\nfunction isError(err) {\n  return Object.prototype.toString.call(err).indexOf('Error') > -1;\n}\n\nvar View = {\n  name: 'router-view',\n  functional: true,\n  props: {\n    name: {\n      type: String,\n      default: 'default'\n    }\n  },\n  render: function render(_, ref) {\n    var props = ref.props;\n    var children = ref.children;\n    var parent = ref.parent;\n    var data = ref.data;\n\n    data.routerView = true;\n\n    // directly use parent context's createElement() function\n    // so that components rendered by router-view can resolve named slots\n    var h = parent.$createElement;\n    var name = props.name;\n    var route = parent.$route;\n    var cache = parent._routerViewCache || (parent._routerViewCache = {});\n\n    // determine current view depth, also check to see if the tree\n    // has been toggled inactive but kept-alive.\n    var depth = 0;\n    var inactive = false;\n    while (parent && parent._routerRoot !== parent) {\n      if (parent.$vnode && parent.$vnode.data.routerView) {\n        depth++;\n      }\n      if (parent._inactive) {\n        inactive = true;\n      }\n      parent = parent.$parent;\n    }\n    data.routerViewDepth = depth;\n\n    // render previous view if the tree is inactive and kept-alive\n    if (inactive) {\n      return h(cache[name], data, children);\n    }\n\n    var matched = route.matched[depth];\n    // render empty node if no matched route\n    if (!matched) {\n      cache[name] = null;\n      return h();\n    }\n\n    var component = cache[name] = matched.components[name];\n\n    // attach instance registration hook\n    // this will be called in the instance's injected lifecycle hooks\n    data.registerRouteInstance = function (vm, val) {\n      // val could be undefined for unregistration\n      var current = matched.instances[name];\n      if (val && current !== vm || !val && current === vm) {\n        matched.instances[name] = val;\n      }\n    }\n\n    // also register instance in prepatch hook\n    // in case the same component instance is reused across different routes\n    ;(data.hook || (data.hook = {})).prepatch = function (_, vnode) {\n      matched.instances[name] = vnode.componentInstance;\n    };\n\n    // resolve props\n    var propsToPass = data.props = resolveProps(route, matched.props && matched.props[name]);\n    if (propsToPass) {\n      // clone to prevent mutation\n      propsToPass = data.props = extend({}, propsToPass);\n      // pass non-declared props as attrs\n      var attrs = data.attrs = data.attrs || {};\n      for (var key in propsToPass) {\n        if (!component.props || !(key in component.props)) {\n          attrs[key] = propsToPass[key];\n          delete propsToPass[key];\n        }\n      }\n    }\n\n    return h(component, data, children);\n  }\n};\n\nfunction resolveProps(route, config) {\n  switch (typeof config === 'undefined' ? 'undefined' : _typeof(config)) {\n    case 'undefined':\n      return;\n    case 'object':\n      return config;\n    case 'function':\n      return config(route);\n    case 'boolean':\n      return config ? route.params : undefined;\n    default:\n      if (process.env.NODE_ENV !== 'production') {\n        warn(false, \"props in \\\"\" + route.path + \"\\\" is a \" + (typeof config === 'undefined' ? 'undefined' : _typeof(config)) + \", \" + \"expecting an object, function or boolean.\");\n      }\n  }\n}\n\nfunction extend(to, from) {\n  for (var key in from) {\n    to[key] = from[key];\n  }\n  return to;\n}\n\n/*  */\n\nvar encodeReserveRE = /[!'()*]/g;\nvar encodeReserveReplacer = function encodeReserveReplacer(c) {\n  return '%' + c.charCodeAt(0).toString(16);\n};\nvar commaRE = /%2C/g;\n\n// fixed encodeURIComponent which is more conformant to RFC3986:\n// - escapes [!'()*]\n// - preserve commas\nvar encode = function encode(str) {\n  return encodeURIComponent(str).replace(encodeReserveRE, encodeReserveReplacer).replace(commaRE, ',');\n};\n\nvar decode = decodeURIComponent;\n\nfunction resolveQuery(query, extraQuery, _parseQuery) {\n  if (extraQuery === void 0) extraQuery = {};\n\n  var parse = _parseQuery || parseQuery;\n  var parsedQuery;\n  try {\n    parsedQuery = parse(query || '');\n  } catch (e) {\n    process.env.NODE_ENV !== 'production' && warn(false, e.message);\n    parsedQuery = {};\n  }\n  for (var key in extraQuery) {\n    parsedQuery[key] = extraQuery[key];\n  }\n  return parsedQuery;\n}\n\nfunction parseQuery(query) {\n  var res = {};\n\n  query = query.trim().replace(/^(\\?|#|&)/, '');\n\n  if (!query) {\n    return res;\n  }\n\n  query.split('&').forEach(function (param) {\n    var parts = param.replace(/\\+/g, ' ').split('=');\n    var key = decode(parts.shift());\n    var val = parts.length > 0 ? decode(parts.join('=')) : null;\n\n    if (res[key] === undefined) {\n      res[key] = val;\n    } else if (Array.isArray(res[key])) {\n      res[key].push(val);\n    } else {\n      res[key] = [res[key], val];\n    }\n  });\n\n  return res;\n}\n\nfunction stringifyQuery(obj) {\n  var res = obj ? Object.keys(obj).map(function (key) {\n    var val = obj[key];\n\n    if (val === undefined) {\n      return '';\n    }\n\n    if (val === null) {\n      return encode(key);\n    }\n\n    if (Array.isArray(val)) {\n      var result = [];\n      val.forEach(function (val2) {\n        if (val2 === undefined) {\n          return;\n        }\n        if (val2 === null) {\n          result.push(encode(key));\n        } else {\n          result.push(encode(key) + '=' + encode(val2));\n        }\n      });\n      return result.join('&');\n    }\n\n    return encode(key) + '=' + encode(val);\n  }).filter(function (x) {\n    return x.length > 0;\n  }).join('&') : null;\n  return res ? \"?\" + res : '';\n}\n\n/*  */\n\nvar trailingSlashRE = /\\/?$/;\n\nfunction createRoute(record, location, redirectedFrom, router) {\n  var stringifyQuery$$1 = router && router.options.stringifyQuery;\n\n  var query = location.query || {};\n  try {\n    query = clone(query);\n  } catch (e) {}\n\n  var route = {\n    name: location.name || record && record.name,\n    meta: record && record.meta || {},\n    path: location.path || '/',\n    hash: location.hash || '',\n    query: query,\n    params: location.params || {},\n    fullPath: getFullPath(location, stringifyQuery$$1),\n    matched: record ? formatMatch(record) : []\n  };\n  if (redirectedFrom) {\n    route.redirectedFrom = getFullPath(redirectedFrom, stringifyQuery$$1);\n  }\n  return Object.freeze(route);\n}\n\nfunction clone(value) {\n  if (Array.isArray(value)) {\n    return value.map(clone);\n  } else if (value && (typeof value === 'undefined' ? 'undefined' : _typeof(value)) === 'object') {\n    var res = {};\n    for (var key in value) {\n      res[key] = clone(value[key]);\n    }\n    return res;\n  } else {\n    return value;\n  }\n}\n\n// the starting route that represents the initial state\nvar START = createRoute(null, {\n  path: '/'\n});\n\nfunction formatMatch(record) {\n  var res = [];\n  while (record) {\n    res.unshift(record);\n    record = record.parent;\n  }\n  return res;\n}\n\nfunction getFullPath(ref, _stringifyQuery) {\n  var path = ref.path;\n  var query = ref.query;if (query === void 0) query = {};\n  var hash = ref.hash;if (hash === void 0) hash = '';\n\n  var stringify = _stringifyQuery || stringifyQuery;\n  return (path || '/') + stringify(query) + hash;\n}\n\nfunction isSameRoute(a, b) {\n  if (b === START) {\n    return a === b;\n  } else if (!b) {\n    return false;\n  } else if (a.path && b.path) {\n    return a.path.replace(trailingSlashRE, '') === b.path.replace(trailingSlashRE, '') && a.hash === b.hash && isObjectEqual(a.query, b.query);\n  } else if (a.name && b.name) {\n    return a.name === b.name && a.hash === b.hash && isObjectEqual(a.query, b.query) && isObjectEqual(a.params, b.params);\n  } else {\n    return false;\n  }\n}\n\nfunction isObjectEqual(a, b) {\n  if (a === void 0) a = {};\n  if (b === void 0) b = {};\n\n  // handle null value #1566\n  if (!a || !b) {\n    return a === b;\n  }\n  var aKeys = Object.keys(a);\n  var bKeys = Object.keys(b);\n  if (aKeys.length !== bKeys.length) {\n    return false;\n  }\n  return aKeys.every(function (key) {\n    var aVal = a[key];\n    var bVal = b[key];\n    // check nested equality\n    if ((typeof aVal === 'undefined' ? 'undefined' : _typeof(aVal)) === 'object' && (typeof bVal === 'undefined' ? 'undefined' : _typeof(bVal)) === 'object') {\n      return isObjectEqual(aVal, bVal);\n    }\n    return String(aVal) === String(bVal);\n  });\n}\n\nfunction isIncludedRoute(current, target) {\n  return current.path.replace(trailingSlashRE, '/').indexOf(target.path.replace(trailingSlashRE, '/')) === 0 && (!target.hash || current.hash === target.hash) && queryIncludes(current.query, target.query);\n}\n\nfunction queryIncludes(current, target) {\n  for (var key in target) {\n    if (!(key in current)) {\n      return false;\n    }\n  }\n  return true;\n}\n\n/*  */\n\n// work around weird flow bug\nvar toTypes = [String, Object];\nvar eventTypes = [String, Array];\n\nvar Link = {\n  name: 'router-link',\n  props: {\n    to: {\n      type: toTypes,\n      required: true\n    },\n    tag: {\n      type: String,\n      default: 'a'\n    },\n    exact: Boolean,\n    append: Boolean,\n    replace: Boolean,\n    activeClass: String,\n    exactActiveClass: String,\n    event: {\n      type: eventTypes,\n      default: 'click'\n    }\n  },\n  render: function render(h) {\n    var this$1 = this;\n\n    var router = this.$router;\n    var current = this.$route;\n    var ref = router.resolve(this.to, current, this.append);\n    var location = ref.location;\n    var route = ref.route;\n    var href = ref.href;\n\n    var classes = {};\n    var globalActiveClass = router.options.linkActiveClass;\n    var globalExactActiveClass = router.options.linkExactActiveClass;\n    // Support global empty active class\n    var activeClassFallback = globalActiveClass == null ? 'router-link-active' : globalActiveClass;\n    var exactActiveClassFallback = globalExactActiveClass == null ? 'router-link-exact-active' : globalExactActiveClass;\n    var activeClass = this.activeClass == null ? activeClassFallback : this.activeClass;\n    var exactActiveClass = this.exactActiveClass == null ? exactActiveClassFallback : this.exactActiveClass;\n    var compareTarget = location.path ? createRoute(null, location, null, router) : route;\n\n    classes[exactActiveClass] = isSameRoute(current, compareTarget);\n    classes[activeClass] = this.exact ? classes[exactActiveClass] : isIncludedRoute(current, compareTarget);\n\n    var handler = function handler(e) {\n      if (guardEvent(e)) {\n        if (this$1.replace) {\n          router.replace(location);\n        } else {\n          router.push(location);\n        }\n      }\n    };\n\n    var on = { click: guardEvent };\n    if (Array.isArray(this.event)) {\n      this.event.forEach(function (e) {\n        on[e] = handler;\n      });\n    } else {\n      on[this.event] = handler;\n    }\n\n    var data = {\n      class: classes\n    };\n\n    if (this.tag === 'a') {\n      data.on = on;\n      data.attrs = { href: href };\n    } else {\n      // find the first <a> child and apply listener and href\n      var a = findAnchor(this.$slots.default);\n      if (a) {\n        // in case the <a> is a static node\n        a.isStatic = false;\n        var extend = _Vue.util.extend;\n        var aData = a.data = extend({}, a.data);\n        aData.on = on;\n        var aAttrs = a.data.attrs = extend({}, a.data.attrs);\n        aAttrs.href = href;\n      } else {\n        // doesn't have <a> child, apply listener to self\n        data.on = on;\n      }\n    }\n\n    return h(this.tag, data, this.$slots.default);\n  }\n};\n\nfunction guardEvent(e) {\n  // don't redirect with control keys\n  if (e.metaKey || e.altKey || e.ctrlKey || e.shiftKey) {\n    return;\n  }\n  // don't redirect when preventDefault called\n  if (e.defaultPrevented) {\n    return;\n  }\n  // don't redirect on right click\n  if (e.button !== undefined && e.button !== 0) {\n    return;\n  }\n  // don't redirect if `target=\"_blank\"`\n  if (e.currentTarget && e.currentTarget.getAttribute) {\n    var target = e.currentTarget.getAttribute('target');\n    if (/\\b_blank\\b/i.test(target)) {\n      return;\n    }\n  }\n  // this may be a Weex event which doesn't have this method\n  if (e.preventDefault) {\n    e.preventDefault();\n  }\n  return true;\n}\n\nfunction findAnchor(children) {\n  if (children) {\n    var child;\n    for (var i = 0; i < children.length; i++) {\n      child = children[i];\n      if (child.tag === 'a') {\n        return child;\n      }\n      if (child.children && (child = findAnchor(child.children))) {\n        return child;\n      }\n    }\n  }\n}\n\nvar _Vue;\n\nfunction install(Vue) {\n  if (install.installed && _Vue === Vue) {\n    return;\n  }\n  install.installed = true;\n\n  _Vue = Vue;\n\n  var isDef = function isDef(v) {\n    return v !== undefined;\n  };\n\n  var registerInstance = function registerInstance(vm, callVal) {\n    var i = vm.$options._parentVnode;\n    if (isDef(i) && isDef(i = i.data) && isDef(i = i.registerRouteInstance)) {\n      i(vm, callVal);\n    }\n  };\n\n  Vue.mixin({\n    beforeCreate: function beforeCreate() {\n      if (isDef(this.$options.router)) {\n        this._routerRoot = this;\n        this._router = this.$options.router;\n        this._router.init(this);\n        Vue.util.defineReactive(this, '_route', this._router.history.current);\n      } else {\n        this._routerRoot = this.$parent && this.$parent._routerRoot || this;\n      }\n      registerInstance(this, this);\n    },\n    destroyed: function destroyed() {\n      registerInstance(this);\n    }\n  });\n\n  Object.defineProperty(Vue.prototype, '$router', {\n    get: function get() {\n      return this._routerRoot._router;\n    }\n  });\n\n  Object.defineProperty(Vue.prototype, '$route', {\n    get: function get() {\n      return this._routerRoot._route;\n    }\n  });\n\n  Vue.component('router-view', View);\n  Vue.component('router-link', Link);\n\n  var strats = Vue.config.optionMergeStrategies;\n  // use the same hook merging strategy for route hooks\n  strats.beforeRouteEnter = strats.beforeRouteLeave = strats.beforeRouteUpdate = strats.created;\n}\n\n/*  */\n\nvar inBrowser = typeof window !== 'undefined';\n\n/*  */\n\nfunction resolvePath(relative, base, append) {\n  var firstChar = relative.charAt(0);\n  if (firstChar === '/') {\n    return relative;\n  }\n\n  if (firstChar === '?' || firstChar === '#') {\n    return base + relative;\n  }\n\n  var stack = base.split('/');\n\n  // remove trailing segment if:\n  // - not appending\n  // - appending to trailing slash (last segment is empty)\n  if (!append || !stack[stack.length - 1]) {\n    stack.pop();\n  }\n\n  // resolve relative path\n  var segments = relative.replace(/^\\//, '').split('/');\n  for (var i = 0; i < segments.length; i++) {\n    var segment = segments[i];\n    if (segment === '..') {\n      stack.pop();\n    } else if (segment !== '.') {\n      stack.push(segment);\n    }\n  }\n\n  // ensure leading slash\n  if (stack[0] !== '') {\n    stack.unshift('');\n  }\n\n  return stack.join('/');\n}\n\nfunction parsePath(path) {\n  var hash = '';\n  var query = '';\n\n  var hashIndex = path.indexOf('#');\n  if (hashIndex >= 0) {\n    hash = path.slice(hashIndex);\n    path = path.slice(0, hashIndex);\n  }\n\n  var queryIndex = path.indexOf('?');\n  if (queryIndex >= 0) {\n    query = path.slice(queryIndex + 1);\n    path = path.slice(0, queryIndex);\n  }\n\n  return {\n    path: path,\n    query: query,\n    hash: hash\n  };\n}\n\nfunction cleanPath(path) {\n  return path.replace(/\\/\\//g, '/');\n}\n\nvar isarray = Array.isArray || function (arr) {\n  return Object.prototype.toString.call(arr) == '[object Array]';\n};\n\n/**\n * Expose `pathToRegexp`.\n */\nvar pathToRegexp_1 = pathToRegexp;\nvar parse_1 = parse;\nvar compile_1 = compile;\nvar tokensToFunction_1 = tokensToFunction;\nvar tokensToRegExp_1 = tokensToRegExp;\n\n/**\n * The main path matching regexp utility.\n *\n * @type {RegExp}\n */\nvar PATH_REGEXP = new RegExp([\n// Match escaped characters that would otherwise appear in future matches.\n// This allows the user to escape special characters that won't transform.\n'(\\\\\\\\.)',\n// Match Express-style parameters and un-named parameters with a prefix\n// and optional suffixes. Matches appear as:\n//\n// \"/:test(\\\\d+)?\" => [\"/\", \"test\", \"\\d+\", undefined, \"?\", undefined]\n// \"/route(\\\\d+)\"  => [undefined, undefined, undefined, \"\\d+\", undefined, undefined]\n// \"/*\"            => [\"/\", undefined, undefined, undefined, undefined, \"*\"]\n'([\\\\/.])?(?:(?:\\\\:(\\\\w+)(?:\\\\(((?:\\\\\\\\.|[^\\\\\\\\()])+)\\\\))?|\\\\(((?:\\\\\\\\.|[^\\\\\\\\()])+)\\\\))([+*?])?|(\\\\*))'].join('|'), 'g');\n\n/**\n * Parse a string for the raw tokens.\n *\n * @param  {string}  str\n * @param  {Object=} options\n * @return {!Array}\n */\nfunction parse(str, options) {\n  var tokens = [];\n  var key = 0;\n  var index = 0;\n  var path = '';\n  var defaultDelimiter = options && options.delimiter || '/';\n  var res;\n\n  while ((res = PATH_REGEXP.exec(str)) != null) {\n    var m = res[0];\n    var escaped = res[1];\n    var offset = res.index;\n    path += str.slice(index, offset);\n    index = offset + m.length;\n\n    // Ignore already escaped sequences.\n    if (escaped) {\n      path += escaped[1];\n      continue;\n    }\n\n    var next = str[index];\n    var prefix = res[2];\n    var name = res[3];\n    var capture = res[4];\n    var group = res[5];\n    var modifier = res[6];\n    var asterisk = res[7];\n\n    // Push the current path onto the tokens.\n    if (path) {\n      tokens.push(path);\n      path = '';\n    }\n\n    var partial = prefix != null && next != null && next !== prefix;\n    var repeat = modifier === '+' || modifier === '*';\n    var optional = modifier === '?' || modifier === '*';\n    var delimiter = res[2] || defaultDelimiter;\n    var pattern = capture || group;\n\n    tokens.push({\n      name: name || key++,\n      prefix: prefix || '',\n      delimiter: delimiter,\n      optional: optional,\n      repeat: repeat,\n      partial: partial,\n      asterisk: !!asterisk,\n      pattern: pattern ? escapeGroup(pattern) : asterisk ? '.*' : '[^' + escapeString(delimiter) + ']+?'\n    });\n  }\n\n  // Match any characters still remaining.\n  if (index < str.length) {\n    path += str.substr(index);\n  }\n\n  // If the path exists, push it onto the end.\n  if (path) {\n    tokens.push(path);\n  }\n\n  return tokens;\n}\n\n/**\n * Compile a string to a template function for the path.\n *\n * @param  {string}             str\n * @param  {Object=}            options\n * @return {!function(Object=, Object=)}\n */\nfunction compile(str, options) {\n  return tokensToFunction(parse(str, options));\n}\n\n/**\n * Prettier encoding of URI path segments.\n *\n * @param  {string}\n * @return {string}\n */\nfunction encodeURIComponentPretty(str) {\n  return encodeURI(str).replace(/[\\/?#]/g, function (c) {\n    return '%' + c.charCodeAt(0).toString(16).toUpperCase();\n  });\n}\n\n/**\n * Encode the asterisk parameter. Similar to `pretty`, but allows slashes.\n *\n * @param  {string}\n * @return {string}\n */\nfunction encodeAsterisk(str) {\n  return encodeURI(str).replace(/[?#]/g, function (c) {\n    return '%' + c.charCodeAt(0).toString(16).toUpperCase();\n  });\n}\n\n/**\n * Expose a method for transforming tokens into the path function.\n */\nfunction tokensToFunction(tokens) {\n  // Compile all the tokens into regexps.\n  var matches = new Array(tokens.length);\n\n  // Compile all the patterns before compilation.\n  for (var i = 0; i < tokens.length; i++) {\n    if (_typeof(tokens[i]) === 'object') {\n      matches[i] = new RegExp('^(?:' + tokens[i].pattern + ')$');\n    }\n  }\n\n  return function (obj, opts) {\n    var path = '';\n    var data = obj || {};\n    var options = opts || {};\n    var encode = options.pretty ? encodeURIComponentPretty : encodeURIComponent;\n\n    for (var i = 0; i < tokens.length; i++) {\n      var token = tokens[i];\n\n      if (typeof token === 'string') {\n        path += token;\n\n        continue;\n      }\n\n      var value = data[token.name];\n      var segment;\n\n      if (value == null) {\n        if (token.optional) {\n          // Prepend partial segment prefixes.\n          if (token.partial) {\n            path += token.prefix;\n          }\n\n          continue;\n        } else {\n          throw new TypeError('Expected \"' + token.name + '\" to be defined');\n        }\n      }\n\n      if (isarray(value)) {\n        if (!token.repeat) {\n          throw new TypeError('Expected \"' + token.name + '\" to not repeat, but received `' + JSON.stringify(value) + '`');\n        }\n\n        if (value.length === 0) {\n          if (token.optional) {\n            continue;\n          } else {\n            throw new TypeError('Expected \"' + token.name + '\" to not be empty');\n          }\n        }\n\n        for (var j = 0; j < value.length; j++) {\n          segment = encode(value[j]);\n\n          if (!matches[i].test(segment)) {\n            throw new TypeError('Expected all \"' + token.name + '\" to match \"' + token.pattern + '\", but received `' + JSON.stringify(segment) + '`');\n          }\n\n          path += (j === 0 ? token.prefix : token.delimiter) + segment;\n        }\n\n        continue;\n      }\n\n      segment = token.asterisk ? encodeAsterisk(value) : encode(value);\n\n      if (!matches[i].test(segment)) {\n        throw new TypeError('Expected \"' + token.name + '\" to match \"' + token.pattern + '\", but received \"' + segment + '\"');\n      }\n\n      path += token.prefix + segment;\n    }\n\n    return path;\n  };\n}\n\n/**\n * Escape a regular expression string.\n *\n * @param  {string} str\n * @return {string}\n */\nfunction escapeString(str) {\n  return str.replace(/([.+*?=^!:${}()[\\]|\\/\\\\])/g, '\\\\$1');\n}\n\n/**\n * Escape the capturing group by escaping special characters and meaning.\n *\n * @param  {string} group\n * @return {string}\n */\nfunction escapeGroup(group) {\n  return group.replace(/([=!:$\\/()])/g, '\\\\$1');\n}\n\n/**\n * Attach the keys as a property of the regexp.\n *\n * @param  {!RegExp} re\n * @param  {Array}   keys\n * @return {!RegExp}\n */\nfunction attachKeys(re, keys) {\n  re.keys = keys;\n  return re;\n}\n\n/**\n * Get the flags for a regexp from the options.\n *\n * @param  {Object} options\n * @return {string}\n */\nfunction flags(options) {\n  return options.sensitive ? '' : 'i';\n}\n\n/**\n * Pull out keys from a regexp.\n *\n * @param  {!RegExp} path\n * @param  {!Array}  keys\n * @return {!RegExp}\n */\nfunction regexpToRegexp(path, keys) {\n  // Use a negative lookahead to match only capturing groups.\n  var groups = path.source.match(/\\((?!\\?)/g);\n\n  if (groups) {\n    for (var i = 0; i < groups.length; i++) {\n      keys.push({\n        name: i,\n        prefix: null,\n        delimiter: null,\n        optional: false,\n        repeat: false,\n        partial: false,\n        asterisk: false,\n        pattern: null\n      });\n    }\n  }\n\n  return attachKeys(path, keys);\n}\n\n/**\n * Transform an array into a regexp.\n *\n * @param  {!Array}  path\n * @param  {Array}   keys\n * @param  {!Object} options\n * @return {!RegExp}\n */\nfunction arrayToRegexp(path, keys, options) {\n  var parts = [];\n\n  for (var i = 0; i < path.length; i++) {\n    parts.push(pathToRegexp(path[i], keys, options).source);\n  }\n\n  var regexp = new RegExp('(?:' + parts.join('|') + ')', flags(options));\n\n  return attachKeys(regexp, keys);\n}\n\n/**\n * Create a path regexp from string input.\n *\n * @param  {string}  path\n * @param  {!Array}  keys\n * @param  {!Object} options\n * @return {!RegExp}\n */\nfunction stringToRegexp(path, keys, options) {\n  return tokensToRegExp(parse(path, options), keys, options);\n}\n\n/**\n * Expose a function for taking tokens and returning a RegExp.\n *\n * @param  {!Array}          tokens\n * @param  {(Array|Object)=} keys\n * @param  {Object=}         options\n * @return {!RegExp}\n */\nfunction tokensToRegExp(tokens, keys, options) {\n  if (!isarray(keys)) {\n    options = /** @type {!Object} */keys || options;\n    keys = [];\n  }\n\n  options = options || {};\n\n  var strict = options.strict;\n  var end = options.end !== false;\n  var route = '';\n\n  // Iterate over the tokens and create our regexp string.\n  for (var i = 0; i < tokens.length; i++) {\n    var token = tokens[i];\n\n    if (typeof token === 'string') {\n      route += escapeString(token);\n    } else {\n      var prefix = escapeString(token.prefix);\n      var capture = '(?:' + token.pattern + ')';\n\n      keys.push(token);\n\n      if (token.repeat) {\n        capture += '(?:' + prefix + capture + ')*';\n      }\n\n      if (token.optional) {\n        if (!token.partial) {\n          capture = '(?:' + prefix + '(' + capture + '))?';\n        } else {\n          capture = prefix + '(' + capture + ')?';\n        }\n      } else {\n        capture = prefix + '(' + capture + ')';\n      }\n\n      route += capture;\n    }\n  }\n\n  var delimiter = escapeString(options.delimiter || '/');\n  var endsWithDelimiter = route.slice(-delimiter.length) === delimiter;\n\n  // In non-strict mode we allow a slash at the end of match. If the path to\n  // match already ends with a slash, we remove it for consistency. The slash\n  // is valid at the end of a path match, not in the middle. This is important\n  // in non-ending mode, where \"/test/\" shouldn't match \"/test//route\".\n  if (!strict) {\n    route = (endsWithDelimiter ? route.slice(0, -delimiter.length) : route) + '(?:' + delimiter + '(?=$))?';\n  }\n\n  if (end) {\n    route += '$';\n  } else {\n    // In non-ending mode, we need the capturing groups to match as much as\n    // possible by using a positive lookahead to the end or next path segment.\n    route += strict && endsWithDelimiter ? '' : '(?=' + delimiter + '|$)';\n  }\n\n  return attachKeys(new RegExp('^' + route, flags(options)), keys);\n}\n\n/**\n * Normalize the given path string, returning a regular expression.\n *\n * An empty array can be passed in for the keys, which will hold the\n * placeholder key descriptions. For example, using `/user/:id`, `keys` will\n * contain `[{ name: 'id', delimiter: '/', optional: false, repeat: false }]`.\n *\n * @param  {(string|RegExp|Array)} path\n * @param  {(Array|Object)=}       keys\n * @param  {Object=}               options\n * @return {!RegExp}\n */\nfunction pathToRegexp(path, keys, options) {\n  if (!isarray(keys)) {\n    options = /** @type {!Object} */keys || options;\n    keys = [];\n  }\n\n  options = options || {};\n\n  if (path instanceof RegExp) {\n    return regexpToRegexp(path, /** @type {!Array} */keys);\n  }\n\n  if (isarray(path)) {\n    return arrayToRegexp( /** @type {!Array} */path, /** @type {!Array} */keys, options);\n  }\n\n  return stringToRegexp( /** @type {string} */path, /** @type {!Array} */keys, options);\n}\n\npathToRegexp_1.parse = parse_1;\npathToRegexp_1.compile = compile_1;\npathToRegexp_1.tokensToFunction = tokensToFunction_1;\npathToRegexp_1.tokensToRegExp = tokensToRegExp_1;\n\n/*  */\n\n// $flow-disable-line\nvar regexpCompileCache = Object.create(null);\n\nfunction fillParams(path, params, routeMsg) {\n  try {\n    var filler = regexpCompileCache[path] || (regexpCompileCache[path] = pathToRegexp_1.compile(path));\n    return filler(params || {}, { pretty: true });\n  } catch (e) {\n    if (process.env.NODE_ENV !== 'production') {\n      warn(false, \"missing param for \" + routeMsg + \": \" + e.message);\n    }\n    return '';\n  }\n}\n\n/*  */\n\nfunction createRouteMap(routes, oldPathList, oldPathMap, oldNameMap) {\n  // the path list is used to control path matching priority\n  var pathList = oldPathList || [];\n  // $flow-disable-line\n  var pathMap = oldPathMap || Object.create(null);\n  // $flow-disable-line\n  var nameMap = oldNameMap || Object.create(null);\n\n  routes.forEach(function (route) {\n    addRouteRecord(pathList, pathMap, nameMap, route);\n  });\n\n  // ensure wildcard routes are always at the end\n  for (var i = 0, l = pathList.length; i < l; i++) {\n    if (pathList[i] === '*') {\n      pathList.push(pathList.splice(i, 1)[0]);\n      l--;\n      i--;\n    }\n  }\n\n  return {\n    pathList: pathList,\n    pathMap: pathMap,\n    nameMap: nameMap\n  };\n}\n\nfunction addRouteRecord(pathList, pathMap, nameMap, route, parent, matchAs) {\n  var path = route.path;\n  var name = route.name;\n  if (process.env.NODE_ENV !== 'production') {\n    assert(path != null, \"\\\"path\\\" is required in a route configuration.\");\n    assert(typeof route.component !== 'string', \"route config \\\"component\\\" for path: \" + String(path || name) + \" cannot be a \" + \"string id. Use an actual component instead.\");\n  }\n\n  var pathToRegexpOptions = route.pathToRegexpOptions || {};\n  var normalizedPath = normalizePath(path, parent, pathToRegexpOptions.strict);\n\n  if (typeof route.caseSensitive === 'boolean') {\n    pathToRegexpOptions.sensitive = route.caseSensitive;\n  }\n\n  var record = {\n    path: normalizedPath,\n    regex: compileRouteRegex(normalizedPath, pathToRegexpOptions),\n    components: route.components || { default: route.component },\n    instances: {},\n    name: name,\n    parent: parent,\n    matchAs: matchAs,\n    redirect: route.redirect,\n    beforeEnter: route.beforeEnter,\n    meta: route.meta || {},\n    props: route.props == null ? {} : route.components ? route.props : { default: route.props }\n  };\n\n  if (route.children) {\n    // Warn if route is named, does not redirect and has a default child route.\n    // If users navigate to this route by name, the default child will\n    // not be rendered (GH Issue #629)\n    if (process.env.NODE_ENV !== 'production') {\n      if (route.name && !route.redirect && route.children.some(function (child) {\n        return (/^\\/?$/.test(child.path)\n        );\n      })) {\n        warn(false, \"Named Route '\" + route.name + \"' has a default child route. \" + \"When navigating to this named route (:to=\\\"{name: '\" + route.name + \"'\\\"), \" + \"the default child route will not be rendered. Remove the name from \" + \"this route and use the name of the default child route for named \" + \"links instead.\");\n      }\n    }\n    route.children.forEach(function (child) {\n      var childMatchAs = matchAs ? cleanPath(matchAs + \"/\" + child.path) : undefined;\n      addRouteRecord(pathList, pathMap, nameMap, child, record, childMatchAs);\n    });\n  }\n\n  if (route.alias !== undefined) {\n    var aliases = Array.isArray(route.alias) ? route.alias : [route.alias];\n\n    aliases.forEach(function (alias) {\n      var aliasRoute = {\n        path: alias,\n        children: route.children\n      };\n      addRouteRecord(pathList, pathMap, nameMap, aliasRoute, parent, record.path || '/' // matchAs\n      );\n    });\n  }\n\n  if (!pathMap[record.path]) {\n    pathList.push(record.path);\n    pathMap[record.path] = record;\n  }\n\n  if (name) {\n    if (!nameMap[name]) {\n      nameMap[name] = record;\n    } else if (process.env.NODE_ENV !== 'production' && !matchAs) {\n      warn(false, \"Duplicate named routes definition: \" + \"{ name: \\\"\" + name + \"\\\", path: \\\"\" + record.path + \"\\\" }\");\n    }\n  }\n}\n\nfunction compileRouteRegex(path, pathToRegexpOptions) {\n  var regex = pathToRegexp_1(path, [], pathToRegexpOptions);\n  if (process.env.NODE_ENV !== 'production') {\n    var keys = Object.create(null);\n    regex.keys.forEach(function (key) {\n      warn(!keys[key.name], \"Duplicate param keys in route with path: \\\"\" + path + \"\\\"\");\n      keys[key.name] = true;\n    });\n  }\n  return regex;\n}\n\nfunction normalizePath(path, parent, strict) {\n  if (!strict) {\n    path = path.replace(/\\/$/, '');\n  }\n  if (path[0] === '/') {\n    return path;\n  }\n  if (parent == null) {\n    return path;\n  }\n  return cleanPath(parent.path + \"/\" + path);\n}\n\n/*  */\n\nfunction normalizeLocation(raw, current, append, router) {\n  var next = typeof raw === 'string' ? { path: raw } : raw;\n  // named target\n  if (next.name || next._normalized) {\n    return next;\n  }\n\n  // relative params\n  if (!next.path && next.params && current) {\n    next = assign({}, next);\n    next._normalized = true;\n    var params = assign(assign({}, current.params), next.params);\n    if (current.name) {\n      next.name = current.name;\n      next.params = params;\n    } else if (current.matched.length) {\n      var rawPath = current.matched[current.matched.length - 1].path;\n      next.path = fillParams(rawPath, params, \"path \" + current.path);\n    } else if (process.env.NODE_ENV !== 'production') {\n      warn(false, \"relative params navigation requires a current route.\");\n    }\n    return next;\n  }\n\n  var parsedPath = parsePath(next.path || '');\n  var basePath = current && current.path || '/';\n  var path = parsedPath.path ? resolvePath(parsedPath.path, basePath, append || next.append) : basePath;\n\n  var query = resolveQuery(parsedPath.query, next.query, router && router.options.parseQuery);\n\n  var hash = next.hash || parsedPath.hash;\n  if (hash && hash.charAt(0) !== '#') {\n    hash = \"#\" + hash;\n  }\n\n  return {\n    _normalized: true,\n    path: path,\n    query: query,\n    hash: hash\n  };\n}\n\nfunction assign(a, b) {\n  for (var key in b) {\n    a[key] = b[key];\n  }\n  return a;\n}\n\n/*  */\n\nfunction createMatcher(routes, router) {\n  var ref = createRouteMap(routes);\n  var pathList = ref.pathList;\n  var pathMap = ref.pathMap;\n  var nameMap = ref.nameMap;\n\n  function addRoutes(routes) {\n    createRouteMap(routes, pathList, pathMap, nameMap);\n  }\n\n  function match(raw, currentRoute, redirectedFrom) {\n    var location = normalizeLocation(raw, currentRoute, false, router);\n    var name = location.name;\n\n    if (name) {\n      var record = nameMap[name];\n      if (process.env.NODE_ENV !== 'production') {\n        warn(record, \"Route with name '\" + name + \"' does not exist\");\n      }\n      if (!record) {\n        return _createRoute(null, location);\n      }\n      var paramNames = record.regex.keys.filter(function (key) {\n        return !key.optional;\n      }).map(function (key) {\n        return key.name;\n      });\n\n      if (_typeof(location.params) !== 'object') {\n        location.params = {};\n      }\n\n      if (currentRoute && _typeof(currentRoute.params) === 'object') {\n        for (var key in currentRoute.params) {\n          if (!(key in location.params) && paramNames.indexOf(key) > -1) {\n            location.params[key] = currentRoute.params[key];\n          }\n        }\n      }\n\n      if (record) {\n        location.path = fillParams(record.path, location.params, \"named route \\\"\" + name + \"\\\"\");\n        return _createRoute(record, location, redirectedFrom);\n      }\n    } else if (location.path) {\n      location.params = {};\n      for (var i = 0; i < pathList.length; i++) {\n        var path = pathList[i];\n        var record$1 = pathMap[path];\n        if (matchRoute(record$1.regex, location.path, location.params)) {\n          return _createRoute(record$1, location, redirectedFrom);\n        }\n      }\n    }\n    // no match\n    return _createRoute(null, location);\n  }\n\n  function redirect(record, location) {\n    var originalRedirect = record.redirect;\n    var redirect = typeof originalRedirect === 'function' ? originalRedirect(createRoute(record, location, null, router)) : originalRedirect;\n\n    if (typeof redirect === 'string') {\n      redirect = { path: redirect };\n    }\n\n    if (!redirect || (typeof redirect === 'undefined' ? 'undefined' : _typeof(redirect)) !== 'object') {\n      if (process.env.NODE_ENV !== 'production') {\n        warn(false, \"invalid redirect option: \" + JSON.stringify(redirect));\n      }\n      return _createRoute(null, location);\n    }\n\n    var re = redirect;\n    var name = re.name;\n    var path = re.path;\n    var query = location.query;\n    var hash = location.hash;\n    var params = location.params;\n    query = re.hasOwnProperty('query') ? re.query : query;\n    hash = re.hasOwnProperty('hash') ? re.hash : hash;\n    params = re.hasOwnProperty('params') ? re.params : params;\n\n    if (name) {\n      // resolved named direct\n      var targetRecord = nameMap[name];\n      if (process.env.NODE_ENV !== 'production') {\n        assert(targetRecord, \"redirect failed: named route \\\"\" + name + \"\\\" not found.\");\n      }\n      return match({\n        _normalized: true,\n        name: name,\n        query: query,\n        hash: hash,\n        params: params\n      }, undefined, location);\n    } else if (path) {\n      // 1. resolve relative redirect\n      var rawPath = resolveRecordPath(path, record);\n      // 2. resolve params\n      var resolvedPath = fillParams(rawPath, params, \"redirect route with path \\\"\" + rawPath + \"\\\"\");\n      // 3. rematch with existing query and hash\n      return match({\n        _normalized: true,\n        path: resolvedPath,\n        query: query,\n        hash: hash\n      }, undefined, location);\n    } else {\n      if (process.env.NODE_ENV !== 'production') {\n        warn(false, \"invalid redirect option: \" + JSON.stringify(redirect));\n      }\n      return _createRoute(null, location);\n    }\n  }\n\n  function alias(record, location, matchAs) {\n    var aliasedPath = fillParams(matchAs, location.params, \"aliased route with path \\\"\" + matchAs + \"\\\"\");\n    var aliasedMatch = match({\n      _normalized: true,\n      path: aliasedPath\n    });\n    if (aliasedMatch) {\n      var matched = aliasedMatch.matched;\n      var aliasedRecord = matched[matched.length - 1];\n      location.params = aliasedMatch.params;\n      return _createRoute(aliasedRecord, location);\n    }\n    return _createRoute(null, location);\n  }\n\n  function _createRoute(record, location, redirectedFrom) {\n    if (record && record.redirect) {\n      return redirect(record, redirectedFrom || location);\n    }\n    if (record && record.matchAs) {\n      return alias(record, location, record.matchAs);\n    }\n    return createRoute(record, location, redirectedFrom, router);\n  }\n\n  return {\n    match: match,\n    addRoutes: addRoutes\n  };\n}\n\nfunction matchRoute(regex, path, params) {\n  var m = path.match(regex);\n\n  if (!m) {\n    return false;\n  } else if (!params) {\n    return true;\n  }\n\n  for (var i = 1, len = m.length; i < len; ++i) {\n    var key = regex.keys[i - 1];\n    var val = typeof m[i] === 'string' ? decodeURIComponent(m[i]) : m[i];\n    if (key) {\n      params[key.name] = val;\n    }\n  }\n\n  return true;\n}\n\nfunction resolveRecordPath(path, record) {\n  return resolvePath(path, record.parent ? record.parent.path : '/', true);\n}\n\n/*  */\n\nvar positionStore = Object.create(null);\n\nfunction setupScroll() {\n  // Fix for #1585 for Firefox\n  window.history.replaceState({ key: getStateKey() }, '');\n  window.addEventListener('popstate', function (e) {\n    saveScrollPosition();\n    if (e.state && e.state.key) {\n      setStateKey(e.state.key);\n    }\n  });\n}\n\nfunction handleScroll(router, to, from, isPop) {\n  if (!router.app) {\n    return;\n  }\n\n  var behavior = router.options.scrollBehavior;\n  if (!behavior) {\n    return;\n  }\n\n  if (process.env.NODE_ENV !== 'production') {\n    assert(typeof behavior === 'function', \"scrollBehavior must be a function\");\n  }\n\n  // wait until re-render finishes before scrolling\n  router.app.$nextTick(function () {\n    var position = getScrollPosition();\n    var shouldScroll = behavior(to, from, isPop ? position : null);\n\n    if (!shouldScroll) {\n      return;\n    }\n\n    if (typeof shouldScroll.then === 'function') {\n      shouldScroll.then(function (shouldScroll) {\n        scrollToPosition(shouldScroll, position);\n      }).catch(function (err) {\n        if (process.env.NODE_ENV !== 'production') {\n          assert(false, err.toString());\n        }\n      });\n    } else {\n      scrollToPosition(shouldScroll, position);\n    }\n  });\n}\n\nfunction saveScrollPosition() {\n  var key = getStateKey();\n  if (key) {\n    positionStore[key] = {\n      x: window.pageXOffset,\n      y: window.pageYOffset\n    };\n  }\n}\n\nfunction getScrollPosition() {\n  var key = getStateKey();\n  if (key) {\n    return positionStore[key];\n  }\n}\n\nfunction getElementPosition(el, offset) {\n  var docEl = document.documentElement;\n  var docRect = docEl.getBoundingClientRect();\n  var elRect = el.getBoundingClientRect();\n  return {\n    x: elRect.left - docRect.left - offset.x,\n    y: elRect.top - docRect.top - offset.y\n  };\n}\n\nfunction isValidPosition(obj) {\n  return isNumber(obj.x) || isNumber(obj.y);\n}\n\nfunction normalizePosition(obj) {\n  return {\n    x: isNumber(obj.x) ? obj.x : window.pageXOffset,\n    y: isNumber(obj.y) ? obj.y : window.pageYOffset\n  };\n}\n\nfunction normalizeOffset(obj) {\n  return {\n    x: isNumber(obj.x) ? obj.x : 0,\n    y: isNumber(obj.y) ? obj.y : 0\n  };\n}\n\nfunction isNumber(v) {\n  return typeof v === 'number';\n}\n\nfunction scrollToPosition(shouldScroll, position) {\n  var isObject = (typeof shouldScroll === 'undefined' ? 'undefined' : _typeof(shouldScroll)) === 'object';\n  if (isObject && typeof shouldScroll.selector === 'string') {\n    var el = document.querySelector(shouldScroll.selector);\n    if (el) {\n      var offset = shouldScroll.offset && _typeof(shouldScroll.offset) === 'object' ? shouldScroll.offset : {};\n      offset = normalizeOffset(offset);\n      position = getElementPosition(el, offset);\n    } else if (isValidPosition(shouldScroll)) {\n      position = normalizePosition(shouldScroll);\n    }\n  } else if (isObject && isValidPosition(shouldScroll)) {\n    position = normalizePosition(shouldScroll);\n  }\n\n  if (position) {\n    window.scrollTo(position.x, position.y);\n  }\n}\n\n/*  */\n\nvar supportsPushState = inBrowser && function () {\n  var ua = window.navigator.userAgent;\n\n  if ((ua.indexOf('Android 2.') !== -1 || ua.indexOf('Android 4.0') !== -1) && ua.indexOf('Mobile Safari') !== -1 && ua.indexOf('Chrome') === -1 && ua.indexOf('Windows Phone') === -1) {\n    return false;\n  }\n\n  return window.history && 'pushState' in window.history;\n}();\n\n// use User Timing api (if present) for more accurate key precision\nvar Time = inBrowser && window.performance && window.performance.now ? window.performance : Date;\n\nvar _key = genKey();\n\nfunction genKey() {\n  return Time.now().toFixed(3);\n}\n\nfunction getStateKey() {\n  return _key;\n}\n\nfunction setStateKey(key) {\n  _key = key;\n}\n\nfunction pushState(url, replace) {\n  saveScrollPosition();\n  // try...catch the pushState call to get around Safari\n  // DOM Exception 18 where it limits to 100 pushState calls\n  var history = window.history;\n  try {\n    if (replace) {\n      history.replaceState({ key: _key }, '', url);\n    } else {\n      _key = genKey();\n      history.pushState({ key: _key }, '', url);\n    }\n  } catch (e) {\n    window.location[replace ? 'replace' : 'assign'](url);\n  }\n}\n\nfunction replaceState(url) {\n  pushState(url, true);\n}\n\n/*  */\n\nfunction runQueue(queue, fn, cb) {\n  var step = function step(index) {\n    if (index >= queue.length) {\n      cb();\n    } else {\n      if (queue[index]) {\n        fn(queue[index], function () {\n          step(index + 1);\n        });\n      } else {\n        step(index + 1);\n      }\n    }\n  };\n  step(0);\n}\n\n/*  */\n\nfunction resolveAsyncComponents(matched) {\n  return function (to, from, next) {\n    var hasAsync = false;\n    var pending = 0;\n    var error = null;\n\n    flatMapComponents(matched, function (def, _, match, key) {\n      // if it's a function and doesn't have cid attached,\n      // assume it's an async component resolve function.\n      // we are not using Vue's default async resolving mechanism because\n      // we want to halt the navigation until the incoming component has been\n      // resolved.\n      if (typeof def === 'function' && def.cid === undefined) {\n        hasAsync = true;\n        pending++;\n\n        var resolve = once(function (resolvedDef) {\n          if (isESModule(resolvedDef)) {\n            resolvedDef = resolvedDef.default;\n          }\n          // save resolved on async factory in case it's used elsewhere\n          def.resolved = typeof resolvedDef === 'function' ? resolvedDef : _Vue.extend(resolvedDef);\n          match.components[key] = resolvedDef;\n          pending--;\n          if (pending <= 0) {\n            next();\n          }\n        });\n\n        var reject = once(function (reason) {\n          var msg = \"Failed to resolve async component \" + key + \": \" + reason;\n          process.env.NODE_ENV !== 'production' && warn(false, msg);\n          if (!error) {\n            error = isError(reason) ? reason : new Error(msg);\n            next(error);\n          }\n        });\n\n        var res;\n        try {\n          res = def(resolve, reject);\n        } catch (e) {\n          reject(e);\n        }\n        if (res) {\n          if (typeof res.then === 'function') {\n            res.then(resolve, reject);\n          } else {\n            // new syntax in Vue 2.3\n            var comp = res.component;\n            if (comp && typeof comp.then === 'function') {\n              comp.then(resolve, reject);\n            }\n          }\n        }\n      }\n    });\n\n    if (!hasAsync) {\n      next();\n    }\n  };\n}\n\nfunction flatMapComponents(matched, fn) {\n  return flatten(matched.map(function (m) {\n    return Object.keys(m.components).map(function (key) {\n      return fn(m.components[key], m.instances[key], m, key);\n    });\n  }));\n}\n\nfunction flatten(arr) {\n  return Array.prototype.concat.apply([], arr);\n}\n\nvar hasSymbol = typeof Symbol === 'function' && _typeof(Symbol.toStringTag) === 'symbol';\n\nfunction isESModule(obj) {\n  return obj.__esModule || hasSymbol && obj[Symbol.toStringTag] === 'Module';\n}\n\n// in Webpack 2, require.ensure now also returns a Promise\n// so the resolve/reject functions may get called an extra time\n// if the user uses an arrow function shorthand that happens to\n// return that Promise.\nfunction once(fn) {\n  var called = false;\n  return function () {\n    var args = [],\n        len = arguments.length;\n    while (len--) {\n      args[len] = arguments[len];\n    }if (called) {\n      return;\n    }\n    called = true;\n    return fn.apply(this, args);\n  };\n}\n\n/*  */\n\nvar History = function History(router, base) {\n  this.router = router;\n  this.base = normalizeBase(base);\n  // start with a route object that stands for \"nowhere\"\n  this.current = START;\n  this.pending = null;\n  this.ready = false;\n  this.readyCbs = [];\n  this.readyErrorCbs = [];\n  this.errorCbs = [];\n};\n\nHistory.prototype.listen = function listen(cb) {\n  this.cb = cb;\n};\n\nHistory.prototype.onReady = function onReady(cb, errorCb) {\n  if (this.ready) {\n    cb();\n  } else {\n    this.readyCbs.push(cb);\n    if (errorCb) {\n      this.readyErrorCbs.push(errorCb);\n    }\n  }\n};\n\nHistory.prototype.onError = function onError(errorCb) {\n  this.errorCbs.push(errorCb);\n};\n\nHistory.prototype.transitionTo = function transitionTo(location, onComplete, onAbort) {\n  var this$1 = this;\n\n  var route = this.router.match(location, this.current);\n  this.confirmTransition(route, function () {\n    this$1.updateRoute(route);\n    onComplete && onComplete(route);\n    this$1.ensureURL();\n\n    // fire ready cbs once\n    if (!this$1.ready) {\n      this$1.ready = true;\n      this$1.readyCbs.forEach(function (cb) {\n        cb(route);\n      });\n    }\n  }, function (err) {\n    if (onAbort) {\n      onAbort(err);\n    }\n    if (err && !this$1.ready) {\n      this$1.ready = true;\n      this$1.readyErrorCbs.forEach(function (cb) {\n        cb(err);\n      });\n    }\n  });\n};\n\nHistory.prototype.confirmTransition = function confirmTransition(route, onComplete, onAbort) {\n  var this$1 = this;\n\n  var current = this.current;\n  var abort = function abort(err) {\n    if (isError(err)) {\n      if (this$1.errorCbs.length) {\n        this$1.errorCbs.forEach(function (cb) {\n          cb(err);\n        });\n      } else {\n        warn(false, 'uncaught error during route navigation:');\n        console.error(err);\n      }\n    }\n    onAbort && onAbort(err);\n  };\n  if (isSameRoute(route, current) &&\n  // in the case the route map has been dynamically appended to\n  route.matched.length === current.matched.length) {\n    this.ensureURL();\n    return abort();\n  }\n\n  var ref = resolveQueue(this.current.matched, route.matched);\n  var updated = ref.updated;\n  var deactivated = ref.deactivated;\n  var activated = ref.activated;\n\n  var queue = [].concat(\n  // in-component leave guards\n  extractLeaveGuards(deactivated),\n  // global before hooks\n  this.router.beforeHooks,\n  // in-component update hooks\n  extractUpdateHooks(updated),\n  // in-config enter guards\n  activated.map(function (m) {\n    return m.beforeEnter;\n  }),\n  // async components\n  resolveAsyncComponents(activated));\n\n  this.pending = route;\n  var iterator = function iterator(hook, next) {\n    if (this$1.pending !== route) {\n      return abort();\n    }\n    try {\n      hook(route, current, function (to) {\n        if (to === false || isError(to)) {\n          // next(false) -> abort navigation, ensure current URL\n          this$1.ensureURL(true);\n          abort(to);\n        } else if (typeof to === 'string' || (typeof to === 'undefined' ? 'undefined' : _typeof(to)) === 'object' && (typeof to.path === 'string' || typeof to.name === 'string')) {\n          // next('/') or next({ path: '/' }) -> redirect\n          abort();\n          if ((typeof to === 'undefined' ? 'undefined' : _typeof(to)) === 'object' && to.replace) {\n            this$1.replace(to);\n          } else {\n            this$1.push(to);\n          }\n        } else {\n          // confirm transition and pass on the value\n          next(to);\n        }\n      });\n    } catch (e) {\n      abort(e);\n    }\n  };\n\n  runQueue(queue, iterator, function () {\n    var postEnterCbs = [];\n    var isValid = function isValid() {\n      return this$1.current === route;\n    };\n    // wait until async components are resolved before\n    // extracting in-component enter guards\n    var enterGuards = extractEnterGuards(activated, postEnterCbs, isValid);\n    var queue = enterGuards.concat(this$1.router.resolveHooks);\n    runQueue(queue, iterator, function () {\n      if (this$1.pending !== route) {\n        return abort();\n      }\n      this$1.pending = null;\n      onComplete(route);\n      if (this$1.router.app) {\n        this$1.router.app.$nextTick(function () {\n          postEnterCbs.forEach(function (cb) {\n            cb();\n          });\n        });\n      }\n    });\n  });\n};\n\nHistory.prototype.updateRoute = function updateRoute(route) {\n  var prev = this.current;\n  this.current = route;\n  this.cb && this.cb(route);\n  this.router.afterHooks.forEach(function (hook) {\n    hook && hook(route, prev);\n  });\n};\n\nfunction normalizeBase(base) {\n  if (!base) {\n    if (inBrowser) {\n      // respect <base> tag\n      var baseEl = document.querySelector('base');\n      base = baseEl && baseEl.getAttribute('href') || '/';\n      // strip full URL origin\n      base = base.replace(/^https?:\\/\\/[^\\/]+/, '');\n    } else {\n      base = '/';\n    }\n  }\n  // make sure there's the starting slash\n  if (base.charAt(0) !== '/') {\n    base = '/' + base;\n  }\n  // remove trailing slash\n  return base.replace(/\\/$/, '');\n}\n\nfunction resolveQueue(current, next) {\n  var i;\n  var max = Math.max(current.length, next.length);\n  for (i = 0; i < max; i++) {\n    if (current[i] !== next[i]) {\n      break;\n    }\n  }\n  return {\n    updated: next.slice(0, i),\n    activated: next.slice(i),\n    deactivated: current.slice(i)\n  };\n}\n\nfunction extractGuards(records, name, bind, reverse) {\n  var guards = flatMapComponents(records, function (def, instance, match, key) {\n    var guard = extractGuard(def, name);\n    if (guard) {\n      return Array.isArray(guard) ? guard.map(function (guard) {\n        return bind(guard, instance, match, key);\n      }) : bind(guard, instance, match, key);\n    }\n  });\n  return flatten(reverse ? guards.reverse() : guards);\n}\n\nfunction extractGuard(def, key) {\n  if (typeof def !== 'function') {\n    // extend now so that global mixins are applied.\n    def = _Vue.extend(def);\n  }\n  return def.options[key];\n}\n\nfunction extractLeaveGuards(deactivated) {\n  return extractGuards(deactivated, 'beforeRouteLeave', bindGuard, true);\n}\n\nfunction extractUpdateHooks(updated) {\n  return extractGuards(updated, 'beforeRouteUpdate', bindGuard);\n}\n\nfunction bindGuard(guard, instance) {\n  if (instance) {\n    return function boundRouteGuard() {\n      return guard.apply(instance, arguments);\n    };\n  }\n}\n\nfunction extractEnterGuards(activated, cbs, isValid) {\n  return extractGuards(activated, 'beforeRouteEnter', function (guard, _, match, key) {\n    return bindEnterGuard(guard, match, key, cbs, isValid);\n  });\n}\n\nfunction bindEnterGuard(guard, match, key, cbs, isValid) {\n  return function routeEnterGuard(to, from, next) {\n    return guard(to, from, function (cb) {\n      next(cb);\n      if (typeof cb === 'function') {\n        cbs.push(function () {\n          // #750\n          // if a router-view is wrapped with an out-in transition,\n          // the instance may not have been registered at this time.\n          // we will need to poll for registration until current route\n          // is no longer valid.\n          poll(cb, match.instances, key, isValid);\n        });\n      }\n    });\n  };\n}\n\nfunction poll(cb, // somehow flow cannot infer this is a function\ninstances, key, isValid) {\n  if (instances[key]) {\n    cb(instances[key]);\n  } else if (isValid()) {\n    setTimeout(function () {\n      poll(cb, instances, key, isValid);\n    }, 16);\n  }\n}\n\n/*  */\n\nvar HTML5History = function (History$$1) {\n  function HTML5History(router, base) {\n    var this$1 = this;\n\n    History$$1.call(this, router, base);\n\n    var expectScroll = router.options.scrollBehavior;\n\n    if (expectScroll) {\n      setupScroll();\n    }\n\n    var initLocation = getLocation(this.base);\n    window.addEventListener('popstate', function (e) {\n      var current = this$1.current;\n\n      // Avoiding first `popstate` event dispatched in some browsers but first\n      // history route not updated since async guard at the same time.\n      var location = getLocation(this$1.base);\n      if (this$1.current === START && location === initLocation) {\n        return;\n      }\n\n      this$1.transitionTo(location, function (route) {\n        if (expectScroll) {\n          handleScroll(router, route, current, true);\n        }\n      });\n    });\n  }\n\n  if (History$$1) HTML5History.__proto__ = History$$1;\n  HTML5History.prototype = Object.create(History$$1 && History$$1.prototype);\n  HTML5History.prototype.constructor = HTML5History;\n\n  HTML5History.prototype.go = function go(n) {\n    window.history.go(n);\n  };\n\n  HTML5History.prototype.push = function push(location, onComplete, onAbort) {\n    var this$1 = this;\n\n    var ref = this;\n    var fromRoute = ref.current;\n    this.transitionTo(location, function (route) {\n      pushState(cleanPath(this$1.base + route.fullPath));\n      handleScroll(this$1.router, route, fromRoute, false);\n      onComplete && onComplete(route);\n    }, onAbort);\n  };\n\n  HTML5History.prototype.replace = function replace(location, onComplete, onAbort) {\n    var this$1 = this;\n\n    var ref = this;\n    var fromRoute = ref.current;\n    this.transitionTo(location, function (route) {\n      replaceState(cleanPath(this$1.base + route.fullPath));\n      handleScroll(this$1.router, route, fromRoute, false);\n      onComplete && onComplete(route);\n    }, onAbort);\n  };\n\n  HTML5History.prototype.ensureURL = function ensureURL(push) {\n    if (getLocation(this.base) !== this.current.fullPath) {\n      var current = cleanPath(this.base + this.current.fullPath);\n      push ? pushState(current) : replaceState(current);\n    }\n  };\n\n  HTML5History.prototype.getCurrentLocation = function getCurrentLocation() {\n    return getLocation(this.base);\n  };\n\n  return HTML5History;\n}(History);\n\nfunction getLocation(base) {\n  var path = window.location.pathname;\n  if (base && path.indexOf(base) === 0) {\n    path = path.slice(base.length);\n  }\n  return (path || '/') + window.location.search + window.location.hash;\n}\n\n/*  */\n\nvar HashHistory = function (History$$1) {\n  function HashHistory(router, base, fallback) {\n    History$$1.call(this, router, base);\n    // check history fallback deeplinking\n    if (fallback && checkFallback(this.base)) {\n      return;\n    }\n    ensureSlash();\n  }\n\n  if (History$$1) HashHistory.__proto__ = History$$1;\n  HashHistory.prototype = Object.create(History$$1 && History$$1.prototype);\n  HashHistory.prototype.constructor = HashHistory;\n\n  // this is delayed until the app mounts\n  // to avoid the hashchange listener being fired too early\n  HashHistory.prototype.setupListeners = function setupListeners() {\n    var this$1 = this;\n\n    var router = this.router;\n    var expectScroll = router.options.scrollBehavior;\n    var supportsScroll = supportsPushState && expectScroll;\n\n    if (supportsScroll) {\n      setupScroll();\n    }\n\n    window.addEventListener(supportsPushState ? 'popstate' : 'hashchange', function () {\n      var current = this$1.current;\n      if (!ensureSlash()) {\n        return;\n      }\n      this$1.transitionTo(getHash(), function (route) {\n        if (supportsScroll) {\n          handleScroll(this$1.router, route, current, true);\n        }\n        if (!supportsPushState) {\n          replaceHash(route.fullPath);\n        }\n      });\n    });\n  };\n\n  HashHistory.prototype.push = function push(location, onComplete, onAbort) {\n    var this$1 = this;\n\n    var ref = this;\n    var fromRoute = ref.current;\n    this.transitionTo(location, function (route) {\n      pushHash(route.fullPath);\n      handleScroll(this$1.router, route, fromRoute, false);\n      onComplete && onComplete(route);\n    }, onAbort);\n  };\n\n  HashHistory.prototype.replace = function replace(location, onComplete, onAbort) {\n    var this$1 = this;\n\n    var ref = this;\n    var fromRoute = ref.current;\n    this.transitionTo(location, function (route) {\n      replaceHash(route.fullPath);\n      handleScroll(this$1.router, route, fromRoute, false);\n      onComplete && onComplete(route);\n    }, onAbort);\n  };\n\n  HashHistory.prototype.go = function go(n) {\n    window.history.go(n);\n  };\n\n  HashHistory.prototype.ensureURL = function ensureURL(push) {\n    var current = this.current.fullPath;\n    if (getHash() !== current) {\n      push ? pushHash(current) : replaceHash(current);\n    }\n  };\n\n  HashHistory.prototype.getCurrentLocation = function getCurrentLocation() {\n    return getHash();\n  };\n\n  return HashHistory;\n}(History);\n\nfunction checkFallback(base) {\n  var location = getLocation(base);\n  if (!/^\\/#/.test(location)) {\n    window.location.replace(cleanPath(base + '/#' + location));\n    return true;\n  }\n}\n\nfunction ensureSlash() {\n  var path = getHash();\n  if (path.charAt(0) === '/') {\n    return true;\n  }\n  replaceHash('/' + path);\n  return false;\n}\n\nfunction getHash() {\n  // We can't use window.location.hash here because it's not\n  // consistent across browsers - Firefox will pre-decode it!\n  var href = window.location.href;\n  var index = href.indexOf('#');\n  return index === -1 ? '' : href.slice(index + 1);\n}\n\nfunction getUrl(path) {\n  var href = window.location.href;\n  var i = href.indexOf('#');\n  var base = i >= 0 ? href.slice(0, i) : href;\n  return base + \"#\" + path;\n}\n\nfunction pushHash(path) {\n  if (supportsPushState) {\n    pushState(getUrl(path));\n  } else {\n    window.location.hash = path;\n  }\n}\n\nfunction replaceHash(path) {\n  if (supportsPushState) {\n    replaceState(getUrl(path));\n  } else {\n    window.location.replace(getUrl(path));\n  }\n}\n\n/*  */\n\nvar AbstractHistory = function (History$$1) {\n  function AbstractHistory(router, base) {\n    History$$1.call(this, router, base);\n    this.stack = [];\n    this.index = -1;\n  }\n\n  if (History$$1) AbstractHistory.__proto__ = History$$1;\n  AbstractHistory.prototype = Object.create(History$$1 && History$$1.prototype);\n  AbstractHistory.prototype.constructor = AbstractHistory;\n\n  AbstractHistory.prototype.push = function push(location, onComplete, onAbort) {\n    var this$1 = this;\n\n    this.transitionTo(location, function (route) {\n      this$1.stack = this$1.stack.slice(0, this$1.index + 1).concat(route);\n      this$1.index++;\n      onComplete && onComplete(route);\n    }, onAbort);\n  };\n\n  AbstractHistory.prototype.replace = function replace(location, onComplete, onAbort) {\n    var this$1 = this;\n\n    this.transitionTo(location, function (route) {\n      this$1.stack = this$1.stack.slice(0, this$1.index).concat(route);\n      onComplete && onComplete(route);\n    }, onAbort);\n  };\n\n  AbstractHistory.prototype.go = function go(n) {\n    var this$1 = this;\n\n    var targetIndex = this.index + n;\n    if (targetIndex < 0 || targetIndex >= this.stack.length) {\n      return;\n    }\n    var route = this.stack[targetIndex];\n    this.confirmTransition(route, function () {\n      this$1.index = targetIndex;\n      this$1.updateRoute(route);\n    });\n  };\n\n  AbstractHistory.prototype.getCurrentLocation = function getCurrentLocation() {\n    var current = this.stack[this.stack.length - 1];\n    return current ? current.fullPath : '/';\n  };\n\n  AbstractHistory.prototype.ensureURL = function ensureURL() {\n    // noop\n  };\n\n  return AbstractHistory;\n}(History);\n\n/*  */\n\nvar VueRouter = function VueRouter(options) {\n  if (options === void 0) options = {};\n\n  this.app = null;\n  this.apps = [];\n  this.options = options;\n  this.beforeHooks = [];\n  this.resolveHooks = [];\n  this.afterHooks = [];\n  this.matcher = createMatcher(options.routes || [], this);\n\n  var mode = options.mode || 'hash';\n  this.fallback = mode === 'history' && !supportsPushState && options.fallback !== false;\n  if (this.fallback) {\n    mode = 'hash';\n  }\n  if (!inBrowser) {\n    mode = 'abstract';\n  }\n  this.mode = mode;\n\n  switch (mode) {\n    case 'history':\n      this.history = new HTML5History(this, options.base);\n      break;\n    case 'hash':\n      this.history = new HashHistory(this, options.base, this.fallback);\n      break;\n    case 'abstract':\n      this.history = new AbstractHistory(this, options.base);\n      break;\n    default:\n      if (process.env.NODE_ENV !== 'production') {\n        assert(false, \"invalid mode: \" + mode);\n      }\n  }\n};\n\nvar prototypeAccessors = { currentRoute: { configurable: true } };\n\nVueRouter.prototype.match = function match(raw, current, redirectedFrom) {\n  return this.matcher.match(raw, current, redirectedFrom);\n};\n\nprototypeAccessors.currentRoute.get = function () {\n  return this.history && this.history.current;\n};\n\nVueRouter.prototype.init = function init(app /* Vue component instance */) {\n  var this$1 = this;\n\n  process.env.NODE_ENV !== 'production' && assert(install.installed, \"not installed. Make sure to call `Vue.use(VueRouter)` \" + \"before creating root instance.\");\n\n  this.apps.push(app);\n\n  // main app already initialized.\n  if (this.app) {\n    return;\n  }\n\n  this.app = app;\n\n  var history = this.history;\n\n  if (history instanceof HTML5History) {\n    history.transitionTo(history.getCurrentLocation());\n  } else if (history instanceof HashHistory) {\n    var setupHashListener = function setupHashListener() {\n      history.setupListeners();\n    };\n    history.transitionTo(history.getCurrentLocation(), setupHashListener, setupHashListener);\n  }\n\n  history.listen(function (route) {\n    this$1.apps.forEach(function (app) {\n      app._route = route;\n    });\n  });\n};\n\nVueRouter.prototype.beforeEach = function beforeEach(fn) {\n  return registerHook(this.beforeHooks, fn);\n};\n\nVueRouter.prototype.beforeResolve = function beforeResolve(fn) {\n  return registerHook(this.resolveHooks, fn);\n};\n\nVueRouter.prototype.afterEach = function afterEach(fn) {\n  return registerHook(this.afterHooks, fn);\n};\n\nVueRouter.prototype.onReady = function onReady(cb, errorCb) {\n  this.history.onReady(cb, errorCb);\n};\n\nVueRouter.prototype.onError = function onError(errorCb) {\n  this.history.onError(errorCb);\n};\n\nVueRouter.prototype.push = function push(location, onComplete, onAbort) {\n  this.history.push(location, onComplete, onAbort);\n};\n\nVueRouter.prototype.replace = function replace(location, onComplete, onAbort) {\n  this.history.replace(location, onComplete, onAbort);\n};\n\nVueRouter.prototype.go = function go(n) {\n  this.history.go(n);\n};\n\nVueRouter.prototype.back = function back() {\n  this.go(-1);\n};\n\nVueRouter.prototype.forward = function forward() {\n  this.go(1);\n};\n\nVueRouter.prototype.getMatchedComponents = function getMatchedComponents(to) {\n  var route = to ? to.matched ? to : this.resolve(to).route : this.currentRoute;\n  if (!route) {\n    return [];\n  }\n  return [].concat.apply([], route.matched.map(function (m) {\n    return Object.keys(m.components).map(function (key) {\n      return m.components[key];\n    });\n  }));\n};\n\nVueRouter.prototype.resolve = function resolve(to, current, append) {\n  var location = normalizeLocation(to, current || this.history.current, append, this);\n  var route = this.match(location, current);\n  var fullPath = route.redirectedFrom || route.fullPath;\n  var base = this.history.base;\n  var href = createHref(base, fullPath, this.mode);\n  return {\n    location: location,\n    route: route,\n    href: href,\n    // for backwards compat\n    normalizedTo: location,\n    resolved: route\n  };\n};\n\nVueRouter.prototype.addRoutes = function addRoutes(routes) {\n  this.matcher.addRoutes(routes);\n  if (this.history.current !== START) {\n    this.history.transitionTo(this.history.getCurrentLocation());\n  }\n};\n\nObject.defineProperties(VueRouter.prototype, prototypeAccessors);\n\nfunction registerHook(list, fn) {\n  list.push(fn);\n  return function () {\n    var i = list.indexOf(fn);\n    if (i > -1) {\n      list.splice(i, 1);\n    }\n  };\n}\n\nfunction createHref(base, fullPath, mode) {\n  var path = mode === 'hash' ? '#' + fullPath : fullPath;\n  return base ? cleanPath(base + '/' + path) : path;\n}\n\nVueRouter.install = install;\nVueRouter.version = '2.8.1';\n\nif (inBrowser && window.Vue) {\n  window.Vue.use(VueRouter);\n}\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (VueRouter);\n/* WEBPACK VAR INJECTION */}.call(__webpack_exports__, __webpack_require__(43)))\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L192dWUtcm91dGVyQDIuOC4xQHZ1ZS1yb3V0ZXIvZGlzdC92dWUtcm91dGVyLmVzbS5qcz8xNmZlIl0sIm5hbWVzIjpbImFzc2VydCIsImNvbmRpdGlvbiIsIm1lc3NhZ2UiLCJFcnJvciIsIndhcm4iLCJwcm9jZXNzIiwiZW52IiwiTk9ERV9FTlYiLCJjb25zb2xlIiwiaXNFcnJvciIsImVyciIsIk9iamVjdCIsInByb3RvdHlwZSIsInRvU3RyaW5nIiwiY2FsbCIsImluZGV4T2YiLCJWaWV3IiwibmFtZSIsImZ1bmN0aW9uYWwiLCJwcm9wcyIsInR5cGUiLCJTdHJpbmciLCJkZWZhdWx0IiwicmVuZGVyIiwiXyIsInJlZiIsImNoaWxkcmVuIiwicGFyZW50IiwiZGF0YSIsInJvdXRlclZpZXciLCJoIiwiJGNyZWF0ZUVsZW1lbnQiLCJyb3V0ZSIsIiRyb3V0ZSIsImNhY2hlIiwiX3JvdXRlclZpZXdDYWNoZSIsImRlcHRoIiwiaW5hY3RpdmUiLCJfcm91dGVyUm9vdCIsIiR2bm9kZSIsIl9pbmFjdGl2ZSIsIiRwYXJlbnQiLCJyb3V0ZXJWaWV3RGVwdGgiLCJtYXRjaGVkIiwiY29tcG9uZW50IiwiY29tcG9uZW50cyIsInJlZ2lzdGVyUm91dGVJbnN0YW5jZSIsInZtIiwidmFsIiwiY3VycmVudCIsImluc3RhbmNlcyIsImhvb2siLCJwcmVwYXRjaCIsInZub2RlIiwiY29tcG9uZW50SW5zdGFuY2UiLCJwcm9wc1RvUGFzcyIsInJlc29sdmVQcm9wcyIsImV4dGVuZCIsImF0dHJzIiwia2V5IiwiY29uZmlnIiwicGFyYW1zIiwidW5kZWZpbmVkIiwicGF0aCIsInRvIiwiZnJvbSIsImVuY29kZVJlc2VydmVSRSIsImVuY29kZVJlc2VydmVSZXBsYWNlciIsImMiLCJjaGFyQ29kZUF0IiwiY29tbWFSRSIsImVuY29kZSIsInN0ciIsImVuY29kZVVSSUNvbXBvbmVudCIsInJlcGxhY2UiLCJkZWNvZGUiLCJkZWNvZGVVUklDb21wb25lbnQiLCJyZXNvbHZlUXVlcnkiLCJxdWVyeSIsImV4dHJhUXVlcnkiLCJfcGFyc2VRdWVyeSIsInBhcnNlIiwicGFyc2VRdWVyeSIsInBhcnNlZFF1ZXJ5IiwiZSIsInJlcyIsInRyaW0iLCJzcGxpdCIsImZvckVhY2giLCJwYXJhbSIsInBhcnRzIiwic2hpZnQiLCJsZW5ndGgiLCJqb2luIiwiQXJyYXkiLCJpc0FycmF5IiwicHVzaCIsInN0cmluZ2lmeVF1ZXJ5Iiwib2JqIiwia2V5cyIsIm1hcCIsInJlc3VsdCIsInZhbDIiLCJmaWx0ZXIiLCJ4IiwidHJhaWxpbmdTbGFzaFJFIiwiY3JlYXRlUm91dGUiLCJyZWNvcmQiLCJsb2NhdGlvbiIsInJlZGlyZWN0ZWRGcm9tIiwicm91dGVyIiwic3RyaW5naWZ5UXVlcnkkJDEiLCJvcHRpb25zIiwiY2xvbmUiLCJtZXRhIiwiaGFzaCIsImZ1bGxQYXRoIiwiZ2V0RnVsbFBhdGgiLCJmb3JtYXRNYXRjaCIsImZyZWV6ZSIsInZhbHVlIiwiU1RBUlQiLCJ1bnNoaWZ0IiwiX3N0cmluZ2lmeVF1ZXJ5Iiwic3RyaW5naWZ5IiwiaXNTYW1lUm91dGUiLCJhIiwiYiIsImlzT2JqZWN0RXF1YWwiLCJhS2V5cyIsImJLZXlzIiwiZXZlcnkiLCJhVmFsIiwiYlZhbCIsImlzSW5jbHVkZWRSb3V0ZSIsInRhcmdldCIsInF1ZXJ5SW5jbHVkZXMiLCJ0b1R5cGVzIiwiZXZlbnRUeXBlcyIsIkxpbmsiLCJyZXF1aXJlZCIsInRhZyIsImV4YWN0IiwiQm9vbGVhbiIsImFwcGVuZCIsImFjdGl2ZUNsYXNzIiwiZXhhY3RBY3RpdmVDbGFzcyIsImV2ZW50IiwidGhpcyQxIiwiJHJvdXRlciIsInJlc29sdmUiLCJocmVmIiwiY2xhc3NlcyIsImdsb2JhbEFjdGl2ZUNsYXNzIiwibGlua0FjdGl2ZUNsYXNzIiwiZ2xvYmFsRXhhY3RBY3RpdmVDbGFzcyIsImxpbmtFeGFjdEFjdGl2ZUNsYXNzIiwiYWN0aXZlQ2xhc3NGYWxsYmFjayIsImV4YWN0QWN0aXZlQ2xhc3NGYWxsYmFjayIsImNvbXBhcmVUYXJnZXQiLCJoYW5kbGVyIiwiZ3VhcmRFdmVudCIsIm9uIiwiY2xpY2siLCJjbGFzcyIsImZpbmRBbmNob3IiLCIkc2xvdHMiLCJpc1N0YXRpYyIsIl9WdWUiLCJ1dGlsIiwiYURhdGEiLCJhQXR0cnMiLCJtZXRhS2V5IiwiYWx0S2V5IiwiY3RybEtleSIsInNoaWZ0S2V5IiwiZGVmYXVsdFByZXZlbnRlZCIsImJ1dHRvbiIsImN1cnJlbnRUYXJnZXQiLCJnZXRBdHRyaWJ1dGUiLCJ0ZXN0IiwicHJldmVudERlZmF1bHQiLCJjaGlsZCIsImkiLCJpbnN0YWxsIiwiVnVlIiwiaW5zdGFsbGVkIiwiaXNEZWYiLCJ2IiwicmVnaXN0ZXJJbnN0YW5jZSIsImNhbGxWYWwiLCIkb3B0aW9ucyIsIl9wYXJlbnRWbm9kZSIsIm1peGluIiwiYmVmb3JlQ3JlYXRlIiwiX3JvdXRlciIsImluaXQiLCJkZWZpbmVSZWFjdGl2ZSIsImhpc3RvcnkiLCJkZXN0cm95ZWQiLCJkZWZpbmVQcm9wZXJ0eSIsImdldCIsIl9yb3V0ZSIsInN0cmF0cyIsIm9wdGlvbk1lcmdlU3RyYXRlZ2llcyIsImJlZm9yZVJvdXRlRW50ZXIiLCJiZWZvcmVSb3V0ZUxlYXZlIiwiYmVmb3JlUm91dGVVcGRhdGUiLCJjcmVhdGVkIiwiaW5Ccm93c2VyIiwid2luZG93IiwicmVzb2x2ZVBhdGgiLCJyZWxhdGl2ZSIsImJhc2UiLCJmaXJzdENoYXIiLCJjaGFyQXQiLCJzdGFjayIsInBvcCIsInNlZ21lbnRzIiwic2VnbWVudCIsInBhcnNlUGF0aCIsImhhc2hJbmRleCIsInNsaWNlIiwicXVlcnlJbmRleCIsImNsZWFuUGF0aCIsImlzYXJyYXkiLCJhcnIiLCJwYXRoVG9SZWdleHBfMSIsInBhdGhUb1JlZ2V4cCIsInBhcnNlXzEiLCJjb21waWxlXzEiLCJjb21waWxlIiwidG9rZW5zVG9GdW5jdGlvbl8xIiwidG9rZW5zVG9GdW5jdGlvbiIsInRva2Vuc1RvUmVnRXhwXzEiLCJ0b2tlbnNUb1JlZ0V4cCIsIlBBVEhfUkVHRVhQIiwiUmVnRXhwIiwidG9rZW5zIiwiaW5kZXgiLCJkZWZhdWx0RGVsaW1pdGVyIiwiZGVsaW1pdGVyIiwiZXhlYyIsIm0iLCJlc2NhcGVkIiwib2Zmc2V0IiwibmV4dCIsInByZWZpeCIsImNhcHR1cmUiLCJncm91cCIsIm1vZGlmaWVyIiwiYXN0ZXJpc2siLCJwYXJ0aWFsIiwicmVwZWF0Iiwib3B0aW9uYWwiLCJwYXR0ZXJuIiwiZXNjYXBlR3JvdXAiLCJlc2NhcGVTdHJpbmciLCJzdWJzdHIiLCJlbmNvZGVVUklDb21wb25lbnRQcmV0dHkiLCJlbmNvZGVVUkkiLCJ0b1VwcGVyQ2FzZSIsImVuY29kZUFzdGVyaXNrIiwibWF0Y2hlcyIsIm9wdHMiLCJwcmV0dHkiLCJ0b2tlbiIsIlR5cGVFcnJvciIsIkpTT04iLCJqIiwiYXR0YWNoS2V5cyIsInJlIiwiZmxhZ3MiLCJzZW5zaXRpdmUiLCJyZWdleHBUb1JlZ2V4cCIsImdyb3VwcyIsInNvdXJjZSIsIm1hdGNoIiwiYXJyYXlUb1JlZ2V4cCIsInJlZ2V4cCIsInN0cmluZ1RvUmVnZXhwIiwic3RyaWN0IiwiZW5kIiwiZW5kc1dpdGhEZWxpbWl0ZXIiLCJyZWdleHBDb21waWxlQ2FjaGUiLCJjcmVhdGUiLCJmaWxsUGFyYW1zIiwicm91dGVNc2ciLCJmaWxsZXIiLCJjcmVhdGVSb3V0ZU1hcCIsInJvdXRlcyIsIm9sZFBhdGhMaXN0Iiwib2xkUGF0aE1hcCIsIm9sZE5hbWVNYXAiLCJwYXRoTGlzdCIsInBhdGhNYXAiLCJuYW1lTWFwIiwiYWRkUm91dGVSZWNvcmQiLCJsIiwic3BsaWNlIiwibWF0Y2hBcyIsInBhdGhUb1JlZ2V4cE9wdGlvbnMiLCJub3JtYWxpemVkUGF0aCIsIm5vcm1hbGl6ZVBhdGgiLCJjYXNlU2Vuc2l0aXZlIiwicmVnZXgiLCJjb21waWxlUm91dGVSZWdleCIsInJlZGlyZWN0IiwiYmVmb3JlRW50ZXIiLCJzb21lIiwiY2hpbGRNYXRjaEFzIiwiYWxpYXMiLCJhbGlhc2VzIiwiYWxpYXNSb3V0ZSIsIm5vcm1hbGl6ZUxvY2F0aW9uIiwicmF3IiwiX25vcm1hbGl6ZWQiLCJhc3NpZ24iLCJyYXdQYXRoIiwicGFyc2VkUGF0aCIsImJhc2VQYXRoIiwiY3JlYXRlTWF0Y2hlciIsImFkZFJvdXRlcyIsImN1cnJlbnRSb3V0ZSIsIl9jcmVhdGVSb3V0ZSIsInBhcmFtTmFtZXMiLCJyZWNvcmQkMSIsIm1hdGNoUm91dGUiLCJvcmlnaW5hbFJlZGlyZWN0IiwiaGFzT3duUHJvcGVydHkiLCJ0YXJnZXRSZWNvcmQiLCJyZXNvbHZlUmVjb3JkUGF0aCIsInJlc29sdmVkUGF0aCIsImFsaWFzZWRQYXRoIiwiYWxpYXNlZE1hdGNoIiwiYWxpYXNlZFJlY29yZCIsImxlbiIsInBvc2l0aW9uU3RvcmUiLCJzZXR1cFNjcm9sbCIsInJlcGxhY2VTdGF0ZSIsImdldFN0YXRlS2V5IiwiYWRkRXZlbnRMaXN0ZW5lciIsInNhdmVTY3JvbGxQb3NpdGlvbiIsInN0YXRlIiwic2V0U3RhdGVLZXkiLCJoYW5kbGVTY3JvbGwiLCJpc1BvcCIsImFwcCIsImJlaGF2aW9yIiwic2Nyb2xsQmVoYXZpb3IiLCIkbmV4dFRpY2siLCJwb3NpdGlvbiIsImdldFNjcm9sbFBvc2l0aW9uIiwic2hvdWxkU2Nyb2xsIiwidGhlbiIsInNjcm9sbFRvUG9zaXRpb24iLCJjYXRjaCIsInBhZ2VYT2Zmc2V0IiwieSIsInBhZ2VZT2Zmc2V0IiwiZ2V0RWxlbWVudFBvc2l0aW9uIiwiZWwiLCJkb2NFbCIsImRvY3VtZW50IiwiZG9jdW1lbnRFbGVtZW50IiwiZG9jUmVjdCIsImdldEJvdW5kaW5nQ2xpZW50UmVjdCIsImVsUmVjdCIsImxlZnQiLCJ0b3AiLCJpc1ZhbGlkUG9zaXRpb24iLCJpc051bWJlciIsIm5vcm1hbGl6ZVBvc2l0aW9uIiwibm9ybWFsaXplT2Zmc2V0IiwiaXNPYmplY3QiLCJzZWxlY3RvciIsInF1ZXJ5U2VsZWN0b3IiLCJzY3JvbGxUbyIsInN1cHBvcnRzUHVzaFN0YXRlIiwidWEiLCJuYXZpZ2F0b3IiLCJ1c2VyQWdlbnQiLCJUaW1lIiwicGVyZm9ybWFuY2UiLCJub3ciLCJEYXRlIiwiX2tleSIsImdlbktleSIsInRvRml4ZWQiLCJwdXNoU3RhdGUiLCJ1cmwiLCJydW5RdWV1ZSIsInF1ZXVlIiwiZm4iLCJjYiIsInN0ZXAiLCJyZXNvbHZlQXN5bmNDb21wb25lbnRzIiwiaGFzQXN5bmMiLCJwZW5kaW5nIiwiZXJyb3IiLCJmbGF0TWFwQ29tcG9uZW50cyIsImRlZiIsImNpZCIsIm9uY2UiLCJyZXNvbHZlZERlZiIsImlzRVNNb2R1bGUiLCJyZXNvbHZlZCIsInJlamVjdCIsInJlYXNvbiIsIm1zZyIsImNvbXAiLCJmbGF0dGVuIiwiY29uY2F0IiwiYXBwbHkiLCJoYXNTeW1ib2wiLCJTeW1ib2wiLCJ0b1N0cmluZ1RhZyIsIl9fZXNNb2R1bGUiLCJjYWxsZWQiLCJhcmdzIiwiYXJndW1lbnRzIiwiSGlzdG9yeSIsIm5vcm1hbGl6ZUJhc2UiLCJyZWFkeSIsInJlYWR5Q2JzIiwicmVhZHlFcnJvckNicyIsImVycm9yQ2JzIiwibGlzdGVuIiwib25SZWFkeSIsImVycm9yQ2IiLCJvbkVycm9yIiwidHJhbnNpdGlvblRvIiwib25Db21wbGV0ZSIsIm9uQWJvcnQiLCJjb25maXJtVHJhbnNpdGlvbiIsInVwZGF0ZVJvdXRlIiwiZW5zdXJlVVJMIiwiYWJvcnQiLCJyZXNvbHZlUXVldWUiLCJ1cGRhdGVkIiwiZGVhY3RpdmF0ZWQiLCJhY3RpdmF0ZWQiLCJleHRyYWN0TGVhdmVHdWFyZHMiLCJiZWZvcmVIb29rcyIsImV4dHJhY3RVcGRhdGVIb29rcyIsIml0ZXJhdG9yIiwicG9zdEVudGVyQ2JzIiwiaXNWYWxpZCIsImVudGVyR3VhcmRzIiwiZXh0cmFjdEVudGVyR3VhcmRzIiwicmVzb2x2ZUhvb2tzIiwicHJldiIsImFmdGVySG9va3MiLCJiYXNlRWwiLCJtYXgiLCJNYXRoIiwiZXh0cmFjdEd1YXJkcyIsInJlY29yZHMiLCJiaW5kIiwicmV2ZXJzZSIsImd1YXJkcyIsImluc3RhbmNlIiwiZ3VhcmQiLCJleHRyYWN0R3VhcmQiLCJiaW5kR3VhcmQiLCJib3VuZFJvdXRlR3VhcmQiLCJjYnMiLCJiaW5kRW50ZXJHdWFyZCIsInJvdXRlRW50ZXJHdWFyZCIsInBvbGwiLCJzZXRUaW1lb3V0IiwiSFRNTDVIaXN0b3J5IiwiSGlzdG9yeSQkMSIsImV4cGVjdFNjcm9sbCIsImluaXRMb2NhdGlvbiIsImdldExvY2F0aW9uIiwiX19wcm90b19fIiwiY29uc3RydWN0b3IiLCJnbyIsIm4iLCJmcm9tUm91dGUiLCJnZXRDdXJyZW50TG9jYXRpb24iLCJwYXRobmFtZSIsInNlYXJjaCIsIkhhc2hIaXN0b3J5IiwiZmFsbGJhY2siLCJjaGVja0ZhbGxiYWNrIiwiZW5zdXJlU2xhc2giLCJzZXR1cExpc3RlbmVycyIsInN1cHBvcnRzU2Nyb2xsIiwiZ2V0SGFzaCIsInJlcGxhY2VIYXNoIiwicHVzaEhhc2giLCJnZXRVcmwiLCJBYnN0cmFjdEhpc3RvcnkiLCJ0YXJnZXRJbmRleCIsIlZ1ZVJvdXRlciIsImFwcHMiLCJtYXRjaGVyIiwibW9kZSIsInByb3RvdHlwZUFjY2Vzc29ycyIsImNvbmZpZ3VyYWJsZSIsInNldHVwSGFzaExpc3RlbmVyIiwiYmVmb3JlRWFjaCIsInJlZ2lzdGVySG9vayIsImJlZm9yZVJlc29sdmUiLCJhZnRlckVhY2giLCJiYWNrIiwiZm9yd2FyZCIsImdldE1hdGNoZWRDb21wb25lbnRzIiwiY3JlYXRlSHJlZiIsIm5vcm1hbGl6ZWRUbyIsImRlZmluZVByb3BlcnRpZXMiLCJsaXN0IiwidmVyc2lvbiIsInVzZSJdLCJtYXBwaW5ncyI6Ijs7O0FBQUE7Ozs7O0FBS0E7O0FBRUEsU0FBU0EsTUFBVCxDQUFpQkMsU0FBakIsRUFBNEJDLE9BQTVCLEVBQXFDO0FBQ25DLE1BQUksQ0FBQ0QsU0FBTCxFQUFnQjtBQUNkLFVBQU0sSUFBSUUsS0FBSixDQUFXLGtCQUFrQkQsT0FBN0IsQ0FBTjtBQUNEO0FBQ0Y7O0FBRUQsU0FBU0UsSUFBVCxDQUFlSCxTQUFmLEVBQTBCQyxPQUExQixFQUFtQztBQUNqQyxNQUFJRyxRQUFRQyxHQUFS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QnpTLElBQXJCLEVBQTJCakcsUUFBM0IsRUFBcUMrWCxJQUFyQyxFQUEyQztBQUN6QyxNQUFJcGIsT0FBT29iLFNBQVMsTUFBVCxHQUFrQixNQUFNL1gsUUFBeEIsR0FBbUNBLFFBQTlDO0FBQ0EsU0FBT2lHLE9BQU9XLFVBQVVYLE9BQU8sR0FBUCxHQUFhdEosSUFBdkIsQ0FBUCxHQUFzQ0EsSUFBN0M7QUFDRDs7QUFFRGliLFVBQVV4VCxPQUFWLEdBQW9CQSxPQUFwQjtBQUNBd1QsVUFBVWtCLE9BQVYsR0FBb0IsT0FBcEI7O0FBRUEsSUFBSWpULGFBQWFDLE9BQU96QixHQUF4QixFQUE2QjtBQUMzQnlCLFNBQU96QixHQUFQLENBQVcwVSxHQUFYLENBQWVuQixTQUFmO0FBQ0Q7O0FBRUQsK0RBQWVBLFNBQWYsRSIsImZpbGUiOiI5OS5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICAqIHZ1ZS1yb3V0ZXIgdjIuOC4xXG4gICogKGMpIDIwMTcgRXZhbiBZb3VcbiAgKiBAbGljZW5zZSBNSVRcbiAgKi9cbi8qICAqL1xuXG5mdW5jdGlvbiBhc3NlcnQgKGNvbmRpdGlvbiwgbWVzc2FnZSkge1xuICBpZiAoIWNvbmRpdGlvbikge1xuICAgIHRocm93IG5ldyBFcnJvcigoXCJbdnVlLXJvdXRlcl0gXCIgKyBtZXNzYWdlKSlcbiAgfVxufVxuXG5mdW5jdGlvbiB3YXJuIChjb25kaXRpb24sIG1lc3NhZ2UpIHtcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgIWNvbmRpdGlvbikge1xuICAgIHR5cGVvZiBjb25zb2xlICE9PSAndW5kZWZpbmVkJyAmJiBjb25zb2xlLndhcm4oKFwiW3Z1ZS1yb3V0ZXJdIFwiICsgbWVzc2FnZSkpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGlzRXJyb3IgKGVycikge1xuICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKGVycikuaW5kZXhPZignRXJyb3InKSA+IC0xXG59XG5cbnZhciBWaWV3ID0ge1xuICBuYW1lOiAncm91dGVyLXZpZXcnLFxuICBmdW5jdGlvbmFsOiB0cnVlLFxuICBwcm9wczoge1xuICAgIG5hbWU6IHtcbiAgICAgIHR5cGU6IFN0cmluZyxcbiAgICAgIGRlZmF1bHQ6ICdkZWZhdWx0J1xuICAgIH1cbiAgfSxcbiAgcmVuZGVyOiBmdW5jdGlvbiByZW5kZXIgKF8sIHJlZikge1xuICAgIHZhciBwcm9wcyA9IHJlZi5wcm9wcztcbiAgICB2YXIgY2hpbGRyZW4gPSByZWYuY2hpbGRyZW47XG4gICAgdmFyIHBhcmVudCA9IHJlZi5wYXJlbnQ7XG4gICAgdmFyIGRhdGEgPSByZWYuZGF0YTtcblxuICAgIGRhdGEucm91dGVyVmlldyA9IHRydWU7XG5cbiAgICAvLyBkaXJlY3RseSB1c2UgcGFyZW50IGNvbnRleHQncyBjcmVhdGVFbGVtZW50KCkgZnVuY3Rpb25cbiAgICAvLyBzbyB0aGF0IGNvbXBvbmVudHMgcmVuZGVyZWQgYnkgcm91dGVyLXZpZXcgY2FuIHJlc29sdmUgbmFtZWQgc2xvdHNcbiAgICB2YXIgaCA9IHBhcmVudC4kY3JlYXRlRWxlbWVudDtcbiAgICB2YXIgbmFtZSA9IHByb3BzLm5hbWU7XG4gICAgdmFyIHJvdXRlID0gcGFyZW50LiRyb3V0ZTtcbiAgICB2YXIgY2FjaGUgPSBwYXJlbnQuX3JvdXRlclZpZXdDYWNoZSB8fCAocGFyZW50Ll9yb3V0ZXJWaWV3Q2FjaGUgPSB7fSk7XG5cbiAgICAvLyBkZXRlcm1pbmUgY3VycmVudCB2aWV3IGRlcHRoLCBhbHNvIGNoZWNrIHRvIHNlZSBpZiB0aGUgdHJlZVxuICAgIC8vIGhhcyBiZWVuIHRvZ2dsZWQgaW5hY3RpdmUgYnV0IGtlcHQtYWxpdmUuXG4gICAgdmFyIGRlcHRoID0gMDtcbiAgICB2YXIgaW5hY3RpdmUgPSBmYWxzZTtcbiAgICB3aGlsZSAocGFyZW50ICYmIHBhcmVudC5fcm91dGVyUm9vdCAhPT0gcGFyZW50KSB7XG4gICAgICBpZiAocGFyZW50LiR2bm9kZSAmJiBwYXJlbnQuJHZub2RlLmRhdGEucm91dGVyVmlldykge1xuICAgICAgICBkZXB0aCsrO1xuICAgICAgfVxuICAgICAgaWYgKHBhcmVudC5faW5hY3RpdmUpIHtcbiAgICAgICAgaW5hY3RpdmUgPSB0cnVlO1xuICAgICAgfVxuICAgICAgcGFyZW50ID0gcGFyZW50LiRwYXJlbnQ7XG4gICAgfVxuICAgIGRhdGEucm91dGVyVmlld0RlcHRoID0gZGVwdGg7XG5cbiAgICAvLyByZW5kZXIgcHJldmlvdXMgdmlldyBpZiB0aGUgdHJlZSBpcyBpbmFjdGl2ZSBhbmQga2VwdC1hbGl2ZVxuICAgIGlmIChpbmFjdGl2ZSkge1xuICAgICAgcmV0dXJuIGgoY2FjaGVbbmFtZV0sIGRhdGEsIGNoaWxkcmVuKVxuICAgIH1cblxuICAgIHZhciBtYXRjaGVkID0gcm91dGUubWF0Y2hlZFtkZXB0aF07XG4gICAgLy8gcmVuZGVyIGVtcHR5IG5vZGUgaWYgbm8gbWF0Y2hlZCByb3V0ZVxuICAgIGlmICghbWF0Y2hlZCkge1xuICAgICAgY2FjaGVbbmFtZV0gPSBudWxsO1xuICAgICAgcmV0dXJuIGgoKVxuICAgIH1cblxuICAgIHZhciBjb21wb25lbnQgPSBjYWNoZVtuYW1lXSA9IG1hdGNoZWQuY29tcG9uZW50c1tuYW1lXTtcblxuICAgIC8vIGF0dGFjaCBpbnN0YW5jZSByZWdpc3RyYXRpb24gaG9va1xuICAgIC8vIHRoaXMgd2lsbCBiZSBjYWxsZWQgaW4gdGhlIGluc3RhbmNlJ3MgaW5qZWN0ZWQgbGlmZWN5Y2xlIGhvb2tzXG4gICAgZGF0YS5yZWdpc3RlclJvdXRlSW5zdGFuY2UgPSBmdW5jdGlvbiAodm0sIHZhbCkge1xuICAgICAgLy8gdmFsIGNvdWxkIGJlIHVuZGVmaW5lZCBmb3IgdW5yZWdpc3RyYXRpb25cbiAgICAgIHZhciBjdXJyZW50ID0gbWF0Y2hlZC5pbnN0YW5jZXNbbmFtZV07XG4gICAgICBpZiAoXG4gICAgICAgICh2YWwgJiYgY3VycmVudCAhPT0gdm0pIHx8XG4gICAgICAgICghdmFsICYmIGN1cnJlbnQgPT09IHZtKVxuICAgICAgKSB7XG4gICAgICAgIG1hdGNoZWQuaW5zdGFuY2VzW25hbWVdID0gdmFsO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIGFsc28gcmVnaXN0ZXIgaW5zdGFuY2UgaW4gcHJlcGF0Y2ggaG9va1xuICAgIC8vIGluIGNhc2UgdGhlIHNhbWUgY29tcG9uZW50IGluc3RhbmNlIGlzIHJldXNlZCBhY3Jvc3MgZGlmZmVyZW50IHJvdXRlc1xuICAgIDsoZGF0YS5ob29rIHx8IChkYXRhLmhvb2sgPSB7fSkpLnByZXBhdGNoID0gZnVuY3Rpb24gKF8sIHZub2RlKSB7XG4gICAgICBtYXRjaGVkLmluc3RhbmNlc1tuYW1lXSA9IHZub2RlLmNvbXBvbmVudEluc3RhbmNlO1xuICAgIH07XG5cbiAgICAvLyByZXNvbHZlIHByb3BzXG4gICAgdmFyIHByb3BzVG9QYXNzID0gZGF0YS5wcm9wcyA9IHJlc29sdmVQcm9wcyhyb3V0ZSwgbWF0Y2hlZC5wcm9wcyAmJiBtYXRjaGVkLnByb3BzW25hbWVdKTtcbiAgICBpZiAocHJvcHNUb1Bhc3MpIHtcbiAgICAgIC8vIGNsb25lIHRvIHByZXZlbnQgbXV0YXRpb25cbiAgICAgIHByb3BzVG9QYXNzID0gZGF0YS5wcm9wcyA9IGV4dGVuZCh7fSwgcHJvcHNUb1Bhc3MpO1xuICAgICAgLy8gcGFzcyBub24tZGVjbGFyZWQgcHJvcHMgYXMgYXR0cnNcbiAgICAgIHZhciBhdHRycyA9IGRhdGEuYXR0cnMgPSBkYXRhLmF0dHJzIHx8IHt9O1xuICAgICAgZm9yICh2YXIga2V5IGluIHByb3BzVG9QYXNzKSB7XG4gICAgICAgIGlmICghY29tcG9uZW50LnByb3BzIHx8ICEoa2V5IGluIGNvbXBvbmVudC5wcm9wcykpIHtcbiAgICAgICAgICBhdHRyc1trZXldID0gcHJvcHNUb1Bhc3Nba2V5XTtcbiAgICAgICAgICBkZWxldGUgcHJvcHNUb1Bhc3Nba2V5XTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBoKGNvbXBvbmVudCwgZGF0YSwgY2hpbGRyZW4pXG4gIH1cbn07XG5cbmZ1bmN0aW9uIHJlc29sdmVQcm9wcyAocm91dGUsIGNvbmZpZykge1xuICBzd2l0Y2ggKHR5cGVvZiBjb25maWcpIHtcbiAgICBjYXNlICd1bmRlZmluZWQnOlxuICAgICAgcmV0dXJuXG4gICAgY2FzZSAnb2JqZWN0JzpcbiAgICAgIHJldHVybiBjb25maWdcbiAgICBjYXNlICdmdW5jdGlvbic6XG4gICAgICByZXR1cm4gY29uZmlnKHJvdXRlKVxuICAgIGNhc2UgJ2Jvb2xlYW4nOlxuICAgICAgcmV0dXJuIGNvbmZpZyA/IHJvdXRlLnBhcmFtcyA6IHVuZGVmaW5lZFxuICAgIGRlZmF1bHQ6XG4gICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICB3YXJuKFxuICAgICAgICAgIGZhbHNlLFxuICAgICAgICAgIFwicHJvcHMgaW4gXFxcIlwiICsgKHJvdXRlLnBhdGgpICsgXCJcXFwiIGlzIGEgXCIgKyAodHlwZW9mIGNvbmZpZykgKyBcIiwgXCIgK1xuICAgICAgICAgIFwiZXhwZWN0aW5nIGFuIG9iamVjdCwgZnVuY3Rpb24gb3IgYm9vbGVhbi5cIlxuICAgICAgICApO1xuICAgICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGV4dGVuZCAodG8sIGZyb20pIHtcbiAgZm9yICh2YXIga2V5IGluIGZyb20pIHtcbiAgICB0b1trZXldID0gZnJvbVtrZXldO1xuICB9XG4gIHJldHVybiB0b1xufVxuXG4vKiAgKi9cblxudmFyIGVuY29kZVJlc2VydmVSRSA9IC9bIScoKSpdL2c7XG52YXIgZW5jb2RlUmVzZXJ2ZVJlcGxhY2VyID0gZnVuY3Rpb24gKGMpIHsgcmV0dXJuICclJyArIGMuY2hhckNvZGVBdCgwKS50b1N0cmluZygxNik7IH07XG52YXIgY29tbWFSRSA9IC8lMkMvZztcblxuLy8gZml4ZWQgZW5jb2RlVVJJQ29tcG9uZW50IHdoaWNoIGlzIG1vcmUgY29uZm9ybWFudCB0byBSRkMzOTg2OlxuLy8gLSBlc2NhcGVzIFshJygpKl1cbi8vIC0gcHJlc2VydmUgY29tbWFzXG52YXIgZW5jb2RlID0gZnVuY3Rpb24gKHN0cikgeyByZXR1cm4gZW5jb2RlVVJJQ29tcG9uZW50KHN0cilcbiAgLnJlcGxhY2UoZW5jb2RlUmVzZXJ2ZVJFLCBlbmNvZGVSZXNlcnZlUmVwbGFjZXIpXG4gIC5yZXBsYWNlKGNvbW1hUkUsICcsJyk7IH07XG5cbnZhciBkZWNvZGUgPSBkZWNvZGVVUklDb21wb25lbnQ7XG5cbmZ1bmN0aW9uIHJlc29sdmVRdWVyeSAoXG4gIHF1ZXJ5LFxuICBleHRyYVF1ZXJ5LFxuICBfcGFyc2VRdWVyeVxuKSB7XG4gIGlmICggZXh0cmFRdWVyeSA9PT0gdm9pZCAwICkgZXh0cmFRdWVyeSA9IHt9O1xuXG4gIHZhciBwYXJzZSA9IF9wYXJzZVF1ZXJ5IHx8IHBhcnNlUXVlcnk7XG4gIHZhciBwYXJzZWRRdWVyeTtcbiAgdHJ5IHtcbiAgICBwYXJzZWRRdWVyeSA9IHBhcnNlKHF1ZXJ5IHx8ICcnKTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgd2FybihmYWxzZSwgZS5tZXNzYWdlKTtcbiAgICBwYXJzZWRRdWVyeSA9IHt9O1xuICB9XG4gIGZvciAodmFyIGtleSBpbiBleHRyYVF1ZXJ5KSB7XG4gICAgcGFyc2VkUXVlcnlba2V5XSA9IGV4dHJhUXVlcnlba2V5XTtcbiAgfVxuICByZXR1cm4gcGFyc2VkUXVlcnlcbn1cblxuZnVuY3Rpb24gcGFyc2VRdWVyeSAocXVlcnkpIHtcbiAgdmFyIHJlcyA9IHt9O1xuXG4gIHF1ZXJ5ID0gcXVlcnkudHJpbSgpLnJlcGxhY2UoL14oXFw/fCN8JikvLCAnJyk7XG5cbiAgaWYgKCFxdWVyeSkge1xuICAgIHJldHVybiByZXNcbiAgfVxuXG4gIHF1ZXJ5LnNwbGl0KCcmJykuZm9yRWFjaChmdW5jdGlvbiAocGFyYW0pIHtcbiAgICB2YXIgcGFydHMgPSBwYXJhbS5yZXBsYWNlKC9cXCsvZywgJyAnKS5zcGxpdCgnPScpO1xuICAgIHZhciBrZXkgPSBkZWNvZGUocGFydHMuc2hpZnQoKSk7XG4gICAgdmFyIHZhbCA9IHBhcnRzLmxlbmd0aCA+IDBcbiAgICAgID8gZGVjb2RlKHBhcnRzLmpvaW4oJz0nKSlcbiAgICAgIDogbnVsbDtcblxuICAgIGlmIChyZXNba2V5XSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXNba2V5XSA9IHZhbDtcbiAgICB9IGVsc2UgaWYgKEFycmF5LmlzQXJyYXkocmVzW2tleV0pKSB7XG4gICAgICByZXNba2V5XS5wdXNoKHZhbCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlc1trZXldID0gW3Jlc1trZXldLCB2YWxdO1xuICAgIH1cbiAgfSk7XG5cbiAgcmV0dXJuIHJlc1xufVxuXG5mdW5jdGlvbiBzdHJpbmdpZnlRdWVyeSAob2JqKSB7XG4gIHZhciByZXMgPSBvYmogPyBPYmplY3Qua2V5cyhvYmopLm1hcChmdW5jdGlvbiAoa2V5KSB7XG4gICAgdmFyIHZhbCA9IG9ialtrZXldO1xuXG4gICAgaWYgKHZhbCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm4gJydcbiAgICB9XG5cbiAgICBpZiAodmFsID09PSBudWxsKSB7XG4gICAgICByZXR1cm4gZW5jb2RlKGtleSlcbiAgICB9XG5cbiAgICBpZiAoQXJyYXkuaXNBcnJheSh2YWwpKSB7XG4gICAgICB2YXIgcmVzdWx0ID0gW107XG4gICAgICB2YWwuZm9yRWFjaChmdW5jdGlvbiAodmFsMikge1xuICAgICAgICBpZiAodmFsMiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgcmV0dXJuXG4gICAgICAgIH1cbiAgICAgICAgaWYgKHZhbDIgPT09IG51bGwpIHtcbiAgICAgICAgICByZXN1bHQucHVzaChlbmNvZGUoa2V5KSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmVzdWx0LnB1c2goZW5jb2RlKGtleSkgKyAnPScgKyBlbmNvZGUodmFsMikpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIHJldHVybiByZXN1bHQuam9pbignJicpXG4gICAgfVxuXG4gICAgcmV0dXJuIGVuY29kZShrZXkpICsgJz0nICsgZW5jb2RlKHZhbClcbiAgfSkuZmlsdGVyKGZ1bmN0aW9uICh4KSB7IHJldHVybiB4Lmxlbmd0aCA+IDA7IH0pLmpvaW4oJyYnKSA6IG51bGw7XG4gIHJldHVybiByZXMgPyAoXCI/XCIgKyByZXMpIDogJydcbn1cblxuLyogICovXG5cblxudmFyIHRyYWlsaW5nU2xhc2hSRSA9IC9cXC8/JC87XG5cbmZ1bmN0aW9uIGNyZWF0ZVJvdXRlIChcbiAgcmVjb3JkLFxuICBsb2NhdGlvbixcbiAgcmVkaXJlY3RlZEZyb20sXG4gIHJvdXRlclxuKSB7XG4gIHZhciBzdHJpbmdpZnlRdWVyeSQkMSA9IHJvdXRlciAmJiByb3V0ZXIub3B0aW9ucy5zdHJpbmdpZnlRdWVyeTtcblxuICB2YXIgcXVlcnkgPSBsb2NhdGlvbi5xdWVyeSB8fCB7fTtcbiAgdHJ5IHtcbiAgICBxdWVyeSA9IGNsb25lKHF1ZXJ5KTtcbiAgfSBjYXRjaCAoZSkge31cblxuICB2YXIgcm91dGUgPSB7XG4gICAgbmFtZTogbG9jYXRpb24ubmFtZSB8fCAocmVjb3JkICYmIHJlY29yZC5uYW1lKSxcbiAgICBtZXRhOiAocmVjb3JkICYmIHJlY29yZC5tZXRhKSB8fCB7fSxcbiAgICBwYXRoOiBsb2NhdGlvbi5wYXRoIHx8ICcvJyxcbiAgICBoYXNoOiBsb2NhdGlvbi5oYXNoIHx8ICcnLFxuICAgIHF1ZXJ5OiBxdWVyeSxcbiAgICBwYXJhbXM6IGxvY2F0aW9uLnBhcmFtcyB8fCB7fSxcbiAgICBmdWxsUGF0aDogZ2V0RnVsbFBhdGgobG9jYXRpb24sIHN0cmluZ2lmeVF1ZXJ5JCQxKSxcbiAgICBtYXRjaGVkOiByZWNvcmQgPyBmb3JtYXRNYXRjaChyZWNvcmQpIDogW11cbiAgfTtcbiAgaWYgKHJlZGlyZWN0ZWRGcm9tKSB7XG4gICAgcm91dGUucmVkaXJlY3RlZEZyb20gPSBnZXRGdWxsUGF0aChyZWRpcmVjdGVkRnJvbSwgc3RyaW5naWZ5UXVlcnkkJDEpO1xuICB9XG4gIHJldHVybiBPYmplY3QuZnJlZXplKHJvdXRlKVxufVxuXG5mdW5jdGlvbiBjbG9uZSAodmFsdWUpIHtcbiAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgcmV0dXJuIHZhbHVlLm1hcChjbG9uZSlcbiAgfSBlbHNlIGlmICh2YWx1ZSAmJiB0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnKSB7XG4gICAgdmFyIHJlcyA9IHt9O1xuICAgIGZvciAodmFyIGtleSBpbiB2YWx1ZSkge1xuICAgICAgcmVzW2tleV0gPSBjbG9uZSh2YWx1ZVtrZXldKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc1xuICB9IGVsc2Uge1xuICAgIHJldHVybiB2YWx1ZVxuICB9XG59XG5cbi8vIHRoZSBzdGFydGluZyByb3V0ZSB0aGF0IHJlcHJlc2VudHMgdGhlIGluaXRpYWwgc3RhdGVcbnZhciBTVEFSVCA9IGNyZWF0ZVJvdXRlKG51bGwsIHtcbiAgcGF0aDogJy8nXG59KTtcblxuZnVuY3Rpb24gZm9ybWF0TWF0Y2ggKHJlY29yZCkge1xuICB2YXIgcmVzID0gW107XG4gIHdoaWxlIChyZWNvcmQpIHtcbiAgICByZXMudW5zaGlmdChyZWNvcmQpO1xuICAgIHJlY29yZCA9IHJlY29yZC5wYXJlbnQ7XG4gIH1cbiAgcmV0dXJuIHJlc1xufVxuXG5mdW5jdGlvbiBnZXRGdWxsUGF0aCAoXG4gIHJlZixcbiAgX3N0cmluZ2lmeVF1ZXJ5XG4pIHtcbiAgdmFyIHBhdGggPSByZWYucGF0aDtcbiAgdmFyIHF1ZXJ5ID0gcmVmLnF1ZXJ5OyBpZiAoIHF1ZXJ5ID09PSB2b2lkIDAgKSBxdWVyeSA9IHt9O1xuICB2YXIgaGFzaCA9IHJlZi5oYXNoOyBpZiAoIGhhc2ggPT09IHZvaWQgMCApIGhhc2ggPSAnJztcblxuICB2YXIgc3RyaW5naWZ5ID0gX3N0cmluZ2lmeVF1ZXJ5IHx8IHN0cmluZ2lmeVF1ZXJ5O1xuICByZXR1cm4gKHBhdGggfHwgJy8nKSArIHN0cmluZ2lmeShxdWVyeSkgKyBoYXNoXG59XG5cbmZ1bmN0aW9uIGlzU2FtZVJvdXRlIChhLCBiKSB7XG4gIGlmIChiID09PSBTVEFSVCkge1xuICAgIHJldHVybiBhID09PSBiXG4gIH0gZWxzZSBpZiAoIWIpIHtcbiAgICByZXR1cm4gZmFsc2VcbiAgfSBlbHNlIGlmIChhLnBhdGggJiYgYi5wYXRoKSB7XG4gICAgcmV0dXJuIChcbiAgICAgIGEucGF0aC5yZXBsYWNlKHRyYWlsaW5nU2xhc2hSRSwgJycpID09PSBiLnBhdGgucmVwbGFjZSh0cmFpbGluZ1NsYXNoUkUsICcnKSAmJlxuICAgICAgYS5oYXNoID09PSBiLmhhc2ggJiZcbiAgICAgIGlzT2JqZWN0RXF1YWwoYS5xdWVyeSwgYi5xdWVyeSlcbiAgICApXG4gIH0gZWxzZSBpZiAoYS5uYW1lICYmIGIubmFtZSkge1xuICAgIHJldHVybiAoXG4gICAgICBhLm5hbWUgPT09IGIubmFtZSAmJlxuICAgICAgYS5oYXNoID09PSBiLmhhc2ggJiZcbiAgICAgIGlzT2JqZWN0RXF1YWwoYS5xdWVyeSwgYi5xdWVyeSkgJiZcbiAgICAgIGlzT2JqZWN0RXF1YWwoYS5wYXJhbXMsIGIucGFyYW1zKVxuICAgIClcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gZmFsc2VcbiAgfVxufVxuXG5mdW5jdGlvbiBpc09iamVjdEVxdWFsIChhLCBiKSB7XG4gIGlmICggYSA9PT0gdm9pZCAwICkgYSA9IHt9O1xuICBpZiAoIGIgPT09IHZvaWQgMCApIGIgPSB7fTtcblxuICAvLyBoYW5kbGUgbnVsbCB2YWx1ZSAjMTU2NlxuICBpZiAoIWEgfHwgIWIpIHsgcmV0dXJuIGEgPT09IGIgfVxuICB2YXIgYUtleXMgPSBPYmplY3Qua2V5cyhhKTtcbiAgdmFyIGJLZXlzID0gT2JqZWN0LmtleXMoYik7XG4gIGlmIChhS2V5cy5sZW5ndGggIT09IGJLZXlzLmxlbmd0aCkge1xuICAgIHJldHVybiBmYWxzZVxuICB9XG4gIHJldHVybiBhS2V5cy5ldmVyeShmdW5jdGlvbiAoa2V5KSB7XG4gICAgdmFyIGFWYWwgPSBhW2tleV07XG4gICAgdmFyIGJWYWwgPSBiW2tleV07XG4gICAgLy8gY2hlY2sgbmVzdGVkIGVxdWFsaXR5XG4gICAgaWYgKHR5cGVvZiBhVmFsID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgYlZhbCA9PT0gJ29iamVjdCcpIHtcbiAgICAgIHJldHVybiBpc09iamVjdEVxdWFsKGFWYWwsIGJWYWwpXG4gICAgfVxuICAgIHJldHVybiBTdHJpbmcoYVZhbCkgPT09IFN0cmluZyhiVmFsKVxuICB9KVxufVxuXG5mdW5jdGlvbiBpc0luY2x1ZGVkUm91dGUgKGN1cnJlbnQsIHRhcmdldCkge1xuICByZXR1cm4gKFxuICAgIGN1cnJlbnQucGF0aC5yZXBsYWNlKHRyYWlsaW5nU2xhc2hSRSwgJy8nKS5pbmRleE9mKFxuICAgICAgdGFyZ2V0LnBhdGgucmVwbGFjZSh0cmFpbGluZ1NsYXNoUkUsICcvJylcbiAgICApID09PSAwICYmXG4gICAgKCF0YXJnZXQuaGFzaCB8fCBjdXJyZW50Lmhhc2ggPT09IHRhcmdldC5oYXNoKSAmJlxuICAgIHF1ZXJ5SW5jbHVkZXMoY3VycmVudC5xdWVyeSwgdGFyZ2V0LnF1ZXJ5KVxuICApXG59XG5cbmZ1bmN0aW9uIHF1ZXJ5SW5jbHVkZXMgKGN1cnJlbnQsIHRhcmdldCkge1xuICBmb3IgKHZhciBrZXkgaW4gdGFyZ2V0KSB7XG4gICAgaWYgKCEoa2V5IGluIGN1cnJlbnQpKSB7XG4gICAgICByZXR1cm4gZmFsc2VcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRydWVcbn1cblxuLyogICovXG5cbi8vIHdvcmsgYXJvdW5kIHdlaXJkIGZsb3cgYnVnXG52YXIgdG9UeXBlcyA9IFtTdHJpbmcsIE9iamVjdF07XG52YXIgZXZlbnRUeXBlcyA9IFtTdHJpbmcsIEFycmF5XTtcblxudmFyIExpbmsgPSB7XG4gIG5hbWU6ICdyb3V0ZXItbGluaycsXG4gIHByb3BzOiB7XG4gICAgdG86IHtcbiAgICAgIHR5cGU6IHRvVHlwZXMsXG4gICAgICByZXF1aXJlZDogdHJ1ZVxuICAgIH0sXG4gICAgdGFnOiB7XG4gICAgICB0eXBlOiBTdHJpbmcsXG4gICAgICBkZWZhdWx0OiAnYSdcbiAgICB9LFxuICAgIGV4YWN0OiBCb29sZWFuLFxuICAgIGFwcGVuZDogQm9vbGVhbixcbiAgICByZXBsYWNlOiBCb29sZWFuLFxuICAgIGFjdGl2ZUNsYXNzOiBTdHJpbmcsXG4gICAgZXhhY3RBY3RpdmVDbGFzczogU3RyaW5nLFxuICAgIGV2ZW50OiB7XG4gICAgICB0eXBlOiBldmVudFR5cGVzLFxuICAgICAgZGVmYXVsdDogJ2NsaWNrJ1xuICAgIH1cbiAgfSxcbiAgcmVuZGVyOiBmdW5jdGlvbiByZW5kZXIgKGgpIHtcbiAgICB2YXIgdGhpcyQxID0gdGhpcztcblxuICAgIHZhciByb3V0ZXIgPSB0aGlzLiRyb3V0ZXI7XG4gICAgdmFyIGN1cnJlbnQgPSB0aGlzLiRyb3V0ZTtcbiAgICB2YXIgcmVmID0gcm91dGVyLnJlc29sdmUodGhpcy50bywgY3VycmVudCwgdGhpcy5hcHBlbmQpO1xuICAgIHZhciBsb2NhdGlvbiA9IHJlZi5sb2NhdGlvbjtcbiAgICB2YXIgcm91dGUgPSByZWYucm91dGU7XG4gICAgdmFyIGhyZWYgPSByZWYuaHJlZjtcblxuICAgIHZhciBjbGFzc2VzID0ge307XG4gICAgdmFyIGdsb2JhbEFjdGl2ZUNsYXNzID0gcm91dGVyLm9wdGlvbnMubGlua0FjdGl2ZUNsYXNzO1xuICAgIHZhciBnbG9iYWxFeGFjdEFjdGl2ZUNsYXNzID0gcm91dGVyLm9wdGlvbnMubGlua0V4YWN0QWN0aXZlQ2xhc3M7XG4gICAgLy8gU3VwcG9ydCBnbG9iYWwgZW1wdHkgYWN0aXZlIGNsYXNzXG4gICAgdmFyIGFjdGl2ZUNsYXNzRmFsbGJhY2sgPSBnbG9iYWxBY3RpdmVDbGFzcyA9PSBudWxsXG4gICAgICAgICAgICA/ICdyb3V0ZXItbGluay1hY3RpdmUnXG4gICAgICAgICAgICA6IGdsb2JhbEFjdGl2ZUNsYXNzO1xuICAgIHZhciBleGFjdEFjdGl2ZUNsYXNzRmFsbGJhY2sgPSBnbG9iYWxFeGFjdEFjdGl2ZUNsYXNzID09IG51bGxcbiAgICAgICAgICAgID8gJ3JvdXRlci1saW5rLWV4YWN0LWFjdGl2ZSdcbiAgICAgICAgICAgIDogZ2xvYmFsRXhhY3RBY3RpdmVDbGFzcztcbiAgICB2YXIgYWN0aXZlQ2xhc3MgPSB0aGlzLmFjdGl2ZUNsYXNzID09IG51bGxcbiAgICAgICAgICAgID8gYWN0aXZlQ2xhc3NGYWxsYmFja1xuICAgICAgICAgICAgOiB0aGlzLmFjdGl2ZUNsYXNzO1xuICAgIHZhciBleGFjdEFjdGl2ZUNsYXNzID0gdGhpcy5leGFjdEFjdGl2ZUNsYXNzID09IG51bGxcbiAgICAgICAgICAgID8gZXhhY3RBY3RpdmVDbGFzc0ZhbGxiYWNrXG4gICAgICAgICAgICA6IHRoaXMuZXhhY3RBY3RpdmVDbGFzcztcbiAgICB2YXIgY29tcGFyZVRhcmdldCA9IGxvY2F0aW9uLnBhdGhcbiAgICAgID8gY3JlYXRlUm91dGUobnVsbCwgbG9jYXRpb24sIG51bGwsIHJvdXRlcilcbiAgICAgIDogcm91dGU7XG5cbiAgICBjbGFzc2VzW2V4YWN0QWN0aXZlQ2xhc3NdID0gaXNTYW1lUm91dGUoY3VycmVudCwgY29tcGFyZVRhcmdldCk7XG4gICAgY2xhc3Nlc1thY3RpdmVDbGFzc10gPSB0aGlzLmV4YWN0XG4gICAgICA/IGNsYXNzZXNbZXhhY3RBY3RpdmVDbGFzc11cbiAgICAgIDogaXNJbmNsdWRlZFJvdXRlKGN1cnJlbnQsIGNvbXBhcmVUYXJnZXQpO1xuXG4gICAgdmFyIGhhbmRsZXIgPSBmdW5jdGlvbiAoZSkge1xuICAgICAgaWYgKGd1YXJkRXZlbnQoZSkpIHtcbiAgICAgICAgaWYgKHRoaXMkMS5yZXBsYWNlKSB7XG4gICAgICAgICAgcm91dGVyLnJlcGxhY2UobG9jYXRpb24pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJvdXRlci5wdXNoKGxvY2F0aW9uKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG5cbiAgICB2YXIgb24gPSB7IGNsaWNrOiBndWFyZEV2ZW50IH07XG4gICAgaWYgKEFycmF5LmlzQXJyYXkodGhpcy5ldmVudCkpIHtcbiAgICAgIHRoaXMuZXZlbnQuZm9yRWFjaChmdW5jdGlvbiAoZSkgeyBvbltlXSA9IGhhbmRsZXI7IH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBvblt0aGlzLmV2ZW50XSA9IGhhbmRsZXI7XG4gICAgfVxuXG4gICAgdmFyIGRhdGEgPSB7XG4gICAgICBjbGFzczogY2xhc3Nlc1xuICAgIH07XG5cbiAgICBpZiAodGhpcy50YWcgPT09ICdhJykge1xuICAgICAgZGF0YS5vbiA9IG9uO1xuICAgICAgZGF0YS5hdHRycyA9IHsgaHJlZjogaHJlZiB9O1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBmaW5kIHRoZSBmaXJzdCA8YT4gY2hpbGQgYW5kIGFwcGx5IGxpc3RlbmVyIGFuZCBocmVmXG4gICAgICB2YXIgYSA9IGZpbmRBbmNob3IodGhpcy4kc2xvdHMuZGVmYXVsdCk7XG4gICAgICBpZiAoYSkge1xuICAgICAgICAvLyBpbiBjYXNlIHRoZSA8YT4gaXMgYSBzdGF0aWMgbm9kZVxuICAgICAgICBhLmlzU3RhdGljID0gZmFsc2U7XG4gICAgICAgIHZhciBleHRlbmQgPSBfVnVlLnV0aWwuZXh0ZW5kO1xuICAgICAgICB2YXIgYURhdGEgPSBhLmRhdGEgPSBleHRlbmQoe30sIGEuZGF0YSk7XG4gICAgICAgIGFEYXRhLm9uID0gb247XG4gICAgICAgIHZhciBhQXR0cnMgPSBhLmRhdGEuYXR0cnMgPSBleHRlbmQoe30sIGEuZGF0YS5hdHRycyk7XG4gICAgICAgIGFBdHRycy5ocmVmID0gaHJlZjtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIGRvZXNuJ3QgaGF2ZSA8YT4gY2hpbGQsIGFwcGx5IGxpc3RlbmVyIHRvIHNlbGZcbiAgICAgICAgZGF0YS5vbiA9IG9uO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBoKHRoaXMudGFnLCBkYXRhLCB0aGlzLiRzbG90cy5kZWZhdWx0KVxuICB9XG59O1xuXG5mdW5jdGlvbiBndWFyZEV2ZW50IChlKSB7XG4gIC8vIGRvbid0IHJlZGlyZWN0IHdpdGggY29udHJvbCBrZXlzXG4gIGlmIChlLm1ldGFLZXkgfHwgZS5hbHRLZXkgfHwgZS5jdHJsS2V5IHx8IGUuc2hpZnRLZXkpIHsgcmV0dXJuIH1cbiAgLy8gZG9uJ3QgcmVkaXJlY3Qgd2hlbiBwcmV2ZW50RGVmYXVsdCBjYWxsZWRcbiAgaWYgKGUuZGVmYXVsdFByZXZlbnRlZCkgeyByZXR1cm4gfVxuICAvLyBkb24ndCByZWRpcmVjdCBvbiByaWdodCBjbGlja1xuICBpZiAoZS5idXR0b24gIT09IHVuZGVmaW5lZCAmJiBlLmJ1dHRvbiAhPT0gMCkgeyByZXR1cm4gfVxuICAvLyBkb24ndCByZWRpcmVjdCBpZiBgdGFyZ2V0PVwiX2JsYW5rXCJgXG4gIGlmIChlLmN1cnJlbnRUYXJnZXQgJiYgZS5jdXJyZW50VGFyZ2V0LmdldEF0dHJpYnV0ZSkge1xuICAgIHZhciB0YXJnZXQgPSBlLmN1cnJlbnRUYXJnZXQuZ2V0QXR0cmlidXRlKCd0YXJnZXQnKTtcbiAgICBpZiAoL1xcYl9ibGFua1xcYi9pLnRlc3QodGFyZ2V0KSkgeyByZXR1cm4gfVxuICB9XG4gIC8vIHRoaXMgbWF5IGJlIGEgV2VleCBldmVudCB3aGljaCBkb2Vzbid0IGhhdmUgdGhpcyBtZXRob2RcbiAgaWYgKGUucHJldmVudERlZmF1bHQpIHtcbiAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gIH1cbiAgcmV0dXJuIHRydWVcbn1cblxuZnVuY3Rpb24gZmluZEFuY2hvciAoY2hpbGRyZW4pIHtcbiAgaWYgKGNoaWxkcmVuKSB7XG4gICAgdmFyIGNoaWxkO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNoaWxkID0gY2hpbGRyZW5baV07XG4gICAgICBpZiAoY2hpbGQudGFnID09PSAnYScpIHtcbiAgICAgICAgcmV0dXJuIGNoaWxkXG4gICAgICB9XG4gICAgICBpZiAoY2hpbGQuY2hpbGRyZW4gJiYgKGNoaWxkID0gZmluZEFuY2hvcihjaGlsZC5jaGlsZHJlbikpKSB7XG4gICAgICAgIHJldHVybiBjaGlsZFxuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG52YXIgX1Z1ZTtcblxuZnVuY3Rpb24gaW5zdGFsbCAoVnVlKSB7XG4gIGlmIChpbnN0YWxsLmluc3RhbGxlZCAmJiBfVnVlID09PSBWdWUpIHsgcmV0dXJuIH1cbiAgaW5zdGFsbC5pbnN0YWxsZWQgPSB0cnVlO1xuXG4gIF9WdWUgPSBWdWU7XG5cbiAgdmFyIGlzRGVmID0gZnVuY3Rpb24gKHYpIHsgcmV0dXJuIHYgIT09IHVuZGVmaW5lZDsgfTtcblxuICB2YXIgcmVnaXN0ZXJJbnN0YW5jZSA9IGZ1bmN0aW9uICh2bSwgY2FsbFZhbCkge1xuICAgIHZhciBpID0gdm0uJG9wdGlvbnMuX3BhcmVudFZub2RlO1xuICAgIGlmIChpc0RlZihpKSAmJiBpc0RlZihpID0gaS5kYXRhKSAmJiBpc0RlZihpID0gaS5yZWdpc3RlclJvdXRlSW5zdGFuY2UpKSB7XG4gICAgICBpKHZtLCBjYWxsVmFsKTtcbiAgICB9XG4gIH07XG5cbiAgVnVlLm1peGluKHtcbiAgICBiZWZvcmVDcmVhdGU6IGZ1bmN0aW9uIGJlZm9yZUNyZWF0ZSAoKSB7XG4gICAgICBpZiAoaXNEZWYodGhpcy4kb3B0aW9ucy5yb3V0ZXIpKSB7XG4gICAgICAgIHRoaXMuX3JvdXRlclJvb3QgPSB0aGlzO1xuICAgICAgICB0aGlzLl9yb3V0ZXIgPSB0aGlzLiRvcHRpb25zLnJvdXRlcjtcbiAgICAgICAgdGhpcy5fcm91dGVyLmluaXQodGhpcyk7XG4gICAgICAgIFZ1ZS51dGlsLmRlZmluZVJlYWN0aXZlKHRoaXMsICdfcm91dGUnLCB0aGlzLl9yb3V0ZXIuaGlzdG9yeS5jdXJyZW50KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuX3JvdXRlclJvb3QgPSAodGhpcy4kcGFyZW50ICYmIHRoaXMuJHBhcmVudC5fcm91dGVyUm9vdCkgfHwgdGhpcztcbiAgICAgIH1cbiAgICAgIHJlZ2lzdGVySW5zdGFuY2UodGhpcywgdGhpcyk7XG4gICAgfSxcbiAgICBkZXN0cm95ZWQ6IGZ1bmN0aW9uIGRlc3Ryb3llZCAoKSB7XG4gICAgICByZWdpc3Rlckluc3RhbmNlKHRoaXMpO1xuICAgIH1cbiAgfSk7XG5cbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFZ1ZS5wcm90b3R5cGUsICckcm91dGVyJywge1xuICAgIGdldDogZnVuY3Rpb24gZ2V0ICgpIHsgcmV0dXJuIHRoaXMuX3JvdXRlclJvb3QuX3JvdXRlciB9XG4gIH0pO1xuXG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShWdWUucHJvdG90eXBlLCAnJHJvdXRlJywge1xuICAgIGdldDogZnVuY3Rpb24gZ2V0ICgpIHsgcmV0dXJuIHRoaXMuX3JvdXRlclJvb3QuX3JvdXRlIH1cbiAgfSk7XG5cbiAgVnVlLmNvbXBvbmVudCgncm91dGVyLXZpZXcnLCBWaWV3KTtcbiAgVnVlLmNvbXBvbmVudCgncm91dGVyLWxpbmsnLCBMaW5rKTtcblxuICB2YXIgc3RyYXRzID0gVnVlLmNvbmZpZy5vcHRpb25NZXJnZVN0cmF0ZWdpZXM7XG4gIC8vIHVzZSB0aGUgc2FtZSBob29rIG1lcmdpbmcgc3RyYXRlZ3kgZm9yIHJvdXRlIGhvb2tzXG4gIHN0cmF0cy5iZWZvcmVSb3V0ZUVudGVyID0gc3RyYXRzLmJlZm9yZVJvdXRlTGVhdmUgPSBzdHJhdHMuYmVmb3JlUm91dGVVcGRhdGUgPSBzdHJhdHMuY3JlYXRlZDtcbn1cblxuLyogICovXG5cbnZhciBpbkJyb3dzZXIgPSB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJztcblxuLyogICovXG5cbmZ1bmN0aW9uIHJlc29sdmVQYXRoIChcbiAgcmVsYXRpdmUsXG4gIGJhc2UsXG4gIGFwcGVuZFxuKSB7XG4gIHZhciBmaXJzdENoYXIgPSByZWxhdGl2ZS5jaGFyQXQoMCk7XG4gIGlmIChmaXJzdENoYXIgPT09ICcvJykge1xuICAgIHJldHVybiByZWxhdGl2ZVxuICB9XG5cbiAgaWYgKGZpcnN0Q2hhciA9PT0gJz8nIHx8IGZpcnN0Q2hhciA9PT0gJyMnKSB7XG4gICAgcmV0dXJuIGJhc2UgKyByZWxhdGl2ZVxuICB9XG5cbiAgdmFyIHN0YWNrID0gYmFzZS5zcGxpdCgnLycpO1xuXG4gIC8vIHJlbW92ZSB0cmFpbGluZyBzZWdtZW50IGlmOlxuICAvLyAtIG5vdCBhcHBlbmRpbmdcbiAgLy8gLSBhcHBlbmRpbmcgdG8gdHJhaWxpbmcgc2xhc2ggKGxhc3Qgc2VnbWVudCBpcyBlbXB0eSlcbiAgaWYgKCFhcHBlbmQgfHwgIXN0YWNrW3N0YWNrLmxlbmd0aCAtIDFdKSB7XG4gICAgc3RhY2sucG9wKCk7XG4gIH1cblxuICAvLyByZXNvbHZlIHJlbGF0aXZlIHBhdGhcbiAgdmFyIHNlZ21lbnRzID0gcmVsYXRpdmUucmVwbGFjZSgvXlxcLy8sICcnKS5zcGxpdCgnLycpO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHNlZ21lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIHNlZ21lbnQgPSBzZWdtZW50c1tpXTtcbiAgICBpZiAoc2VnbWVudCA9PT0gJy4uJykge1xuICAgICAgc3RhY2sucG9wKCk7XG4gICAgfSBlbHNlIGlmIChzZWdtZW50ICE9PSAnLicpIHtcbiAgICAgIHN0YWNrLnB1c2goc2VnbWVudCk7XG4gICAgfVxuICB9XG5cbiAgLy8gZW5zdXJlIGxlYWRpbmcgc2xhc2hcbiAgaWYgKHN0YWNrWzBdICE9PSAnJykge1xuICAgIHN0YWNrLnVuc2hpZnQoJycpO1xuICB9XG5cbiAgcmV0dXJuIHN0YWNrLmpvaW4oJy8nKVxufVxuXG5mdW5jdGlvbiBwYXJzZVBhdGggKHBhdGgpIHtcbiAgdmFyIGhhc2ggPSAnJztcbiAgdmFyIHF1ZXJ5ID0gJyc7XG5cbiAgdmFyIGhhc2hJbmRleCA9IHBhdGguaW5kZXhPZignIycpO1xuICBpZiAoaGFzaEluZGV4ID49IDApIHtcbiAgICBoYXNoID0gcGF0aC5zbGljZShoYXNoSW5kZXgpO1xuICAgIHBhdGggPSBwYXRoLnNsaWNlKDAsIGhhc2hJbmRleCk7XG4gIH1cblxuICB2YXIgcXVlcnlJbmRleCA9IHBhdGguaW5kZXhPZignPycpO1xuICBpZiAocXVlcnlJbmRleCA+PSAwKSB7XG4gICAgcXVlcnkgPSBwYXRoLnNsaWNlKHF1ZXJ5SW5kZXggKyAxKTtcbiAgICBwYXRoID0gcGF0aC5zbGljZSgwLCBxdWVyeUluZGV4KTtcbiAgfVxuXG4gIHJldHVybiB7XG4gICAgcGF0aDogcGF0aCxcbiAgICBxdWVyeTogcXVlcnksXG4gICAgaGFzaDogaGFzaFxuICB9XG59XG5cbmZ1bmN0aW9uIGNsZWFuUGF0aCAocGF0aCkge1xuICByZXR1cm4gcGF0aC5yZXBsYWNlKC9cXC9cXC8vZywgJy8nKVxufVxuXG52YXIgaXNhcnJheSA9IEFycmF5LmlzQXJyYXkgfHwgZnVuY3Rpb24gKGFycikge1xuICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKGFycikgPT0gJ1tvYmplY3QgQXJyYXldJztcbn07XG5cbi8qKlxuICogRXhwb3NlIGBwYXRoVG9SZWdleHBgLlxuICovXG52YXIgcGF0aFRvUmVnZXhwXzEgPSBwYXRoVG9SZWdleHA7XG52YXIgcGFyc2VfMSA9IHBhcnNlO1xudmFyIGNvbXBpbGVfMSA9IGNvbXBpbGU7XG52YXIgdG9rZW5zVG9GdW5jdGlvbl8xID0gdG9rZW5zVG9GdW5jdGlvbjtcbnZhciB0b2tlbnNUb1JlZ0V4cF8xID0gdG9rZW5zVG9SZWdFeHA7XG5cbi8qKlxuICogVGhlIG1haW4gcGF0aCBtYXRjaGluZyByZWdleHAgdXRpbGl0eS5cbiAqXG4gKiBAdHlwZSB7UmVnRXhwfVxuICovXG52YXIgUEFUSF9SRUdFWFAgPSBuZXcgUmVnRXhwKFtcbiAgLy8gTWF0Y2ggZXNjYXBlZCBjaGFyYWN0ZXJzIHRoYXQgd291bGQgb3RoZXJ3aXNlIGFwcGVhciBpbiBmdXR1cmUgbWF0Y2hlcy5cbiAgLy8gVGhpcyBhbGxvd3MgdGhlIHVzZXIgdG8gZXNjYXBlIHNwZWNpYWwgY2hhcmFjdGVycyB0aGF0IHdvbid0IHRyYW5zZm9ybS5cbiAgJyhcXFxcXFxcXC4pJyxcbiAgLy8gTWF0Y2ggRXhwcmVzcy1zdHlsZSBwYXJhbWV0ZXJzIGFuZCB1bi1uYW1lZCBwYXJhbWV0ZXJzIHdpdGggYSBwcmVmaXhcbiAgLy8gYW5kIG9wdGlvbmFsIHN1ZmZpeGVzLiBNYXRjaGVzIGFwcGVhciBhczpcbiAgLy9cbiAgLy8gXCIvOnRlc3QoXFxcXGQrKT9cIiA9PiBbXCIvXCIsIFwidGVzdFwiLCBcIlxcZCtcIiwgdW5kZWZpbmVkLCBcIj9cIiwgdW5kZWZpbmVkXVxuICAvLyBcIi9yb3V0ZShcXFxcZCspXCIgID0+IFt1bmRlZmluZWQsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCBcIlxcZCtcIiwgdW5kZWZpbmVkLCB1bmRlZmluZWRdXG4gIC8vIFwiLypcIiAgICAgICAgICAgID0+IFtcIi9cIiwgdW5kZWZpbmVkLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCBcIipcIl1cbiAgJyhbXFxcXC8uXSk/KD86KD86XFxcXDooXFxcXHcrKSg/OlxcXFwoKCg/OlxcXFxcXFxcLnxbXlxcXFxcXFxcKCldKSspXFxcXCkpP3xcXFxcKCgoPzpcXFxcXFxcXC58W15cXFxcXFxcXCgpXSkrKVxcXFwpKShbKyo/XSk/fChcXFxcKikpJ1xuXS5qb2luKCd8JyksICdnJyk7XG5cbi8qKlxuICogUGFyc2UgYSBzdHJpbmcgZm9yIHRoZSByYXcgdG9rZW5zLlxuICpcbiAqIEBwYXJhbSAge3N0cmluZ30gIHN0clxuICogQHBhcmFtICB7T2JqZWN0PX0gb3B0aW9uc1xuICogQHJldHVybiB7IUFycmF5fVxuICovXG5mdW5jdGlvbiBwYXJzZSAoc3RyLCBvcHRpb25zKSB7XG4gIHZhciB0b2tlbnMgPSBbXTtcbiAgdmFyIGtleSA9IDA7XG4gIHZhciBpbmRleCA9IDA7XG4gIHZhciBwYXRoID0gJyc7XG4gIHZhciBkZWZhdWx0RGVsaW1pdGVyID0gb3B0aW9ucyAmJiBvcHRpb25zLmRlbGltaXRlciB8fCAnLyc7XG4gIHZhciByZXM7XG5cbiAgd2hpbGUgKChyZXMgPSBQQVRIX1JFR0VYUC5leGVjKHN0cikpICE9IG51bGwpIHtcbiAgICB2YXIgbSA9IHJlc1swXTtcbiAgICB2YXIgZXNjYXBlZCA9IHJlc1sxXTtcbiAgICB2YXIgb2Zmc2V0ID0gcmVzLmluZGV4O1xuICAgIHBhdGggKz0gc3RyLnNsaWNlKGluZGV4LCBvZmZzZXQpO1xuICAgIGluZGV4ID0gb2Zmc2V0ICsgbS5sZW5ndGg7XG5cbiAgICAvLyBJZ25vcmUgYWxyZWFkeSBlc2NhcGVkIHNlcXVlbmNlcy5cbiAgICBpZiAoZXNjYXBlZCkge1xuICAgICAgcGF0aCArPSBlc2NhcGVkWzFdO1xuICAgICAgY29udGludWVcbiAgICB9XG5cbiAgICB2YXIgbmV4dCA9IHN0cltpbmRleF07XG4gICAgdmFyIHByZWZpeCA9IHJlc1syXTtcbiAgICB2YXIgbmFtZSA9IHJlc1szXTtcbiAgICB2YXIgY2FwdHVyZSA9IHJlc1s0XTtcbiAgICB2YXIgZ3JvdXAgPSByZXNbNV07XG4gICAgdmFyIG1vZGlmaWVyID0gcmVzWzZdO1xuICAgIHZhciBhc3RlcmlzayA9IHJlc1s3XTtcblxuICAgIC8vIFB1c2ggdGhlIGN1cnJlbnQgcGF0aCBvbnRvIHRoZSB0b2tlbnMuXG4gICAgaWYgKHBhdGgpIHtcbiAgICAgIHRva2Vucy5wdXNoKHBhdGgpO1xuICAgICAgcGF0aCA9ICcnO1xuICAgIH1cblxuICAgIHZhciBwYXJ0aWFsID0gcHJlZml4ICE9IG51bGwgJiYgbmV4dCAhPSBudWxsICYmIG5leHQgIT09IHByZWZpeDtcbiAgICB2YXIgcmVwZWF0ID0gbW9kaWZpZXIgPT09ICcrJyB8fCBtb2RpZmllciA9PT0gJyonO1xuICAgIHZhciBvcHRpb25hbCA9IG1vZGlmaWVyID09PSAnPycgfHwgbW9kaWZpZXIgPT09ICcqJztcbiAgICB2YXIgZGVsaW1pdGVyID0gcmVzWzJdIHx8IGRlZmF1bHREZWxpbWl0ZXI7XG4gICAgdmFyIHBhdHRlcm4gPSBjYXB0dXJlIHx8IGdyb3VwO1xuXG4gICAgdG9rZW5zLnB1c2goe1xuICAgICAgbmFtZTogbmFtZSB8fCBrZXkrKyxcbiAgICAgIHByZWZpeDogcHJlZml4IHx8ICcnLFxuICAgICAgZGVsaW1pdGVyOiBkZWxpbWl0ZXIsXG4gICAgICBvcHRpb25hbDogb3B0aW9uYWwsXG4gICAgICByZXBlYXQ6IHJlcGVhdCxcbiAgICAgIHBhcnRpYWw6IHBhcnRpYWwsXG4gICAgICBhc3RlcmlzazogISFhc3RlcmlzayxcbiAgICAgIHBhdHRlcm46IHBhdHRlcm4gPyBlc2NhcGVHcm91cChwYXR0ZXJuKSA6IChhc3RlcmlzayA/ICcuKicgOiAnW14nICsgZXNjYXBlU3RyaW5nKGRlbGltaXRlcikgKyAnXSs/JylcbiAgICB9KTtcbiAgfVxuXG4gIC8vIE1hdGNoIGFueSBjaGFyYWN0ZXJzIHN0aWxsIHJlbWFpbmluZy5cbiAgaWYgKGluZGV4IDwgc3RyLmxlbmd0aCkge1xuICAgIHBhdGggKz0gc3RyLnN1YnN0cihpbmRleCk7XG4gIH1cblxuICAvLyBJZiB0aGUgcGF0aCBleGlzdHMsIHB1c2ggaXQgb250byB0aGUgZW5kLlxuICBpZiAocGF0aCkge1xuICAgIHRva2Vucy5wdXNoKHBhdGgpO1xuICB9XG5cbiAgcmV0dXJuIHRva2Vuc1xufVxuXG4vKipcbiAqIENvbXBpbGUgYSBzdHJpbmcgdG8gYSB0ZW1wbGF0ZSBmdW5jdGlvbiBmb3IgdGhlIHBhdGguXG4gKlxuICogQHBhcmFtICB7c3RyaW5nfSAgICAgICAgICAgICBzdHJcbiAqIEBwYXJhbSAge09iamVjdD19ICAgICAgICAgICAgb3B0aW9uc1xuICogQHJldHVybiB7IWZ1bmN0aW9uKE9iamVjdD0sIE9iamVjdD0pfVxuICovXG5mdW5jdGlvbiBjb21waWxlIChzdHIsIG9wdGlvbnMpIHtcbiAgcmV0dXJuIHRva2Vuc1RvRnVuY3Rpb24ocGFyc2Uoc3RyLCBvcHRpb25zKSlcbn1cblxuLyoqXG4gKiBQcmV0dGllciBlbmNvZGluZyBvZiBVUkkgcGF0aCBzZWdtZW50cy5cbiAqXG4gKiBAcGFyYW0gIHtzdHJpbmd9XG4gKiBAcmV0dXJuIHtzdHJpbmd9XG4gKi9cbmZ1bmN0aW9uIGVuY29kZVVSSUNvbXBvbmVudFByZXR0eSAoc3RyKSB7XG4gIHJldHVybiBlbmNvZGVVUkkoc3RyKS5yZXBsYWNlKC9bXFwvPyNdL2csIGZ1bmN0aW9uIChjKSB7XG4gICAgcmV0dXJuICclJyArIGMuY2hhckNvZGVBdCgwKS50b1N0cmluZygxNikudG9VcHBlckNhc2UoKVxuICB9KVxufVxuXG4vKipcbiAqIEVuY29kZSB0aGUgYXN0ZXJpc2sgcGFyYW1ldGVyLiBTaW1pbGFyIHRvIGBwcmV0dHlgLCBidXQgYWxsb3dzIHNsYXNoZXMuXG4gKlxuICogQHBhcmFtICB7c3RyaW5nfVxuICogQHJldHVybiB7c3RyaW5nfVxuICovXG5mdW5jdGlvbiBlbmNvZGVBc3RlcmlzayAoc3RyKSB7XG4gIHJldHVybiBlbmNvZGVVUkkoc3RyKS5yZXBsYWNlKC9bPyNdL2csIGZ1bmN0aW9uIChjKSB7XG4gICAgcmV0dXJuICclJyArIGMuY2hhckNvZGVBdCgwKS50b1N0cmluZygxNikudG9VcHBlckNhc2UoKVxuICB9KVxufVxuXG4vKipcbiAqIEV4cG9zZSBhIG1ldGhvZCBmb3IgdHJhbnNmb3JtaW5nIHRva2VucyBpbnRvIHRoZSBwYXRoIGZ1bmN0aW9uLlxuICovXG5mdW5jdGlvbiB0b2tlbnNUb0Z1bmN0aW9uICh0b2tlbnMpIHtcbiAgLy8gQ29tcGlsZSBhbGwgdGhlIHRva2VucyBpbnRvIHJlZ2V4cHMuXG4gIHZhciBtYXRjaGVzID0gbmV3IEFycmF5KHRva2Vucy5sZW5ndGgpO1xuXG4gIC8vIENvbXBpbGUgYWxsIHRoZSBwYXR0ZXJucyBiZWZvcmUgY29tcGlsYXRpb24uXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgdG9rZW5zLmxlbmd0aDsgaSsrKSB7XG4gICAgaWYgKHR5cGVvZiB0b2tlbnNbaV0gPT09ICdvYmplY3QnKSB7XG4gICAgICBtYXRjaGVzW2ldID0gbmV3IFJlZ0V4cCgnXig/OicgKyB0b2tlbnNbaV0ucGF0dGVybiArICcpJCcpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBmdW5jdGlvbiAob2JqLCBvcHRzKSB7XG4gICAgdmFyIHBhdGggPSAnJztcbiAgICB2YXIgZGF0YSA9IG9iaiB8fCB7fTtcbiAgICB2YXIgb3B0aW9ucyA9IG9wdHMgfHwge307XG4gICAgdmFyIGVuY29kZSA9IG9wdGlvbnMucHJldHR5ID8gZW5jb2RlVVJJQ29tcG9uZW50UHJldHR5IDogZW5jb2RlVVJJQ29tcG9uZW50O1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0b2tlbnMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciB0b2tlbiA9IHRva2Vuc1tpXTtcblxuICAgICAgaWYgKHR5cGVvZiB0b2tlbiA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgcGF0aCArPSB0b2tlbjtcblxuICAgICAgICBjb250aW51ZVxuICAgICAgfVxuXG4gICAgICB2YXIgdmFsdWUgPSBkYXRhW3Rva2VuLm5hbWVdO1xuICAgICAgdmFyIHNlZ21lbnQ7XG5cbiAgICAgIGlmICh2YWx1ZSA9PSBudWxsKSB7XG4gICAgICAgIGlmICh0b2tlbi5vcHRpb25hbCkge1xuICAgICAgICAgIC8vIFByZXBlbmQgcGFydGlhbCBzZWdtZW50IHByZWZpeGVzLlxuICAgICAgICAgIGlmICh0b2tlbi5wYXJ0aWFsKSB7XG4gICAgICAgICAgICBwYXRoICs9IHRva2VuLnByZWZpeDtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBjb250aW51ZVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0V4cGVjdGVkIFwiJyArIHRva2VuLm5hbWUgKyAnXCIgdG8gYmUgZGVmaW5lZCcpXG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKGlzYXJyYXkodmFsdWUpKSB7XG4gICAgICAgIGlmICghdG9rZW4ucmVwZWF0KSB7XG4gICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignRXhwZWN0ZWQgXCInICsgdG9rZW4ubmFtZSArICdcIiB0byBub3QgcmVwZWF0LCBidXQgcmVjZWl2ZWQgYCcgKyBKU09OLnN0cmluZ2lmeSh2YWx1ZSkgKyAnYCcpXG4gICAgICAgIH1cblxuICAgICAgICBpZiAodmFsdWUubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgaWYgKHRva2VuLm9wdGlvbmFsKSB7XG4gICAgICAgICAgICBjb250aW51ZVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdFeHBlY3RlZCBcIicgKyB0b2tlbi5uYW1lICsgJ1wiIHRvIG5vdCBiZSBlbXB0eScpXG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCB2YWx1ZS5sZW5ndGg7IGorKykge1xuICAgICAgICAgIHNlZ21lbnQgPSBlbmNvZGUodmFsdWVbal0pO1xuXG4gICAgICAgICAgaWYgKCFtYXRjaGVzW2ldLnRlc3Qoc2VnbWVudCkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0V4cGVjdGVkIGFsbCBcIicgKyB0b2tlbi5uYW1lICsgJ1wiIHRvIG1hdGNoIFwiJyArIHRva2VuLnBhdHRlcm4gKyAnXCIsIGJ1dCByZWNlaXZlZCBgJyArIEpTT04uc3RyaW5naWZ5KHNlZ21lbnQpICsgJ2AnKVxuICAgICAgICAgIH1cblxuICAgICAgICAgIHBhdGggKz0gKGogPT09IDAgPyB0b2tlbi5wcmVmaXggOiB0b2tlbi5kZWxpbWl0ZXIpICsgc2VnbWVudDtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnRpbnVlXG4gICAgICB9XG5cbiAgICAgIHNlZ21lbnQgPSB0b2tlbi5hc3RlcmlzayA/IGVuY29kZUFzdGVyaXNrKHZhbHVlKSA6IGVuY29kZSh2YWx1ZSk7XG5cbiAgICAgIGlmICghbWF0Y2hlc1tpXS50ZXN0KHNlZ21lbnQpKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0V4cGVjdGVkIFwiJyArIHRva2VuLm5hbWUgKyAnXCIgdG8gbWF0Y2ggXCInICsgdG9rZW4ucGF0dGVybiArICdcIiwgYnV0IHJlY2VpdmVkIFwiJyArIHNlZ21lbnQgKyAnXCInKVxuICAgICAgfVxuXG4gICAgICBwYXRoICs9IHRva2VuLnByZWZpeCArIHNlZ21lbnQ7XG4gICAgfVxuXG4gICAgcmV0dXJuIHBhdGhcbiAgfVxufVxuXG4vKipcbiAqIEVzY2FwZSBhIHJlZ3VsYXIgZXhwcmVzc2lvbiBzdHJpbmcuXG4gKlxuICogQHBhcmFtICB7c3RyaW5nfSBzdHJcbiAqIEByZXR1cm4ge3N0cmluZ31cbiAqL1xuZnVuY3Rpb24gZXNjYXBlU3RyaW5nIChzdHIpIHtcbiAgcmV0dXJuIHN0ci5yZXBsYWNlKC8oWy4rKj89XiE6JHt9KClbXFxdfFxcL1xcXFxdKS9nLCAnXFxcXCQxJylcbn1cblxuLyoqXG4gKiBFc2NhcGUgdGhlIGNhcHR1cmluZyBncm91cCBieSBlc2NhcGluZyBzcGVjaWFsIGNoYXJhY3RlcnMgYW5kIG1lYW5pbmcuXG4gKlxuICogQHBhcmFtICB7c3RyaW5nfSBncm91cFxuICogQHJldHVybiB7c3RyaW5nfVxuICovXG5mdW5jdGlvbiBlc2NhcGVHcm91cCAoZ3JvdXApIHtcbiAgcmV0dXJuIGdyb3VwLnJlcGxhY2UoLyhbPSE6JFxcLygpXSkvZywgJ1xcXFwkMScpXG59XG5cbi8qKlxuICogQXR0YWNoIHRoZSBrZXlzIGFzIGEgcHJvcGVydHkgb2YgdGhlIHJlZ2V4cC5cbiAqXG4gKiBAcGFyYW0gIHshUmVnRXhwfSByZVxuICogQHBhcmFtICB7QXJyYXl9ICAga2V5c1xuICogQHJldHVybiB7IVJlZ0V4cH1cbiAqL1xuZnVuY3Rpb24gYXR0YWNoS2V5cyAocmUsIGtleXMpIHtcbiAgcmUua2V5cyA9IGtleXM7XG4gIHJldHVybiByZVxufVxuXG4vKipcbiAqIEdldCB0aGUgZmxhZ3MgZm9yIGEgcmVnZXhwIGZyb20gdGhlIG9wdGlvbnMuXG4gKlxuICogQHBhcmFtICB7T2JqZWN0fSBvcHRpb25zXG4gKiBAcmV0dXJuIHtzdHJpbmd9XG4gKi9cbmZ1bmN0aW9uIGZsYWdzIChvcHRpb25zKSB7XG4gIHJldHVybiBvcHRpb25zLnNlbnNpdGl2ZSA/ICcnIDogJ2knXG59XG5cbi8qKlxuICogUHVsbCBvdXQga2V5cyBmcm9tIGEgcmVnZXhwLlxuICpcbiAqIEBwYXJhbSAgeyFSZWdFeHB9IHBhdGhcbiAqIEBwYXJhbSAgeyFBcnJheX0gIGtleXNcbiAqIEByZXR1cm4geyFSZWdFeHB9XG4gKi9cbmZ1bmN0aW9uIHJlZ2V4cFRvUmVnZXhwIChwYXRoLCBrZXlzKSB7XG4gIC8vIFVzZSBhIG5lZ2F0aXZlIGxvb2thaGVhZCB0byBtYXRjaCBvbmx5IGNhcHR1cmluZyBncm91cHMuXG4gIHZhciBncm91cHMgPSBwYXRoLnNvdXJjZS5tYXRjaCgvXFwoKD8hXFw/KS9nKTtcblxuICBpZiAoZ3JvdXBzKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBncm91cHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGtleXMucHVzaCh7XG4gICAgICAgIG5hbWU6IGksXG4gICAgICAgIHByZWZpeDogbnVsbCxcbiAgICAgICAgZGVsaW1pdGVyOiBudWxsLFxuICAgICAgICBvcHRpb25hbDogZmFsc2UsXG4gICAgICAgIHJlcGVhdDogZmFsc2UsXG4gICAgICAgIHBhcnRpYWw6IGZhbHNlLFxuICAgICAgICBhc3RlcmlzazogZmFsc2UsXG4gICAgICAgIHBhdHRlcm46IG51bGxcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBhdHRhY2hLZXlzKHBhdGgsIGtleXMpXG59XG5cbi8qKlxuICogVHJhbnNmb3JtIGFuIGFycmF5IGludG8gYSByZWdleHAuXG4gKlxuICogQHBhcmFtICB7IUFycmF5fSAgcGF0aFxuICogQHBhcmFtICB7QXJyYXl9ICAga2V5c1xuICogQHBhcmFtICB7IU9iamVjdH0gb3B0aW9uc1xuICogQHJldHVybiB7IVJlZ0V4cH1cbiAqL1xuZnVuY3Rpb24gYXJyYXlUb1JlZ2V4cCAocGF0aCwga2V5cywgb3B0aW9ucykge1xuICB2YXIgcGFydHMgPSBbXTtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IHBhdGgubGVuZ3RoOyBpKyspIHtcbiAgICBwYXJ0cy5wdXNoKHBhdGhUb1JlZ2V4cChwYXRoW2ldLCBrZXlzLCBvcHRpb25zKS5zb3VyY2UpO1xuICB9XG5cbiAgdmFyIHJlZ2V4cCA9IG5ldyBSZWdFeHAoJyg/OicgKyBwYXJ0cy5qb2luKCd8JykgKyAnKScsIGZsYWdzKG9wdGlvbnMpKTtcblxuICByZXR1cm4gYXR0YWNoS2V5cyhyZWdleHAsIGtleXMpXG59XG5cbi8qKlxuICogQ3JlYXRlIGEgcGF0aCByZWdleHAgZnJvbSBzdHJpbmcgaW5wdXQuXG4gKlxuICogQHBhcmFtICB7c3RyaW5nfSAgcGF0aFxuICogQHBhcmFtICB7IUFycmF5fSAga2V5c1xuICogQHBhcmFtICB7IU9iamVjdH0gb3B0aW9uc1xuICogQHJldHVybiB7IVJlZ0V4cH1cbiAqL1xuZnVuY3Rpb24gc3RyaW5nVG9SZWdleHAgKHBhdGgsIGtleXMsIG9wdGlvbnMpIHtcbiAgcmV0dXJuIHRva2Vuc1RvUmVnRXhwKHBhcnNlKHBhdGgsIG9wdGlvbnMpLCBrZXlzLCBvcHRpb25zKVxufVxuXG4vKipcbiAqIEV4cG9zZSBhIGZ1bmN0aW9uIGZvciB0YWtpbmcgdG9rZW5zIGFuZCByZXR1cm5pbmcgYSBSZWdFeHAuXG4gKlxuICogQHBhcmFtICB7IUFycmF5fSAgICAgICAgICB0b2tlbnNcbiAqIEBwYXJhbSAgeyhBcnJheXxPYmplY3QpPX0ga2V5c1xuICogQHBhcmFtICB7T2JqZWN0PX0gICAgICAgICBvcHRpb25zXG4gKiBAcmV0dXJuIHshUmVnRXhwfVxuICovXG5mdW5jdGlvbiB0b2tlbnNUb1JlZ0V4cCAodG9rZW5zLCBrZXlzLCBvcHRpb25zKSB7XG4gIGlmICghaXNhcnJheShrZXlzKSkge1xuICAgIG9wdGlvbnMgPSAvKiogQHR5cGUgeyFPYmplY3R9ICovIChrZXlzIHx8IG9wdGlvbnMpO1xuICAgIGtleXMgPSBbXTtcbiAgfVxuXG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXG4gIHZhciBzdHJpY3QgPSBvcHRpb25zLnN0cmljdDtcbiAgdmFyIGVuZCA9IG9wdGlvbnMuZW5kICE9PSBmYWxzZTtcbiAgdmFyIHJvdXRlID0gJyc7XG5cbiAgLy8gSXRlcmF0ZSBvdmVyIHRoZSB0b2tlbnMgYW5kIGNyZWF0ZSBvdXIgcmVnZXhwIHN0cmluZy5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCB0b2tlbnMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgdG9rZW4gPSB0b2tlbnNbaV07XG5cbiAgICBpZiAodHlwZW9mIHRva2VuID09PSAnc3RyaW5nJykge1xuICAgICAgcm91dGUgKz0gZXNjYXBlU3RyaW5nKHRva2VuKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIHByZWZpeCA9IGVzY2FwZVN0cmluZyh0b2tlbi5wcmVmaXgpO1xuICAgICAgdmFyIGNhcHR1cmUgPSAnKD86JyArIHRva2VuLnBhdHRlcm4gKyAnKSc7XG5cbiAgICAgIGtleXMucHVzaCh0b2tlbik7XG5cbiAgICAgIGlmICh0b2tlbi5yZXBlYXQpIHtcbiAgICAgICAgY2FwdHVyZSArPSAnKD86JyArIHByZWZpeCArIGNhcHR1cmUgKyAnKSonO1xuICAgICAgfVxuXG4gICAgICBpZiAodG9rZW4ub3B0aW9uYWwpIHtcbiAgICAgICAgaWYgKCF0b2tlbi5wYXJ0aWFsKSB7XG4gICAgICAgICAgY2FwdHVyZSA9ICcoPzonICsgcHJlZml4ICsgJygnICsgY2FwdHVyZSArICcpKT8nO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNhcHR1cmUgPSBwcmVmaXggKyAnKCcgKyBjYXB0dXJlICsgJyk/JztcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY2FwdHVyZSA9IHByZWZpeCArICcoJyArIGNhcHR1cmUgKyAnKSc7XG4gICAgICB9XG5cbiAgICAgIHJvdXRlICs9IGNhcHR1cmU7XG4gICAgfVxuICB9XG5cbiAgdmFyIGRlbGltaXRlciA9IGVzY2FwZVN0cmluZyhvcHRpb25zLmRlbGltaXRlciB8fCAnLycpO1xuICB2YXIgZW5kc1dpdGhEZWxpbWl0ZXIgPSByb3V0ZS5zbGljZSgtZGVsaW1pdGVyLmxlbmd0aCkgPT09IGRlbGltaXRlcjtcblxuICAvLyBJbiBub24tc3RyaWN0IG1vZGUgd2UgYWxsb3cgYSBzbGFzaCBhdCB0aGUgZW5kIG9mIG1hdGNoLiBJZiB0aGUgcGF0aCB0b1xuICAvLyBtYXRjaCBhbHJlYWR5IGVuZHMgd2l0aCBhIHNsYXNoLCB3ZSByZW1vdmUgaXQgZm9yIGNvbnNpc3RlbmN5LiBUaGUgc2xhc2hcbiAgLy8gaXMgdmFsaWQgYXQgdGhlIGVuZCBvZiBhIHBhdGggbWF0Y2gsIG5vdCBpbiB0aGUgbWlkZGxlLiBUaGlzIGlzIGltcG9ydGFudFxuICAvLyBpbiBub24tZW5kaW5nIG1vZGUsIHdoZXJlIFwiL3Rlc3QvXCIgc2hvdWxkbid0IG1hdGNoIFwiL3Rlc3QvL3JvdXRlXCIuXG4gIGlmICghc3RyaWN0KSB7XG4gICAgcm91dGUgPSAoZW5kc1dpdGhEZWxpbWl0ZXIgPyByb3V0ZS5zbGljZSgwLCAtZGVsaW1pdGVyLmxlbmd0aCkgOiByb3V0ZSkgKyAnKD86JyArIGRlbGltaXRlciArICcoPz0kKSk/JztcbiAgfVxuXG4gIGlmIChlbmQpIHtcbiAgICByb3V0ZSArPSAnJCc7XG4gIH0gZWxzZSB7XG4gICAgLy8gSW4gbm9uLWVuZGluZyBtb2RlLCB3ZSBuZWVkIHRoZSBjYXB0dXJpbmcgZ3JvdXBzIHRvIG1hdGNoIGFzIG11Y2ggYXNcbiAgICAvLyBwb3NzaWJsZSBieSB1c2luZyBhIHBvc2l0aXZlIGxvb2thaGVhZCB0byB0aGUgZW5kIG9yIG5leHQgcGF0aCBzZWdtZW50LlxuICAgIHJvdXRlICs9IHN0cmljdCAmJiBlbmRzV2l0aERlbGltaXRlciA/ICcnIDogJyg/PScgKyBkZWxpbWl0ZXIgKyAnfCQpJztcbiAgfVxuXG4gIHJldHVybiBhdHRhY2hLZXlzKG5ldyBSZWdFeHAoJ14nICsgcm91dGUsIGZsYWdzKG9wdGlvbnMpKSwga2V5cylcbn1cblxuLyoqXG4gKiBOb3JtYWxpemUgdGhlIGdpdmVuIHBhdGggc3RyaW5nLCByZXR1cm5pbmcgYSByZWd1bGFyIGV4cHJlc3Npb24uXG4gKlxuICogQW4gZW1wdHkgYXJyYXkgY2FuIGJlIHBhc3NlZCBpbiBmb3IgdGhlIGtleXMsIHdoaWNoIHdpbGwgaG9sZCB0aGVcbiAqIHBsYWNlaG9sZGVyIGtleSBkZXNjcmlwdGlvbnMuIEZvciBleGFtcGxlLCB1c2luZyBgL3VzZXIvOmlkYCwgYGtleXNgIHdpbGxcbiAqIGNvbnRhaW4gYFt7IG5hbWU6ICdpZCcsIGRlbGltaXRlcjogJy8nLCBvcHRpb25hbDogZmFsc2UsIHJlcGVhdDogZmFsc2UgfV1gLlxuICpcbiAqIEBwYXJhbSAgeyhzdHJpbmd8UmVnRXhwfEFycmF5KX0gcGF0aFxuICogQHBhcmFtICB7KEFycmF5fE9iamVjdCk9fSAgICAgICBrZXlzXG4gKiBAcGFyYW0gIHtPYmplY3Q9fSAgICAgICAgICAgICAgIG9wdGlvbnNcbiAqIEByZXR1cm4geyFSZWdFeHB9XG4gKi9cbmZ1bmN0aW9uIHBhdGhUb1JlZ2V4cCAocGF0aCwga2V5cywgb3B0aW9ucykge1xuICBpZiAoIWlzYXJyYXkoa2V5cykpIHtcbiAgICBvcHRpb25zID0gLyoqIEB0eXBlIHshT2JqZWN0fSAqLyAoa2V5cyB8fCBvcHRpb25zKTtcbiAgICBrZXlzID0gW107XG4gIH1cblxuICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblxuICBpZiAocGF0aCBpbnN0YW5jZW9mIFJlZ0V4cCkge1xuICAgIHJldHVybiByZWdleHBUb1JlZ2V4cChwYXRoLCAvKiogQHR5cGUgeyFBcnJheX0gKi8gKGtleXMpKVxuICB9XG5cbiAgaWYgKGlzYXJyYXkocGF0aCkpIHtcbiAgICByZXR1cm4gYXJyYXlUb1JlZ2V4cCgvKiogQHR5cGUgeyFBcnJheX0gKi8gKHBhdGgpLCAvKiogQHR5cGUgeyFBcnJheX0gKi8gKGtleXMpLCBvcHRpb25zKVxuICB9XG5cbiAgcmV0dXJuIHN0cmluZ1RvUmVnZXhwKC8qKiBAdHlwZSB7c3RyaW5nfSAqLyAocGF0aCksIC8qKiBAdHlwZSB7IUFycmF5fSAqLyAoa2V5cyksIG9wdGlvbnMpXG59XG5cbnBhdGhUb1JlZ2V4cF8xLnBhcnNlID0gcGFyc2VfMTtcbnBhdGhUb1JlZ2V4cF8xLmNvbXBpbGUgPSBjb21waWxlXzE7XG5wYXRoVG9SZWdleHBfMS50b2tlbnNUb0Z1bmN0aW9uID0gdG9rZW5zVG9GdW5jdGlvbl8xO1xucGF0aFRvUmVnZXhwXzEudG9rZW5zVG9SZWdFeHAgPSB0b2tlbnNUb1JlZ0V4cF8xO1xuXG4vKiAgKi9cblxuLy8gJGZsb3ctZGlzYWJsZS1saW5lXG52YXIgcmVnZXhwQ29tcGlsZUNhY2hlID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcblxuZnVuY3Rpb24gZmlsbFBhcmFtcyAoXG4gIHBhdGgsXG4gIHBhcmFtcyxcbiAgcm91dGVNc2dcbikge1xuICB0cnkge1xuICAgIHZhciBmaWxsZXIgPVxuICAgICAgcmVnZXhwQ29tcGlsZUNhY2hlW3BhdGhdIHx8XG4gICAgICAocmVnZXhwQ29tcGlsZUNhY2hlW3BhdGhdID0gcGF0aFRvUmVnZXhwXzEuY29tcGlsZShwYXRoKSk7XG4gICAgcmV0dXJuIGZpbGxlcihwYXJhbXMgfHwge30sIHsgcHJldHR5OiB0cnVlIH0pXG4gIH0gY2F0Y2ggKGUpIHtcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgd2FybihmYWxzZSwgKFwibWlzc2luZyBwYXJhbSBmb3IgXCIgKyByb3V0ZU1zZyArIFwiOiBcIiArIChlLm1lc3NhZ2UpKSk7XG4gICAgfVxuICAgIHJldHVybiAnJ1xuICB9XG59XG5cbi8qICAqL1xuXG5mdW5jdGlvbiBjcmVhdGVSb3V0ZU1hcCAoXG4gIHJvdXRlcyxcbiAgb2xkUGF0aExpc3QsXG4gIG9sZFBhdGhNYXAsXG4gIG9sZE5hbWVNYXBcbikge1xuICAvLyB0aGUgcGF0aCBsaXN0IGlzIHVzZWQgdG8gY29udHJvbCBwYXRoIG1hdGNoaW5nIHByaW9yaXR5XG4gIHZhciBwYXRoTGlzdCA9IG9sZFBhdGhMaXN0IHx8IFtdO1xuICAvLyAkZmxvdy1kaXNhYmxlLWxpbmVcbiAgdmFyIHBhdGhNYXAgPSBvbGRQYXRoTWFwIHx8IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gIC8vICRmbG93LWRpc2FibGUtbGluZVxuICB2YXIgbmFtZU1hcCA9IG9sZE5hbWVNYXAgfHwgT2JqZWN0LmNyZWF0ZShudWxsKTtcblxuICByb3V0ZXMuZm9yRWFjaChmdW5jdGlvbiAocm91dGUpIHtcbiAgICBhZGRSb3V0ZVJlY29yZChwYXRoTGlzdCwgcGF0aE1hcCwgbmFtZU1hcCwgcm91dGUpO1xuICB9KTtcblxuICAvLyBlbnN1cmUgd2lsZGNhcmQgcm91dGVzIGFyZSBhbHdheXMgYXQgdGhlIGVuZFxuICBmb3IgKHZhciBpID0gMCwgbCA9IHBhdGhMaXN0Lmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgIGlmIChwYXRoTGlzdFtpXSA9PT0gJyonKSB7XG4gICAgICBwYXRoTGlzdC5wdXNoKHBhdGhMaXN0LnNwbGljZShpLCAxKVswXSk7XG4gICAgICBsLS07XG4gICAgICBpLS07XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHtcbiAgICBwYXRoTGlzdDogcGF0aExpc3QsXG4gICAgcGF0aE1hcDogcGF0aE1hcCxcbiAgICBuYW1lTWFwOiBuYW1lTWFwXG4gIH1cbn1cblxuZnVuY3Rpb24gYWRkUm91dGVSZWNvcmQgKFxuICBwYXRoTGlzdCxcbiAgcGF0aE1hcCxcbiAgbmFtZU1hcCxcbiAgcm91dGUsXG4gIHBhcmVudCxcbiAgbWF0Y2hBc1xuKSB7XG4gIHZhciBwYXRoID0gcm91dGUucGF0aDtcbiAgdmFyIG5hbWUgPSByb3V0ZS5uYW1lO1xuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgIGFzc2VydChwYXRoICE9IG51bGwsIFwiXFxcInBhdGhcXFwiIGlzIHJlcXVpcmVkIGluIGEgcm91dGUgY29uZmlndXJhdGlvbi5cIik7XG4gICAgYXNzZXJ0KFxuICAgICAgdHlwZW9mIHJvdXRlLmNvbXBvbmVudCAhPT0gJ3N0cmluZycsXG4gICAgICBcInJvdXRlIGNvbmZpZyBcXFwiY29tcG9uZW50XFxcIiBmb3IgcGF0aDogXCIgKyAoU3RyaW5nKHBhdGggfHwgbmFtZSkpICsgXCIgY2Fubm90IGJlIGEgXCIgK1xuICAgICAgXCJzdHJpbmcgaWQuIFVzZSBhbiBhY3R1YWwgY29tcG9uZW50IGluc3RlYWQuXCJcbiAgICApO1xuICB9XG5cbiAgdmFyIHBhdGhUb1JlZ2V4cE9wdGlvbnMgPSByb3V0ZS5wYXRoVG9SZWdleHBPcHRpb25zIHx8IHt9O1xuICB2YXIgbm9ybWFsaXplZFBhdGggPSBub3JtYWxpemVQYXRoKFxuICAgIHBhdGgsXG4gICAgcGFyZW50LFxuICAgIHBhdGhUb1JlZ2V4cE9wdGlvbnMuc3RyaWN0XG4gICk7XG5cbiAgaWYgKHR5cGVvZiByb3V0ZS5jYXNlU2Vuc2l0aXZlID09PSAnYm9vbGVhbicpIHtcbiAgICBwYXRoVG9SZWdleHBPcHRpb25zLnNlbnNpdGl2ZSA9IHJvdXRlLmNhc2VTZW5zaXRpdmU7XG4gIH1cblxuICB2YXIgcmVjb3JkID0ge1xuICAgIHBhdGg6IG5vcm1hbGl6ZWRQYXRoLFxuICAgIHJlZ2V4OiBjb21waWxlUm91dGVSZWdleChub3JtYWxpemVkUGF0aCwgcGF0aFRvUmVnZXhwT3B0aW9ucyksXG4gICAgY29tcG9uZW50czogcm91dGUuY29tcG9uZW50cyB8fCB7IGRlZmF1bHQ6IHJvdXRlLmNvbXBvbmVudCB9LFxuICAgIGluc3RhbmNlczoge30sXG4gICAgbmFtZTogbmFtZSxcbiAgICBwYXJlbnQ6IHBhcmVudCxcbiAgICBtYXRjaEFzOiBtYXRjaEFzLFxuICAgIHJlZGlyZWN0OiByb3V0ZS5yZWRpcmVjdCxcbiAgICBiZWZvcmVFbnRlcjogcm91dGUuYmVmb3JlRW50ZXIsXG4gICAgbWV0YTogcm91dGUubWV0YSB8fCB7fSxcbiAgICBwcm9wczogcm91dGUucHJvcHMgPT0gbnVsbFxuICAgICAgPyB7fVxuICAgICAgOiByb3V0ZS5jb21wb25lbnRzXG4gICAgICAgID8gcm91dGUucHJvcHNcbiAgICAgICAgOiB7IGRlZmF1bHQ6IHJvdXRlLnByb3BzIH1cbiAgfTtcblxuICBpZiAocm91dGUuY2hpbGRyZW4pIHtcbiAgICAvLyBXYXJuIGlmIHJvdXRlIGlzIG5hbWVkLCBkb2VzIG5vdCByZWRpcmVjdCBhbmQgaGFzIGEgZGVmYXVsdCBjaGlsZCByb3V0ZS5cbiAgICAvLyBJZiB1c2VycyBuYXZpZ2F0ZSB0byB0aGlzIHJvdXRlIGJ5IG5hbWUsIHRoZSBkZWZhdWx0IGNoaWxkIHdpbGxcbiAgICAvLyBub3QgYmUgcmVuZGVyZWQgKEdIIElzc3VlICM2MjkpXG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIGlmIChyb3V0ZS5uYW1lICYmICFyb3V0ZS5yZWRpcmVjdCAmJiByb3V0ZS5jaGlsZHJlbi5zb21lKGZ1bmN0aW9uIChjaGlsZCkgeyByZXR1cm4gL15cXC8/JC8udGVzdChjaGlsZC5wYXRoKTsgfSkpIHtcbiAgICAgICAgd2FybihcbiAgICAgICAgICBmYWxzZSxcbiAgICAgICAgICBcIk5hbWVkIFJvdXRlICdcIiArIChyb3V0ZS5uYW1lKSArIFwiJyBoYXMgYSBkZWZhdWx0IGNoaWxkIHJvdXRlLiBcIiArXG4gICAgICAgICAgXCJXaGVuIG5hdmlnYXRpbmcgdG8gdGhpcyBuYW1lZCByb3V0ZSAoOnRvPVxcXCJ7bmFtZTogJ1wiICsgKHJvdXRlLm5hbWUpICsgXCInXFxcIiksIFwiICtcbiAgICAgICAgICBcInRoZSBkZWZhdWx0IGNoaWxkIHJvdXRlIHdpbGwgbm90IGJlIHJlbmRlcmVkLiBSZW1vdmUgdGhlIG5hbWUgZnJvbSBcIiArXG4gICAgICAgICAgXCJ0aGlzIHJvdXRlIGFuZCB1c2UgdGhlIG5hbWUgb2YgdGhlIGRlZmF1bHQgY2hpbGQgcm91dGUgZm9yIG5hbWVkIFwiICtcbiAgICAgICAgICBcImxpbmtzIGluc3RlYWQuXCJcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcm91dGUuY2hpbGRyZW4uZm9yRWFjaChmdW5jdGlvbiAoY2hpbGQpIHtcbiAgICAgIHZhciBjaGlsZE1hdGNoQXMgPSBtYXRjaEFzXG4gICAgICAgID8gY2xlYW5QYXRoKChtYXRjaEFzICsgXCIvXCIgKyAoY2hpbGQucGF0aCkpKVxuICAgICAgICA6IHVuZGVmaW5lZDtcbiAgICAgIGFkZFJvdXRlUmVjb3JkKHBhdGhMaXN0LCBwYXRoTWFwLCBuYW1lTWFwLCBjaGlsZCwgcmVjb3JkLCBjaGlsZE1hdGNoQXMpO1xuICAgIH0pO1xuICB9XG5cbiAgaWYgKHJvdXRlLmFsaWFzICE9PSB1bmRlZmluZWQpIHtcbiAgICB2YXIgYWxpYXNlcyA9IEFycmF5LmlzQXJyYXkocm91dGUuYWxpYXMpXG4gICAgICA/IHJvdXRlLmFsaWFzXG4gICAgICA6IFtyb3V0ZS5hbGlhc107XG5cbiAgICBhbGlhc2VzLmZvckVhY2goZnVuY3Rpb24gKGFsaWFzKSB7XG4gICAgICB2YXIgYWxpYXNSb3V0ZSA9IHtcbiAgICAgICAgcGF0aDogYWxpYXMsXG4gICAgICAgIGNoaWxkcmVuOiByb3V0ZS5jaGlsZHJlblxuICAgICAgfTtcbiAgICAgIGFkZFJvdXRlUmVjb3JkKFxuICAgICAgICBwYXRoTGlzdCxcbiAgICAgICAgcGF0aE1hcCxcbiAgICAgICAgbmFtZU1hcCxcbiAgICAgICAgYWxpYXNSb3V0ZSxcbiAgICAgICAgcGFyZW50LFxuICAgICAgICByZWNvcmQucGF0aCB8fCAnLycgLy8gbWF0Y2hBc1xuICAgICAgKTtcbiAgICB9KTtcbiAgfVxuXG4gIGlmICghcGF0aE1hcFtyZWNvcmQucGF0aF0pIHtcbiAgICBwYXRoTGlzdC5wdXNoKHJlY29yZC5wYXRoKTtcbiAgICBwYXRoTWFwW3JlY29yZC5wYXRoXSA9IHJlY29yZDtcbiAgfVxuXG4gIGlmIChuYW1lKSB7XG4gICAgaWYgKCFuYW1lTWFwW25hbWVdKSB7XG4gICAgICBuYW1lTWFwW25hbWVdID0gcmVjb3JkO1xuICAgIH0gZWxzZSBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiAhbWF0Y2hBcykge1xuICAgICAgd2FybihcbiAgICAgICAgZmFsc2UsXG4gICAgICAgIFwiRHVwbGljYXRlIG5hbWVkIHJvdXRlcyBkZWZpbml0aW9uOiBcIiArXG4gICAgICAgIFwieyBuYW1lOiBcXFwiXCIgKyBuYW1lICsgXCJcXFwiLCBwYXRoOiBcXFwiXCIgKyAocmVjb3JkLnBhdGgpICsgXCJcXFwiIH1cIlxuICAgICAgKTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gY29tcGlsZVJvdXRlUmVnZXggKHBhdGgsIHBhdGhUb1JlZ2V4cE9wdGlvbnMpIHtcbiAgdmFyIHJlZ2V4ID0gcGF0aFRvUmVnZXhwXzEocGF0aCwgW10sIHBhdGhUb1JlZ2V4cE9wdGlvbnMpO1xuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgIHZhciBrZXlzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICByZWdleC5rZXlzLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgICAgd2Fybigha2V5c1trZXkubmFtZV0sIChcIkR1cGxpY2F0ZSBwYXJhbSBrZXlzIGluIHJvdXRlIHdpdGggcGF0aDogXFxcIlwiICsgcGF0aCArIFwiXFxcIlwiKSk7XG4gICAgICBrZXlzW2tleS5uYW1lXSA9IHRydWU7XG4gICAgfSk7XG4gIH1cbiAgcmV0dXJuIHJlZ2V4XG59XG5cbmZ1bmN0aW9uIG5vcm1hbGl6ZVBhdGggKHBhdGgsIHBhcmVudCwgc3RyaWN0KSB7XG4gIGlmICghc3RyaWN0KSB7IHBhdGggPSBwYXRoLnJlcGxhY2UoL1xcLyQvLCAnJyk7IH1cbiAgaWYgKHBhdGhbMF0gPT09ICcvJykgeyByZXR1cm4gcGF0aCB9XG4gIGlmIChwYXJlbnQgPT0gbnVsbCkgeyByZXR1cm4gcGF0aCB9XG4gIHJldHVybiBjbGVhblBhdGgoKChwYXJlbnQucGF0aCkgKyBcIi9cIiArIHBhdGgpKVxufVxuXG4vKiAgKi9cblxuXG5mdW5jdGlvbiBub3JtYWxpemVMb2NhdGlvbiAoXG4gIHJhdyxcbiAgY3VycmVudCxcbiAgYXBwZW5kLFxuICByb3V0ZXJcbikge1xuICB2YXIgbmV4dCA9IHR5cGVvZiByYXcgPT09ICdzdHJpbmcnID8geyBwYXRoOiByYXcgfSA6IHJhdztcbiAgLy8gbmFtZWQgdGFyZ2V0XG4gIGlmIChuZXh0Lm5hbWUgfHwgbmV4dC5fbm9ybWFsaXplZCkge1xuICAgIHJldHVybiBuZXh0XG4gIH1cblxuICAvLyByZWxhdGl2ZSBwYXJhbXNcbiAgaWYgKCFuZXh0LnBhdGggJiYgbmV4dC5wYXJhbXMgJiYgY3VycmVudCkge1xuICAgIG5leHQgPSBhc3NpZ24oe30sIG5leHQpO1xuICAgIG5leHQuX25vcm1hbGl6ZWQgPSB0cnVlO1xuICAgIHZhciBwYXJhbXMgPSBhc3NpZ24oYXNzaWduKHt9LCBjdXJyZW50LnBhcmFtcyksIG5leHQucGFyYW1zKTtcbiAgICBpZiAoY3VycmVudC5uYW1lKSB7XG4gICAgICBuZXh0Lm5hbWUgPSBjdXJyZW50Lm5hbWU7XG4gICAgICBuZXh0LnBhcmFtcyA9IHBhcmFtcztcbiAgICB9IGVsc2UgaWYgKGN1cnJlbnQubWF0Y2hlZC5sZW5ndGgpIHtcbiAgICAgIHZhciByYXdQYXRoID0gY3VycmVudC5tYXRjaGVkW2N1cnJlbnQubWF0Y2hlZC5sZW5ndGggLSAxXS5wYXRoO1xuICAgICAgbmV4dC5wYXRoID0gZmlsbFBhcmFtcyhyYXdQYXRoLCBwYXJhbXMsIChcInBhdGggXCIgKyAoY3VycmVudC5wYXRoKSkpO1xuICAgIH0gZWxzZSBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgd2FybihmYWxzZSwgXCJyZWxhdGl2ZSBwYXJhbXMgbmF2aWdhdGlvbiByZXF1aXJlcyBhIGN1cnJlbnQgcm91dGUuXCIpO1xuICAgIH1cbiAgICByZXR1cm4gbmV4dFxuICB9XG5cbiAgdmFyIHBhcnNlZFBhdGggPSBwYXJzZVBhdGgobmV4dC5wYXRoIHx8ICcnKTtcbiAgdmFyIGJhc2VQYXRoID0gKGN1cnJlbnQgJiYgY3VycmVudC5wYXRoKSB8fCAnLyc7XG4gIHZhciBwYXRoID0gcGFyc2VkUGF0aC5wYXRoXG4gICAgPyByZXNvbHZlUGF0aChwYXJzZWRQYXRoLnBhdGgsIGJhc2VQYXRoLCBhcHBlbmQgfHwgbmV4dC5hcHBlbmQpXG4gICAgOiBiYXNlUGF0aDtcblxuICB2YXIgcXVlcnkgPSByZXNvbHZlUXVlcnkoXG4gICAgcGFyc2VkUGF0aC5xdWVyeSxcbiAgICBuZXh0LnF1ZXJ5LFxuICAgIHJvdXRlciAmJiByb3V0ZXIub3B0aW9ucy5wYXJzZVF1ZXJ5XG4gICk7XG5cbiAgdmFyIGhhc2ggPSBuZXh0Lmhhc2ggfHwgcGFyc2VkUGF0aC5oYXNoO1xuICBpZiAoaGFzaCAmJiBoYXNoLmNoYXJBdCgwKSAhPT0gJyMnKSB7XG4gICAgaGFzaCA9IFwiI1wiICsgaGFzaDtcbiAgfVxuXG4gIHJldHVybiB7XG4gICAgX25vcm1hbGl6ZWQ6IHRydWUsXG4gICAgcGF0aDogcGF0aCxcbiAgICBxdWVyeTogcXVlcnksXG4gICAgaGFzaDogaGFzaFxuICB9XG59XG5cbmZ1bmN0aW9uIGFzc2lnbiAoYSwgYikge1xuICBmb3IgKHZhciBrZXkgaW4gYikge1xuICAgIGFba2V5XSA9IGJba2V5XTtcbiAgfVxuICByZXR1cm4gYVxufVxuXG4vKiAgKi9cblxuXG5mdW5jdGlvbiBjcmVhdGVNYXRjaGVyIChcbiAgcm91dGVzLFxuICByb3V0ZXJcbikge1xuICB2YXIgcmVmID0gY3JlYXRlUm91dGVNYXAocm91dGVzKTtcbiAgdmFyIHBhdGhMaXN0ID0gcmVmLnBhdGhMaXN0O1xuICB2YXIgcGF0aE1hcCA9IHJlZi5wYXRoTWFwO1xuICB2YXIgbmFtZU1hcCA9IHJlZi5uYW1lTWFwO1xuXG4gIGZ1bmN0aW9uIGFkZFJvdXRlcyAocm91dGVzKSB7XG4gICAgY3JlYXRlUm91dGVNYXAocm91dGVzLCBwYXRoTGlzdCwgcGF0aE1hcCwgbmFtZU1hcCk7XG4gIH1cblxuICBmdW5jdGlvbiBtYXRjaCAoXG4gICAgcmF3LFxuICAgIGN1cnJlbnRSb3V0ZSxcbiAgICByZWRpcmVjdGVkRnJvbVxuICApIHtcbiAgICB2YXIgbG9jYXRpb24gPSBub3JtYWxpemVMb2NhdGlvbihyYXcsIGN1cnJlbnRSb3V0ZSwgZmFsc2UsIHJvdXRlcik7XG4gICAgdmFyIG5hbWUgPSBsb2NhdGlvbi5uYW1lO1xuXG4gICAgaWYgKG5hbWUpIHtcbiAgICAgIHZhciByZWNvcmQgPSBuYW1lTWFwW25hbWVdO1xuICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgd2FybihyZWNvcmQsIChcIlJvdXRlIHdpdGggbmFtZSAnXCIgKyBuYW1lICsgXCInIGRvZXMgbm90IGV4aXN0XCIpKTtcbiAgICAgIH1cbiAgICAgIGlmICghcmVjb3JkKSB7IHJldHVybiBfY3JlYXRlUm91dGUobnVsbCwgbG9jYXRpb24pIH1cbiAgICAgIHZhciBwYXJhbU5hbWVzID0gcmVjb3JkLnJlZ2V4LmtleXNcbiAgICAgICAgLmZpbHRlcihmdW5jdGlvbiAoa2V5KSB7IHJldHVybiAha2V5Lm9wdGlvbmFsOyB9KVxuICAgICAgICAubWFwKGZ1bmN0aW9uIChrZXkpIHsgcmV0dXJuIGtleS5uYW1lOyB9KTtcblxuICAgICAgaWYgKHR5cGVvZiBsb2NhdGlvbi5wYXJhbXMgIT09ICdvYmplY3QnKSB7XG4gICAgICAgIGxvY2F0aW9uLnBhcmFtcyA9IHt9O1xuICAgICAgfVxuXG4gICAgICBpZiAoY3VycmVudFJvdXRlICYmIHR5cGVvZiBjdXJyZW50Um91dGUucGFyYW1zID09PSAnb2JqZWN0Jykge1xuICAgICAgICBmb3IgKHZhciBrZXkgaW4gY3VycmVudFJvdXRlLnBhcmFtcykge1xuICAgICAgICAgIGlmICghKGtleSBpbiBsb2NhdGlvbi5wYXJhbXMpICYmIHBhcmFtTmFtZXMuaW5kZXhPZihrZXkpID4gLTEpIHtcbiAgICAgICAgICAgIGxvY2F0aW9uLnBhcmFtc1trZXldID0gY3VycmVudFJvdXRlLnBhcmFtc1trZXldO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAocmVjb3JkKSB7XG4gICAgICAgIGxvY2F0aW9uLnBhdGggPSBmaWxsUGFyYW1zKHJlY29yZC5wYXRoLCBsb2NhdGlvbi5wYXJhbXMsIChcIm5hbWVkIHJvdXRlIFxcXCJcIiArIG5hbWUgKyBcIlxcXCJcIikpO1xuICAgICAgICByZXR1cm4gX2NyZWF0ZVJvdXRlKHJlY29yZCwgbG9jYXRpb24sIHJlZGlyZWN0ZWRGcm9tKVxuICAgICAgfVxuICAgIH0gZWxzZSBpZiAobG9jYXRpb24ucGF0aCkge1xuICAgICAgbG9jYXRpb24ucGFyYW1zID0ge307XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHBhdGhMaXN0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBwYXRoID0gcGF0aExpc3RbaV07XG4gICAgICAgIHZhciByZWNvcmQkMSA9IHBhdGhNYXBbcGF0aF07XG4gICAgICAgIGlmIChtYXRjaFJvdXRlKHJlY29yZCQxLnJlZ2V4LCBsb2NhdGlvbi5wYXRoLCBsb2NhdGlvbi5wYXJhbXMpKSB7XG4gICAgICAgICAgcmV0dXJuIF9jcmVhdGVSb3V0ZShyZWNvcmQkMSwgbG9jYXRpb24sIHJlZGlyZWN0ZWRGcm9tKVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIC8vIG5vIG1hdGNoXG4gICAgcmV0dXJuIF9jcmVhdGVSb3V0ZShudWxsLCBsb2NhdGlvbilcbiAgfVxuXG4gIGZ1bmN0aW9uIHJlZGlyZWN0IChcbiAgICByZWNvcmQsXG4gICAgbG9jYXRpb25cbiAgKSB7XG4gICAgdmFyIG9yaWdpbmFsUmVkaXJlY3QgPSByZWNvcmQucmVkaXJlY3Q7XG4gICAgdmFyIHJlZGlyZWN0ID0gdHlwZW9mIG9yaWdpbmFsUmVkaXJlY3QgPT09ICdmdW5jdGlvbidcbiAgICAgICAgPyBvcmlnaW5hbFJlZGlyZWN0KGNyZWF0ZVJvdXRlKHJlY29yZCwgbG9jYXRpb24sIG51bGwsIHJvdXRlcikpXG4gICAgICAgIDogb3JpZ2luYWxSZWRpcmVjdDtcblxuICAgIGlmICh0eXBlb2YgcmVkaXJlY3QgPT09ICdzdHJpbmcnKSB7XG4gICAgICByZWRpcmVjdCA9IHsgcGF0aDogcmVkaXJlY3QgfTtcbiAgICB9XG5cbiAgICBpZiAoIXJlZGlyZWN0IHx8IHR5cGVvZiByZWRpcmVjdCAhPT0gJ29iamVjdCcpIHtcbiAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgIHdhcm4oXG4gICAgICAgICAgZmFsc2UsIChcImludmFsaWQgcmVkaXJlY3Qgb3B0aW9uOiBcIiArIChKU09OLnN0cmluZ2lmeShyZWRpcmVjdCkpKVxuICAgICAgICApO1xuICAgICAgfVxuICAgICAgcmV0dXJuIF9jcmVhdGVSb3V0ZShudWxsLCBsb2NhdGlvbilcbiAgICB9XG5cbiAgICB2YXIgcmUgPSByZWRpcmVjdDtcbiAgICB2YXIgbmFtZSA9IHJlLm5hbWU7XG4gICAgdmFyIHBhdGggPSByZS5wYXRoO1xuICAgIHZhciBxdWVyeSA9IGxvY2F0aW9uLnF1ZXJ5O1xuICAgIHZhciBoYXNoID0gbG9jYXRpb24uaGFzaDtcbiAgICB2YXIgcGFyYW1zID0gbG9jYXRpb24ucGFyYW1zO1xuICAgIHF1ZXJ5ID0gcmUuaGFzT3duUHJvcGVydHkoJ3F1ZXJ5JykgPyByZS5xdWVyeSA6IHF1ZXJ5O1xuICAgIGhhc2ggPSByZS5oYXNPd25Qcm9wZXJ0eSgnaGFzaCcpID8gcmUuaGFzaCA6IGhhc2g7XG4gICAgcGFyYW1zID0gcmUuaGFzT3duUHJvcGVydHkoJ3BhcmFtcycpID8gcmUucGFyYW1zIDogcGFyYW1zO1xuXG4gICAgaWYgKG5hbWUpIHtcbiAgICAgIC8vIHJlc29sdmVkIG5hbWVkIGRpcmVjdFxuICAgICAgdmFyIHRhcmdldFJlY29yZCA9IG5hbWVNYXBbbmFtZV07XG4gICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICBhc3NlcnQodGFyZ2V0UmVjb3JkLCAoXCJyZWRpcmVjdCBmYWlsZWQ6IG5hbWVkIHJvdXRlIFxcXCJcIiArIG5hbWUgKyBcIlxcXCIgbm90IGZvdW5kLlwiKSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gbWF0Y2goe1xuICAgICAgICBfbm9ybWFsaXplZDogdHJ1ZSxcbiAgICAgICAgbmFtZTogbmFtZSxcbiAgICAgICAgcXVlcnk6IHF1ZXJ5LFxuICAgICAgICBoYXNoOiBoYXNoLFxuICAgICAgICBwYXJhbXM6IHBhcmFtc1xuICAgICAgfSwgdW5kZWZpbmVkLCBsb2NhdGlvbilcbiAgICB9IGVsc2UgaWYgKHBhdGgpIHtcbiAgICAgIC8vIDEuIHJlc29sdmUgcmVsYXRpdmUgcmVkaXJlY3RcbiAgICAgIHZhciByYXdQYXRoID0gcmVzb2x2ZVJlY29yZFBhdGgocGF0aCwgcmVjb3JkKTtcbiAgICAgIC8vIDIuIHJlc29sdmUgcGFyYW1zXG4gICAgICB2YXIgcmVzb2x2ZWRQYXRoID0gZmlsbFBhcmFtcyhyYXdQYXRoLCBwYXJhbXMsIChcInJlZGlyZWN0IHJvdXRlIHdpdGggcGF0aCBcXFwiXCIgKyByYXdQYXRoICsgXCJcXFwiXCIpKTtcbiAgICAgIC8vIDMuIHJlbWF0Y2ggd2l0aCBleGlzdGluZyBxdWVyeSBhbmQgaGFzaFxuICAgICAgcmV0dXJuIG1hdGNoKHtcbiAgICAgICAgX25vcm1hbGl6ZWQ6IHRydWUsXG4gICAgICAgIHBhdGg6IHJlc29sdmVkUGF0aCxcbiAgICAgICAgcXVlcnk6IHF1ZXJ5LFxuICAgICAgICBoYXNoOiBoYXNoXG4gICAgICB9LCB1bmRlZmluZWQsIGxvY2F0aW9uKVxuICAgIH0gZWxzZSB7XG4gICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICB3YXJuKGZhbHNlLCAoXCJpbnZhbGlkIHJlZGlyZWN0IG9wdGlvbjogXCIgKyAoSlNPTi5zdHJpbmdpZnkocmVkaXJlY3QpKSkpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIF9jcmVhdGVSb3V0ZShudWxsLCBsb2NhdGlvbilcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBhbGlhcyAoXG4gICAgcmVjb3JkLFxuICAgIGxvY2F0aW9uLFxuICAgIG1hdGNoQXNcbiAgKSB7XG4gICAgdmFyIGFsaWFzZWRQYXRoID0gZmlsbFBhcmFtcyhtYXRjaEFzLCBsb2NhdGlvbi5wYXJhbXMsIChcImFsaWFzZWQgcm91dGUgd2l0aCBwYXRoIFxcXCJcIiArIG1hdGNoQXMgKyBcIlxcXCJcIikpO1xuICAgIHZhciBhbGlhc2VkTWF0Y2ggPSBtYXRjaCh7XG4gICAgICBfbm9ybWFsaXplZDogdHJ1ZSxcbiAgICAgIHBhdGg6IGFsaWFzZWRQYXRoXG4gICAgfSk7XG4gICAgaWYgKGFsaWFzZWRNYXRjaCkge1xuICAgICAgdmFyIG1hdGNoZWQgPSBhbGlhc2VkTWF0Y2gubWF0Y2hlZDtcbiAgICAgIHZhciBhbGlhc2VkUmVjb3JkID0gbWF0Y2hlZFttYXRjaGVkLmxlbmd0aCAtIDFdO1xuICAgICAgbG9jYXRpb24ucGFyYW1zID0gYWxpYXNlZE1hdGNoLnBhcmFtcztcbiAgICAgIHJldHVybiBfY3JlYXRlUm91dGUoYWxpYXNlZFJlY29yZCwgbG9jYXRpb24pXG4gICAgfVxuICAgIHJldHVybiBfY3JlYXRlUm91dGUobnVsbCwgbG9jYXRpb24pXG4gIH1cblxuICBmdW5jdGlvbiBfY3JlYXRlUm91dGUgKFxuICAgIHJlY29yZCxcbiAgICBsb2NhdGlvbixcbiAgICByZWRpcmVjdGVkRnJvbVxuICApIHtcbiAgICBpZiAocmVjb3JkICYmIHJlY29yZC5yZWRpcmVjdCkge1xuICAgICAgcmV0dXJuIHJlZGlyZWN0KHJlY29yZCwgcmVkaXJlY3RlZEZyb20gfHwgbG9jYXRpb24pXG4gICAgfVxuICAgIGlmIChyZWNvcmQgJiYgcmVjb3JkLm1hdGNoQXMpIHtcbiAgICAgIHJldHVybiBhbGlhcyhyZWNvcmQsIGxvY2F0aW9uLCByZWNvcmQubWF0Y2hBcylcbiAgICB9XG4gICAgcmV0dXJuIGNyZWF0ZVJvdXRlKHJlY29yZCwgbG9jYXRpb24sIHJlZGlyZWN0ZWRGcm9tLCByb3V0ZXIpXG4gIH1cblxuICByZXR1cm4ge1xuICAgIG1hdGNoOiBtYXRjaCxcbiAgICBhZGRSb3V0ZXM6IGFkZFJvdXRlc1xuICB9XG59XG5cbmZ1bmN0aW9uIG1hdGNoUm91dGUgKFxuICByZWdleCxcbiAgcGF0aCxcbiAgcGFyYW1zXG4pIHtcbiAgdmFyIG0gPSBwYXRoLm1hdGNoKHJlZ2V4KTtcblxuICBpZiAoIW0pIHtcbiAgICByZXR1cm4gZmFsc2VcbiAgfSBlbHNlIGlmICghcGFyYW1zKSB7XG4gICAgcmV0dXJuIHRydWVcbiAgfVxuXG4gIGZvciAodmFyIGkgPSAxLCBsZW4gPSBtLmxlbmd0aDsgaSA8IGxlbjsgKytpKSB7XG4gICAgdmFyIGtleSA9IHJlZ2V4LmtleXNbaSAtIDFdO1xuICAgIHZhciB2YWwgPSB0eXBlb2YgbVtpXSA9PT0gJ3N0cmluZycgPyBkZWNvZGVVUklDb21wb25lbnQobVtpXSkgOiBtW2ldO1xuICAgIGlmIChrZXkpIHtcbiAgICAgIHBhcmFtc1trZXkubmFtZV0gPSB2YWw7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRydWVcbn1cblxuZnVuY3Rpb24gcmVzb2x2ZVJlY29yZFBhdGggKHBhdGgsIHJlY29yZCkge1xuICByZXR1cm4gcmVzb2x2ZVBhdGgocGF0aCwgcmVjb3JkLnBhcmVudCA/IHJlY29yZC5wYXJlbnQucGF0aCA6ICcvJywgdHJ1ZSlcbn1cblxuLyogICovXG5cblxudmFyIHBvc2l0aW9uU3RvcmUgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuXG5mdW5jdGlvbiBzZXR1cFNjcm9sbCAoKSB7XG4gIC8vIEZpeCBmb3IgIzE1ODUgZm9yIEZpcmVmb3hcbiAgd2luZG93Lmhpc3RvcnkucmVwbGFjZVN0YXRlKHsga2V5OiBnZXRTdGF0ZUtleSgpIH0sICcnKTtcbiAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ3BvcHN0YXRlJywgZnVuY3Rpb24gKGUpIHtcbiAgICBzYXZlU2Nyb2xsUG9zaXRpb24oKTtcbiAgICBpZiAoZS5zdGF0ZSAmJiBlLnN0YXRlLmtleSkge1xuICAgICAgc2V0U3RhdGVLZXkoZS5zdGF0ZS5rZXkpO1xuICAgIH1cbiAgfSk7XG59XG5cbmZ1bmN0aW9uIGhhbmRsZVNjcm9sbCAoXG4gIHJvdXRlcixcbiAgdG8sXG4gIGZyb20sXG4gIGlzUG9wXG4pIHtcbiAgaWYgKCFyb3V0ZXIuYXBwKSB7XG4gICAgcmV0dXJuXG4gIH1cblxuICB2YXIgYmVoYXZpb3IgPSByb3V0ZXIub3B0aW9ucy5zY3JvbGxCZWhhdmlvcjtcbiAgaWYgKCFiZWhhdmlvcikge1xuICAgIHJldHVyblxuICB9XG5cbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICBhc3NlcnQodHlwZW9mIGJlaGF2aW9yID09PSAnZnVuY3Rpb24nLCBcInNjcm9sbEJlaGF2aW9yIG11c3QgYmUgYSBmdW5jdGlvblwiKTtcbiAgfVxuXG4gIC8vIHdhaXQgdW50aWwgcmUtcmVuZGVyIGZpbmlzaGVzIGJlZm9yZSBzY3JvbGxpbmdcbiAgcm91dGVyLmFwcC4kbmV4dFRpY2soZnVuY3Rpb24gKCkge1xuICAgIHZhciBwb3NpdGlvbiA9IGdldFNjcm9sbFBvc2l0aW9uKCk7XG4gICAgdmFyIHNob3VsZFNjcm9sbCA9IGJlaGF2aW9yKHRvLCBmcm9tLCBpc1BvcCA/IHBvc2l0aW9uIDogbnVsbCk7XG5cbiAgICBpZiAoIXNob3VsZFNjcm9sbCkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBzaG91bGRTY3JvbGwudGhlbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgc2hvdWxkU2Nyb2xsLnRoZW4oZnVuY3Rpb24gKHNob3VsZFNjcm9sbCkge1xuICAgICAgICBzY3JvbGxUb1Bvc2l0aW9uKChzaG91bGRTY3JvbGwpLCBwb3NpdGlvbik7XG4gICAgICB9KS5jYXRjaChmdW5jdGlvbiAoZXJyKSB7XG4gICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgICAgYXNzZXJ0KGZhbHNlLCBlcnIudG9TdHJpbmcoKSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBzY3JvbGxUb1Bvc2l0aW9uKHNob3VsZFNjcm9sbCwgcG9zaXRpb24pO1xuICAgIH1cbiAgfSk7XG59XG5cbmZ1bmN0aW9uIHNhdmVTY3JvbGxQb3NpdGlvbiAoKSB7XG4gIHZhciBrZXkgPSBnZXRTdGF0ZUtleSgpO1xuICBpZiAoa2V5KSB7XG4gICAgcG9zaXRpb25TdG9yZVtrZXldID0ge1xuICAgICAgeDogd2luZG93LnBhZ2VYT2Zmc2V0LFxuICAgICAgeTogd2luZG93LnBhZ2VZT2Zmc2V0XG4gICAgfTtcbiAgfVxufVxuXG5mdW5jdGlvbiBnZXRTY3JvbGxQb3NpdGlvbiAoKSB7XG4gIHZhciBrZXkgPSBnZXRTdGF0ZUtleSgpO1xuICBpZiAoa2V5KSB7XG4gICAgcmV0dXJuIHBvc2l0aW9uU3RvcmVba2V5XVxuICB9XG59XG5cbmZ1bmN0aW9uIGdldEVsZW1lbnRQb3NpdGlvbiAoZWwsIG9mZnNldCkge1xuICB2YXIgZG9jRWwgPSBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQ7XG4gIHZhciBkb2NSZWN0ID0gZG9jRWwuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gIHZhciBlbFJlY3QgPSBlbC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgcmV0dXJuIHtcbiAgICB4OiBlbFJlY3QubGVmdCAtIGRvY1JlY3QubGVmdCAtIG9mZnNldC54LFxuICAgIHk6IGVsUmVjdC50b3AgLSBkb2NSZWN0LnRvcCAtIG9mZnNldC55XG4gIH1cbn1cblxuZnVuY3Rpb24gaXNWYWxpZFBvc2l0aW9uIChvYmopIHtcbiAgcmV0dXJuIGlzTnVtYmVyKG9iai54KSB8fCBpc051bWJlcihvYmoueSlcbn1cblxuZnVuY3Rpb24gbm9ybWFsaXplUG9zaXRpb24gKG9iaikge1xuICByZXR1cm4ge1xuICAgIHg6IGlzTnVtYmVyKG9iai54KSA/IG9iai54IDogd2luZG93LnBhZ2VYT2Zmc2V0LFxuICAgIHk6IGlzTnVtYmVyKG9iai55KSA/IG9iai55IDogd2luZG93LnBhZ2VZT2Zmc2V0XG4gIH1cbn1cblxuZnVuY3Rpb24gbm9ybWFsaXplT2Zmc2V0IChvYmopIHtcbiAgcmV0dXJuIHtcbiAgICB4OiBpc051bWJlcihvYmoueCkgPyBvYmoueCA6IDAsXG4gICAgeTogaXNOdW1iZXIob2JqLnkpID8gb2JqLnkgOiAwXG4gIH1cbn1cblxuZnVuY3Rpb24gaXNOdW1iZXIgKHYpIHtcbiAgcmV0dXJuIHR5cGVvZiB2ID09PSAnbnVtYmVyJ1xufVxuXG5mdW5jdGlvbiBzY3JvbGxUb1Bvc2l0aW9uIChzaG91bGRTY3JvbGwsIHBvc2l0aW9uKSB7XG4gIHZhciBpc09iamVjdCA9IHR5cGVvZiBzaG91bGRTY3JvbGwgPT09ICdvYmplY3QnO1xuICBpZiAoaXNPYmplY3QgJiYgdHlwZW9mIHNob3VsZFNjcm9sbC5zZWxlY3RvciA9PT0gJ3N0cmluZycpIHtcbiAgICB2YXIgZWwgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKHNob3VsZFNjcm9sbC5zZWxlY3Rvcik7XG4gICAgaWYgKGVsKSB7XG4gICAgICB2YXIgb2Zmc2V0ID0gc2hvdWxkU2Nyb2xsLm9mZnNldCAmJiB0eXBlb2Ygc2hvdWxkU2Nyb2xsLm9mZnNldCA9PT0gJ29iamVjdCcgPyBzaG91bGRTY3JvbGwub2Zmc2V0IDoge307XG4gICAgICBvZmZzZXQgPSBub3JtYWxpemVPZmZzZXQob2Zmc2V0KTtcbiAgICAgIHBvc2l0aW9uID0gZ2V0RWxlbWVudFBvc2l0aW9uKGVsLCBvZmZzZXQpO1xuICAgIH0gZWxzZSBpZiAoaXNWYWxpZFBvc2l0aW9uKHNob3VsZFNjcm9sbCkpIHtcbiAgICAgIHBvc2l0aW9uID0gbm9ybWFsaXplUG9zaXRpb24oc2hvdWxkU2Nyb2xsKTtcbiAgICB9XG4gIH0gZWxzZSBpZiAoaXNPYmplY3QgJiYgaXNWYWxpZFBvc2l0aW9uKHNob3VsZFNjcm9sbCkpIHtcbiAgICBwb3NpdGlvbiA9IG5vcm1hbGl6ZVBvc2l0aW9uKHNob3VsZFNjcm9sbCk7XG4gIH1cblxuICBpZiAocG9zaXRpb24pIHtcbiAgICB3aW5kb3cuc2Nyb2xsVG8ocG9zaXRpb24ueCwgcG9zaXRpb24ueSk7XG4gIH1cbn1cblxuLyogICovXG5cbnZhciBzdXBwb3J0c1B1c2hTdGF0ZSA9IGluQnJvd3NlciAmJiAoZnVuY3Rpb24gKCkge1xuICB2YXIgdWEgPSB3aW5kb3cubmF2aWdhdG9yLnVzZXJBZ2VudDtcblxuICBpZiAoXG4gICAgKHVhLmluZGV4T2YoJ0FuZHJvaWQgMi4nKSAhPT0gLTEgfHwgdWEuaW5kZXhPZignQW5kcm9pZCA0LjAnKSAhPT0gLTEpICYmXG4gICAgdWEuaW5kZXhPZignTW9iaWxlIFNhZmFyaScpICE9PSAtMSAmJlxuICAgIHVhLmluZGV4T2YoJ0Nocm9tZScpID09PSAtMSAmJlxuICAgIHVhLmluZGV4T2YoJ1dpbmRvd3MgUGhvbmUnKSA9PT0gLTFcbiAgKSB7XG4gICAgcmV0dXJuIGZhbHNlXG4gIH1cblxuICByZXR1cm4gd2luZG93Lmhpc3RvcnkgJiYgJ3B1c2hTdGF0ZScgaW4gd2luZG93Lmhpc3Rvcnlcbn0pKCk7XG5cbi8vIHVzZSBVc2VyIFRpbWluZyBhcGkgKGlmIHByZXNlbnQpIGZvciBtb3JlIGFjY3VyYXRlIGtleSBwcmVjaXNpb25cbnZhciBUaW1lID0gaW5Ccm93c2VyICYmIHdpbmRvdy5wZXJmb3JtYW5jZSAmJiB3aW5kb3cucGVyZm9ybWFuY2Uubm93XG4gID8gd2luZG93LnBlcmZvcm1hbmNlXG4gIDogRGF0ZTtcblxudmFyIF9rZXkgPSBnZW5LZXkoKTtcblxuZnVuY3Rpb24gZ2VuS2V5ICgpIHtcbiAgcmV0dXJuIFRpbWUubm93KCkudG9GaXhlZCgzKVxufVxuXG5mdW5jdGlvbiBnZXRTdGF0ZUtleSAoKSB7XG4gIHJldHVybiBfa2V5XG59XG5cbmZ1bmN0aW9uIHNldFN0YXRlS2V5IChrZXkpIHtcbiAgX2tleSA9IGtleTtcbn1cblxuZnVuY3Rpb24gcHVzaFN0YXRlICh1cmwsIHJlcGxhY2UpIHtcbiAgc2F2ZVNjcm9sbFBvc2l0aW9uKCk7XG4gIC8vIHRyeS4uLmNhdGNoIHRoZSBwdXNoU3RhdGUgY2FsbCB0byBnZXQgYXJvdW5kIFNhZmFyaVxuICAvLyBET00gRXhjZXB0aW9uIDE4IHdoZXJlIGl0IGxpbWl0cyB0byAxMDAgcHVzaFN0YXRlIGNhbGxzXG4gIHZhciBoaXN0b3J5ID0gd2luZG93Lmhpc3Rvcnk7XG4gIHRyeSB7XG4gICAgaWYgKHJlcGxhY2UpIHtcbiAgICAgIGhpc3RvcnkucmVwbGFjZVN0YXRlKHsga2V5OiBfa2V5IH0sICcnLCB1cmwpO1xuICAgIH0gZWxzZSB7XG4gICAgICBfa2V5ID0gZ2VuS2V5KCk7XG4gICAgICBoaXN0b3J5LnB1c2hTdGF0ZSh7IGtleTogX2tleSB9LCAnJywgdXJsKTtcbiAgICB9XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICB3aW5kb3cubG9jYXRpb25bcmVwbGFjZSA/ICdyZXBsYWNlJyA6ICdhc3NpZ24nXSh1cmwpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHJlcGxhY2VTdGF0ZSAodXJsKSB7XG4gIHB1c2hTdGF0ZSh1cmwsIHRydWUpO1xufVxuXG4vKiAgKi9cblxuZnVuY3Rpb24gcnVuUXVldWUgKHF1ZXVlLCBmbiwgY2IpIHtcbiAgdmFyIHN0ZXAgPSBmdW5jdGlvbiAoaW5kZXgpIHtcbiAgICBpZiAoaW5kZXggPj0gcXVldWUubGVuZ3RoKSB7XG4gICAgICBjYigpO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAocXVldWVbaW5kZXhdKSB7XG4gICAgICAgIGZuKHF1ZXVlW2luZGV4XSwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHN0ZXAoaW5kZXggKyAxKTtcbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzdGVwKGluZGV4ICsgMSk7XG4gICAgICB9XG4gICAgfVxuICB9O1xuICBzdGVwKDApO1xufVxuXG4vKiAgKi9cblxuZnVuY3Rpb24gcmVzb2x2ZUFzeW5jQ29tcG9uZW50cyAobWF0Y2hlZCkge1xuICByZXR1cm4gZnVuY3Rpb24gKHRvLCBmcm9tLCBuZXh0KSB7XG4gICAgdmFyIGhhc0FzeW5jID0gZmFsc2U7XG4gICAgdmFyIHBlbmRpbmcgPSAwO1xuICAgIHZhciBlcnJvciA9IG51bGw7XG5cbiAgICBmbGF0TWFwQ29tcG9uZW50cyhtYXRjaGVkLCBmdW5jdGlvbiAoZGVmLCBfLCBtYXRjaCwga2V5KSB7XG4gICAgICAvLyBpZiBpdCdzIGEgZnVuY3Rpb24gYW5kIGRvZXNuJ3QgaGF2ZSBjaWQgYXR0YWNoZWQsXG4gICAgICAvLyBhc3N1bWUgaXQncyBhbiBhc3luYyBjb21wb25lbnQgcmVzb2x2ZSBmdW5jdGlvbi5cbiAgICAgIC8vIHdlIGFyZSBub3QgdXNpbmcgVnVlJ3MgZGVmYXVsdCBhc3luYyByZXNvbHZpbmcgbWVjaGFuaXNtIGJlY2F1c2VcbiAgICAgIC8vIHdlIHdhbnQgdG8gaGFsdCB0aGUgbmF2aWdhdGlvbiB1bnRpbCB0aGUgaW5jb21pbmcgY29tcG9uZW50IGhhcyBiZWVuXG4gICAgICAvLyByZXNvbHZlZC5cbiAgICAgIGlmICh0eXBlb2YgZGVmID09PSAnZnVuY3Rpb24nICYmIGRlZi5jaWQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBoYXNBc3luYyA9IHRydWU7XG4gICAgICAgIHBlbmRpbmcrKztcblxuICAgICAgICB2YXIgcmVzb2x2ZSA9IG9uY2UoZnVuY3Rpb24gKHJlc29sdmVkRGVmKSB7XG4gICAgICAgICAgaWYgKGlzRVNNb2R1bGUocmVzb2x2ZWREZWYpKSB7XG4gICAgICAgICAgICByZXNvbHZlZERlZiA9IHJlc29sdmVkRGVmLmRlZmF1bHQ7XG4gICAgICAgICAgfVxuICAgICAgICAgIC8vIHNhdmUgcmVzb2x2ZWQgb24gYXN5bmMgZmFjdG9yeSBpbiBjYXNlIGl0J3MgdXNlZCBlbHNld2hlcmVcbiAgICAgICAgICBkZWYucmVzb2x2ZWQgPSB0eXBlb2YgcmVzb2x2ZWREZWYgPT09ICdmdW5jdGlvbidcbiAgICAgICAgICAgID8gcmVzb2x2ZWREZWZcbiAgICAgICAgICAgIDogX1Z1ZS5leHRlbmQocmVzb2x2ZWREZWYpO1xuICAgICAgICAgIG1hdGNoLmNvbXBvbmVudHNba2V5XSA9IHJlc29sdmVkRGVmO1xuICAgICAgICAgIHBlbmRpbmctLTtcbiAgICAgICAgICBpZiAocGVuZGluZyA8PSAwKSB7XG4gICAgICAgICAgICBuZXh0KCk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICB2YXIgcmVqZWN0ID0gb25jZShmdW5jdGlvbiAocmVhc29uKSB7XG4gICAgICAgICAgdmFyIG1zZyA9IFwiRmFpbGVkIHRvIHJlc29sdmUgYXN5bmMgY29tcG9uZW50IFwiICsga2V5ICsgXCI6IFwiICsgcmVhc29uO1xuICAgICAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgd2FybihmYWxzZSwgbXNnKTtcbiAgICAgICAgICBpZiAoIWVycm9yKSB7XG4gICAgICAgICAgICBlcnJvciA9IGlzRXJyb3IocmVhc29uKVxuICAgICAgICAgICAgICA/IHJlYXNvblxuICAgICAgICAgICAgICA6IG5ldyBFcnJvcihtc2cpO1xuICAgICAgICAgICAgbmV4dChlcnJvcik7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICB2YXIgcmVzO1xuICAgICAgICB0cnkge1xuICAgICAgICAgIHJlcyA9IGRlZihyZXNvbHZlLCByZWplY3QpO1xuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgcmVqZWN0KGUpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChyZXMpIHtcbiAgICAgICAgICBpZiAodHlwZW9mIHJlcy50aGVuID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICByZXMudGhlbihyZXNvbHZlLCByZWplY3QpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBuZXcgc3ludGF4IGluIFZ1ZSAyLjNcbiAgICAgICAgICAgIHZhciBjb21wID0gcmVzLmNvbXBvbmVudDtcbiAgICAgICAgICAgIGlmIChjb21wICYmIHR5cGVvZiBjb21wLnRoZW4gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgY29tcC50aGVuKHJlc29sdmUsIHJlamVjdCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICBpZiAoIWhhc0FzeW5jKSB7IG5leHQoKTsgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGZsYXRNYXBDb21wb25lbnRzIChcbiAgbWF0Y2hlZCxcbiAgZm5cbikge1xuICByZXR1cm4gZmxhdHRlbihtYXRjaGVkLm1hcChmdW5jdGlvbiAobSkge1xuICAgIHJldHVybiBPYmplY3Qua2V5cyhtLmNvbXBvbmVudHMpLm1hcChmdW5jdGlvbiAoa2V5KSB7IHJldHVybiBmbihcbiAgICAgIG0uY29tcG9uZW50c1trZXldLFxuICAgICAgbS5pbnN0YW5jZXNba2V5XSxcbiAgICAgIG0sIGtleVxuICAgICk7IH0pXG4gIH0pKVxufVxuXG5mdW5jdGlvbiBmbGF0dGVuIChhcnIpIHtcbiAgcmV0dXJuIEFycmF5LnByb3RvdHlwZS5jb25jYXQuYXBwbHkoW10sIGFycilcbn1cblxudmFyIGhhc1N5bWJvbCA9XG4gIHR5cGVvZiBTeW1ib2wgPT09ICdmdW5jdGlvbicgJiZcbiAgdHlwZW9mIFN5bWJvbC50b1N0cmluZ1RhZyA9PT0gJ3N5bWJvbCc7XG5cbmZ1bmN0aW9uIGlzRVNNb2R1bGUgKG9iaikge1xuICByZXR1cm4gb2JqLl9fZXNNb2R1bGUgfHwgKGhhc1N5bWJvbCAmJiBvYmpbU3ltYm9sLnRvU3RyaW5nVGFnXSA9PT0gJ01vZHVsZScpXG59XG5cbi8vIGluIFdlYnBhY2sgMiwgcmVxdWlyZS5lbnN1cmUgbm93IGFsc28gcmV0dXJucyBhIFByb21pc2Vcbi8vIHNvIHRoZSByZXNvbHZlL3JlamVjdCBmdW5jdGlvbnMgbWF5IGdldCBjYWxsZWQgYW4gZXh0cmEgdGltZVxuLy8gaWYgdGhlIHVzZXIgdXNlcyBhbiBhcnJvdyBmdW5jdGlvbiBzaG9ydGhhbmQgdGhhdCBoYXBwZW5zIHRvXG4vLyByZXR1cm4gdGhhdCBQcm9taXNlLlxuZnVuY3Rpb24gb25jZSAoZm4pIHtcbiAgdmFyIGNhbGxlZCA9IGZhbHNlO1xuICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgIHZhciBhcmdzID0gW10sIGxlbiA9IGFyZ3VtZW50cy5sZW5ndGg7XG4gICAgd2hpbGUgKCBsZW4tLSApIGFyZ3NbIGxlbiBdID0gYXJndW1lbnRzWyBsZW4gXTtcblxuICAgIGlmIChjYWxsZWQpIHsgcmV0dXJuIH1cbiAgICBjYWxsZWQgPSB0cnVlO1xuICAgIHJldHVybiBmbi5hcHBseSh0aGlzLCBhcmdzKVxuICB9XG59XG5cbi8qICAqL1xuXG52YXIgSGlzdG9yeSA9IGZ1bmN0aW9uIEhpc3RvcnkgKHJvdXRlciwgYmFzZSkge1xuICB0aGlzLnJvdXRlciA9IHJvdXRlcjtcbiAgdGhpcy5iYXNlID0gbm9ybWFsaXplQmFzZShiYXNlKTtcbiAgLy8gc3RhcnQgd2l0aCBhIHJvdXRlIG9iamVjdCB0aGF0IHN0YW5kcyBmb3IgXCJub3doZXJlXCJcbiAgdGhpcy5jdXJyZW50ID0gU1RBUlQ7XG4gIHRoaXMucGVuZGluZyA9IG51bGw7XG4gIHRoaXMucmVhZHkgPSBmYWxzZTtcbiAgdGhpcy5yZWFkeUNicyA9IFtdO1xuICB0aGlzLnJlYWR5RXJyb3JDYnMgPSBbXTtcbiAgdGhpcy5lcnJvckNicyA9IFtdO1xufTtcblxuSGlzdG9yeS5wcm90b3R5cGUubGlzdGVuID0gZnVuY3Rpb24gbGlzdGVuIChjYikge1xuICB0aGlzLmNiID0gY2I7XG59O1xuXG5IaXN0b3J5LnByb3RvdHlwZS5vblJlYWR5ID0gZnVuY3Rpb24gb25SZWFkeSAoY2IsIGVycm9yQ2IpIHtcbiAgaWYgKHRoaXMucmVhZHkpIHtcbiAgICBjYigpO1xuICB9IGVsc2Uge1xuICAgIHRoaXMucmVhZHlDYnMucHVzaChjYik7XG4gICAgaWYgKGVycm9yQ2IpIHtcbiAgICAgIHRoaXMucmVhZHlFcnJvckNicy5wdXNoKGVycm9yQ2IpO1xuICAgIH1cbiAgfVxufTtcblxuSGlzdG9yeS5wcm90b3R5cGUub25FcnJvciA9IGZ1bmN0aW9uIG9uRXJyb3IgKGVycm9yQ2IpIHtcbiAgdGhpcy5lcnJvckNicy5wdXNoKGVycm9yQ2IpO1xufTtcblxuSGlzdG9yeS5wcm90b3R5cGUudHJhbnNpdGlvblRvID0gZnVuY3Rpb24gdHJhbnNpdGlvblRvIChsb2NhdGlvbiwgb25Db21wbGV0ZSwgb25BYm9ydCkge1xuICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gIHZhciByb3V0ZSA9IHRoaXMucm91dGVyLm1hdGNoKGxvY2F0aW9uLCB0aGlzLmN1cnJlbnQpO1xuICB0aGlzLmNvbmZpcm1UcmFuc2l0aW9uKHJvdXRlLCBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcyQxLnVwZGF0ZVJvdXRlKHJvdXRlKTtcbiAgICBvbkNvbXBsZXRlICYmIG9uQ29tcGxldGUocm91dGUpO1xuICAgIHRoaXMkMS5lbnN1cmVVUkwoKTtcblxuICAgIC8vIGZpcmUgcmVhZHkgY2JzIG9uY2VcbiAgICBpZiAoIXRoaXMkMS5yZWFkeSkge1xuICAgICAgdGhpcyQxLnJlYWR5ID0gdHJ1ZTtcbiAgICAgIHRoaXMkMS5yZWFkeUNicy5mb3JFYWNoKGZ1bmN0aW9uIChjYikgeyBjYihyb3V0ZSk7IH0pO1xuICAgIH1cbiAgfSwgZnVuY3Rpb24gKGVycikge1xuICAgIGlmIChvbkFib3J0KSB7XG4gICAgICBvbkFib3J0KGVycik7XG4gICAgfVxuICAgIGlmIChlcnIgJiYgIXRoaXMkMS5yZWFkeSkge1xuICAgICAgdGhpcyQxLnJlYWR5ID0gdHJ1ZTtcbiAgICAgIHRoaXMkMS5yZWFkeUVycm9yQ2JzLmZvckVhY2goZnVuY3Rpb24gKGNiKSB7IGNiKGVycik7IH0pO1xuICAgIH1cbiAgfSk7XG59O1xuXG5IaXN0b3J5LnByb3RvdHlwZS5jb25maXJtVHJhbnNpdGlvbiA9IGZ1bmN0aW9uIGNvbmZpcm1UcmFuc2l0aW9uIChyb3V0ZSwgb25Db21wbGV0ZSwgb25BYm9ydCkge1xuICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gIHZhciBjdXJyZW50ID0gdGhpcy5jdXJyZW50O1xuICB2YXIgYWJvcnQgPSBmdW5jdGlvbiAoZXJyKSB7XG4gICAgaWYgKGlzRXJyb3IoZXJyKSkge1xuICAgICAgaWYgKHRoaXMkMS5lcnJvckNicy5sZW5ndGgpIHtcbiAgICAgICAgdGhpcyQxLmVycm9yQ2JzLmZvckVhY2goZnVuY3Rpb24gKGNiKSB7IGNiKGVycik7IH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgd2FybihmYWxzZSwgJ3VuY2F1Z2h0IGVycm9yIGR1cmluZyByb3V0ZSBuYXZpZ2F0aW9uOicpO1xuICAgICAgICBjb25zb2xlLmVycm9yKGVycik7XG4gICAgICB9XG4gICAgfVxuICAgIG9uQWJvcnQgJiYgb25BYm9ydChlcnIpO1xuICB9O1xuICBpZiAoXG4gICAgaXNTYW1lUm91dGUocm91dGUsIGN1cnJlbnQpICYmXG4gICAgLy8gaW4gdGhlIGNhc2UgdGhlIHJvdXRlIG1hcCBoYXMgYmVlbiBkeW5hbWljYWxseSBhcHBlbmRlZCB0b1xuICAgIHJvdXRlLm1hdGNoZWQubGVuZ3RoID09PSBjdXJyZW50Lm1hdGNoZWQubGVuZ3RoXG4gICkge1xuICAgIHRoaXMuZW5zdXJlVVJMKCk7XG4gICAgcmV0dXJuIGFib3J0KClcbiAgfVxuXG4gIHZhciByZWYgPSByZXNvbHZlUXVldWUodGhpcy5jdXJyZW50Lm1hdGNoZWQsIHJvdXRlLm1hdGNoZWQpO1xuICAgIHZhciB1cGRhdGVkID0gcmVmLnVwZGF0ZWQ7XG4gICAgdmFyIGRlYWN0aXZhdGVkID0gcmVmLmRlYWN0aXZhdGVkO1xuICAgIHZhciBhY3RpdmF0ZWQgPSByZWYuYWN0aXZhdGVkO1xuXG4gIHZhciBxdWV1ZSA9IFtdLmNvbmNhdChcbiAgICAvLyBpbi1jb21wb25lbnQgbGVhdmUgZ3VhcmRzXG4gICAgZXh0cmFjdExlYXZlR3VhcmRzKGRlYWN0aXZhdGVkKSxcbiAgICAvLyBnbG9iYWwgYmVmb3JlIGhvb2tzXG4gICAgdGhpcy5yb3V0ZXIuYmVmb3JlSG9va3MsXG4gICAgLy8gaW4tY29tcG9uZW50IHVwZGF0ZSBob29rc1xuICAgIGV4dHJhY3RVcGRhdGVIb29rcyh1cGRhdGVkKSxcbiAgICAvLyBpbi1jb25maWcgZW50ZXIgZ3VhcmRzXG4gICAgYWN0aXZhdGVkLm1hcChmdW5jdGlvbiAobSkgeyByZXR1cm4gbS5iZWZvcmVFbnRlcjsgfSksXG4gICAgLy8gYXN5bmMgY29tcG9uZW50c1xuICAgIHJlc29sdmVBc3luY0NvbXBvbmVudHMoYWN0aXZhdGVkKVxuICApO1xuXG4gIHRoaXMucGVuZGluZyA9IHJvdXRlO1xuICB2YXIgaXRlcmF0b3IgPSBmdW5jdGlvbiAoaG9vaywgbmV4dCkge1xuICAgIGlmICh0aGlzJDEucGVuZGluZyAhPT0gcm91dGUpIHtcbiAgICAgIHJldHVybiBhYm9ydCgpXG4gICAgfVxuICAgIHRyeSB7XG4gICAgICBob29rKHJvdXRlLCBjdXJyZW50LCBmdW5jdGlvbiAodG8pIHtcbiAgICAgICAgaWYgKHRvID09PSBmYWxzZSB8fCBpc0Vycm9yKHRvKSkge1xuICAgICAgICAgIC8vIG5leHQoZmFsc2UpIC0+IGFib3J0IG5hdmlnYXRpb24sIGVuc3VyZSBjdXJyZW50IFVSTFxuICAgICAgICAgIHRoaXMkMS5lbnN1cmVVUkwodHJ1ZSk7XG4gICAgICAgICAgYWJvcnQodG8pO1xuICAgICAgICB9IGVsc2UgaWYgKFxuICAgICAgICAgIHR5cGVvZiB0byA9PT0gJ3N0cmluZycgfHxcbiAgICAgICAgICAodHlwZW9mIHRvID09PSAnb2JqZWN0JyAmJiAoXG4gICAgICAgICAgICB0eXBlb2YgdG8ucGF0aCA9PT0gJ3N0cmluZycgfHxcbiAgICAgICAgICAgIHR5cGVvZiB0by5uYW1lID09PSAnc3RyaW5nJ1xuICAgICAgICAgICkpXG4gICAgICAgICkge1xuICAgICAgICAgIC8vIG5leHQoJy8nKSBvciBuZXh0KHsgcGF0aDogJy8nIH0pIC0+IHJlZGlyZWN0XG4gICAgICAgICAgYWJvcnQoKTtcbiAgICAgICAgICBpZiAodHlwZW9mIHRvID09PSAnb2JqZWN0JyAmJiB0by5yZXBsYWNlKSB7XG4gICAgICAgICAgICB0aGlzJDEucmVwbGFjZSh0byk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMkMS5wdXNoKHRvKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gY29uZmlybSB0cmFuc2l0aW9uIGFuZCBwYXNzIG9uIHRoZSB2YWx1ZVxuICAgICAgICAgIG5leHQodG8pO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICBhYm9ydChlKTtcbiAgICB9XG4gIH07XG5cbiAgcnVuUXVldWUocXVldWUsIGl0ZXJhdG9yLCBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHBvc3RFbnRlckNicyA9IFtdO1xuICAgIHZhciBpc1ZhbGlkID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcyQxLmN1cnJlbnQgPT09IHJvdXRlOyB9O1xuICAgIC8vIHdhaXQgdW50aWwgYXN5bmMgY29tcG9uZW50cyBhcmUgcmVzb2x2ZWQgYmVmb3JlXG4gICAgLy8gZXh0cmFjdGluZyBpbi1jb21wb25lbnQgZW50ZXIgZ3VhcmRzXG4gICAgdmFyIGVudGVyR3VhcmRzID0gZXh0cmFjdEVudGVyR3VhcmRzKGFjdGl2YXRlZCwgcG9zdEVudGVyQ2JzLCBpc1ZhbGlkKTtcbiAgICB2YXIgcXVldWUgPSBlbnRlckd1YXJkcy5jb25jYXQodGhpcyQxLnJvdXRlci5yZXNvbHZlSG9va3MpO1xuICAgIHJ1blF1ZXVlKHF1ZXVlLCBpdGVyYXRvciwgZnVuY3Rpb24gKCkge1xuICAgICAgaWYgKHRoaXMkMS5wZW5kaW5nICE9PSByb3V0ZSkge1xuICAgICAgICByZXR1cm4gYWJvcnQoKVxuICAgICAgfVxuICAgICAgdGhpcyQxLnBlbmRpbmcgPSBudWxsO1xuICAgICAgb25Db21wbGV0ZShyb3V0ZSk7XG4gICAgICBpZiAodGhpcyQxLnJvdXRlci5hcHApIHtcbiAgICAgICAgdGhpcyQxLnJvdXRlci5hcHAuJG5leHRUaWNrKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBwb3N0RW50ZXJDYnMuZm9yRWFjaChmdW5jdGlvbiAoY2IpIHsgY2IoKTsgfSk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0pO1xuICB9KTtcbn07XG5cbkhpc3RvcnkucHJvdG90eXBlLnVwZGF0ZVJvdXRlID0gZnVuY3Rpb24gdXBkYXRlUm91dGUgKHJvdXRlKSB7XG4gIHZhciBwcmV2ID0gdGhpcy5jdXJyZW50O1xuICB0aGlzLmN1cnJlbnQgPSByb3V0ZTtcbiAgdGhpcy5jYiAmJiB0aGlzLmNiKHJvdXRlKTtcbiAgdGhpcy5yb3V0ZXIuYWZ0ZXJIb29rcy5mb3JFYWNoKGZ1bmN0aW9uIChob29rKSB7XG4gICAgaG9vayAmJiBob29rKHJvdXRlLCBwcmV2KTtcbiAgfSk7XG59O1xuXG5mdW5jdGlvbiBub3JtYWxpemVCYXNlIChiYXNlKSB7XG4gIGlmICghYmFzZSkge1xuICAgIGlmIChpbkJyb3dzZXIpIHtcbiAgICAgIC8vIHJlc3BlY3QgPGJhc2U+IHRhZ1xuICAgICAgdmFyIGJhc2VFbCA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJ2Jhc2UnKTtcbiAgICAgIGJhc2UgPSAoYmFzZUVsICYmIGJhc2VFbC5nZXRBdHRyaWJ1dGUoJ2hyZWYnKSkgfHwgJy8nO1xuICAgICAgLy8gc3RyaXAgZnVsbCBVUkwgb3JpZ2luXG4gICAgICBiYXNlID0gYmFzZS5yZXBsYWNlKC9eaHR0cHM/OlxcL1xcL1teXFwvXSsvLCAnJyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGJhc2UgPSAnLyc7XG4gICAgfVxuICB9XG4gIC8vIG1ha2Ugc3VyZSB0aGVyZSdzIHRoZSBzdGFydGluZyBzbGFzaFxuICBpZiAoYmFzZS5jaGFyQXQoMCkgIT09ICcvJykge1xuICAgIGJhc2UgPSAnLycgKyBiYXNlO1xuICB9XG4gIC8vIHJlbW92ZSB0cmFpbGluZyBzbGFzaFxuICByZXR1cm4gYmFzZS5yZXBsYWNlKC9cXC8kLywgJycpXG59XG5cbmZ1bmN0aW9uIHJlc29sdmVRdWV1ZSAoXG4gIGN1cnJlbnQsXG4gIG5leHRcbikge1xuICB2YXIgaTtcbiAgdmFyIG1heCA9IE1hdGgubWF4KGN1cnJlbnQubGVuZ3RoLCBuZXh0Lmxlbmd0aCk7XG4gIGZvciAoaSA9IDA7IGkgPCBtYXg7IGkrKykge1xuICAgIGlmIChjdXJyZW50W2ldICE9PSBuZXh0W2ldKSB7XG4gICAgICBicmVha1xuICAgIH1cbiAgfVxuICByZXR1cm4ge1xuICAgIHVwZGF0ZWQ6IG5leHQuc2xpY2UoMCwgaSksXG4gICAgYWN0aXZhdGVkOiBuZXh0LnNsaWNlKGkpLFxuICAgIGRlYWN0aXZhdGVkOiBjdXJyZW50LnNsaWNlKGkpXG4gIH1cbn1cblxuZnVuY3Rpb24gZXh0cmFjdEd1YXJkcyAoXG4gIHJlY29yZHMsXG4gIG5hbWUsXG4gIGJpbmQsXG4gIHJldmVyc2Vcbikge1xuICB2YXIgZ3VhcmRzID0gZmxhdE1hcENvbXBvbmVudHMocmVjb3JkcywgZnVuY3Rpb24gKGRlZiwgaW5zdGFuY2UsIG1hdGNoLCBrZXkpIHtcbiAgICB2YXIgZ3VhcmQgPSBleHRyYWN0R3VhcmQoZGVmLCBuYW1lKTtcbiAgICBpZiAoZ3VhcmQpIHtcbiAgICAgIHJldHVybiBBcnJheS5pc0FycmF5KGd1YXJkKVxuICAgICAgICA/IGd1YXJkLm1hcChmdW5jdGlvbiAoZ3VhcmQpIHsgcmV0dXJuIGJpbmQoZ3VhcmQsIGluc3RhbmNlLCBtYXRjaCwga2V5KTsgfSlcbiAgICAgICAgOiBiaW5kKGd1YXJkLCBpbnN0YW5jZSwgbWF0Y2gsIGtleSlcbiAgICB9XG4gIH0pO1xuICByZXR1cm4gZmxhdHRlbihyZXZlcnNlID8gZ3VhcmRzLnJldmVyc2UoKSA6IGd1YXJkcylcbn1cblxuZnVuY3Rpb24gZXh0cmFjdEd1YXJkIChcbiAgZGVmLFxuICBrZXlcbikge1xuICBpZiAodHlwZW9mIGRlZiAhPT0gJ2Z1bmN0aW9uJykge1xuICAgIC8vIGV4dGVuZCBub3cgc28gdGhhdCBnbG9iYWwgbWl4aW5zIGFyZSBhcHBsaWVkLlxuICAgIGRlZiA9IF9WdWUuZXh0ZW5kKGRlZik7XG4gIH1cbiAgcmV0dXJuIGRlZi5vcHRpb25zW2tleV1cbn1cblxuZnVuY3Rpb24gZXh0cmFjdExlYXZlR3VhcmRzIChkZWFjdGl2YXRlZCkge1xuICByZXR1cm4gZXh0cmFjdEd1YXJkcyhkZWFjdGl2YXRlZCwgJ2JlZm9yZVJvdXRlTGVhdmUnLCBiaW5kR3VhcmQsIHRydWUpXG59XG5cbmZ1bmN0aW9uIGV4dHJhY3RVcGRhdGVIb29rcyAodXBkYXRlZCkge1xuICByZXR1cm4gZXh0cmFjdEd1YXJkcyh1cGRhdGVkLCAnYmVmb3JlUm91dGVVcGRhdGUnLCBiaW5kR3VhcmQpXG59XG5cbmZ1bmN0aW9uIGJpbmRHdWFyZCAoZ3VhcmQsIGluc3RhbmNlKSB7XG4gIGlmIChpbnN0YW5jZSkge1xuICAgIHJldHVybiBmdW5jdGlvbiBib3VuZFJvdXRlR3VhcmQgKCkge1xuICAgICAgcmV0dXJuIGd1YXJkLmFwcGx5KGluc3RhbmNlLCBhcmd1bWVudHMpXG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGV4dHJhY3RFbnRlckd1YXJkcyAoXG4gIGFjdGl2YXRlZCxcbiAgY2JzLFxuICBpc1ZhbGlkXG4pIHtcbiAgcmV0dXJuIGV4dHJhY3RHdWFyZHMoYWN0aXZhdGVkLCAnYmVmb3JlUm91dGVFbnRlcicsIGZ1bmN0aW9uIChndWFyZCwgXywgbWF0Y2gsIGtleSkge1xuICAgIHJldHVybiBiaW5kRW50ZXJHdWFyZChndWFyZCwgbWF0Y2gsIGtleSwgY2JzLCBpc1ZhbGlkKVxuICB9KVxufVxuXG5mdW5jdGlvbiBiaW5kRW50ZXJHdWFyZCAoXG4gIGd1YXJkLFxuICBtYXRjaCxcbiAga2V5LFxuICBjYnMsXG4gIGlzVmFsaWRcbikge1xuICByZXR1cm4gZnVuY3Rpb24gcm91dGVFbnRlckd1YXJkICh0bywgZnJvbSwgbmV4dCkge1xuICAgIHJldHVybiBndWFyZCh0bywgZnJvbSwgZnVuY3Rpb24gKGNiKSB7XG4gICAgICBuZXh0KGNiKTtcbiAgICAgIGlmICh0eXBlb2YgY2IgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgY2JzLnB1c2goZnVuY3Rpb24gKCkge1xuICAgICAgICAgIC8vICM3NTBcbiAgICAgICAgICAvLyBpZiBhIHJvdXRlci12aWV3IGlzIHdyYXBwZWQgd2l0aCBhbiBvdXQtaW4gdHJhbnNpdGlvbixcbiAgICAgICAgICAvLyB0aGUgaW5zdGFuY2UgbWF5IG5vdCBoYXZlIGJlZW4gcmVnaXN0ZXJlZCBhdCB0aGlzIHRpbWUuXG4gICAgICAgICAgLy8gd2Ugd2lsbCBuZWVkIHRvIHBvbGwgZm9yIHJlZ2lzdHJhdGlvbiB1bnRpbCBjdXJyZW50IHJvdXRlXG4gICAgICAgICAgLy8gaXMgbm8gbG9uZ2VyIHZhbGlkLlxuICAgICAgICAgIHBvbGwoY2IsIG1hdGNoLmluc3RhbmNlcywga2V5LCBpc1ZhbGlkKTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSlcbiAgfVxufVxuXG5mdW5jdGlvbiBwb2xsIChcbiAgY2IsIC8vIHNvbWVob3cgZmxvdyBjYW5ub3QgaW5mZXIgdGhpcyBpcyBhIGZ1bmN0aW9uXG4gIGluc3RhbmNlcyxcbiAga2V5LFxuICBpc1ZhbGlkXG4pIHtcbiAgaWYgKGluc3RhbmNlc1trZXldKSB7XG4gICAgY2IoaW5zdGFuY2VzW2tleV0pO1xuICB9IGVsc2UgaWYgKGlzVmFsaWQoKSkge1xuICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgcG9sbChjYiwgaW5zdGFuY2VzLCBrZXksIGlzVmFsaWQpO1xuICAgIH0sIDE2KTtcbiAgfVxufVxuXG4vKiAgKi9cblxuXG52YXIgSFRNTDVIaXN0b3J5ID0gKGZ1bmN0aW9uIChIaXN0b3J5JCQxKSB7XG4gIGZ1bmN0aW9uIEhUTUw1SGlzdG9yeSAocm91dGVyLCBiYXNlKSB7XG4gICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgICBIaXN0b3J5JCQxLmNhbGwodGhpcywgcm91dGVyLCBiYXNlKTtcblxuICAgIHZhciBleHBlY3RTY3JvbGwgPSByb3V0ZXIub3B0aW9ucy5zY3JvbGxCZWhhdmlvcjtcblxuICAgIGlmIChleHBlY3RTY3JvbGwpIHtcbiAgICAgIHNldHVwU2Nyb2xsKCk7XG4gICAgfVxuXG4gICAgdmFyIGluaXRMb2NhdGlvbiA9IGdldExvY2F0aW9uKHRoaXMuYmFzZSk7XG4gICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ3BvcHN0YXRlJywgZnVuY3Rpb24gKGUpIHtcbiAgICAgIHZhciBjdXJyZW50ID0gdGhpcyQxLmN1cnJlbnQ7XG5cbiAgICAgIC8vIEF2b2lkaW5nIGZpcnN0IGBwb3BzdGF0ZWAgZXZlbnQgZGlzcGF0Y2hlZCBpbiBzb21lIGJyb3dzZXJzIGJ1dCBmaXJzdFxuICAgICAgLy8gaGlzdG9yeSByb3V0ZSBub3QgdXBkYXRlZCBzaW5jZSBhc3luYyBndWFyZCBhdCB0aGUgc2FtZSB0aW1lLlxuICAgICAgdmFyIGxvY2F0aW9uID0gZ2V0TG9jYXRpb24odGhpcyQxLmJhc2UpO1xuICAgICAgaWYgKHRoaXMkMS5jdXJyZW50ID09PSBTVEFSVCAmJiBsb2NhdGlvbiA9PT0gaW5pdExvY2F0aW9uKSB7XG4gICAgICAgIHJldHVyblxuICAgICAgfVxuXG4gICAgICB0aGlzJDEudHJhbnNpdGlvblRvKGxvY2F0aW9uLCBmdW5jdGlvbiAocm91dGUpIHtcbiAgICAgICAgaWYgKGV4cGVjdFNjcm9sbCkge1xuICAgICAgICAgIGhhbmRsZVNjcm9sbChyb3V0ZXIsIHJvdXRlLCBjdXJyZW50LCB0cnVlKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSk7XG4gIH1cblxuICBpZiAoIEhpc3RvcnkkJDEgKSBIVE1MNUhpc3RvcnkuX19wcm90b19fID0gSGlzdG9yeSQkMTtcbiAgSFRNTDVIaXN0b3J5LnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIEhpc3RvcnkkJDEgJiYgSGlzdG9yeSQkMS5wcm90b3R5cGUgKTtcbiAgSFRNTDVIaXN0b3J5LnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IEhUTUw1SGlzdG9yeTtcblxuICBIVE1MNUhpc3RvcnkucHJvdG90eXBlLmdvID0gZnVuY3Rpb24gZ28gKG4pIHtcbiAgICB3aW5kb3cuaGlzdG9yeS5nbyhuKTtcbiAgfTtcblxuICBIVE1MNUhpc3RvcnkucHJvdG90eXBlLnB1c2ggPSBmdW5jdGlvbiBwdXNoIChsb2NhdGlvbiwgb25Db21wbGV0ZSwgb25BYm9ydCkge1xuICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gICAgdmFyIHJlZiA9IHRoaXM7XG4gICAgdmFyIGZyb21Sb3V0ZSA9IHJlZi5jdXJyZW50O1xuICAgIHRoaXMudHJhbnNpdGlvblRvKGxvY2F0aW9uLCBmdW5jdGlvbiAocm91dGUpIHtcbiAgICAgIHB1c2hTdGF0ZShjbGVhblBhdGgodGhpcyQxLmJhc2UgKyByb3V0ZS5mdWxsUGF0aCkpO1xuICAgICAgaGFuZGxlU2Nyb2xsKHRoaXMkMS5yb3V0ZXIsIHJvdXRlLCBmcm9tUm91dGUsIGZhbHNlKTtcbiAgICAgIG9uQ29tcGxldGUgJiYgb25Db21wbGV0ZShyb3V0ZSk7XG4gICAgfSwgb25BYm9ydCk7XG4gIH07XG5cbiAgSFRNTDVIaXN0b3J5LnByb3RvdHlwZS5yZXBsYWNlID0gZnVuY3Rpb24gcmVwbGFjZSAobG9jYXRpb24sIG9uQ29tcGxldGUsIG9uQWJvcnQpIHtcbiAgICB2YXIgdGhpcyQxID0gdGhpcztcblxuICAgIHZhciByZWYgPSB0aGlzO1xuICAgIHZhciBmcm9tUm91dGUgPSByZWYuY3VycmVudDtcbiAgICB0aGlzLnRyYW5zaXRpb25Ubyhsb2NhdGlvbiwgZnVuY3Rpb24gKHJvdXRlKSB7XG4gICAgICByZXBsYWNlU3RhdGUoY2xlYW5QYXRoKHRoaXMkMS5iYXNlICsgcm91dGUuZnVsbFBhdGgpKTtcbiAgICAgIGhhbmRsZVNjcm9sbCh0aGlzJDEucm91dGVyLCByb3V0ZSwgZnJvbVJvdXRlLCBmYWxzZSk7XG4gICAgICBvbkNvbXBsZXRlICYmIG9uQ29tcGxldGUocm91dGUpO1xuICAgIH0sIG9uQWJvcnQpO1xuICB9O1xuXG4gIEhUTUw1SGlzdG9yeS5wcm90b3R5cGUuZW5zdXJlVVJMID0gZnVuY3Rpb24gZW5zdXJlVVJMIChwdXNoKSB7XG4gICAgaWYgKGdldExvY2F0aW9uKHRoaXMuYmFzZSkgIT09IHRoaXMuY3VycmVudC5mdWxsUGF0aCkge1xuICAgICAgdmFyIGN1cnJlbnQgPSBjbGVhblBhdGgodGhpcy5iYXNlICsgdGhpcy5jdXJyZW50LmZ1bGxQYXRoKTtcbiAgICAgIHB1c2ggPyBwdXNoU3RhdGUoY3VycmVudCkgOiByZXBsYWNlU3RhdGUoY3VycmVudCk7XG4gICAgfVxuICB9O1xuXG4gIEhUTUw1SGlzdG9yeS5wcm90b3R5cGUuZ2V0Q3VycmVudExvY2F0aW9uID0gZnVuY3Rpb24gZ2V0Q3VycmVudExvY2F0aW9uICgpIHtcbiAgICByZXR1cm4gZ2V0TG9jYXRpb24odGhpcy5iYXNlKVxuICB9O1xuXG4gIHJldHVybiBIVE1MNUhpc3Rvcnk7XG59KEhpc3RvcnkpKTtcblxuZnVuY3Rpb24gZ2V0TG9jYXRpb24gKGJhc2UpIHtcbiAgdmFyIHBhdGggPSB3aW5kb3cubG9jYXRpb24ucGF0aG5hbWU7XG4gIGlmIChiYXNlICYmIHBhdGguaW5kZXhPZihiYXNlKSA9PT0gMCkge1xuICAgIHBhdGggPSBwYXRoLnNsaWNlKGJhc2UubGVuZ3RoKTtcbiAgfVxuICByZXR1cm4gKHBhdGggfHwgJy8nKSArIHdpbmRvdy5sb2NhdGlvbi5zZWFyY2ggKyB3aW5kb3cubG9jYXRpb24uaGFzaFxufVxuXG4vKiAgKi9cblxuXG52YXIgSGFzaEhpc3RvcnkgPSAoZnVuY3Rpb24gKEhpc3RvcnkkJDEpIHtcbiAgZnVuY3Rpb24gSGFzaEhpc3RvcnkgKHJvdXRlciwgYmFzZSwgZmFsbGJhY2spIHtcbiAgICBIaXN0b3J5JCQxLmNhbGwodGhpcywgcm91dGVyLCBiYXNlKTtcbiAgICAvLyBjaGVjayBoaXN0b3J5IGZhbGxiYWNrIGRlZXBsaW5raW5nXG4gICAgaWYgKGZhbGxiYWNrICYmIGNoZWNrRmFsbGJhY2sodGhpcy5iYXNlKSkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuICAgIGVuc3VyZVNsYXNoKCk7XG4gIH1cblxuICBpZiAoIEhpc3RvcnkkJDEgKSBIYXNoSGlzdG9yeS5fX3Byb3RvX18gPSBIaXN0b3J5JCQxO1xuICBIYXNoSGlzdG9yeS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBIaXN0b3J5JCQxICYmIEhpc3RvcnkkJDEucHJvdG90eXBlICk7XG4gIEhhc2hIaXN0b3J5LnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IEhhc2hIaXN0b3J5O1xuXG4gIC8vIHRoaXMgaXMgZGVsYXllZCB1bnRpbCB0aGUgYXBwIG1vdW50c1xuICAvLyB0byBhdm9pZCB0aGUgaGFzaGNoYW5nZSBsaXN0ZW5lciBiZWluZyBmaXJlZCB0b28gZWFybHlcbiAgSGFzaEhpc3RvcnkucHJvdG90eXBlLnNldHVwTGlzdGVuZXJzID0gZnVuY3Rpb24gc2V0dXBMaXN0ZW5lcnMgKCkge1xuICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gICAgdmFyIHJvdXRlciA9IHRoaXMucm91dGVyO1xuICAgIHZhciBleHBlY3RTY3JvbGwgPSByb3V0ZXIub3B0aW9ucy5zY3JvbGxCZWhhdmlvcjtcbiAgICB2YXIgc3VwcG9ydHNTY3JvbGwgPSBzdXBwb3J0c1B1c2hTdGF0ZSAmJiBleHBlY3RTY3JvbGw7XG5cbiAgICBpZiAoc3VwcG9ydHNTY3JvbGwpIHtcbiAgICAgIHNldHVwU2Nyb2xsKCk7XG4gICAgfVxuXG4gICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoc3VwcG9ydHNQdXNoU3RhdGUgPyAncG9wc3RhdGUnIDogJ2hhc2hjaGFuZ2UnLCBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgY3VycmVudCA9IHRoaXMkMS5jdXJyZW50O1xuICAgICAgaWYgKCFlbnN1cmVTbGFzaCgpKSB7XG4gICAgICAgIHJldHVyblxuICAgICAgfVxuICAgICAgdGhpcyQxLnRyYW5zaXRpb25UbyhnZXRIYXNoKCksIGZ1bmN0aW9uIChyb3V0ZSkge1xuICAgICAgICBpZiAoc3VwcG9ydHNTY3JvbGwpIHtcbiAgICAgICAgICBoYW5kbGVTY3JvbGwodGhpcyQxLnJvdXRlciwgcm91dGUsIGN1cnJlbnQsIHRydWUpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghc3VwcG9ydHNQdXNoU3RhdGUpIHtcbiAgICAgICAgICByZXBsYWNlSGFzaChyb3V0ZS5mdWxsUGF0aCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0pO1xuICB9O1xuXG4gIEhhc2hIaXN0b3J5LnByb3RvdHlwZS5wdXNoID0gZnVuY3Rpb24gcHVzaCAobG9jYXRpb24sIG9uQ29tcGxldGUsIG9uQWJvcnQpIHtcbiAgICB2YXIgdGhpcyQxID0gdGhpcztcblxuICAgIHZhciByZWYgPSB0aGlzO1xuICAgIHZhciBmcm9tUm91dGUgPSByZWYuY3VycmVudDtcbiAgICB0aGlzLnRyYW5zaXRpb25Ubyhsb2NhdGlvbiwgZnVuY3Rpb24gKHJvdXRlKSB7XG4gICAgICBwdXNoSGFzaChyb3V0ZS5mdWxsUGF0aCk7XG4gICAgICBoYW5kbGVTY3JvbGwodGhpcyQxLnJvdXRlciwgcm91dGUsIGZyb21Sb3V0ZSwgZmFsc2UpO1xuICAgICAgb25Db21wbGV0ZSAmJiBvbkNvbXBsZXRlKHJvdXRlKTtcbiAgICB9LCBvbkFib3J0KTtcbiAgfTtcblxuICBIYXNoSGlzdG9yeS5wcm90b3R5cGUucmVwbGFjZSA9IGZ1bmN0aW9uIHJlcGxhY2UgKGxvY2F0aW9uLCBvbkNvbXBsZXRlLCBvbkFib3J0KSB7XG4gICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgICB2YXIgcmVmID0gdGhpcztcbiAgICB2YXIgZnJvbVJvdXRlID0gcmVmLmN1cnJlbnQ7XG4gICAgdGhpcy50cmFuc2l0aW9uVG8obG9jYXRpb24sIGZ1bmN0aW9uIChyb3V0ZSkge1xuICAgICAgcmVwbGFjZUhhc2gocm91dGUuZnVsbFBhdGgpO1xuICAgICAgaGFuZGxlU2Nyb2xsKHRoaXMkMS5yb3V0ZXIsIHJvdXRlLCBmcm9tUm91dGUsIGZhbHNlKTtcbiAgICAgIG9uQ29tcGxldGUgJiYgb25Db21wbGV0ZShyb3V0ZSk7XG4gICAgfSwgb25BYm9ydCk7XG4gIH07XG5cbiAgSGFzaEhpc3RvcnkucHJvdG90eXBlLmdvID0gZnVuY3Rpb24gZ28gKG4pIHtcbiAgICB3aW5kb3cuaGlzdG9yeS5nbyhuKTtcbiAgfTtcblxuICBIYXNoSGlzdG9yeS5wcm90b3R5cGUuZW5zdXJlVVJMID0gZnVuY3Rpb24gZW5zdXJlVVJMIChwdXNoKSB7XG4gICAgdmFyIGN1cnJlbnQgPSB0aGlzLmN1cnJlbnQuZnVsbFBhdGg7XG4gICAgaWYgKGdldEhhc2goKSAhPT0gY3VycmVudCkge1xuICAgICAgcHVzaCA/IHB1c2hIYXNoKGN1cnJlbnQpIDogcmVwbGFjZUhhc2goY3VycmVudCk7XG4gICAgfVxuICB9O1xuXG4gIEhhc2hIaXN0b3J5LnByb3RvdHlwZS5nZXRDdXJyZW50TG9jYXRpb24gPSBmdW5jdGlvbiBnZXRDdXJyZW50TG9jYXRpb24gKCkge1xuICAgIHJldHVybiBnZXRIYXNoKClcbiAgfTtcblxuICByZXR1cm4gSGFzaEhpc3Rvcnk7XG59KEhpc3RvcnkpKTtcblxuZnVuY3Rpb24gY2hlY2tGYWxsYmFjayAoYmFzZSkge1xuICB2YXIgbG9jYXRpb24gPSBnZXRMb2NhdGlvbihiYXNlKTtcbiAgaWYgKCEvXlxcLyMvLnRlc3QobG9jYXRpb24pKSB7XG4gICAgd2luZG93LmxvY2F0aW9uLnJlcGxhY2UoXG4gICAgICBjbGVhblBhdGgoYmFzZSArICcvIycgKyBsb2NhdGlvbilcbiAgICApO1xuICAgIHJldHVybiB0cnVlXG4gIH1cbn1cblxuZnVuY3Rpb24gZW5zdXJlU2xhc2ggKCkge1xuICB2YXIgcGF0aCA9IGdldEhhc2goKTtcbiAgaWYgKHBhdGguY2hhckF0KDApID09PSAnLycpIHtcbiAgICByZXR1cm4gdHJ1ZVxuICB9XG4gIHJlcGxhY2VIYXNoKCcvJyArIHBhdGgpO1xuICByZXR1cm4gZmFsc2Vcbn1cblxuZnVuY3Rpb24gZ2V0SGFzaCAoKSB7XG4gIC8vIFdlIGNhbid0IHVzZSB3aW5kb3cubG9jYXRpb24uaGFzaCBoZXJlIGJlY2F1c2UgaXQncyBub3RcbiAgLy8gY29uc2lzdGVudCBhY3Jvc3MgYnJvd3NlcnMgLSBGaXJlZm94IHdpbGwgcHJlLWRlY29kZSBpdCFcbiAgdmFyIGhyZWYgPSB3aW5kb3cubG9jYXRpb24uaHJlZjtcbiAgdmFyIGluZGV4ID0gaHJlZi5pbmRleE9mKCcjJyk7XG4gIHJldHVybiBpbmRleCA9PT0gLTEgPyAnJyA6IGhyZWYuc2xpY2UoaW5kZXggKyAxKVxufVxuXG5mdW5jdGlvbiBnZXRVcmwgKHBhdGgpIHtcbiAgdmFyIGhyZWYgPSB3aW5kb3cubG9jYXRpb24uaHJlZjtcbiAgdmFyIGkgPSBocmVmLmluZGV4T2YoJyMnKTtcbiAgdmFyIGJhc2UgPSBpID49IDAgPyBocmVmLnNsaWNlKDAsIGkpIDogaHJlZjtcbiAgcmV0dXJuIChiYXNlICsgXCIjXCIgKyBwYXRoKVxufVxuXG5mdW5jdGlvbiBwdXNoSGFzaCAocGF0aCkge1xuICBpZiAoc3VwcG9ydHNQdXNoU3RhdGUpIHtcbiAgICBwdXNoU3RhdGUoZ2V0VXJsKHBhdGgpKTtcbiAgfSBlbHNlIHtcbiAgICB3aW5kb3cubG9jYXRpb24uaGFzaCA9IHBhdGg7XG4gIH1cbn1cblxuZnVuY3Rpb24gcmVwbGFjZUhhc2ggKHBhdGgpIHtcbiAgaWYgKHN1cHBvcnRzUHVzaFN0YXRlKSB7XG4gICAgcmVwbGFjZVN0YXRlKGdldFVybChwYXRoKSk7XG4gIH0gZWxzZSB7XG4gICAgd2luZG93LmxvY2F0aW9uLnJlcGxhY2UoZ2V0VXJsKHBhdGgpKTtcbiAgfVxufVxuXG4vKiAgKi9cblxuXG52YXIgQWJzdHJhY3RIaXN0b3J5ID0gKGZ1bmN0aW9uIChIaXN0b3J5JCQxKSB7XG4gIGZ1bmN0aW9uIEFic3RyYWN0SGlzdG9yeSAocm91dGVyLCBiYXNlKSB7XG4gICAgSGlzdG9yeSQkMS5jYWxsKHRoaXMsIHJvdXRlciwgYmFzZSk7XG4gICAgdGhpcy5zdGFjayA9IFtdO1xuICAgIHRoaXMuaW5kZXggPSAtMTtcbiAgfVxuXG4gIGlmICggSGlzdG9yeSQkMSApIEFic3RyYWN0SGlzdG9yeS5fX3Byb3RvX18gPSBIaXN0b3J5JCQxO1xuICBBYnN0cmFjdEhpc3RvcnkucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggSGlzdG9yeSQkMSAmJiBIaXN0b3J5JCQxLnByb3RvdHlwZSApO1xuICBBYnN0cmFjdEhpc3RvcnkucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gQWJzdHJhY3RIaXN0b3J5O1xuXG4gIEFic3RyYWN0SGlzdG9yeS5wcm90b3R5cGUucHVzaCA9IGZ1bmN0aW9uIHB1c2ggKGxvY2F0aW9uLCBvbkNvbXBsZXRlLCBvbkFib3J0KSB7XG4gICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgICB0aGlzLnRyYW5zaXRpb25Ubyhsb2NhdGlvbiwgZnVuY3Rpb24gKHJvdXRlKSB7XG4gICAgICB0aGlzJDEuc3RhY2sgPSB0aGlzJDEuc3RhY2suc2xpY2UoMCwgdGhpcyQxLmluZGV4ICsgMSkuY29uY2F0KHJvdXRlKTtcbiAgICAgIHRoaXMkMS5pbmRleCsrO1xuICAgICAgb25Db21wbGV0ZSAmJiBvbkNvbXBsZXRlKHJvdXRlKTtcbiAgICB9LCBvbkFib3J0KTtcbiAgfTtcblxuICBBYnN0cmFjdEhpc3RvcnkucHJvdG90eXBlLnJlcGxhY2UgPSBmdW5jdGlvbiByZXBsYWNlIChsb2NhdGlvbiwgb25Db21wbGV0ZSwgb25BYm9ydCkge1xuICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gICAgdGhpcy50cmFuc2l0aW9uVG8obG9jYXRpb24sIGZ1bmN0aW9uIChyb3V0ZSkge1xuICAgICAgdGhpcyQxLnN0YWNrID0gdGhpcyQxLnN0YWNrLnNsaWNlKDAsIHRoaXMkMS5pbmRleCkuY29uY2F0KHJvdXRlKTtcbiAgICAgIG9uQ29tcGxldGUgJiYgb25Db21wbGV0ZShyb3V0ZSk7XG4gICAgfSwgb25BYm9ydCk7XG4gIH07XG5cbiAgQWJzdHJhY3RIaXN0b3J5LnByb3RvdHlwZS5nbyA9IGZ1bmN0aW9uIGdvIChuKSB7XG4gICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgICB2YXIgdGFyZ2V0SW5kZXggPSB0aGlzLmluZGV4ICsgbjtcbiAgICBpZiAodGFyZ2V0SW5kZXggPCAwIHx8IHRhcmdldEluZGV4ID49IHRoaXMuc3RhY2subGVuZ3RoKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG4gICAgdmFyIHJvdXRlID0gdGhpcy5zdGFja1t0YXJnZXRJbmRleF07XG4gICAgdGhpcy5jb25maXJtVHJhbnNpdGlvbihyb3V0ZSwgZnVuY3Rpb24gKCkge1xuICAgICAgdGhpcyQxLmluZGV4ID0gdGFyZ2V0SW5kZXg7XG4gICAgICB0aGlzJDEudXBkYXRlUm91dGUocm91dGUpO1xuICAgIH0pO1xuICB9O1xuXG4gIEFic3RyYWN0SGlzdG9yeS5wcm90b3R5cGUuZ2V0Q3VycmVudExvY2F0aW9uID0gZnVuY3Rpb24gZ2V0Q3VycmVudExvY2F0aW9uICgpIHtcbiAgICB2YXIgY3VycmVudCA9IHRoaXMuc3RhY2tbdGhpcy5zdGFjay5sZW5ndGggLSAxXTtcbiAgICByZXR1cm4gY3VycmVudCA/IGN1cnJlbnQuZnVsbFBhdGggOiAnLydcbiAgfTtcblxuICBBYnN0cmFjdEhpc3RvcnkucHJvdG90eXBlLmVuc3VyZVVSTCA9IGZ1bmN0aW9uIGVuc3VyZVVSTCAoKSB7XG4gICAgLy8gbm9vcFxuICB9O1xuXG4gIHJldHVybiBBYnN0cmFjdEhpc3Rvcnk7XG59KEhpc3RvcnkpKTtcblxuLyogICovXG5cbnZhciBWdWVSb3V0ZXIgPSBmdW5jdGlvbiBWdWVSb3V0ZXIgKG9wdGlvbnMpIHtcbiAgaWYgKCBvcHRpb25zID09PSB2b2lkIDAgKSBvcHRpb25zID0ge307XG5cbiAgdGhpcy5hcHAgPSBudWxsO1xuICB0aGlzLmFwcHMgPSBbXTtcbiAgdGhpcy5vcHRpb25zID0gb3B0aW9ucztcbiAgdGhpcy5iZWZvcmVIb29rcyA9IFtdO1xuICB0aGlzLnJlc29sdmVIb29rcyA9IFtdO1xuICB0aGlzLmFmdGVySG9va3MgPSBbXTtcbiAgdGhpcy5tYXRjaGVyID0gY3JlYXRlTWF0Y2hlcihvcHRpb25zLnJvdXRlcyB8fCBbXSwgdGhpcyk7XG5cbiAgdmFyIG1vZGUgPSBvcHRpb25zLm1vZGUgfHwgJ2hhc2gnO1xuICB0aGlzLmZhbGxiYWNrID0gbW9kZSA9PT0gJ2hpc3RvcnknICYmICFzdXBwb3J0c1B1c2hTdGF0ZSAmJiBvcHRpb25zLmZhbGxiYWNrICE9PSBmYWxzZTtcbiAgaWYgKHRoaXMuZmFsbGJhY2spIHtcbiAgICBtb2RlID0gJ2hhc2gnO1xuICB9XG4gIGlmICghaW5Ccm93c2VyKSB7XG4gICAgbW9kZSA9ICdhYnN0cmFjdCc7XG4gIH1cbiAgdGhpcy5tb2RlID0gbW9kZTtcblxuICBzd2l0Y2ggKG1vZGUpIHtcbiAgICBjYXNlICdoaXN0b3J5JzpcbiAgICAgIHRoaXMuaGlzdG9yeSA9IG5ldyBIVE1MNUhpc3RvcnkodGhpcywgb3B0aW9ucy5iYXNlKTtcbiAgICAgIGJyZWFrXG4gICAgY2FzZSAnaGFzaCc6XG4gICAgICB0aGlzLmhpc3RvcnkgPSBuZXcgSGFzaEhpc3RvcnkodGhpcywgb3B0aW9ucy5iYXNlLCB0aGlzLmZhbGxiYWNrKTtcbiAgICAgIGJyZWFrXG4gICAgY2FzZSAnYWJzdHJhY3QnOlxuICAgICAgdGhpcy5oaXN0b3J5ID0gbmV3IEFic3RyYWN0SGlzdG9yeSh0aGlzLCBvcHRpb25zLmJhc2UpO1xuICAgICAgYnJlYWtcbiAgICBkZWZhdWx0OlxuICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgYXNzZXJ0KGZhbHNlLCAoXCJpbnZhbGlkIG1vZGU6IFwiICsgbW9kZSkpO1xuICAgICAgfVxuICB9XG59O1xuXG52YXIgcHJvdG90eXBlQWNjZXNzb3JzID0geyBjdXJyZW50Um91dGU6IHsgY29uZmlndXJhYmxlOiB0cnVlIH0gfTtcblxuVnVlUm91dGVyLnByb3RvdHlwZS5tYXRjaCA9IGZ1bmN0aW9uIG1hdGNoIChcbiAgcmF3LFxuICBjdXJyZW50LFxuICByZWRpcmVjdGVkRnJvbVxuKSB7XG4gIHJldHVybiB0aGlzLm1hdGNoZXIubWF0Y2gocmF3LCBjdXJyZW50LCByZWRpcmVjdGVkRnJvbSlcbn07XG5cbnByb3RvdHlwZUFjY2Vzc29ycy5jdXJyZW50Um91dGUuZ2V0ID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gdGhpcy5oaXN0b3J5ICYmIHRoaXMuaGlzdG9yeS5jdXJyZW50XG59O1xuXG5WdWVSb3V0ZXIucHJvdG90eXBlLmluaXQgPSBmdW5jdGlvbiBpbml0IChhcHAgLyogVnVlIGNvbXBvbmVudCBpbnN0YW5jZSAqLykge1xuICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgYXNzZXJ0KFxuICAgIGluc3RhbGwuaW5zdGFsbGVkLFxuICAgIFwibm90IGluc3RhbGxlZC4gTWFrZSBzdXJlIHRvIGNhbGwgYFZ1ZS51c2UoVnVlUm91dGVyKWAgXCIgK1xuICAgIFwiYmVmb3JlIGNyZWF0aW5nIHJvb3QgaW5zdGFuY2UuXCJcbiAgKTtcblxuICB0aGlzLmFwcHMucHVzaChhcHApO1xuXG4gIC8vIG1haW4gYXBwIGFscmVhZHkgaW5pdGlhbGl6ZWQuXG4gIGlmICh0aGlzLmFwcCkge1xuICAgIHJldHVyblxuICB9XG5cbiAgdGhpcy5hcHAgPSBhcHA7XG5cbiAgdmFyIGhpc3RvcnkgPSB0aGlzLmhpc3Rvcnk7XG5cbiAgaWYgKGhpc3RvcnkgaW5zdGFuY2VvZiBIVE1MNUhpc3RvcnkpIHtcbiAgICBoaXN0b3J5LnRyYW5zaXRpb25UbyhoaXN0b3J5LmdldEN1cnJlbnRMb2NhdGlvbigpKTtcbiAgfSBlbHNlIGlmIChoaXN0b3J5IGluc3RhbmNlb2YgSGFzaEhpc3RvcnkpIHtcbiAgICB2YXIgc2V0dXBIYXNoTGlzdGVuZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICBoaXN0b3J5LnNldHVwTGlzdGVuZXJzKCk7XG4gICAgfTtcbiAgICBoaXN0b3J5LnRyYW5zaXRpb25UbyhcbiAgICAgIGhpc3RvcnkuZ2V0Q3VycmVudExvY2F0aW9uKCksXG4gICAgICBzZXR1cEhhc2hMaXN0ZW5lcixcbiAgICAgIHNldHVwSGFzaExpc3RlbmVyXG4gICAgKTtcbiAgfVxuXG4gIGhpc3RvcnkubGlzdGVuKGZ1bmN0aW9uIChyb3V0ZSkge1xuICAgIHRoaXMkMS5hcHBzLmZvckVhY2goZnVuY3Rpb24gKGFwcCkge1xuICAgICAgYXBwLl9yb3V0ZSA9IHJvdXRlO1xuICAgIH0pO1xuICB9KTtcbn07XG5cblZ1ZVJvdXRlci5wcm90b3R5cGUuYmVmb3JlRWFjaCA9IGZ1bmN0aW9uIGJlZm9yZUVhY2ggKGZuKSB7XG4gIHJldHVybiByZWdpc3Rlckhvb2sodGhpcy5iZWZvcmVIb29rcywgZm4pXG59O1xuXG5WdWVSb3V0ZXIucHJvdG90eXBlLmJlZm9yZVJlc29sdmUgPSBmdW5jdGlvbiBiZWZvcmVSZXNvbHZlIChmbikge1xuICByZXR1cm4gcmVnaXN0ZXJIb29rKHRoaXMucmVzb2x2ZUhvb2tzLCBmbilcbn07XG5cblZ1ZVJvdXRlci5wcm90b3R5cGUuYWZ0ZXJFYWNoID0gZnVuY3Rpb24gYWZ0ZXJFYWNoIChmbikge1xuICByZXR1cm4gcmVnaXN0ZXJIb29rKHRoaXMuYWZ0ZXJIb29rcywgZm4pXG59O1xuXG5WdWVSb3V0ZXIucHJvdG90eXBlLm9uUmVhZHkgPSBmdW5jdGlvbiBvblJlYWR5IChjYiwgZXJyb3JDYikge1xuICB0aGlzLmhpc3Rvcnkub25SZWFkeShjYiwgZXJyb3JDYik7XG59O1xuXG5WdWVSb3V0ZXIucHJvdG90eXBlLm9uRXJyb3IgPSBmdW5jdGlvbiBvbkVycm9yIChlcnJvckNiKSB7XG4gIHRoaXMuaGlzdG9yeS5vbkVycm9yKGVycm9yQ2IpO1xufTtcblxuVnVlUm91dGVyLnByb3RvdHlwZS5wdXNoID0gZnVuY3Rpb24gcHVzaCAobG9jYXRpb24sIG9uQ29tcGxldGUsIG9uQWJvcnQpIHtcbiAgdGhpcy5oaXN0b3J5LnB1c2gobG9jYXRpb24sIG9uQ29tcGxldGUsIG9uQWJvcnQpO1xufTtcblxuVnVlUm91dGVyLnByb3RvdHlwZS5yZXBsYWNlID0gZnVuY3Rpb24gcmVwbGFjZSAobG9jYXRpb24sIG9uQ29tcGxldGUsIG9uQWJvcnQpIHtcbiAgdGhpcy5oaXN0b3J5LnJlcGxhY2UobG9jYXRpb24sIG9uQ29tcGxldGUsIG9uQWJvcnQpO1xufTtcblxuVnVlUm91dGVyLnByb3RvdHlwZS5nbyA9IGZ1bmN0aW9uIGdvIChuKSB7XG4gIHRoaXMuaGlzdG9yeS5nbyhuKTtcbn07XG5cblZ1ZVJvdXRlci5wcm90b3R5cGUuYmFjayA9IGZ1bmN0aW9uIGJhY2sgKCkge1xuICB0aGlzLmdvKC0xKTtcbn07XG5cblZ1ZVJvdXRlci5wcm90b3R5cGUuZm9yd2FyZCA9IGZ1bmN0aW9uIGZvcndhcmQgKCkge1xuICB0aGlzLmdvKDEpO1xufTtcblxuVnVlUm91dGVyLnByb3RvdHlwZS5nZXRNYXRjaGVkQ29tcG9uZW50cyA9IGZ1bmN0aW9uIGdldE1hdGNoZWRDb21wb25lbnRzICh0bykge1xuICB2YXIgcm91dGUgPSB0b1xuICAgID8gdG8ubWF0Y2hlZFxuICAgICAgPyB0b1xuICAgICAgOiB0aGlzLnJlc29sdmUodG8pLnJvdXRlXG4gICAgOiB0aGlzLmN1cnJlbnRSb3V0ZTtcbiAgaWYgKCFyb3V0ZSkge1xuICAgIHJldHVybiBbXVxuICB9XG4gIHJldHVybiBbXS5jb25jYXQuYXBwbHkoW10sIHJvdXRlLm1hdGNoZWQubWFwKGZ1bmN0aW9uIChtKSB7XG4gICAgcmV0dXJuIE9iamVjdC5rZXlzKG0uY29tcG9uZW50cykubWFwKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgIHJldHVybiBtLmNvbXBvbmVudHNba2V5XVxuICAgIH0pXG4gIH0pKVxufTtcblxuVnVlUm91dGVyLnByb3RvdHlwZS5yZXNvbHZlID0gZnVuY3Rpb24gcmVzb2x2ZSAoXG4gIHRvLFxuICBjdXJyZW50LFxuICBhcHBlbmRcbikge1xuICB2YXIgbG9jYXRpb24gPSBub3JtYWxpemVMb2NhdGlvbihcbiAgICB0byxcbiAgICBjdXJyZW50IHx8IHRoaXMuaGlzdG9yeS5jdXJyZW50LFxuICAgIGFwcGVuZCxcbiAgICB0aGlzXG4gICk7XG4gIHZhciByb3V0ZSA9IHRoaXMubWF0Y2gobG9jYXRpb24sIGN1cnJlbnQpO1xuICB2YXIgZnVsbFBhdGggPSByb3V0ZS5yZWRpcmVjdGVkRnJvbSB8fCByb3V0ZS5mdWxsUGF0aDtcbiAgdmFyIGJhc2UgPSB0aGlzLmhpc3RvcnkuYmFzZTtcbiAgdmFyIGhyZWYgPSBjcmVhdGVIcmVmKGJhc2UsIGZ1bGxQYXRoLCB0aGlzLm1vZGUpO1xuICByZXR1cm4ge1xuICAgIGxvY2F0aW9uOiBsb2NhdGlvbixcbiAgICByb3V0ZTogcm91dGUsXG4gICAgaHJlZjogaHJlZixcbiAgICAvLyBmb3IgYmFja3dhcmRzIGNvbXBhdFxuICAgIG5vcm1hbGl6ZWRUbzogbG9jYXRpb24sXG4gICAgcmVzb2x2ZWQ6IHJvdXRlXG4gIH1cbn07XG5cblZ1ZVJvdXRlci5wcm90b3R5cGUuYWRkUm91dGVzID0gZnVuY3Rpb24gYWRkUm91dGVzIChyb3V0ZXMpIHtcbiAgdGhpcy5tYXRjaGVyLmFkZFJvdXRlcyhyb3V0ZXMpO1xuICBpZiAodGhpcy5oaXN0b3J5LmN1cnJlbnQgIT09IFNUQVJUKSB7XG4gICAgdGhpcy5oaXN0b3J5LnRyYW5zaXRpb25Ubyh0aGlzLmhpc3RvcnkuZ2V0Q3VycmVudExvY2F0aW9uKCkpO1xuICB9XG59O1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydGllcyggVnVlUm91dGVyLnByb3RvdHlwZSwgcHJvdG90eXBlQWNjZXNzb3JzICk7XG5cbmZ1bmN0aW9uIHJlZ2lzdGVySG9vayAobGlzdCwgZm4pIHtcbiAgbGlzdC5wdXNoKGZuKTtcbiAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgaSA9IGxpc3QuaW5kZXhPZihmbik7XG4gICAgaWYgKGkgPiAtMSkgeyBsaXN0LnNwbGljZShpLCAxKTsgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUhyZWYgKGJhc2UsIGZ1bGxQYXRoLCBtb2RlKSB7XG4gIHZhciBwYXRoID0gbW9kZSA9PT0gJ2hhc2gnID8gJyMnICsgZnVsbFBhdGggOiBmdWxsUGF0aDtcbiAgcmV0dXJuIGJhc2UgPyBjbGVhblBhdGgoYmFzZSArICcvJyArIHBhdGgpIDogcGF0aFxufVxuXG5WdWVSb3V0ZXIuaW5zdGFsbCA9IGluc3RhbGw7XG5WdWVSb3V0ZXIudmVyc2lvbiA9ICcyLjguMSc7XG5cbmlmIChpbkJyb3dzZXIgJiYgd2luZG93LlZ1ZSkge1xuICB3aW5kb3cuVnVlLnVzZShWdWVSb3V0ZXIpO1xufVxuXG5leHBvcnQgZGVmYXVsdCBWdWVSb3V0ZXI7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L192dWUtcm91dGVyQDIuOC4xQHZ1ZS1yb3V0ZXIvZGlzdC92dWUtcm91dGVyLmVzbS5qcyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///99\n");

/***/ })

},[403]);